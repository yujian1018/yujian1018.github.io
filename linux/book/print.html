<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>linux笔记</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="1.基础/_index.html"><strong aria-hidden="true">1.</strong> 基础</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="1.基础/1.6 debian/_index.html"><strong aria-hidden="true">1.1.</strong> debian</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="1.基础/1.6 debian/1.6.1 sudo提权.html"><strong aria-hidden="true">1.1.1.</strong> 1.6.1 sudo提权</a></li></ol></li><li class="chapter-item expanded "><a href="1.基础/1.7 ubuntu/_index.html"><strong aria-hidden="true">1.2.</strong> ubuntu</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="1.基础/1.7 ubuntu/ubuntu 开机启动.html"><strong aria-hidden="true">1.2.1.</strong> ubuntu 开机启动</a></li><li class="chapter-item expanded "><a href="1.基础/1.7 ubuntu/ubuntu 收藏夹 快捷方式.html"><strong aria-hidden="true">1.2.2.</strong> ubuntu 收藏夹 快捷方式</a></li></ol></li><li class="chapter-item expanded "><a href="1.基础/1.1 目录结构.html"><strong aria-hidden="true">1.3.</strong> 1.1 目录结构</a></li><li class="chapter-item expanded "><a href="1.基础/1.2 系统调优.html"><strong aria-hidden="true">1.4.</strong> 1.2 系统调优</a></li><li class="chapter-item expanded "><a href="1.基础/1.2.1 修改系统参数.html"><strong aria-hidden="true">1.5.</strong> 1.2.1 修改系统参数</a></li><li class="chapter-item expanded "><a href="1.基础/1.3 自动化.html"><strong aria-hidden="true">1.6.</strong> 1.3 自动化</a></li><li class="chapter-item expanded "><a href="1.基础/1.4 系统设置.html"><strong aria-hidden="true">1.7.</strong> 1.4 系统设置</a></li><li class="chapter-item expanded "><a href="1.基础/1.5 常用命令.html"><strong aria-hidden="true">1.8.</strong> 1.5 常用命令</a></li><li class="chapter-item expanded "><a href="1.基础/1.5.1 man.html"><strong aria-hidden="true">1.9.</strong> 1.5.1 man</a></li><li class="chapter-item expanded "><a href="1.基础/1.5.2 用户及文件权限管理.html"><strong aria-hidden="true">1.10.</strong> 1.5.2 用户及文件权限管理</a></li><li class="chapter-item expanded "><a href="1.基础/1.5.3 包管理.html"><strong aria-hidden="true">1.11.</strong> 1.5.3 包管理</a></li><li class="chapter-item expanded "><a href="1.基础/1.5.4 性能监控工具.html"><strong aria-hidden="true">1.12.</strong> 1.5.4 性能监控工具</a></li></ol></li><li class="chapter-item expanded "><a href="2.Shell 教程/_index.html"><strong aria-hidden="true">2.</strong> Shell 教程</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="2.Shell 教程/2.1. 基础教程/_index.html"><strong aria-hidden="true">2.1.</strong> 基础教程</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="2.Shell 教程/2.1. 基础教程/2.1.1 终端快捷键.html"><strong aria-hidden="true">2.1.1.</strong> 2.1.1 终端快捷键</a></li><li class="chapter-item expanded "><a href="2.Shell 教程/2.1. 基础教程/2.1.2 通配符.html"><strong aria-hidden="true">2.1.2.</strong> 2.1.2 通配符</a></li><li class="chapter-item expanded "><a href="2.Shell 教程/2.1. 基础教程/2.1.3 关键字.html"><strong aria-hidden="true">2.1.3.</strong> 2.1.3 关键字</a></li><li class="chapter-item expanded "><a href="2.Shell 教程/2.1. 基础教程/2.1.4 语法.html"><strong aria-hidden="true">2.1.4.</strong> 2.1.4 语法</a></li><li class="chapter-item expanded "><a href="2.Shell 教程/2.1. 基础教程/2.1.5 Function.html"><strong aria-hidden="true">2.1.5.</strong> 2.1.5 Function</a></li><li class="chapter-item expanded "><a href="2.Shell 教程/2.1. 基础教程/2.1.6 转译符.html"><strong aria-hidden="true">2.1.6.</strong> 2.1.6 转译符</a></li><li class="chapter-item expanded "><a href="2.Shell 教程/2.1. 基础教程/2.1.7 数据结构.html"><strong aria-hidden="true">2.1.7.</strong> 2.1.7 数据结构</a></li><li class="chapter-item expanded "><a href="2.Shell 教程/2.2. Shell脚本/shtools/index.html"><strong aria-hidden="true">2.1.8.</strong> Shtools</a></li></ol></li><li class="chapter-item expanded "><a href="2.Shell 教程/2.2. Shell脚本/_index.html"><strong aria-hidden="true">2.2.</strong> Shell脚本</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="2.Shell 教程/2.2. Shell脚本/安装系统后操作.html"><strong aria-hidden="true">2.2.1.</strong> 安装系统后操作</a></li></ol></li><li class="chapter-item expanded "><a href="2.Shell 教程/2.3. Makefile/_index.html"><strong aria-hidden="true">2.3.</strong> Makefile</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="2.Shell 教程/2.3. Makefile/2.3.1 案例Makefile 1.html"><strong aria-hidden="true">2.3.1.</strong> 2.3.1 案例Makefile 1</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="3.Linux 命令/_index.html"><strong aria-hidden="true">3.</strong> Linux 命令</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3.Linux 命令/1.文件管理/_index.html"><strong aria-hidden="true">3.1.</strong> 文件管理</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3.Linux 命令/1.文件管理/1.1 文件管理.html"><strong aria-hidden="true">3.1.1.</strong> 1.1 文件管理</a></li><li class="chapter-item expanded "><a href="3.Linux 命令/1.文件管理/1.2 目录.html"><strong aria-hidden="true">3.1.2.</strong> 1.2 目录</a></li><li class="chapter-item expanded "><a href="3.Linux 命令/1.文件管理/1.3 权限.html"><strong aria-hidden="true">3.1.3.</strong> 1.3 权限</a></li><li class="chapter-item expanded "><a href="3.Linux 命令/1.文件管理/1.4 压缩.html"><strong aria-hidden="true">3.1.4.</strong> 1.4 压缩</a></li><li class="chapter-item expanded "><a href="3.Linux 命令/1.文件管理/1.4.1 zip.html"><strong aria-hidden="true">3.1.5.</strong> 1.4.1 zip</a></li></ol></li><li class="chapter-item expanded "><a href="3.Linux 命令/2.文档编辑/_index.html"><strong aria-hidden="true">3.2.</strong> 文档编辑</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3.Linux 命令/2.文档编辑/2.1 文档编辑.html"><strong aria-hidden="true">3.2.1.</strong> 2.1 文档编辑</a></li><li class="chapter-item expanded "><a href="3.Linux 命令/2.文档编辑/2.10 wc.html"><strong aria-hidden="true">3.2.2.</strong> 2.10 wc</a></li><li class="chapter-item expanded "><a href="3.Linux 命令/2.文档编辑/2.2 sed.html"><strong aria-hidden="true">3.2.3.</strong> 2.2 sed</a></li><li class="chapter-item expanded "><a href="3.Linux 命令/2.文档编辑/2.3 awk.html"><strong aria-hidden="true">3.2.4.</strong> 2.3 awk</a></li><li class="chapter-item expanded "><a href="3.Linux 命令/2.文档编辑/2.4 uniq.html"><strong aria-hidden="true">3.2.5.</strong> 2.4 uniq</a></li><li class="chapter-item expanded "><a href="3.Linux 命令/2.文档编辑/2.5 sort.html"><strong aria-hidden="true">3.2.6.</strong> 2.5 sort</a></li><li class="chapter-item expanded "><a href="3.Linux 命令/2.文档编辑/2.6 grep.html"><strong aria-hidden="true">3.2.7.</strong> 2.6 grep</a></li><li class="chapter-item expanded "><a href="3.Linux 命令/2.文档编辑/2.7 tail.html"><strong aria-hidden="true">3.2.8.</strong> 2.7 tail</a></li><li class="chapter-item expanded "><a href="3.Linux 命令/2.文档编辑/2.8 find.html"><strong aria-hidden="true">3.2.9.</strong> 2.8 find</a></li><li class="chapter-item expanded "><a href="3.Linux 命令/2.文档编辑/2.9 iconv.html"><strong aria-hidden="true">3.2.10.</strong> 2.9 iconv</a></li></ol></li><li class="chapter-item expanded "><a href="3.Linux 命令/3.系统管理/_index.html"><strong aria-hidden="true">3.3.</strong> 系统管理</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3.Linux 命令/3.系统管理/3.1 crontab.html"><strong aria-hidden="true">3.3.1.</strong> 3.1 crontab</a></li><li class="chapter-item expanded "><a href="3.Linux 命令/3.系统管理/3.2 nohup.html"><strong aria-hidden="true">3.3.2.</strong> 3.2 nohup</a></li><li class="chapter-item expanded "><a href="3.Linux 命令/3.系统管理/3.3 xclip.html"><strong aria-hidden="true">3.3.3.</strong> 3.3 xclip</a></li><li class="chapter-item expanded "><a href="3.Linux 命令/3.系统管理/3.4 tmux.html"><strong aria-hidden="true">3.3.4.</strong> 3.4 tmux</a></li><li class="chapter-item expanded "><a href="3.Linux 命令/3.系统管理/3.5 systemd.html"><strong aria-hidden="true">3.3.5.</strong> 3.5 systemd</a></li></ol></li><li class="chapter-item expanded "><a href="3.Linux 命令/4.磁盘管理/_index.html"><strong aria-hidden="true">3.4.</strong> 磁盘管理</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3.Linux 命令/4.磁盘管理/4.1 du.html"><strong aria-hidden="true">3.4.1.</strong> 4.1 du</a></li><li class="chapter-item expanded "><a href="3.Linux 命令/4.磁盘管理/4.2 mount.html"><strong aria-hidden="true">3.4.2.</strong> 4.2 mount</a></li></ol></li><li class="chapter-item expanded "><a href="3.Linux 命令/5.文件传输/_index.html"><strong aria-hidden="true">3.5.</strong> 文件传输</a></li><li class="chapter-item expanded "><a href="3.Linux 命令/6.网络通讯/_index.html"><strong aria-hidden="true">3.6.</strong> 网络通讯</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3.Linux 命令/6.网络通讯/6.1 tcpdump.html"><strong aria-hidden="true">3.6.1.</strong> 6.1 tcpdump</a></li><li class="chapter-item expanded "><a href="3.Linux 命令/6.网络通讯/6.2 curl.html"><strong aria-hidden="true">3.6.2.</strong> 6.2 curl</a></li><li class="chapter-item expanded "><a href="3.Linux 命令/6.网络通讯/6.3 ssh.html"><strong aria-hidden="true">3.6.3.</strong> 6.3 ssh</a></li><li class="chapter-item expanded "><a href="3.Linux 命令/6.网络通讯/6.4 tc.html"><strong aria-hidden="true">3.6.4.</strong> 6.4 tc</a></li><li class="chapter-item expanded "><a href="3.Linux 命令/6.网络通讯/6.5 firewall.html"><strong aria-hidden="true">3.6.5.</strong> 6.5 firewall</a></li><li class="chapter-item expanded "><a href="3.Linux 命令/6.网络通讯/6.6 openssh.html"><strong aria-hidden="true">3.6.6.</strong> 6.6 openssh</a></li><li class="chapter-item expanded "><a href="3.Linux 命令/6.网络通讯/nc.html"><strong aria-hidden="true">3.6.7.</strong> Nc</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="4.Linux软件/_index.html"><strong aria-hidden="true">4.</strong> Linux软件</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="4.Linux软件/4.1 idea/_index.html"><strong aria-hidden="true">4.1.</strong> idea</a></li><li class="chapter-item expanded "><a href="4.Linux软件/4.2 vim/_index.html"><strong aria-hidden="true">4.2.</strong> vim</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="4.Linux软件/4.2 vim/VIM.html"><strong aria-hidden="true">4.2.1.</strong> VIM</a></li></ol></li><li class="chapter-item expanded "><a href="4.Linux软件/4.3 Let's Encrypt/_index.html"><strong aria-hidden="true">4.3.</strong> Let's Encrypt</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="4.Linux软件/4.3 Let's Encrypt/4.3.1 acme.html"><strong aria-hidden="true">4.3.1.</strong> 4.3.1 acme</a></li></ol></li><li class="chapter-item expanded "><a href="4.Linux软件/4.4 nginx/_index.html"><strong aria-hidden="true">4.4.</strong> nginx</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="4.Linux软件/4.4 nginx/4.4.1nginxError排查.html"><strong aria-hidden="true">4.4.1.</strong> 4.4.1nginxError排查</a></li><li class="chapter-item expanded "><a href="4.Linux软件/4.4 nginx/4.4.2nginxRewrite规则.html"><strong aria-hidden="true">4.4.2.</strong> 4.4.2nginxRewrite规则</a></li><li class="chapter-item expanded "><a href="4.Linux软件/4.4 nginx/4.4.3nginx_grpc_conf.html"><strong aria-hidden="true">4.4.3.</strong> 4.4.3nginx_grpc_conf</a></li><li class="chapter-item expanded "><a href="4.Linux软件/4.4 nginx/4.4.4nginx_conf.html"><strong aria-hidden="true">4.4.4.</strong> 4.4.4nginx_conf</a></li><li class="chapter-item expanded "><a href="4.Linux软件/4.4 nginx/4.4.5nginx安装.html"><strong aria-hidden="true">4.4.5.</strong> 4.4.5nginx安装</a></li></ol></li><li class="chapter-item expanded "><a href="4.Linux软件/4.5 v2ray/_index.html"><strong aria-hidden="true">4.5.</strong> v2ray</a></li><li class="chapter-item expanded "><a href="4.Linux软件/4.6 Docker/_index.html"><strong aria-hidden="true">4.6.</strong> Docker</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="4.Linux软件/4.6 Docker/4.6.1 Docker-Dockerfile.html"><strong aria-hidden="true">4.6.1.</strong> 4.6.1 Docker-Dockerfile</a></li><li class="chapter-item expanded "><a href="4.Linux软件/4.6 Docker/4.6.2 Docker.html"><strong aria-hidden="true">4.6.2.</strong> 4.6.2 Docker</a></li><li class="chapter-item expanded "><a href="4.Linux软件/4.6 Docker/4.6.4 Docker Compose.html"><strong aria-hidden="true">4.6.3.</strong> 4.6.4 Docker Compose</a></li><li class="chapter-item expanded "><a href="4.Linux软件/4.6 Docker/4.6.5 Docker-网络.html"><strong aria-hidden="true">4.6.4.</strong> 4.6.5 Docker-网络</a></li></ol></li><li class="chapter-item expanded "><a href="4.Linux软件/4.7 git/_index.html"><strong aria-hidden="true">4.7.</strong> git</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="4.Linux软件/4.7 git/git.html"><strong aria-hidden="true">4.7.1.</strong> Git</a></li><li class="chapter-item expanded "><a href="4.Linux软件/4.7 git/gitea.html"><strong aria-hidden="true">4.7.2.</strong> Gitea</a></li></ol></li><li class="chapter-item expanded "><a href="4.Linux软件/4.3.4 frp.html"><strong aria-hidden="true">4.8.</strong> 4.3.4 frp</a></li><li class="chapter-item expanded "><a href="4.Linux软件/4.3.5 protobuf.html"><strong aria-hidden="true">4.9.</strong> 4.3.5 protobuf</a></li><li class="chapter-item expanded "><a href="4.Linux软件/4.3.6 wget.html"><strong aria-hidden="true">4.10.</strong> 4.3.6 wget</a></li><li class="chapter-item expanded "><a href="4.Linux软件/4.4.4 svn.html"><strong aria-hidden="true">4.11.</strong> 4.4.4 svn</a></li><li class="chapter-item expanded "><a href="4.Linux软件/ntp.html"><strong aria-hidden="true">4.12.</strong> Ntp</a></li></ol></li><li class="chapter-item expanded "><a href="etc_/index.html"><strong aria-hidden="true">5.</strong> Etc</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="etc_/cpp/project_tpl/index.html"><strong aria-hidden="true">5.1.</strong> Project Tpl</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">linux笔记</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/yujian1018/yujian1018.github.io/tree/master/linux" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <div style="break-before: page; page-break-before: always;"></div><h2 id="debian"><a class="header" href="#debian">debian</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h2 id="如何安装sudo及配置其sudoers文件"><a class="header" href="#如何安装sudo及配置其sudoers文件">如何安装sudo及配置其sudoers文件</a></h2>
<pre><code class="language-bash">
#首先登陆超级管理员账户，在 Terminal 命令行内输入 
su  #“Enter”键后，输入超级管理员密码，即进入root账户
apt install sudo #&quot;Enter&quot;键后，系统即开始安装sudo（因为我这边已经安装好了sudo，所以只提示已安装的信息）
adduser yl sudo #“Enter”键 意思是：将我的用户名 yl 添加到sudo组内，大家根据实际将自己的用户名添加进sudo组内

#接下来是配置sudoers文件，这里通过vi编辑器来写


vi /etc/sudoers
#-在vi命令模式中，输入 /%sudo 搜索定位到 %sudo ALL = (ALL:ALL) ALL，或者手动定位
#-在vi插入模式中（按一下 i 键），在  %sudo ALL = (ALL:ALL) ALL 下面键入 yl ALL = (ALL:ALL) ALL  （同样，这里 yl 代表我的普通用户名，大家根据实际修改）
#-在vi命令模式中，输入 :x ,即可退出vi并保存文件

#验证sudo是否安装成功
#重启下Terminal ，输入命令 sudo ls ，再输入用户密码，如果显示如下字样，则可能sudo安装或配置出现了问题，需要重复上述步骤；
#yl is not in the sudoers file.  This incident will be reported.
#如果显示如下字样，则说明sudo安装与配置成功
#Desktop  Documents  Downloads  Music  Pictures  Public  Templates  Videos

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ubuntu"><a class="header" href="#ubuntu">ubuntu</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ubuntu1804"><a class="header" href="#ubuntu1804">ubuntu18.04</a></h2>
<pre><code class="language-bash">/lib/systemd/system
sudo vim rc.local.service
[Install]
WantedBy=multi-user.target
Alias=rc-local.service

sudo ln -s rc.local.service /etc/systemd/system/
sudo vim /etc/rc.local
#!/bin/sh -e
#
# rc.local
#
# This script is executed at the end of each multiuser runlevel.
# Make sure that the script will &quot;exit 0&quot; on success or any other
# value on error.
#
# In order to enable or disable this script just change the execution
# bits.
#
# By default this script does nothing.

echo &quot;看到这行字，说明添加自启动脚本成功。&quot; &gt; /home/yj/test.log

exit 0

sudo reboot
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="收藏夹"><a class="header" href="#收藏夹">收藏夹</a></h2>
<pre><code class="language-bash">
#应用程序
cd /usr/share/applications
vim app.desktop
# [Desktop Entry]
# Version=1.0
# Type=Application
# Name=脑图
# Icon = /home/yj/tool/DesktopNaotu-linux-x64/resources/app/favicon.png
# Exec = &quot;/home/yj/tool/DesktopNaotu-linux-x64/DesktopNaotu&quot;
# Comment=脑图
# Categories=Development;IDE;
# Terminal=false

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="目录结构"><a class="header" href="#目录结构">目录结构</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">目录</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left">/</td><td style="text-align: left">根目录，只能包含目录，不能包含具体文件。</td></tr>
<tr><td style="text-align: left">/bin</td><td style="text-align: left">存放可执行文件。很多命令就对应/bin目录下的某个程序，例如 ls、cp、mkdir。/bin目录对所有用户有效。</td></tr>
<tr><td style="text-align: left">/dev</td><td style="text-align: left">硬件驱动程序。例如声卡、磁盘驱动等，还有如 /dev/null、/dev/console、/dev/zero、/dev/full 等文件。</td></tr>
<tr><td style="text-align: left">/etc</td><td style="text-align: left">主要包含系统配置文件和用户、用户组配置文件。</td></tr>
<tr><td style="text-align: left">/lib</td><td style="text-align: left">主要包含共享库文件，类似于Windows下的DLL；有时也会包含内核相关文件。</td></tr>
<tr><td style="text-align: left">/boot</td><td style="text-align: left">系统启动文件，例如Linux内核、引导程序等。</td></tr>
<tr><td style="text-align: left">/home</td><td style="text-align: left">用户工作目录（主目录），每个用户都会分配一个目录。</td></tr>
<tr><td style="text-align: left">/mnt</td><td style="text-align: left">临时挂载文件系统。这个目录一般是用于存放挂载储存设备的挂载目录的，例如挂载CD-ROM的cdrom目录。</td></tr>
<tr><td style="text-align: left">/proc</td><td style="text-align: left">操作系统运行时，进程（正在运行中的程序）信息及内核信息（比如cpu、硬盘分区、内存信息等）存放在这里。/proc目录伪装的文</td></tr>
<tr><td style="text-align: left">/tmp</td><td style="text-align: left">临时文件目录，系统重启后不会被保存。</td></tr>
<tr><td style="text-align: left">/usr</td><td style="text-align: left">/user目下的文件比较混杂，包含了管理命令、共享文件、库文件等，可以被很多用户使用。</td></tr>
<tr><td style="text-align: left">/var</td><td style="text-align: left">主要包含一些可变长度的文件，会经常对数据进行读写，例如日志文件和打印队列里的文件。</td></tr>
<tr><td style="text-align: left">/sbin</td><td style="text-align: left">和 /bin 类似，主要包含可执行文件，不过一般是系统管理所需要的，不是所有用户都需要。</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h2 id="系统调优"><a class="header" href="#系统调优">系统调优</a></h2>
<pre><code class="language-bash">ulimit -a

ulimit -n 102400
1.在/etc/rc.local 中增加一行 ulimit -SHn 65535
2.在/etc/profile 中增加一行 ulimit -SHn 65535
3.在/etc/security/limits.conf最后增加如下两行记录
* soft nofile 65535
* hard nofile 65535

查看 /etc/security/limits.conf 没有就新建，加入 core 和 nofile 的相关配置，比如：
* soft nofile 65536
* hard nofile 65536
* soft core unlimited
* hard core unlimited
# End of file
之类的，不用到 ~/.bashrc 里面调用 ulimit。


sudo vim /etc/sysctl.conf
fs.inotify.max_user_watches=16384

ulimit -n 8192

</code></pre>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">type</th><th style="text-align: left">cmd</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left">core file size</td><td style="text-align: left">(blocks, -c) 0</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">data seg size</td><td style="text-align: left">(kbytes, -d) unlimited</td><td style="text-align: left">数据段长度</td></tr>
<tr><td style="text-align: left">scheduling priority</td><td style="text-align: left">(-e) 0</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">file size</td><td style="text-align: left">(blocks, -f) unlimited</td><td style="text-align: left">文件大小</td></tr>
<tr><td style="text-align: left">pending</td><td style="text-align: left">signals (-i) 15240</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">max locked memory</td><td style="text-align: left">(kbytes, -l) 64</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">max memory size</td><td style="text-align: left">(kbytes, -m) unlimited</td><td style="text-align: left">最大内存大小</td></tr>
<tr><td style="text-align: left">open files</td><td style="text-align: left">(-n) 1024</td><td style="text-align: left">可打开的文件数</td></tr>
<tr><td style="text-align: left">pipe size</td><td style="text-align: left">(512 bytes, -p) 8</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">POSIX message queues</td><td style="text-align: left">(bytes, -q) 819200</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">real-time priority</td><td style="text-align: left">(-r) 0</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">stack size</td><td style="text-align: left">(kbytes, -s) 8192</td><td style="text-align: left">堆栈大小</td></tr>
<tr><td style="text-align: left">cpu time</td><td style="text-align: left">(seconds, -t) unlimited CPU</td><td style="text-align: left">时间</td></tr>
<tr><td style="text-align: left">max user processes</td><td style="text-align: left">(-u) 15240</td><td style="text-align: left">最大进程数</td></tr>
<tr><td style="text-align: left">virtual memory</td><td style="text-align: left">(kbytes, -v) unlimited</td><td style="text-align: left">虚拟内存</td></tr>
<tr><td style="text-align: left">file locks</td><td style="text-align: left">(-x) unlimited</td><td style="text-align: left"></td></tr>
</tbody></table>
</div>
<h2 id="网卡多队列"><a class="header" href="#网卡多队列">网卡多队列</a></h2>
<pre><code class="language-bash">打开内核网卡多队列支持，避免网卡中断都集中在 cpu0 上处理，多队列打开后，可以让网卡中断均摊到各个 cpu上，对提高并发十分有用：

wget http://skywind3000.github.io/install/set_irq_affinity.sh

放到 /etc/config 目录下面（没有就新建），然后在 /etc/rc.local 里面加一行，每次重启就跑 set_irq_affinity.sh 且必须用 bash跑，参数传入需要开启多队列的网卡，以下是 /etc/rc.local 的内容：
/bin/bash 
/etc/set_irq_affinity.sh eth0 eth1 eth2
 
exit 0
下面是 setirqaffinity.sh 的代码：
# setting up irq affinity according to /proc/interrupts
# 2008-11-25 Robert Olsson
# 2009-02-19 updated by Jesse Brandeburg
#
# &gt; Dave Miller:
# (To get consistent naming in /proc/interrups)
# I would suggest that people use something like:
#   char buf[IFNAMSIZ+6];
#
#   sprintf(buf, &quot;%s-%s-%d&quot;,
#           netdev-&gt;name,
#       (RX_INTERRUPT ? &quot;rx&quot; : &quot;tx&quot;),
#       queue-&gt;index);
#
#  Assuming a device with two RX and TX queues.
#  This script will assign: 
#
#   eth0-rx-0  CPU0
#   eth0-rx-1  CPU1
#   eth0-tx-0  CPU0
#   eth0-tx-1  CPU1
#
 
set_affinity()
{
    MASK=$((1&lt;&lt;$VEC))
    printf &quot;%s mask=%X for /proc/irq/%d/smp_affinity\n&quot; $DEV $MASK $IRQ
    printf &quot;%X&quot; $MASK &gt; /proc/irq/$IRQ/smp_affinity
    #echo $DEV mask=$MASK for /proc/irq/$IRQ/smp_affinity
    #echo $MASK &gt; /proc/irq/$IRQ/smp_affinity
}
 
if [ &quot;$1&quot; = &quot;&quot; ] ; then
    echo &quot;Description:&quot;
    echo &quot;    This script attempts to bind each queue of a multi-queue NIC&quot;
    echo &quot;    to the same numbered core, ie tx0|rx0 --&gt; cpu0, tx1|rx1 --&gt; cpu1&quot;
    echo &quot;usage:&quot;
    echo &quot;    $0 eth0 [eth1 eth2 eth3]&quot;
fi
 
 
# check for irqbalance running
IRQBALANCE_ON=`ps ax | grep -v grep | grep -q irqbalance; echo $?`
if [ &quot;$IRQBALANCE_ON&quot; == &quot;0&quot; ] ; then
    echo &quot; WARNING: irqbalance is running and will&quot;
    echo &quot;          likely override this script's affinitization.&quot;
    echo &quot;          Please stop the irqbalance service and/or execute&quot;
    echo &quot;          'killall irqbalance'&quot;
fi
 
#
# Set up the desired devices.
#
 
for DEV in $*
do
  for DIR in rx tx TxRx
  do
     MAX=`grep $DEV-$DIR /proc/interrupts | wc -l`
     if [ &quot;$MAX&quot; == &quot;0&quot; ] ; then
       MAX=`egrep -i &quot;$DEV:.*$DIR&quot; /proc/interrupts | wc -l`
     fi
     if [ &quot;$MAX&quot; == &quot;0&quot; ] ; then
       echo no $DIR vectors found on $DEV
       continue
       #exit 1
     fi
     for VEC in `seq 0 1 $MAX`
     do
        IRQ=`cat /proc/interrupts | grep -i $DEV-$DIR-$VEC&quot;$&quot;  | cut  -d:  -f1 | sed &quot;s/ //g&quot;`
        if [ -n  &quot;$IRQ&quot; ]; then
          set_affinity
        else
           IRQ=`cat /proc/interrupts | egrep -i $DEV:v$VEC-$DIR&quot;$&quot;  | cut  -d:  -f1 | sed &quot;s/ //g&quot;`
           if [ -n  &quot;$IRQ&quot; ]; then
             set_affinity
           fi
        fi
     done
  done
done
 
 
# done
重启以后，cat 一下 /proc/interrupts里面，最右边网卡相关的中断是不是分摊到不同的cpu上面了。
</code></pre>
<h2 id="网络参数优化"><a class="header" href="#网络参数优化">网络参数优化</a></h2>
<pre><code class="language-bash">参考下面 /etc/sysctl.conf里面的优化选项和你 /etc/sysctl.conf 的具体内容，视情况更改：

#

# /etc/sysctl.conf - Configuration file for setting system variables

fs.file-max = 100000

# 表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0

# 是为了防止一定程度上的DOD的

net.ipv4.tcp_syncookies = 1

# 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭； 不是很建议设置，可能接受错误的数据

# net.ipv4.tcp_tw_reuse = 1

# 表示尽量不启用交换分区

vm.swappiness=0

# 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭

net.ipv4.tcp_tw_recycle = 1

# 表示系统同时保持TIME_WAIT套接字的最大数量，如果超过这个数字，TIME_WAIT套接字将立刻被清除并打印警告信息。默认为180000，改为5000

net.ipv4.tcp_max_tw_buckets = 10000

# 允许更多的PIDs (减少滚动翻转问题); may break some programs 32768

kernel.pid_max = 65535

# 表示用于向外连接的端口范围。缺省情况下很小：32768到61000，改为1024到65000

net.ipv4.ip_local_port_range = 1024 65000

# 记录的那些尚未收到客户端确认信息的连接请求的最大值。对于有128M内存的系统而言，缺省值是1024

net.ipv4.tcp_max_syn_backlog = 16384

# 时间戳可以避免序列号的卷绕。一个1Gbps的链路肯定会遇到以前用过的序列号。时间戳能够让内核接受这种“异常”的数据包。这里需要将其关掉

net.ipv4.tcp_timestamps = 0

# 为了打开对端的连接，内核需要发送一个SYN并附带一个回应前面一个SYN的ACK。也就是所谓三次握手中的第二次握手。这个设置决定了内核放弃连接之前发送SYN+ACK包的数量

net.ipv4.tcp_synack_retries = 2

# 在内核放弃建立连接之前发送SYN包的数量

net.ipv4.tcp_syn_retries = 2

# 如果套接字由本端要求关闭，这个参数决定了它保持在FIN-WAIT-2状态的时间。对端可以出错并永远不关闭连接，甚至意外当机。缺省值是60秒

# 但要记住的是，即使你的机器是一个轻载的WEB服务器，也有因为大量的死套接字而内存溢出的风险，FIN- WAIT-2的危险性比FIN-WAIT-1要小，因为它最多只能吃掉1.5K内存，但是它们的生存期长些

# 表示如果套接字由本端要求关闭，这个参数决定了它保持在FIN-WAIT-2状态的时间

net.ipv4.tcp_fin_timeout = 5

# 当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时

net.ipv4.tcp_keepalive_time = 1200

# ip_conntrack如果超过限制会出现丢包错误，默认为65535

# net.ipv4.ip_conntrack_max = 655360

# ip_conntrack回收速度

# net.ipv4.netfilter.ip_conntrack_tcp_timeout_established = 180

# 每个网络接口接收数据包的速率比内核处理这些包的速率快时，允许送到队列的数据包的最大数目

net.core.netdev_max_backlog =  262144

# web应用中listen函数的backlog默认会给我们内核参数的net.core.somaxconn限制到128，而Nginx内核参数定义的NGX_LISTEN_BACKLOG默认为511，所以有必要调整这个值

net.core.somaxconn = 262144

net.core.wmem_default = 8388608
net.core.rmem_default = 8388608
net.core.rmem_max = 16777216
net.core.wmem_max = 16777216

net.ipv4.tcp_mem = 94500000 915000000 927000000

# 系统中最多有多少个TCP套接字不被关联到任何一个用户文件句柄上。如果超过这个数字，孤儿连接将即刻被复位并打印出警告信息。这个限制仅仅是为了防止简单的DoS攻击

net.ipv4.tcp_max_orphans = 3276800

# 避免放大攻击

# net.ipv4.icmp_echo_ignore_broadcasts = 1

# 开启恶意icmp错误消息保护

# net.ipv4.icmp_ignore_bogus_error_responses = 1

# 开启并记录欺骗，源路由和重定向包

# net.ipv4.conf.all.log_martians = 1

# net.ipv4.conf.default.log_martians = 1

# 处理无源路由的包

# net.ipv4.conf.all.accept_source_route = 0

# net.ipv4.conf.default.accept_source_route = 0

# 开启反向路径过滤

# net.ipv4.conf.all.rp_filter = 1

# net.ipv4.conf.default.rp_filter = 1

# 确保无人能修改路由表

# net.ipv4.conf.all.accept_redirects = 0

# net.ipv4.conf.default.accept_redirects = 0

# net.ipv4.conf.all.secure_redirects = 0

# net.ipv4.conf.default.secure_redirects = 0

# 不充当路由器

# net.ipv4.ip_forward = 0

# net.ipv4.conf.all.send_redirects = 0

# net.ipv4.conf.default.send_redirects = 0

# Turn off the tcp_window_scaling

# #net.ipv4.tcp_window_scaling = 0

# # Turn off the tcp_sack

# #net.ipv4.tcp_sack = 0

#

参考上面的经验配置，按需要取消注释。
</code></pre>
<h2 id="修改时钟源"><a class="header" href="#修改时钟源">修改时钟源</a></h2>
<pre><code class="language-bash">查看当前时钟源和修改时钟源：

# cat /sys/devices/system/clocksource/clocksource0/available_clocksource

# cat /sys/devices/system/clocksource/clocksource0/current_clocksource

# echo hpet &gt; /sys/devices/system/clocksource/clocksource0/current_clocksource

之前发现有一台服务器同样进程耗费的 cpu比其他服务器高很多，经过查证开发同学在那个进程里频繁取系统时间，同时那台机器 gettimeofday之类的系统调用耗时比其他服务器要久。因为改代码已经来不及了，还好发现原来几台服务器的时钟源不同，经过修改后，取时间的系统调用时间大大下降。
</code></pre>
<h2 id="强制扫描磁盘"><a class="header" href="#强制扫描磁盘">强制扫描磁盘</a></h2>
<pre><code class="language-bash">机房突然停电，UPS没弄好，机器发生重启，一般会自动扫描硬盘，但是如果不放心要扫描主硬盘的话，可以手动来：

touch /forcefsck
在根目录下面创建一个名为 forcefsdk 的文件即可，然后重新启动就会进入强制 fsck程序。
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="修改系统参数"><a class="header" href="#修改系统参数">修改系统参数</a></h2>
<p>vi /etc/sysctl.conf</p>
<h2 id="修改下列配置参数根据自己情况修改"><a class="header" href="#修改下列配置参数根据自己情况修改">修改下列配置(参数根据自己情况修改)</a></h2>
<pre><code class="language-text">kernel.shmmax = 500000000
kernel.shmmni = 4096
kernel.shmall = 4000000000
kernel.sem = 500 1024000 200 4096

kernel.sysrq = 1
kernel.core_uses_pid = 1
kernel.msgmnb = 65536
kernel.msgmax = 65536
kernel.msgmni = 2048
net.ipv4.tcp_syncookies = 1
net.ipv4.ip_forward = 0
net.ipv4.conf.default.accept_source_route = 0
net.ipv4.tcp_tw_recycle = 1
net.ipv4.tcp_max_syn_backlog = 4096
net.ipv4.conf.all.arp_filter = 1
net.ipv4.ip_local_port_range = 1025 65535
net.core.netdev_max_backlog = 10000
net.core.rmem_max = 2097152
net.core.wmem_max = 2097152
vm.overcommit_memory = 2
</code></pre>
<h2 id="修改完毕后重新载入"><a class="header" href="#修改完毕后重新载入">修改完毕后重新载入</a></h2>
<p>sysctl -p</p>
<p>复制代码
limits参数</p>
<h2 id="修改文件打开数等限制"><a class="header" href="#修改文件打开数等限制">修改文件打开数等限制</a></h2>
<pre><code class="language-bash">vi /etc/security/limits.conf

## 添加如下几行（注意*也需要添加）

* soft nofile 65536
* hard nofile 65536
* soft nproc 131072
* hard nproc 131072

## 添加如下几行（注意*也需要添加）

vi /etc/security/limits.d/90-nproc.conf

* soft nofile 65536
* hard nofile 65536
* soft nproc 131072
* hard nproc 131072
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="自动启动"><a class="header" href="#自动启动">自动启动</a></h2>
<pre><code class="language-bash"># ubuntu 

vim /etc/rc.local
#添加命令
#你想系统启动时自动运行 SSH 隧道，你可以将上面的 autossh 命令添加到 

systemd

chkconfig --list
chkconfig -–list httpd
chkconfig –-add httpd
chkconfig httpd on
chkconfig httpd off

chkconfig mysqld on



vi /etc/rc.d/rc.local

#添加以下命令
/usr/sbin/apachectl start
/etc/rc.d/init.d/mysqld start
/etc/rc.d/init.d/smb start
/usr/local/subversion/bin/svnserve -d


启动命令
systemctl restart iptables.service
systemctl enable iptables.service

</code></pre>
<h2 id="linux的自动化"><a class="header" href="#linux的自动化">linux的“自动化”</a></h2>
<p>linux系统的web网站在运营状态时，我们常需要对网站进行维护，例如查看资源剩余并做出响应、日志分割、数据整理，在特定状态执行特定任务等等，这些都会需要linux能实现自动执行某些任任务。本篇博文介绍如何进行常见的linux自动化任务。</p>
<p>实现“自动化”有如下好处：</p>
<p>节省人力，一个脚本就够了。
在夜晚自动执行可以避开网站流量高峰期，不影响网站白天的效率。
准确，设置完善的情况下，不会出差错。
当然最重要的还是省心了，不用频繁的敲某些命令了。
开机启动
开机启动应该是我们很经常的需求了，我们常需要在开机时就自动执行某些命令来开启服务，进程等，有了它我们不必再在每次开机时输入同一堆命令。</p>
<p>chkconfig命令</p>
<p>使用chkconfig命令可以在设置在不同启动级别下启动特定的服务或是程序。</p>
<p>先说一下linux的运行级别：</p>
<p>等级0表示：表示关机
等级1表示：单用户模式
等级2表示：无网络连接的多用户命令行模式
等级3表示：有网络连接的多用户命令行模式
等级4表示：不可用
等级5表示：带图形界面的多用户模式
等级6表示：重新启动
chkconfig的命令如下：</p>
<p>chkconfig --list //命令查看已设置的开启自启动列表。
xxxd 0:off 1:off 2:on ... 6:off //list的结果，表示在xxxd服务在启动级别为2 3 4 5 的情况下会自动启动。
chkconfig --add xxxd//向任务列表中添加一个xxxd服务
chkconfig [--level 1/2/../6] xxxd on/off//设置xxxd用服务在n状态为开/关，[]内省略则在2345级别开启
chkconfig --del xxxd //将任务列表中的xxxd服务删除
rc.d文件的编辑</p>
<p>也可以直接编辑/etc/rc.d/目录下的文件来实现开机自启动。此目录下有很多文件，rcn.d是在启动状态为n的情况下的启动文件夹，rc、rc.sysinit、init.d都是系统的模块或系统设置的自启文件[夹]。</p>
<p>我们用vim rc.local 编辑 rc.local文件，来定制自己的自启计划。命令十分简单，就像平常在操作一样。如/usr/local/apache/bin/apachectl start表示开机自启动apache服务器。</p>
<p>at实现定时任务
at是一个简单的功能简单的定时任务程序，它只能进行一次性的定时任务，其用法如下：</p>
<blockquote>
<p>at time　　　　　　//at加时间启动at命令
at&gt;operation　　　　//输入要执行的操作
at&gt;Ctrl+D　　　　　　//按Ctrl+D退出命令编辑
其time的常见形式如下</p>
</blockquote>
<p>at H:m tomorrow     //第二天的H点m分
at now + n minutes/hours/days/weeks  //在n分/时/天/周后
at midnight         //在午夜=-=
at H:m pm/am        //在当天上午/下午的H点m分
我们也可以在/var/spool/at文件中查看at的当前命令。还需要注意的是，linux默认atd进程关闭状态，需要手动打开。</p>
<p>crontab实现定时任务
linux内置的cron进程能帮我们实现这些需求，cron搭配shell脚本，非常复杂的指令也没有问题。</p>
<p>cron介绍</p>
<p>cron守护进程是一个由实用程序和配置文件组成的小型子系统，在几乎所有类 UNIX 系统上都可以找到某种风格的cron，我们可以用ps aux|grep cron找到crond这个守护进程。</p>
<p>我们经常使用的是crontab命令是cron table的简写，它是cron的配置文件，也可以叫它作业列表，我们可以在以下文件夹内找到相关配置文件。</p>
<p>/var/spool/cron/ 目录下存放的是每个用户包括root的crontab任务，每个任务以创建者的名字命名
/etc/crontab 这个文件负责调度各种管理和维护任务。
/etc/cron.d/ 这个目录用来存放任何要执行的crontab文件或脚本。
我们还可以把脚本放在/etc/con.hourly、/etc/con.daily、/etc/con.weekly、/etc/con.monthly目录中，让它每小时/天/星期、月执行一次。
crontab的使用</p>
<p>我们常用的命令如下：</p>
<p>crontab [-u username]　　　　//省略用户表表示操作当前用户的crontab
-e      (编辑工作表)
-l      (列出工作表里的命令)
-r      (删除工作作)
我们用crontab -e进入当前用户的工作表编辑，是常见的vim界面。每行是一条命令。</p>
<p>crontab的命令构成为 时间+动作，其时间有分、时、日、月、周五种，操作符有</p>
<ul>
<li>
<p>取值范围内的所有数字
/ 每过多少个数字</p>
</li>
<li>
<p>从X到Z
，散列数字
以下是几个例子。</p>
</li>
</ul>
<p>时间                  注释
0 0 25 12 *//在12月25日的0时0分
*/5 ****     //每过5分钟</p>
<ul>
<li>4-6 ***//每天的4 5 6点
*** * 2，5     //每周二和周五
配合简单的shell脚本</li>
</ul>
<p>如果我们的命令有逻辑判断等非常复杂的操作时，再直接编辑crontab就有点困难了，这时，我们可以使用shell脚本。其来历，分类定义与题不符，不再多说，我们直接说它的用法。</p>
<p>我们用vim /usr/sh/test.sh来使用vim编辑一个shell脚本</p>
<pre><code class="language-bash">!/bin/sh           //声明开始shell脚本
a = &quot;hello world&quot;   //定义一个shell变量
echo $a             //熟悉的echo，输出a变量

#然后crontab -e编辑crontab，添加 */5* ** * /usr/sh/test.sh每隔五分钟运行一次test.sh脚本，也可以用 /phppath/php /filepath/test.php 来用php进程来执行php程序。
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="系统设置"><a class="header" href="#系统设置">系统设置</a></h2>
<h2 id="环境变量"><a class="header" href="#环境变量">环境变量</a></h2>
<pre><code class="language-bash">
# 所有用户
vim /etc/profile
 PATH=$PATH:/home/erlang/bin/
source /etc/profile

# 当前用户 
vim ~/.bashrc
 export JAVA_HOME=/home/[username]/apps/jdk
 export JRE_HOME=${JAVA_HOME}/jre
 export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib
 export PATH=${JAVA_HOME}/bin:$PATH
source ~/.bashrc
</code></pre>
<h2 id="修改机器名称"><a class="header" href="#修改机器名称">修改机器名称</a></h2>
<h3 id="ubuntu-1"><a class="header" href="#ubuntu-1">ubuntu</a></h3>
<pre><code class="language-bash">sudo vi /etc/hostname
</code></pre>
<h3 id="centos"><a class="header" href="#centos">centOS</a></h3>
<pre><code class="language-bash">sudo hostname Server_192.168.69.171
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="常用命令"><a class="header" href="#常用命令">常用命令</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h2 id="man"><a class="header" href="#man">man</a></h2>
<p>通常情况下，man 手册里面的内容都是英文的，这就要求你有一定的英文基础。man 手册的内容很多，涉及了 Linux 使用过程中的方方面面。为了便于查找，man 手册被进行了分册（分区段）处理，在 Research UNIX、BSD、OS X 和 Linux 中，手册通常被分为8个区段，安排如下：
| 区段 | 说明 |
| :--- | :------ |
| 1 | 一般命令 |
| 2 | 系统调用 |
| 3 | 库函数，涵盖了C标准函数库 |
| 4 | 特殊文件（通常是/dev中的设备）和驱动程序 |
| 5 | 文件格式和约定 |
| 6 | 游戏和屏保 |
| 7 | 杂项 |
| 8 | 系统管理命令和守护进程 |</p>
<p>要查看相应区段的内容，就在 man 后面加上相应区段的数字即可，如：</p>
<p>$ man 1 ls</p>
<p>会显示第一区段中的ls命令 man 页面。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="用户和群组"><a class="header" href="#用户和群组">用户和群组</a></h2>
<pre><code class="language-bash">groupadd group_name 创建一个新用户组
groupdel group_name 删除一个用户组
groupmod -n new_group_name old_group_name 重命名一个用户组
useradd -c &quot;Name Surname &quot; -g admin -d /home/user1 -s /bin/bash user1 创建一个属于 &quot;admin&quot; 用户组的用户
useradd user1 创建一个新用户
userdel -r user1 删除一个用户 ( '-r' 排除主目录)
usermod -c &quot;User FTP&quot; -g system -d /ftp/user1 -s /bin/nologin user1 修改用户属性
passwd 修改口令
passwd user1 修改一个用户的口令 (只允许root执行)
chage -E 2005-12-31 user1 设置用户口令的失效期限
pwck 检查 '/etc/passwd' 的文件格式和语法修正以及存在的用户
grpck 检查 '/etc/passwd' 的文件格式和语法修正以及存在的群组
newgrp group_name 登陆进一个新的群组以改变新创建文件的预设群组
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="包管理"><a class="header" href="#包管理">包管理</a></h2>
<pre><code class="language-bash"># RPM 包 - （Fedora, Redhat及类似系统）

rpm -ivh package.rpm 安装一个rpm包
rpm -ivh --nodeeps package.rpm 安装一个rpm包而忽略依赖关系警告
rpm -U package.rpm 更新一个rpm包但不改变其配置文件
rpm -F package.rpm 更新一个确定已经安装的rpm包
rpm -e package_name.rpm 删除一个rpm包
rpm -qa 显示系统中所有已经安装的rpm包
rpm -qa | grep httpd 显示所有名称中包含 &quot;httpd&quot; 字样的rpm包
rpm -qi package_name 获取一个已安装包的特殊信息
rpm -qg &quot;System Environment/Daemons&quot; 显示一个组件的rpm包
rpm -ql package_name 显示一个已经安装的rpm包提供的文件列表
rpm -qc package_name 显示一个已经安装的rpm包提供的配置文件列表
rpm -q package_name --whatrequires 显示与一个rpm包存在依赖关系的列表
rpm -q package_name --whatprovides 显示一个rpm包所占的体积
rpm -q package_name --scripts 显示在安装/删除期间所执行的脚本l
rpm -q package_name --changelog 显示一个rpm包的修改历史
rpm -qf /etc/httpd/conf/httpd.conf 确认所给的文件由哪个rpm包所提供
rpm -qp package.rpm -l 显示由一个尚未安装的rpm包提供的文件列表
rpm --import /media/cdrom/RPM-GPG-KEY 导入公钥数字证书
rpm --checksig package.rpm 确认一个rpm包的完整性
rpm -qa gpg-pubkey 确认已安装的所有rpm包的完整性
rpm -V package_name 检查文件尺寸、 许可、类型、所有者、群组、MD5检查以及最后修改时间
rpm -Va 检查系统中所有已安装的rpm包- 小心使用
rpm -Vp package.rpm 确认一个rpm包还未安装
rpm2cpio package.rpm | cpio --extract --make-directories *bin* 从一个rpm包运行可执行文件
rpm -ivh /usr/src/redhat/RPMS/`arch`/package.rpm 从一个rpm源码安装一个构建好的包
rpmbuild --rebuild package_name.src.rpm 从一个rpm源码构建一个 rpm 包


# YUM 软件包升级器 - （Fedora, RedHat及类似系统）
yum install package_name 下载并安装一个rpm包
yum localinstall package_name.rpm 将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系
yum update package_name.rpm 更新当前系统中所有安装的rpm包
yum update package_name 更新一个rpm包
yum remove package_name 删除一个rpm包
yum list 列出当前系统中安装的所有包
yum search package_name 在rpm仓库中搜寻软件包
yum clean packages 清理rpm缓存删除下载的包
yum clean headers 删除所有头文件
yum clean all 删除所有缓存的包和头文件


# DEB 包 (Debian, Ubuntu 以及类似系统)
dpkg -i package.deb 安装/更新一个 deb 包
dpkg -r package_name 从系统删除一个 deb 包
dpkg -l 显示系统中所有已经安装的 deb 包
dpkg -l | grep httpd 显示所有名称中包含 &quot;httpd&quot; 字样的deb包
dpkg -s package_name 获得已经安装在系统中一个特殊包的信息
dpkg -L package_name 显示系统中已经安装的一个deb包所提供的文件列表
dpkg --contents package.deb 显示尚未安装的一个包所提供的文件列表
dpkg -S /bin/ping 确认所给的文件由哪个deb包提供


# APT 软件工具 (Debian, Ubuntu 以及类似系统)
apt-get install package_name 安装/更新一个 deb 包
apt-cdrom install package_name 从光盘安装/更新一个 deb 包
apt-get update 升级列表中的软件包
apt-get upgrade 升级所有已安装的软件
apt-get remove package_name 从系统删除一个deb包
apt-get check 确认依赖的软件仓库正确
apt-get clean 从下载的软件包中清理缓存
apt-cache search searched-package 返回包含所要搜索字符串的软件包名称


# 字符设置和文件格式转换
dos2unix filedos.txt fileunix.txt 将一个文本文件的格式从MSDOS转换成UNIX
unix2dos fileunix.txt filedos.txt 将一个文本文件的格式从UNIX转换成MSDOS
recode ..HTML &lt; page.txt &gt; page.html 将一个文本文件转换成html
recode -l | more 显示所有允许的转换格式


# 文件系统分析
badblocks -v /dev/hda1 检查磁盘hda1上的坏磁块
fsck /dev/hda1 修复/检查hda1磁盘上linux文件系统的完整性
fsck.ext2 /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性
e2fsck /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性
e2fsck -j /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性
fsck.ext3 /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性
fsck.vfat /dev/hda1 修复/检查hda1磁盘上fat文件系统的完整性
fsck.msdos /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性
dosfsck /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性


# 初始化一个文件系统
mkfs /dev/hda1 在hda1分区创建一个文件系统
mke2fs /dev/hda1 在hda1分区创建一个linux ext2的文件系统
mke2fs -j /dev/hda1 在hda1分区创建一个linux ext3(日志型)的文件系统
mkfs -t vfat 32 -F /dev/hda1 创建一个 FAT32 文件系统
fdformat -n /dev/fd0 格式化一个软盘
mkswap /dev/hda3 创建一个swap文件系统


# SWAP文件系统
mkswap /dev/hda3 创建一个swap文件系统
swapon /dev/hda3 启用一个新的swap文件系统
swapon /dev/hda2 /dev/hdb3 启用两个swap分区

# 备份
dump -0aj -f /tmp/home0.bak /home 制作一个 '/home' 目录的完整备份
dump -1aj -f /tmp/home0.bak /home 制作一个 '/home' 目录的交互式备份
restore -if /tmp/home0.bak 还原一个交互式备份
rsync -rogpav --delete /home /tmp 同步两边的目录
rsync -rogpav -e ssh --delete /home ip_address:/tmp 通过SSH通道rsync
rsync -az -e ssh --delete ip_addr:/home/public /home/local 通过ssh和压缩将一个远程目录同步到本地目录
rsync -az -e ssh --delete /home/local ip_addr:/home/public 通过ssh和压缩将本地目录同步到远程目录
dd bs=1M if=/dev/hda | gzip | ssh user@ip_addr 'dd of=hda.gz' 通过ssh在远程主机上执行一次备份本地磁盘的操作
dd if=/dev/sda of=/tmp/file1 备份磁盘内容到一个文件
tar -Puf backup.tar /home/user 执行一次对 '/home/user' 目录的交互式备份操作
( cd /tmp/local/ &amp;&amp; tar c . ) | ssh -C user@ip_addr 'cd /home/share/ &amp;&amp; tar x -p' 通过ssh在远程目录中复制一个目录内容
( tar c /home ) | ssh -C user@ip_addr 'cd /home/backup-home &amp;&amp; tar x -p' 通过ssh在远程目录中复制一个本地目录
tar cf - . | (cd /tmp/backup ; tar xf - ) 本地将一个目录复制到另一个地方，保留原有权限及链接
find /home/user1 -name '*.txt' | xargs cp -av --target-directory=/home/backup/ --parents 从一个目录查找并复制所有以 '.txt' 结尾的文件到另一个目录
find /var/log -name '*.log' | tar cv --files-from=- | bzip2 &gt; log.tar.bz2 查找所有以 '.log' 结尾的文件并做成一个bzip包
dd if=/dev/hda of=/dev/fd0 bs=512 count=1 做一个将 MBR (Master Boot Record)内容复制到软盘的动作
dd if=/dev/fd0 of=/dev/hda bs=512 count=1 从已经保存到软盘的备份中恢复MBR内容

# 光盘
cdrecord -v gracetime=2 dev=/dev/cdrom -eject blank=fast -force 清空一个可复写的光盘内容
mkisofs /dev/cdrom &gt; cd.iso 在磁盘上创建一个光盘的iso镜像文件
mkisofs /dev/cdrom | gzip &gt; cd_iso.gz 在磁盘上创建一个压缩了的光盘iso镜像文件
mkisofs -J -allow-leading-dots -R -V &quot;Label CD&quot; -iso-level 4 -o ./cd.iso data_cd 创建一个目录的iso镜像文件
cdrecord -v dev=/dev/cdrom cd.iso 刻录一个ISO镜像文件
gzip -dc cd_iso.gz | cdrecord dev=/dev/cdrom - 刻录一个压缩了的ISO镜像文件
mount -o loop cd.iso /mnt/iso 挂载一个ISO镜像文件
cd-paranoia -B 从一个CD光盘转录音轨到 wav 文件中
cd-paranoia -- &quot;-3&quot; 从一个CD光盘转录音轨到 wav 文件中（参数-3）
cdrecord --scanbus 扫描总线以识别scsi通道
dd if=/dev/hdc | md5sum 校验一个设备的md5sum编码，例如一张 CD

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="1top-linux进程监控"><a class="header" href="#1top-linux进程监控">1.Top-Linux进程监控</a></h2>
<p>Linux下的Top命令是一个性能监控程序，许多系统管理员常常用它来监控Linux性能，在许多Linux或者类Unix操作系统里都有这个命令。Top命令用于按一定的顺序显示所有正在运行而且处于活动状态的实时进程，而且会定期更新显示结果。这条命令显示了CPU的使用率、内存使用率、交换内存使用大小、高速缓存使用大小、缓冲区使用大小，进程PID、所使用命令以及其他。它还可以显示正在运行进程的内存和CPU占用多的情况。对系统管理员来说，top命令式是一个非常有用的，它可用于监控系统并在需要的时候采取正确的处理动作。让我们看看实际中的top命令。</p>
<blockquote>
<p>top</p>
</blockquote>
<h2 id="2-vmstat--虚拟内存统计"><a class="header" href="#2-vmstat--虚拟内存统计">2. VmStat – 虚拟内存统计</a></h2>
<p>Linux 的 VmStat 命令用于显示虚拟内存、内核线程、磁盘、系统进程、I/O 块、中断、CPU 活动 等的统计信息。缺省情况下， vmstat 命令在 Linux 系统下不可用，你需要安装一个包含了 vmstat 程序的 sysstat 软件包。命令格式的常见用法是：</p>
<blockquote>
<p>vmstat
procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu-----
r  b   swpd   free  inact active   si   so    bi    bo   in   cs us sy id wa st
1  0      0 810420  97380  70628    0    0   115     4   89   79  1  6 90  3  0</p>
</blockquote>
<h2 id="3lsof-列出打开的文件"><a class="header" href="#3lsof-列出打开的文件">3.Lsof-列出打开的文件</a></h2>
<p>在许多Linux或者类Unix系统里都有lsof命令，它常用于以列表的形式显示所有打开的文件和进程。打开的文件包括磁盘文件、网络套接字、管道、设备和进程。使用这条命令的主要情形之一就是在无法挂载磁盘和显示正在使用或者打开某个文件的错误信息的时候。使用这条命令，你可以很容易地看到正在使用哪个文件。这条命令最常用的格式如下：</p>
<blockquote>
<p>lsof
COMMAND     PID      USER   FD      TYPE     DEVICE     SIZE       NODE NAME
init          1      root  cwd       DIR      104,2     4096          2 /
init          1      root  rtd       DIR      104,2     4096          2 /
init          1      root  txt       REG      104,2    38652   17710339 /sbin/init
init          1      root  mem       REG      104,2   129900     196453 /lib/ld-2.5.so
init          1      root  mem       REG      104,2  1693812     196454 /lib/libc-2.5.so
init          1      root  mem       REG      104,2    20668     196479 /lib/libdl-2.5.so
init          1      root  mem       REG      104,2   245376     196419 /lib/libsepol.so.1
init          1      root  mem       REG      104,2    93508     196431 /lib/libselinux.so.1
init          1      root   10u     FIFO       0,17                 953 /dev/initctl</p>
</blockquote>
<p>4.Tcpdump-网络包分析器</p>
<p>Tcpdump是最广泛使用的网络包分析器或者包监控程序之一，它用于捕捉或者过滤网络上指定接口上接收或者传输的TCP/IP包。它还有一个选项用于把捕捉到的包保存到文件里，以便以后进行分析。在几乎所有主要的Linux发布里，tcpdump都可以使用。</p>
<blockquote>
<p>tcpdump -i eth0tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth0, link-type EN10MB (Ethernet), capture size 96 bytes
22:08:59.617628 IP tecmint.com.ssh &gt; 115.113.134.3.static-mumbai.vsnl.net.in.28472: P 2532133365:2532133481(116) ack 3561562349 win 9648
22:09:07.653466 IP tecmint.com.ssh &gt; 115.113.134.3.static-mumbai.vsnl.net.in.28472: P 116:232(116) ack 1 win 9648
22:08:59.617916 IP 115.113.134.3.static-mumbai.vsnl.net.in.28472 &gt; tecmint.com.ssh: . ack 116 win 64347</p>
</blockquote>
<h2 id="5netstat-网络状态统计"><a class="header" href="#5netstat-网络状态统计">5.Netstat-网络状态统计</a></h2>
<p>Netstat是一个用于监控进出网络的包和网络接口统计的命令行工具。它是一个非常有用的工具，系统管理员可以用来监控网络性能，定位并解决网络相关问题。</p>
<blockquote>
<p>netstat -a | moreActive Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address               Foreign Address             State
tcp        0      0 <em>:mysql</em>:<em>LISTEN
tcp        0      0</em>:sunrpc                    <em>:</em>                         LISTEN
tcp        0      0 <em>:realm-rusd</em>:<em>LISTEN
tcp        0      0</em>:ftp                       <em>:</em>                         LISTEN
tcp        0      0 localhost.localdomain:ipp   <em>:</em>                         LISTEN
tcp        0      0 localhost.localdomain:smtp  <em>:</em>                         LISTEN
tcp        0      0 localhost.localdomain:smtp  localhost.localdomain:42709 TIME_WAIT
tcp        0      0 localhost.localdomain:smtp  localhost.localdomain:42710 TIME_WAIT
tcp        0      0 <em>:http</em>:<em>LISTEN
tcp        0      0</em>:ssh                       <em>:</em>                         LISTEN
tcp        0      0 <em>:https</em>:*                         LISTEN</p>
</blockquote>
<h2 id="6-htop--linux进程监控"><a class="header" href="#6-htop--linux进程监控">6. Htop – Linux进程监控</a></h2>
<p>Htop 是一个非常高级的交互式的实时linux进程监控工具。 它和top命令十分相似，但是它具有更丰富的特性，例如用户可以友好地管理进程，快捷键，垂直和水平方式显示进程等等。 Htop是一个第三方工具，它不包含在linux系统中，你需要使用YUM包管理工具去安装它。 关于安装的更多信息，请阅读下文.</p>
<blockquote>
<p>htop
Htop Command Example</p>
</blockquote>
<h2 id="7iotop-监控linux磁盘io"><a class="header" href="#7iotop-监控linux磁盘io">7.Iotop-监控Linux磁盘I/O</a></h2>
<p>Iotop命令同样也非常类似于top命令和Htop程序，不过它具有监控并显示实时磁盘I/O和进程的统计功能。在查找具体进程和大量使用磁盘读写进程的时候，这个工具就非常有用。</p>
<blockquote>
<p>iotop</p>
</blockquote>
<p>Iotop Command Example Iotop命令举例的截图
有关如何安装和使用iotop的信息，请阅读： 在Linux下安装Iotop。</p>
<h2 id="8iostat-输入输出统计"><a class="header" href="#8iostat-输入输出统计">8.Iostat-输入/输出统计</a></h2>
<p>Iostat是一个用于收集显示系统存储设备输入和输出状态统计的简单工具。这个工具常常用来追踪存储设备的性能问题，其中存储设备包括设备、本地磁盘，以及诸如使用NFS等的远端磁盘。</p>
<blockquote>
<p>iostat
Linux 2.6.18-238.9.1.el5 (tecmint.com)         09/13/2012</p>
</blockquote>
<p>avg-cpu:  %user   %nice %system %iowait  %steal   %idle
2.60    3.65    1.04    4.29    0.00   88.42</p>
<p>Device:            tps   Blk_read/s   Blk_wrtn/s   Blk_read   Blk_wrtn
cciss/c0d0       17.79       545.80       256.52  855159769  401914750
cciss/c0d0p1      0.00         0.00         0.00       5459       3518
cciss/c0d0p2     16.45       533.97       245.18  836631746  384153384
cciss/c0d0p3      0.63         5.58         3.97    8737650    6215544
cciss/c0d0p4      0.00         0.00         0.00          8          0
cciss/c0d0p5      0.63         3.79         5.03    5936778    7882528
cciss/c0d0p6      0.08         2.46         2.34    3847771    3659776</p>
<h2 id="9iptraf-实时局域网ip监控"><a class="header" href="#9iptraf-实时局域网ip监控">9.IPTraf-实时局域网IP监控</a></h2>
<p>IPTraf是一个在Linux控制台运行的、开放源代码的实时网络（局域网）监控应用。它采集了大量信息，比如通过网络的IP流量监控，包括TCP标记、ICMP详细信息、TCP/UDP流量分离、TCP连接包和字节数。同时还采集有关接口状态的常见信息和详细信息：TCP、UDP、IP、ICMP、非IP，IP校验和错误，接口活动等。</p>
<p>IP Traffic Monitor</p>
<h2 id="10-psacct-或者-acct---监视用户活动"><a class="header" href="#10-psacct-或者-acct---监视用户活动">10. psacct 或者 acct - 监视用户活动</a></h2>
<p>psacct或者acct工具用于监视系统里每个用户的活动状况。这两个服务进程运行在后台，它们对系统上运行的每个用户的所有活动进行近距离监视，同时还监视这些活动所使用的资源情况。</p>
<p>系统管理员可以使用这两个工具跟踪每个用户的活动，比如用户正在做什么，他们提交了那些命令，他们使用了多少资源，他们在系统上持续了多长时间等等。</p>
<h2 id="11monit---linux进程和服务监控工具"><a class="header" href="#11monit---linux进程和服务监控工具">11.Monit - Linux进程和服务监控工具</a></h2>
<p>Monit是一个免费的开源软件，也是一个基于网络的进程监控工具。它能自动监控和管理系统进程，程序，文件，文件夹，权限，总和验证码和文件系统。</p>
<p>这个软件能监控像Apache, MySQL, Mail, FTP, ProFTP, Nginx, SSH这样的服务。你可以通过命令行或者这个软件提供的网络借口来查看系统状态。</p>
<p>The Interface of Moint</p>
<p>Monit Linux系统监控</p>
<h2 id="12nethogs-监视每个进程使用的网络带宽"><a class="header" href="#12nethogs-监视每个进程使用的网络带宽">12.NetHogs-监视每个进程使用的网络带宽</a></h2>
<p>NetHogs是一个开放源源代码的很小程序（与Linux下的top命令很相似），它密切监视着系统上每个进程的网络活动。同时还追踪着每个程序或者应用所使用的实时网络带宽。</p>
<p>NetHogs Linux Bandwidth Monitoring</p>
<h2 id="13iftop-监视网络带宽"><a class="header" href="#13iftop-监视网络带宽">13.iftop-监视网络带宽</a></h2>
<p>iftop是另一个在控制台运行的开放源代码系统监控应用，它显示了系统上通过网络接口的应用网络带宽使用（源主机或者目的主机）的列表，这个列表定期更新。iftop用于监视网络的使用情况，而'top'用于监视CPU的使用情况。iftop是'top'工具系列中的一员，它用于监视所选接口，并显示两个主机间当前网络带宽的使用情况。</p>
<p>iftop - Network Bandwidth Monitoring</p>
<p>iftop-监视网络带宽。</p>
<h2 id="14-monitorix-系统和网络监控"><a class="header" href="#14-monitorix-系统和网络监控">14 Monitorix-系统和网络监控</a></h2>
<p>Monitorix 是一个免费的轻量级应用工具，它的设计初衷是运行和监控Linux/Unix服务器系统和资源等。它有一个HTTP 网络服务器，这个服务器有规律的收集系统和网络的信息并以图形化的形式展示出来。它监控系统的平均负载和使用，内存分配、磁盘健康状况、系统服务、网络端口、邮件统计（Sendmail，Postfix,Dovecot等），MySQL统计，等等。它就是用来监控系统的总体性能，帮助发现失误、瓶颈和异常活动的。</p>
<h2 id="15-arpwatch--以太网活动监视器"><a class="header" href="#15-arpwatch--以太网活动监视器">15. Arpwatch – 以太网活动监视器</a></h2>
<p>Arpwatch被设计用来监控Linux上的以太网地址解析 (MAC和IP地址的变化)。他在一段时间内持续监控以太网活动并输出IP和MAC地址配对变动的日志。它还可以向管理员发送邮件通知，对地址配对的增改发出警告。这对于检测网络上的ARP攻击很有用。</p>
<p>更多信息请参阅 : Arpwatch to Monitor Ethernet Activity</p>
<h2 id="16-suricata--网络安全监控"><a class="header" href="#16-suricata--网络安全监控">16. Suricata – 网络安全监控</a></h2>
<p>Suricata 是一个开源的高性能网络安全、入侵检测和反监测工具，可以运行Linux、FreeBSD和Windows上。非营利组织OISF (Open Information Security Foundation)开发并拥有其版权。</p>
<h2 id="17-vnstat-php--网络流量监控"><a class="header" href="#17-vnstat-php--网络流量监控">17. VnStat PHP – 网络流量监控</a></h2>
<p>VnStat PHP 是流行网络工具&quot;vnstat&quot;的基于web的前端呈现。VnStat PHP 将网络使用情况呈现在漂亮的图形界面中。他可以显示以小时、日、月计的上传和下载流量并输出总结报告。</p>
<h2 id="18-nagios--网络服务器监控"><a class="header" href="#18-nagios--网络服务器监控">18. Nagios – 网络/服务器监控</a></h2>
<p>Nagios是领先而强大的开源监控系统，他可以让网络/系统管理员在问题影响到正常的业务之前发现并解决它们。有了Nagios系统，管理员可以在单个窗口内远程检测Linux、Windows、开关、路由器和打印机。它可以危险警告并指出系统/服务器是否有异常，这可以间接帮助你在问题发生之前采取抢救措施。</p>
<p>更多信息请参阅 : Install Nagios Monitoring System to Monitor Remote Linux/Windows Hosts</p>
<p>我们想知道：你在用什么监控程序来监控Linux服务器的性能呢？如果我们在上面错过了你认为重要的工具，请在评论中告诉我们，不要忘了分享它！</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="安裝"><a class="header" href="#安裝">安裝</a></h2>
<p>install linux库时，有时带有 lib，dev，gdb</p>
<p>运行装lib</p>
<p>编译dev</p>
<p>调试装gdb</p>
<pre><code class="language-text">linux下configure，make，make install的意义

tar.gz、tar.bz2的是源代码包，需要编译之后才能安装，在编译过程中你可以指定各种参数以适应你的系统需求，比如安装位置，优化参数，要哪些功能不要哪些功能等等。

这类源代码包需要解压后（tar.gz的用 tar zxvf 解压，tar.bz2的用 tar jxvf 解压），进入解压目录，一般都有一个 INSTALL 的文本文件，里面一般都是安装的详细说明，可以用vi、nano、pico或X下面的文本编辑器（如gedit,gvim,kedit等）打开查看，安装一般就是三个步骤：

configure 这一步一般用来生成 Makefile，为下一步的编译做准备，你可以通过在 configure 后加上参数来对安装进行控制，比如代码:
  ./configure --prefix=/usr
     上面的意思是将该软件安装在 /usr 下面，执行文件就会安装在 /usr/bin （而不是默认的 /usr/local/bin),资源文件就会安装在 /usr/share（而不是默认的/usr/local/share）。同时一些软件的配置文件你可以通过指定 --sys-config= 参数进行设定。有一些软件还可以加上 --with、--enable、--without、--disable 等等参数对编译加以控制，你可以通过允许 ./configure --help 察看详细的说明帮助。

make 这一步就是编译，大多数的源代码包都经过这一步进行编译（当然有些perl或python编写的软件需要调用perl或python来进行编译）。如果在 make 过程中出现 error ，你就要记下错误代码（注意不仅仅是最后一行），然后你可以向开发者提交 bugreport（一般在 INSTALL 里有提交地址），或者你的系统少了一些依赖库等，这些需要自己仔细研究错误代码。

make install 这条命令来进行安装（当然有些软件需要先运行 make check 或 make test 来进行一些测试），这一步一般需要你有 root 权限（因为要向系统写入文件）。

 安装完毕后你就可以删除解压目录了。采用源代码编译方式来安装软件是 Linux 系统下最常见的安装软件方法，而且这种方法使你可以更加自由地控制安装细节，所以提倡大家多使用该方法安装软件。
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h3 id="终端快捷键"><a class="header" href="#终端快捷键">终端快捷键</a></h3>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">快捷键</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left">tab</td><td style="text-align: left">补全</td></tr>
<tr><td style="text-align: left">ctrl+a</td><td style="text-align: left">移动游标到行首</td></tr>
<tr><td style="text-align: left">ctrl+e</td><td style="text-align: left">移动游标到行尾</td></tr>
<tr><td style="text-align: left">ctrl+b</td><td style="text-align: left">向左移动</td></tr>
<tr><td style="text-align: left">ctrl+f</td><td style="text-align: left">向右移动</td></tr>
<tr><td style="text-align: left">ctrl+k</td><td style="text-align: left">删除此处至末尾所有内容</td></tr>
<tr><td style="text-align: left">ctrl+u</td><td style="text-align: left">删除此处至开始所有内容</td></tr>
<tr><td style="text-align: left">ctrl+d</td><td style="text-align: left">删除当前字母</td></tr>
<tr><td style="text-align: left">ctrl+w</td><td style="text-align: left">删除此处到左边的单词</td></tr>
<tr><td style="text-align: left">ctrl+y</td><td style="text-align: left">粘贴由ctrl+u，ctrl+d，ctrl+w删除的单词</td></tr>
<tr><td style="text-align: left">ctrl+l</td><td style="text-align: left">相当于clear</td></tr>
<tr><td style="text-align: left">ctrl+p</td><td style="text-align: left">向上显示缓存命令(向上箭头)</td></tr>
<tr><td style="text-align: left">ctrl+shift+n</td><td style="text-align: left">新终端</td></tr>
<tr><td style="text-align: left">ctrl+c</td><td style="text-align: left">终止</td></tr>
<tr><td style="text-align: left">ctrl+r</td><td style="text-align: left">搜索你已经输入的命令</td></tr>
<tr><td style="text-align: left">Ctrl+d</td><td style="text-align: left">键盘输入结束或退出终端</td></tr>
<tr><td style="text-align: left">Ctrl+s</td><td style="text-align: left">暂停当前程序，暂停后按下任意键恢复运行</td></tr>
<tr><td style="text-align: left">Ctrl+z</td><td style="text-align: left">将当前程序放到后台运行，恢复到前台为命令fg</td></tr>
<tr><td style="text-align: left">Ctrl+a</td><td style="text-align: left">将光标移至输入行头，相当于Home键</td></tr>
<tr><td style="text-align: left">Ctrl+e</td><td style="text-align: left">将光标移至输入行末，相当于End键</td></tr>
<tr><td style="text-align: left">Ctrl+k</td><td style="text-align: left">删除从光标所在位置到行末</td></tr>
<tr><td style="text-align: left">Alt+Backspace</td><td style="text-align: left">向前删除一个单词</td></tr>
<tr><td style="text-align: left">Shift+PgUp</td><td style="text-align: left">将终端显示向上滚动</td></tr>
<tr><td style="text-align: left">Shift+PgDn</td><td style="text-align: left">将终端显示向下滚动</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h3 id="终端快捷键-1"><a class="header" href="#终端快捷键-1">终端快捷键</a></h3>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">字符</th><th style="text-align: left">含义</th></tr></thead><tbody>
<tr><td style="text-align: left">*</td><td style="text-align: left">匹配 0 或多个字符</td></tr>
<tr><td style="text-align: left">?</td><td style="text-align: left">匹配任意一个字符</td></tr>
<tr><td style="text-align: left">[list]</td><td style="text-align: left">匹配 list 中的任意单一字符</td></tr>
<tr><td style="text-align: left"><sup class="footnote-reference"><a href="#list">1</a></sup></td><td style="text-align: left">匹配 除list 中的任意单一字符以外的字符</td></tr>
<tr><td style="text-align: left">[c1-c2]</td><td style="text-align: left">匹配 c1-c2 中的任意单一字符 如：[0-9] [a-z]</td></tr>
<tr><td style="text-align: left">{string1,string2,...}</td><td style="text-align: left">匹配 string1 或 string2 (或更多)其一字符串</td></tr>
<tr><td style="text-align: left">{c1..c2}</td><td style="text-align: left">匹配 c1-c2 中全部字符 如{1..10}</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h3 id="终端快捷键-2"><a class="header" href="#终端快捷键-2">终端快捷键</a></h3>
<pre><code class="language-bash">sh /var/vpn.sh 执行 
sh -x vpn.sh  这将执行该脚本并显示所有变量的值。 
sh -n vpn.sh 不需要执行脚本只是检查语法的模式。返回所有语法错误 

#!/bin/sh #程序必须以下面的行开始（必须方在文件的第一行）

关键字  说明  描述 
|  管道标识符，把“|”左边的执行结果，当作“|”右边的传入参数  echo compact status  storage_0@192.168.1.101 | nc -C 127.0.0.1 10010
  grep “hello” file.txt | wc -l 
&gt;.  &gt;&gt; 重定向：将命令的结果输出到文件，而不是标准输出（屏幕）。 
 &gt; 写入文件并覆盖旧文件
 &gt;&gt; 加到文件的尾部，保留旧文件内容
read 从shell中读取字符   
readonly 只读变量  
unset 删除变量 $unset .f function_name
删除函数
`command` 命令执行结果保存在变量   tar -zcvf lastmod.tar.gz `find . -mtime -1 -type f -print`
 用反短斜线可以将一个命令的输出作为另外一个命令的一个命令行参数。
    
     


命令  说明  描述 
$$  Shell本身的PID（ProcessID）   
$!  Shell最后运行的后台Process的PID   
$?  最后运行的命令的结束代码（返回值）   
$-  使用Set命令设定的Flag一览   
$*  所有参数列表。如&quot;$*&quot;用「&quot;」括起来的情况、以&quot;$1 $2 … $n&quot;的形式输出所有参数。   
$@  所有参数列表。如&quot;$@&quot;用「&quot;」括起来的情况、以&quot;$1&quot; &quot;$2&quot; … &quot;$n&quot; 的形式输出所有参数。   
$#  添加到Shell的参数个数   
$0  Shell本身的文件名   
$1 ~ $n  添加到Shell的各参数值。$1是第1参数、$2是第2参数…。   
 
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="语法"><a class="header" href="#语法">语法</a></h3>
<pre><code class="language-bash">if
if ... fi 语句；
if ... else ... fi 语句；
if ... elif ... else ... fi 语句。

## 变量

    #!/bin/sh
        
    a=10
    b=20

    if [ $a == $b ]
    then
    echo &quot;a is equal to b&quot;
    elif [ $a -gt $b ]
    then
    echo &quot;a is greater than b&quot;
    elif [ $a -lt $b ]
    then
    echo &quot;a is less than b&quot;
    else
    echo &quot;None of the condition met&quot;
    fi



## Case esac

    #!/bin/bash
    
    option=&quot;${1}&quot;
    case ${option} in
    -f) FILE=&quot;${2}&quot;
    echo &quot;File name is $FILE&quot;
    ;;
    -d) DIR=&quot;${2}&quot;
    echo &quot;Dir name is $DIR&quot;
    ;;
    *) 
    echo &quot;`basename ${0}`:usage: [-f file] | [-d directory]&quot;
    exit 1 # Command to come out of the program with status 1
    ;;
    esac



## for do done

    #!/bin/bash
    
    for FILE in $HOME/.bash*
    do
    echo $FILE
    done



## 

    COUNTER=0
    while [ $COUNTER -lt 5 ]
    do
    COUNTER='expr $COUNTER+1'
    echo $COUNTER
    done


## until 
  #循环执行一系列命令直至条件为 true 时停止。until 循环与 while 循环在处理方式上刚好相反。一般while循环优于until循环，但在某些时候，也只是极少数情况下，until 循环更加有用。

## Break
  #break命令允许跳出所有循环（终止执行后面的所有循环）。

    #!/bin/bash
    while :
    do
    echo -n &quot;Input a number between 1 to 5: &quot;
    read aNum
    case $aNum in
    1|2|3|4|5) echo &quot;Your number is $aNum!&quot;
    ;;
    *) echo &quot;You do not select a number between 1 to 5, game is over!&quot;
    break
    ;;
    esac
    done

## Continue
  #不会跳出所有循环，仅仅跳出当前循环

    #!/bin/bash
    while :
    do
    echo -n &quot;Input a number between 1 to 5: &quot;
    read aNum
    case $aNum in
    1|2|3|4|5) echo &quot;Your number is $aNum!&quot;
    ;;
    *) echo &quot;You do not select a number between 1 to 5!&quot;
    continue
    echo &quot;Game is over!&quot;
    ;;
    esac
    done


## Function

    show_help()
    {
        echo &quot;Usage: 
        -h | -help show help
        st
        t
        default show info&quot;
    }
    
    show_info()
    {
        ps aux | grep $NODENAME@$HOSTNAME | grep -v grep
    }
    
    case $1 in 
        '-h'|'--help')
            show_help ;;
        *)
            show_info ;;
    esac








</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="语法-1"><a class="header" href="#语法-1">语法</a></h3>
<pre><code class="language-bash">#!/bin/sh
  
 fSum 3 2;
 function fSum()
 {
     echo $1,$2;
     return $(($1+$2));
 }
 fSum 5 7;
 total=$(fSum 3 2);
 echo $total,$?;
                  
sh testfun1.sh
testfun1.sh: line 3: fSum: command not found
5,7
3,2
5


#!/bin/sh

echo $(uname);
declare num=1000;
 
uname()
{
    echo &quot;test!&quot;;
    ((num++));
    return 100;
}
testvar()
{
    local num=10;
    ((num++));
    echo $num;
 
}
 
uname;
echo $?
echo $num;
testvar;
echo $num;
                
                               
sh testfun2.sh
Linux
test!
100
1001
11
1001

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="转译符"><a class="header" href="#转译符">转译符</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">转义字符</th><th style="text-align: left">含义</th></tr></thead><tbody>
<tr><td style="text-align: left">\</td><td style="text-align: left">反斜杠</td></tr>
<tr><td style="text-align: left">\a</td><td style="text-align: left">警报，响铃</td></tr>
<tr><td style="text-align: left">\b</td><td style="text-align: left">退格（删除键）</td></tr>
<tr><td style="text-align: left">\f</td><td style="text-align: left">换页(FF)，将当前位置移到下页开头</td></tr>
<tr><td style="text-align: left">\n</td><td style="text-align: left">换行</td></tr>
<tr><td style="text-align: left">\r</td><td style="text-align: left">回车</td></tr>
<tr><td style="text-align: left">\t</td><td style="text-align: left">水平制表符（tab键）</td></tr>
<tr><td style="text-align: left">\v</td><td style="text-align: left">垂直制表符</td></tr>
</tbody></table>
</div>
<h2 id="变量替换"><a class="header" href="#变量替换">变量替换</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">形式</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left">${var}</td><td style="text-align: left">变量本来的值</td></tr>
<tr><td style="text-align: left">${var:-word}</td><td style="text-align: left">如果变量 var 为空或已被删除(unset)，那么返回 word，但不改变 var 的值。</td></tr>
<tr><td style="text-align: left">${var:=word}</td><td style="text-align: left">如果变量 var 为空或已被删除(unset)，那么返回 word，并将 var 的值设置为 word。</td></tr>
<tr><td style="text-align: left">${var:?message}</td><td style="text-align: left">如果变量 var 为空或已被删除(unset)，那么将消息 message 送到标准错误输出，可以用来检测变量 var 是否可以被正常赋值。 若此替换出现在Shell脚本中，那么脚本将停止运行。</td></tr>
<tr><td style="text-align: left">${var:+word}</td><td style="text-align: left">如果变量 var 被定义，那么返回 word，但不改变 var 的值。</td></tr>
</tbody></table>
</div>
<h2 id="算术运算符列表"><a class="header" href="#算术运算符列表">算术运算符列表</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">运算符</th><th style="text-align: left">说明</th><th style="text-align: left">举例</th></tr></thead><tbody>
<tr><td style="text-align: left">+</td><td style="text-align: left">加法</td><td style="text-align: left"><code>expr $a + $b</code> 结果为 30。</td></tr>
<tr><td style="text-align: left">-</td><td style="text-align: left">减法</td><td style="text-align: left"><code>expr $a - $b</code> 结果为 10。</td></tr>
<tr><td style="text-align: left">*</td><td style="text-align: left">乘法</td><td style="text-align: left"><code>expr $a \* $b</code> 结果为  200。</td></tr>
<tr><td style="text-align: left">/</td><td style="text-align: left">除法</td><td style="text-align: left"><code>expr $b / $a</code> 结果为 2。</td></tr>
<tr><td style="text-align: left">%</td><td style="text-align: left">取余</td><td style="text-align: left"><code>expr $b % $a</code> 结果为 0。</td></tr>
<tr><td style="text-align: left">=</td><td style="text-align: left">赋值</td><td style="text-align: left">a=$b 将把变量 b 的值赋给 a。</td></tr>
<tr><td style="text-align: left">==</td><td style="text-align: left">相等。用于比较两个数字，相同则返回true。</td><td style="text-align: left">[ $a == $b ] 返回 false。</td></tr>
<tr><td style="text-align: left">!=</td><td style="text-align: left">不相等。用于比较两个数字，不相同则返回 true。</td><td style="text-align: left">[ $a != $b ] 返回 true。</td></tr>
</tbody></table>
</div>
<p>注意：条件表达式要放在方括号之间，并且要有空格，例如 [$a==$b] 是错误的，必须写成 [ $a == $b ]。</p>
<h2 id="关系运算符列表"><a class="header" href="#关系运算符列表">关系运算符列表</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">运算符</th><th style="text-align: left">说明</th><th style="text-align: left">举例</th></tr></thead><tbody>
<tr><td style="text-align: left">-eq</td><td style="text-align: left">检测两个数是否相等，相等返回 true。</td><td style="text-align: left">[ $a -eq $b ] 返回 true。</td></tr>
<tr><td style="text-align: left">-ne</td><td style="text-align: left">检测两个数是否相等，不相等返回 true。</td><td style="text-align: left">[ $a -ne $b ] 返回 true。</td></tr>
<tr><td style="text-align: left">-gt</td><td style="text-align: left">检测左边的数是否大于右边的，如果是，则返回 true。</td><td style="text-align: left">[ $a -gt $b ] 返回 false。</td></tr>
<tr><td style="text-align: left">-lt</td><td style="text-align: left">检测左边的数是否小于右边的，如果是，则返回 true。</td><td style="text-align: left">[ $a -lt $b ] 返回 true。</td></tr>
<tr><td style="text-align: left">-ge</td><td style="text-align: left">检测左边的数是否大等于右边的，如果是，则返回 true。</td><td style="text-align: left">[ $a -ge $b ] 返回 false。</td></tr>
<tr><td style="text-align: left">-le</td><td style="text-align: left">检测左边的数是否小于等于右边的，如果是，则返回 true。</td><td style="text-align: left">[ $a -le $b ] 返回 true。</td></tr>
</tbody></table>
</div>
<h2 id="布尔运算符列表"><a class="header" href="#布尔运算符列表">布尔运算符列表</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">运算符</th><th style="text-align: left">说明</th><th style="text-align: left">举例</th></tr></thead><tbody>
<tr><td style="text-align: left">!</td><td style="text-align: left">非运算，表达式为 true 则返回 false，否则返回 true。</td><td style="text-align: left">[ ! false ] 返回 true。</td></tr>
<tr><td style="text-align: left">-o</td><td style="text-align: left">或运算，有一个表达式为 true 则返回 true。</td><td style="text-align: left">[ $a -lt 20 -o $b -gt 100 ] 返回 true。</td></tr>
<tr><td style="text-align: left">-a</td><td style="text-align: left">与运算，两个表达式都为 true 才返回 true。</td><td style="text-align: left">[ $a -lt 20 -a $b -gt 100 ] 返回 false。</td></tr>
</tbody></table>
</div>
<h2 id="字符串运算符列表"><a class="header" href="#字符串运算符列表">字符串运算符列表</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">运算符</th><th style="text-align: left">说明</th><th style="text-align: left">举例</th></tr></thead><tbody>
<tr><td style="text-align: left">=</td><td style="text-align: left">检测两个字符串是否相等，相等返回 true。</td><td style="text-align: left">[ $a = $b ] 返回 false。</td></tr>
<tr><td style="text-align: left">!=</td><td style="text-align: left">检测两个字符串是否相等，不相等返回 true。</td><td style="text-align: left">[ $a != $b ] 返回 true。</td></tr>
<tr><td style="text-align: left">-z</td><td style="text-align: left">检测字符串长度是否为0，为0返回 true。</td><td style="text-align: left">[ -z $a ] 返回 false。</td></tr>
<tr><td style="text-align: left">-n</td><td style="text-align: left">检测字符串长度是否为0，不为0返回 true。</td><td style="text-align: left">[ -z $a ] 返回 true。</td></tr>
<tr><td style="text-align: left">str</td><td style="text-align: left">检测字符串是否为空，不为空返回 true。</td><td style="text-align: left">[ $a ] 返回 true。</td></tr>
</tbody></table>
</div>
<h2 id="文件测试运算符列表"><a class="header" href="#文件测试运算符列表">文件测试运算符列表</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">操作符</th><th style="text-align: left">说明</th><th style="text-align: left">举例</th></tr></thead><tbody>
<tr><td style="text-align: left">-b</td><td style="text-align: left">file 检测文件是否是块设备文件，如果是，则返回 true。</td><td style="text-align: left">[ -b $file ] 返回 false。</td></tr>
<tr><td style="text-align: left">-c</td><td style="text-align: left">file 检测文件是否是字符设备文件，如果是，则返回 true。</td><td style="text-align: left">[ -b $file ] 返回 false。</td></tr>
<tr><td style="text-align: left">-d</td><td style="text-align: left">file 检测文件是否是目录，如果是，则返回 true。</td><td style="text-align: left">[ -d $file ] 返回 false。</td></tr>
<tr><td style="text-align: left">-f</td><td style="text-align: left">file 检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。</td><td style="text-align: left">[ -f $file ] 返回 true。</td></tr>
<tr><td style="text-align: left">-g</td><td style="text-align: left">file 检测文件是否设置了 SGID 位，如果是，则返回 true。</td><td style="text-align: left">[ -g $file ] 返回 false。</td></tr>
<tr><td style="text-align: left">-k</td><td style="text-align: left">file 检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。</td><td style="text-align: left">[ -k $file ] 返回 false。</td></tr>
<tr><td style="text-align: left">-p</td><td style="text-align: left">file 检测文件是否是具名管道，如果是，则返回 true。</td><td style="text-align: left">[ -p $file ] 返回 false。</td></tr>
<tr><td style="text-align: left">-u</td><td style="text-align: left">file 检测文件是否设置了 SUID 位，如果是，则返回 true。</td><td style="text-align: left">[ -u $file ] 返回 false。</td></tr>
<tr><td style="text-align: left">-r</td><td style="text-align: left">file 检测文件是否可读，如果是，则返回 true。</td><td style="text-align: left">[ -r $file ] 返回 true。</td></tr>
<tr><td style="text-align: left">-w</td><td style="text-align: left">file 检测文件是否可写，如果是，则返回 true。</td><td style="text-align: left">[ -w $file ] 返回 true。</td></tr>
<tr><td style="text-align: left">-x</td><td style="text-align: left">file 检测文件是否可执行，如果是，则返回 true。</td><td style="text-align: left">[ -x $file ] 返回 true。</td></tr>
<tr><td style="text-align: left">-s</td><td style="text-align: left">file 检测文件是否为空（文件大小是否大于0），不为空返回 true。</td><td style="text-align: left">[ -s $file ] 返回 true。</td></tr>
<tr><td style="text-align: left">-e</td><td style="text-align: left">file 检测文件（包括目录）是否存在，如果是，则返回 true。</td><td style="text-align: left">[ -e $file ] 返回 true。</td></tr>
</tbody></table>
</div>
<h2 id="全部可用的重定向命令列表"><a class="header" href="#全部可用的重定向命令列表">全部可用的重定向命令列表</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">命令</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left">command &gt; file</td><td style="text-align: left">将输出重定向到 file。</td></tr>
<tr><td style="text-align: left">command &lt; file</td><td style="text-align: left">将输入重定向到 file。</td></tr>
<tr><td style="text-align: left">command &gt;&gt; file</td><td style="text-align: left">将输出以追加的方式重定向到 file。</td></tr>
<tr><td style="text-align: left">n &gt; file</td><td style="text-align: left">将文件描述符为 n 的文件重定向到 file。</td></tr>
<tr><td style="text-align: left">n &gt;&gt; file</td><td style="text-align: left">将文件描述符为 n 的文件以追加的方式重定向到 file。</td></tr>
<tr><td style="text-align: left">n &gt;&amp; m</td><td style="text-align: left">将输出文件 m 和 n 合并。</td></tr>
<tr><td style="text-align: left">n &lt;&amp; m</td><td style="text-align: left">将输入文件 m 和 n 合并。</td></tr>
<tr><td style="text-align: left">&lt;&lt; tag</td><td style="text-align: left">将开始标记 tag 和结束标记 tag 之间的内容作为输入。</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h2 id="数据结构"><a class="header" href="#数据结构">数据结构</a></h2>
<p>变量
注意，变量名和等号之间不能有空格，这可能和你熟悉的所有编程语言都不一样。同时，变量名的命名须遵循如下规则：
首个字符必须为字母（a-z，A-Z）。
中间不能有空格，可以使用下划线（_）。
不能使用标点符号。
不能使用bash里的关键字（可用help命令查看保留关键字）。</p>
<p>数组
在Shell中，用括号来表示数组，数组元素用“空格”符号分割开。定义数组的一般形式为：
array_name=(value1 ... valuen)</p>
<p>array_name[0]=value0</p>
<p>array_name[1]=value1</p>
<p>array_name[2]=value2</p>
<p>valuen=${array_name[2]}</p>
<p>${array_name[*]}
${array_name[@]}
使用@ 或 * 可以获取数组中的所有元素</p>
<p>取得数组元素的个数</p>
<p>length=${#array_name[@]}</p>
<p>或者</p>
<p>length=${#array_name[*]}</p>
<p>取得数组单个元素的长度</p>
<p>lengthn=${#array_name[n]}</p>
<div style="break-before: page; page-break-before: always;"></div><p><a href="http://superuser.com/questions/440015/restore-tmux-session-after-reboot">tmux-session</a> : <code>tmux-session save</code> and <code>tmux-session restore</code></p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h3 id="安装"><a class="header" href="#安装">安装</a></h3>
<h3 id="配置"><a class="header" href="#配置">配置</a></h3>
<pre><code class="language-bash">ssh 证书登录 关闭密码和 root 登录。SSH 登录必须 KEY ，禁用掉密码登录，禁用 ROOT 远程  

fail2ban + 防火墙 检测状态 开 ssh 端口访问  

数据库除了 bind ，也要用防火墙限制。

所有端口改成非默认  
不是必须的话不开放外网服务端口, 数据库，缓存这些都只开 127 或者局域网 IP  

进程尽量不以 root 启动  
关注自己网站所用的程序的漏洞  
关注自己所用的开源程序的漏洞  
及时更新版本

</code></pre>
<h3 id="实例"><a class="header" href="#实例">实例</a></h3>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h3 id="案例"><a class="header" href="#案例">案例</a></h3>
<pre><code class="language-makefile"># See LICENSE for licensing information.

DIALYZER = dialyzer
REBAR = rebar
APPNAME = goldrush

all: app

app: deps
    @$(REBAR) compile

deps:
    @$(REBAR) get-deps

clean:
    @$(REBAR) clean
    rm -f test/*.beam
    rm -f erl_crash.dump

tests: clean app eunit ct

eunit:
    @$(REBAR) -C rebar.test.config eunit skip_deps=true

ct:
    @$(REBAR) -C rebar.test.config ct skip_deps=true

build-plt:
    @$(DIALYZER) --build_plt --output_plt .$(APPNAME)_dialyzer.plt \
        --apps kernel stdlib sasl inets crypto public_key ssl compiler syntax_tools

dialyze:
    @$(DIALYZER) --src src --plt .$(APPNAME)_dialyzer.plt --no_native \
        -Werror_handling -Wrace_conditions -Wunmatched_returns # -Wunderspecs

docs:
    @$(REBAR) doc skip_deps=true

===================================================================

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="linux-命令大全"><a class="header" href="#linux-命令大全">Linux 命令大全</a></h2>
<h3 id="1文件管理"><a class="header" href="#1文件管理">1、文件管理</a></h3>
<pre><code class="language-text">cat chattr chgrp chmod
chown cksum cmp diff
diffstat file find git
gitview indent cut ln
less locate lsattr mattrib
mc mdel mdir mktemp
more mmove mread mren
mtools mtoolstest mv od
paste patch rcp rm
slocate split tee tmpwatch
touch umask which cp
whereis mcopy mshowfat rhmask
scp awk read updatedb
</code></pre>
<h3 id="2文档编辑"><a class="header" href="#2文档编辑">2、文档编辑</a></h3>
<pre><code class="language-text">col colrm comm csplit
ed egrep ex fgrep
fmt fold grep ispell
jed joe join look
mtype pico rgrep sed
sort spell tr expr
uniq wc let  
</code></pre>
<h3 id="3文件传输"><a class="header" href="#3文件传输">3、文件传输</a></h3>
<pre><code class="language-text">lprm lpr lpq lpd
bye ftp uuto uupick
uucp uucico tftp ncftp
ftpshut ftpwho ftpcount  
</code></pre>
<h3 id="4磁盘管理"><a class="header" href="#4磁盘管理">4、磁盘管理</a></h3>
<pre><code class="language-text">cd df dirs du
edquota eject mcd mdeltree
mdu mkdir mlabel mmd
mrd mzip pwd quota
mount mmount rmdir rmt
stat tree umount ls
quotacheck quotaoff lndir repquota
quotaon
</code></pre>
<h3 id="5磁盘维护"><a class="header" href="#5磁盘维护">5、磁盘维护</a></h3>
<pre><code class="language-text">badblocks cfdisk dd e2fsck
ext2ed fsck fsck.minix fsconf
fdformat hdparm mformat mkbootdisk
mkdosfs mke2fs mkfs.ext2 mkfs.msdos
mkinitrd mkisofs mkswap mpartition
swapon symlinks sync mbadblocks
mkfs.minix fsck.ext2 fdisk losetup
mkfs sfdisk swapoff  
</code></pre>
<h3 id="6网络通讯"><a class="header" href="#6网络通讯">6、网络通讯</a></h3>
<pre><code class="language-text">apachectl arpwatch dip getty
mingetty uux telnet uulog
uustat ppp-off netconfig nc
httpd ifconfig minicom mesg
dnsconf wall netstat ping
pppstats samba setserial talk
traceroute tty newaliases uuname
netconf write statserial efax
pppsetup tcpdump ytalk cu
smbd testparm smbclient shapecfg
</code></pre>
<h3 id="7系统管理"><a class="header" href="#7系统管理">7、系统管理</a></h3>
<pre><code class="language-text">adduser chfn useradd date
exit finger fwhios sleep
suspend groupdel groupmod halt
kill last lastb login
logname logout ps nice
procinfo top pstree reboot
rlogin rsh sliplogin screen
shutdown rwho sudo gitps
swatch tload logrotate uname
chsh userconf userdel usermod
vlock who whoami whois
newgrp renice su skill
w id groupadd free
</code></pre>
<h3 id="8系统设置"><a class="header" href="#8系统设置">8、系统设置</a></h3>
<pre><code class="language-text">reset clear alias dircolors
aumix bind chroot clock
crontab declare depmod dmesg
enable eval export pwunconv
grpconv rpm insmod kbdconfig
lilo liloconfig lsmod minfo
set modprobe ntsysv mouseconfig
passwd pwconv rdate resize
rmmod grpunconv modinfo time
setup sndconfig setenv setconsole
timeconfig ulimit unset chkconfig
apmd hwclock mkkickstart fbset
unalias SVGATextMode gpasswd  
</code></pre>
<h3 id="9备份压缩"><a class="header" href="#9备份压缩">9、备份压缩</a></h3>
<pre><code class="language-text">ar bunzip2 bzip2 bzip2recover
gunzip unarj compress cpio
dump uuencode gzexe gzip
lha restore tar uudecode
unzip zip zipinfo  
</code></pre>
<h3 id="10设备管理"><a class="header" href="#10设备管理">10、设备管理</a></h3>
<pre><code class="language-text">setleds loadkeys rdev dumpkeys
MAKEDEV poweroff
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="1文件管理-1"><a class="header" href="#1文件管理-1">1、文件管理</a></h2>
<pre><code class="language-text">cat chattr chgrp chmod
chown cksum cmp diff
diffstat file find git
gitview indent cut ln
less locate lsattr mattrib
mc mdel mdir mktemp
more mmove mread mren
mtools mtoolstest mv od
paste patch rcp rm
slocate split tee tmpwatch
touch umask which cp
whereis mcopy mshowfat rhmask
scp awk read updatedb
</code></pre>
<h2 id="常用命令-1"><a class="header" href="#常用命令-1">常用命令</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">命令</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left">cat</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">chown</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">diffstat</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">gitview</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">less</td><td style="text-align: left">查看文件的全部内容，可以分页显示，比more命令要强大</td></tr>
<tr><td style="text-align: left">mc</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">more</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">mtools</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">paste</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">touch</td><td style="text-align: left">touch file.txt touch -t 0712250000 file1 <br/>修改一个文件或目录的时间戳 - (YYMMDDhhmm) <br/>文件不存在时创建一个空文件，存在时修改文件时间戳</td></tr>
<tr><td style="text-align: left">whereis</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">scp</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">chattr</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">cksum</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">file</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">indent</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">locate</td><td style="text-align: left">命令用于查找符合条件的文档</td></tr>
<tr><td style="text-align: left">mdel</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">mmove</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">mtoolstest</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">patch</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">split</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">umask</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">mcopy</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">awk</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">chgrp</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">cmp</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">find</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">cut</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">lsattr</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">mdir</td><td style="text-align: left">mkdir dir1 dir 2 <br>mkdir -p path/dir1/dir2</td></tr>
<tr><td style="text-align: left">mread</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">mv</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">rcp</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">tee</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">which</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">mshowfat</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">read</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">chmod</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">diff</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">git</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">ln</td><td style="text-align: left">ln -s  源地址 目标地址 <br>ln -s /usr/local/erlang/bin/erlc /usr/sbin/erlc</td></tr>
<tr><td style="text-align: left">mattrib</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">mktemp</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">mren</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">od</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">rm</td><td style="text-align: left">rm -r file1 <br> rm -rf dir1 <br> rm -rf <em>关键字</em></td></tr>
<tr><td style="text-align: left">tmpwatch</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">cp</td><td style="text-align: left">cp file1 file2 <br> cp -a /path/dir1 . <br> cp -r /path/dir1 /path/dir2</td></tr>
<tr><td style="text-align: left">rhmask</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">updatedb</td><td style="text-align: left"></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h2 id="tar"><a class="header" href="#tar">tar</a></h2>
<pre><code class="language-bash">tar -czf a.tar.gz a/
tar -xzf a.tar.gz

# -z 是否同时具有 gzip 的属性？亦即是否需要用 gzip 压缩或解压？ 一般格式为xx.tar.gz或xx. tgz
# -j 是否同时具有 bzip2 的属性？亦即是否需要用 bzip2 压缩或解压？一般格式为xx.tar.bz2  
# -v 压缩的过程中显示文件
# -f 使用档名，请留意，在 f 之后要立即接档名喔！不要再加其他参数！
# -p 使用原文件的原来属性（属性不会依据使用者而变）
# -x 从归档文件中解出文件
#-c 建立新的归档文件

</code></pre>
<h2 id="lsof"><a class="header" href="#lsof">lsof</a></h2>
<pre><code class="language-bash">#列出当前系统打开文件的工具
lsof -i:3306
lsof abc.txt 显示开启文件abc.txt的进程
lsof -c abc 显示abc进程现在打开的文件
lsof -c -p 1234 列出进程号为1234的进程所打开的文件
lsof -g gid 显示归属gid的进程情况
lsof +d /usr/local/ 显示目录下被进程开启的文件
lsof +D /usr/local/ 同上，但是会搜索目录下的目录，时间较长
lsof -d 4 显示使用fd为4的进程
lsof -i 用以显示符合条件的进程情况
lsof -i[46] [protocol][@hostname|hostaddr][:service|port]
        46 --&gt; IPv4 or IPv6
        protocol --&gt; TCP or UDP
        hostname --&gt; Internet host name
        hostaddr --&gt; IPv4地址
        service --&gt; /etc/service中的 service name (可以不止一个)
        port --&gt; 端口号 (可以不止一个)
</code></pre>
<h2 id="挂载"><a class="header" href="#挂载">挂载</a></h2>
<pre><code class="language-bash">ls -l /dev/disk/by-uuid
mkdir /media/yj/d
mkdir /media/yj/e
vim /etc/fstab
/dev/sdb1       /media/yj/d     auto    auto    0    0
UUID=           /media/yj/e     auto    auto    0    0
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cd"><a class="header" href="#cd">cd</a></h2>
<pre><code class="language-bash"> cd -
 cd ./
 cd
</code></pre>
<h2 id="ls"><a class="header" href="#ls">ls</a></h2>
<pre><code class="language-bash"> ls -F
 ls -l
 ls -a
 ls *[0-9]*
 ls -lSr |more 以尺寸大小排列文件和目录 
 ls -d
</code></pre>
<h2 id="pwd"><a class="header" href="#pwd">pwd</a></h2>
<pre><code class="language-bash">pwd
</code></pre>
<h2 id="basename"><a class="header" href="#basename">basename</a></h2>
<pre><code class="language-bash">basename file 返回不包含路径的文件名比如： basename /bin/tux将返回 tux
</code></pre>
<h2 id="dirname"><a class="header" href="#dirname">dirname</a></h2>
<pre><code class="language-bash">dirname file 返回文件所在路径比如：dirname /bin/tux将返回 /bin
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="权限"><a class="header" href="#权限">权限</a></h2>
<pre><code class="language-bash">ls
lrwxrwxrwx  1 yujian yujian     16 12月 11 11:11 .vimrc -&gt; git/config/vimrc
drwxr-xr-x  2 yujian yujian   4096 12月  4 15:52 .wireshark/

l rwx rwx rwx  
表示是一个链接 第一组字符(2-4)表示文件所有者的权限 第二组字符(5-7)表示文件所属用户组的权限 第三组字符(8-10)表示所有其他用户的权限  
d rwx r-x r-x  
表示是文件夹 (2-4)表示文件所有者的权限 (5-7)表示文件所属用户组的权限 (8-10)表示所有其他用户的权限  

文件权限是Linux系统的第一道安全防线，基本的权限有读取(r)、写入(w)和执行(x)：
    读取(r)：用户能够读取文件信息，查看文件内容。
    写入(w)：用户可以编辑文件，可以向文件写入内容，也可以删除文件内容。
    执行(x)：用户可以将文件作为程序来运行。

目录访问模式
目录的访问模式和文件类似，但是稍有不同：

    读取：用户可以查看目录中的文件
    写入：用户可以在当前目录中删除文件或创建文件
    执行：执行权限赋予用户遍历目录的权利，例如执行 cd 和 ls 命令。
</code></pre>
<h2 id="chmod"><a class="header" href="#chmod">chmod</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">符号</th><th style="text-align: left">说明</th><th style="text-align: left">例</th></tr></thead><tbody>
<tr><td style="text-align: left">+</td><td style="text-align: left">为文件或目录增加权限</td><td style="text-align: left">chmod o+wx testfile o+表示所属用户组</td></tr>
<tr><td style="text-align: left">-</td><td style="text-align: left">删除文件或目录的权限</td><td style="text-align: left">chmod u-x testfile u表示文件所有者</td></tr>
<tr><td style="text-align: left">=</td><td style="text-align: left">设置指定的权限</td><td style="text-align: left">chmod g=rx testfile g表示所有其他用户</td></tr>
</tbody></table>
</div>
<pre><code class="language-bash">chmod o+wx,u-x,g=rx testfile
</code></pre>
<p>除了符号，也可以使用八进制数字来指定具体权限，如下表所示：
| 数字 | 说明 | 权限 |
| :--- | :--- | :------ |
| 0 | 没有任何权限 | --- |
| 1 | 执行权限 | --x |
| 2 | 写入权限 | -w- |
| 3 | 执行权限和写入权限：1 (执行) + 2 (写入) = 3 | -wx |
| 4 | 读取权限 | r-- |
| 5 | 读取和执行权限：4 (读取) + 1 (执行) = 5 | r-x |
| 6 | 读取和写入权限：4 (读取) + 2 (写入) = 6 | rw- |
| 7 | 所有权限: 4 (读取) + 2 (写入) + 1 (执行) = 7 | rwx |</p>
<pre><code class="language-bash">chmod 755 testfile 
</code></pre>
<p>chown：chown 命令是&quot;change owner&quot;的缩写，用来改变文件的所有者。</p>
<p>chgrp：chgrp 命令是&quot;change group&quot;的缩写，用来改变文件所在的群组。</p>
<pre><code class="language-bash">chmod 644 -R * 
等价于：find /path -type f -exec chmod 644 {} \ ;
chmod 755 `find -type d` 
等价于：find /path -type d -exec chmod 755 {} \;


find ./ -name *.php -exec chmod 644 {} \;

ls -lh 显示权限
ls /tmp | pr -T5 -W$COLUMNS 将终端划分成5栏显示 
chmod ugo+rwx directory1 设置目录的所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限 
chmod go-rwx directory1 删除群组(g)与其他人(o)对目录的读写执行权限 
chown user1 file1 改变一个文件的所有人属性 
chown -R user1 directory1 改变一个目录的所有人属性并同时改变改目录下所有文件的属性 
chgrp group1 file1 改变文件的群组 
chown user1:group1 file1 改变一个文件的所有人和群组属性 
find / -perm -u+s 罗列一个系统中所有使用了SUID控制的文件 
chmod u+s /bin/file1 设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限 
chmod u-s /bin/file1 禁用一个二进制文件的 SUID位 
chmod g+s /home/public 设置一个目录的SGID 位 - 类似SUID ，不过这是针对目录的 
chmod g-s /home/public 禁用一个目录的 SGID 位 
chmod o+t /home/public 设置一个文件的 STIKY 位 - 只允许合法所有人删除文件 
chmod o-t /home/public 禁用一个目录的 STIKY 位 


文件的特殊属性 - 使用 &quot;+&quot; 设置权限，使用 &quot;-&quot; 用于取消
chattr +a file1 只允许以追加方式读写文件
chattr +c file1 允许这个文件能被内核自动压缩/解压
chattr +d file1 在进行文件系统备份时，dump程序将忽略这个文件
chattr +i file1 设置成不可变的文件，不能被删除、修改、重命名或者链接
chattr +s file1 允许一个文件被安全地删除
chattr +S file1 一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘
chattr +u file1 若文件被删除，系统会允许你在以后恢复这个被删除的文件
lsattr 显示特殊的属性
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="压缩"><a class="header" href="#压缩">压缩</a></h2>
<pre><code class="language-bash">
 tar -zcvf /home/xahot.tar.gz /xahot 把/xahot文件夹打包后生成一个/home/xahot.tar.gz的文件
 tar -zcvf this.tar.gz ./*.txt 将当前目录下所有.txt文件打包并压缩归档到文件this.tar.gz 
 tar -zcf this.tar.gz ./*.txt 
 
 -c 建立新的归档文件 
 -r 向归档文件末尾追加文件 
 -x 从归档文件中解出文件 
 -O 将文件解开到标准输出 
 -v 处理过程中输出相关信息 
 -f 对普通文件操作 
 -z 调用gzip来压缩归档文件，与-x联用时调用gzip完成解压缩 
 -Z 调用compress来压缩归档文件，与-x联用时调用compress完成解压缩
 --exclude=tomcat/logs
 这里大家要注意的时候，在我们使用tar 的--exclude 命令排除打包的时候，不能加“/”，否则还是会把logs目录以及其下的文件打包进去
 
rar e file.rar //解压rar
unzip file.zip //解压zip
7z 
gzip .gz
 gzip /home/file -&gt; file.gz
bzip2 .bz2
 

*.tar.gz 
    tar -xzvf
    tar -xzf 
*.tar.xz 
    tar xvJf
*.tar.bz2  
    tar -xjvf
    tar -xjf 
*.tar.Z 
    tar -xZvf 
*.tar  
    tar -xvf 
*.tar.Z 
    tar -xZf
*.rar 
    unrar e
*.zip 
    unzip

 
bunzip2 file1.bz2 解压一个叫做 'file1.bz2'的文件 
bzip2 file1 压缩一个叫做 'file1' 的文件 
gunzip file1.gz 解压一个叫做 'file1.gz'的文件 
gzip file1 压缩一个叫做 'file1'的文件 
gzip -9 file1 最大程度压缩 
rar a file1.rar test_file 创建一个叫做 'file1.rar' 的包 
rar a file1.rar file1 file2 dir1 同时压缩 'file1', 'file2' 以及目录 'dir1' 
rar x file1.rar 解压rar包 
unrar x file1.rar 解压rar包 
tar -cvf archive.tar file1 创建一个非压缩的 tarball 
tar -cvf archive.tar file1 file2 dir1 创建一个包含了 'file1', 'file2' 以及 'dir1'的档案文件 
tar -tf archive.tar 显示一个包中的内容 
tar -xvf archive.tar 释放一个包 
tar -xvf archive.tar -C /tmp 将压缩包释放到 /tmp目录下 
tar -cvfj archive.tar.bz2 dir1 创建一个bzip2格式的压缩包 
tar -xvfj archive.tar.bz2 解压一个bzip2格式的压缩包 
tar -cvfz archive.tar.gz dir1 创建一个gzip格式的压缩包 
tar -xvfz archive.tar.gz 解压一个gzip格式的压缩包 

unzip file1.zip 解压一个zip格式压缩包

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="zip用法"><a class="header" href="#zip用法">zip用法</a></h2>
<pre><code class="language-bash">zip -r myfile.zip ./*   将当前目录下的所有文件和文件夹全部压缩成myfile.zip文件,－r表示递归压缩子目录下所有文件. 
zip -r bbb.zip aaa bc.zip bbb 把当前文件夹下的 &quot;aaa文件夹及其子文件、bc.zip、bbb文件夹及其子文件&quot; 全都压缩成一个bbb.zip 
  
 -a 将文件转成ASCII模式 
 -F 尝试修复损坏的压缩文件 
 -h 显示帮助界面 
 -m 将文件压缩之后，删除源文件 
 -n 特定字符串 不压缩具有特定字尾字符串的文件 
 -o 将压缩文件内的所有文件的最新变动时间设为压缩时候的时间 
 -q 安静模式，在压缩的时候不显示指令的执行过程 
 -r 将指定的目录下的所有子目录以及文件一起处理 
 -S 包含系统文件和隐含文件（S是大写） 
 -t 日期 把压缩文件的最后修改日期设为指定的日期，日期格式为mmddyyyy
</code></pre>
<pre><code class="language-base">zip [-AcdDfFghjJKlLmoqrSTuvVwXyz$][-b &lt;工作目录&gt;][-ll][-n &lt;字尾字符串&gt;][-t &lt;日期时间&gt;][-&lt;压缩效率&gt;][压缩文件][文件...][-i &lt;范本样式&gt;][-x &lt;范本样式&gt;]
</code></pre>
<blockquote>
<ul>
<li>-A 调整可执行的自动解压缩文件。</li>
<li>-b&lt;工作目录&gt; 指定暂时存放文件的目录。</li>
<li>-c 替每个被压缩的文件加上注释。</li>
<li>-d 从压缩文件内删除指定的文件。</li>
<li>-D 压缩文件内不建立目录名称。</li>
<li>-f 此参数的效果和指定&quot;-u&quot;参数类似，但不仅更新既有文件，如果某些文件原本不存在于压缩文件内，使用本参数会一并将其加入压缩文件中。</li>
<li>-F 尝试修复已损坏的压缩文件。</li>
<li>-g 将文件压缩后附加在既有的压缩文件之后，而非另行建立新的压缩文件。</li>
<li>-h 在线帮助。</li>
<li>-i&lt;范本样式&gt; 只压缩符合条件的文件。</li>
<li>-j 只保存文件名称及其内容，而不存放任何目录名称。</li>
<li>-J 删除压缩文件前面不必要的数据。</li>
<li>-k 使用MS-DOS兼容格式的文件名称。</li>
<li>-l 压缩文件时，把LF字符置换成LF+CR字符。</li>
<li>-ll 压缩文件时，把LF+CR字符置换成LF字符。</li>
<li>-L 显示版权信息。</li>
<li>-m 将文件压缩并加入压缩文件后，删除原始文件，即把文件移到压缩文件中。</li>
<li>-n&lt;字尾字符串&gt; 不压缩具有特定字尾字符串的文件。</li>
<li>-o 以压缩文件内拥有最新更改时间的文件为准，将压缩文件的更改时间设成和该文件相同。</li>
<li>-q 不显示指令执行过程。</li>
<li>-r 递归处理，将指定目录下的所有文件和子目录一并处理。</li>
<li>-S 包含系统和隐藏文件。</li>
<li>-t&lt;日期时间&gt; 把压缩文件的日期设成指定的日期。</li>
<li>-T 检查备份文件内的每个文件是否正确无误。</li>
<li>-u 更换较新的文件到压缩文件内。</li>
<li>-v 显示指令执行过程或显示版本信息。</li>
<li>-V 保存VMS操作系统的文件属性。</li>
<li>-w 在文件名称里假如版本编号，本参数仅在VMS操作系统下有效。</li>
<li>-x&lt;范本样式&gt; 压缩时排除符合条件的文件。</li>
<li>-X 不保存额外的文件属性。</li>
<li>-y 直接保存符号连接，而非该连接所指向的文件，本参数仅在UNIX之类的系统下有效。</li>
<li>-z 替压缩文件加上注释。</li>
<li>-$ 保存第一个被压缩文件所在磁盘的卷册名称。</li>
<li>-&lt;压缩效率&gt; 压缩效率是一个介于1-9的数值。</li>
</ul>
</blockquote>
<h2 id="实例-1"><a class="header" href="#实例-1">实例</a></h2>
<pre><code class="language-bash">zip -q -r html.zip /home/html # 将 /home/html/ 这个目录下所有文件和文件夹打包为当前目录下的 html.zip
zip -q -r html.zip * # 如果在我们在 /home/html 目录下，可以执行以下命令
zip -dv cp.zip a.c # 从压缩文件 cp.zip 中删除文件 a.c
zip file1.zip file1 创建一个zip格式的压缩包 
zip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包 
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="文档编辑"><a class="header" href="#文档编辑">文档编辑</a></h2>
<pre><code class="language-text">col colrm comm csplit
ed egrep ex fgrep
fmt fold grep ispell
jed joe join look
mtype pico rgrep sed
sort spell tr expr
uniq wc let  
</code></pre>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">命令</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left">col</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">ed</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">fmt</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">jed</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">mtype</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">sort</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">uniq</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">colrm</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">egrep</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">fold</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">joe</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">pico</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">spell</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">wc</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">comm</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">ex</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">grep</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">join</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">rgrep</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">tr</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">let</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">csplit</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">fgrep</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">ispell</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">look</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">sed</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">expr</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">head</td><td style="text-align: left">file  打印文本文件开头几行</td></tr>
<tr><td style="text-align: left">tail</td><td style="text-align: left">file  打印文本文件末尾几行</td></tr>
<tr><td style="text-align: left">iconv</td><td style="text-align: left">iconv -l <br> iconv -f <br> find . -name *.java -exec sh -c &quot;iconv -f GBK -t UTF8 {} &gt; /tmp/iconv.tmp&quot; ; -exec mv /tmp/iconv.tmp '{}' ;</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h2 id="wc"><a class="header" href="#wc">wc</a></h2>
<pre><code class="language-bash">wc -lcw rebar.config rebar.config.script
find . -name &quot;*.erl&quot; -or -name &quot;*.hrl&quot;|xargs cat|wc -l #查看所有文件行数 
# -c 统计字节数
# -l 统计行数
# -w 统计字数

ls -l | grep &quot;^-&quot; | wc -l # 1、统计当前目录下文件的个数（不包括目录）
ls -lR| grep &quot;^-&quot; | wc -l # 2、统计当前目录下文件的个数（包括子目录）
ls -lR | grep &quot;^d&quot; | wc -l # 3、查看某目录下文件夹(目录)的个数（包括子目录）
find . -name filename | wc -l # 4、统计当前文件夹下叫某某的文件的数量
find -name &quot;*.js&quot; | wc -l  # 例如这里需要找 js 文件的数量

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="sed"><a class="header" href="#sed">sed</a></h2>
<p><a href="http://man.linuxde.net/sed">http://man.linuxde.net/sed</a><br />
sed是一种流编辑器，它是文本处理中非常中的工具，能够完美的配合正则表达式使用，功能不同凡响。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有 改变，除非你使用重定向存储输出。Sed主要用来自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等</p>
<pre><code class="language-bash"># Sed是一个基本的查找替换程序。可以从标准输入（比如命令管道）读入文本，并将结果输出到标准输出（屏幕）。该命令采用正则表达式（见参考）进行搜索。不要和shell中的通配符相混淆。

sed [options] 'command' file(s)
sed [options] -f scriptfile file(s)

-e&lt;script&gt;或--expression=&lt;script&gt;：以选项中的指定的script来处理输入的文本文件；
-f&lt;script文件&gt;或--file=&lt;script文件&gt;：以选项中指定的script文件来处理输入的文本文件；
-h或--help：显示帮助；
-n或--quiet或——silent：仅显示script处理后的结果；
-V或--version：显示版本信息。

# 比如：将linuxfocus替换为 LinuxFocus
cat text.file | sed ’s/linuxfocus/LinuxFocus/’ &gt;newtext.fileawk: awk 
# 用来从文本文件中提取字段。缺省地，字段分割符格，可以使用-F指定其他分割符。


sed -i &quot;s/book/books/g&quot; file -i 直接修改文件内容，会匹配file文件中每一行的第一个book替换为books
sed -i &quot;s/127.0.0.1/192.168.1.16/&quot; priv/docroot/index.html 把index.html 中的127.0.0.1替换成192.168.1.6
sed &quot;s/book\&quot;\//books\&quot;\//&quot; file  替换文本中的字符串
sed -n &quot;s/test/TEST/p&quot; file -n选项和p命令一起使用表示只打印那些发生替换的行
sed &quot;s/book/books/g&quot; file 使用后缀 /g 标记会替换每一行中的所有匹配
sed -i 's/ -Werror//g' `grep -rl &quot; -Werror&quot; ./` 


</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="awk"><a class="header" href="#awk">awk</a></h2>
<pre><code class="language-bash">echo 'Adam Bor, 34, IndiaKerryMiller, 22, USA' | awk -F  ',' '{print $1 , $3}'

ifconfig eth0 |awk -F 'inet |  netmask ' '{print $2}' 获取网卡eth0的ip地址

grep 'release' rebar.config | awk -F '&quot;' '{print $2}'

|awk -F/  '{print $NF}'

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="uniq"><a class="header" href="#uniq">uniq</a></h2>
<pre><code class="language-bash"># 删除重复的行比如： sort file.txt | uniq
uniq [-cdu][-f&lt;栏位&gt;][-s&lt;字符位置&gt;][-w&lt;字符位置&gt;][--help][--version][输入文件][输出文件]
 -c或--count 在每列旁边显示该行重复出现的次数。
 -d或--repeated 仅显示重复出现的行列。
 -f&lt;栏位&gt;或--skip-fields=&lt;栏位&gt; 忽略比较指定的栏位。
 -s&lt;字符位置&gt;或--skip-chars=&lt;字符位置&gt; 忽略比较指定的字符。
 -u或--unique 仅显示出一次的行列。
 -w&lt;字符位置&gt;或--check-chars=&lt;字符位置&gt; 指定要比较的字符。
 --help 显示帮助。
 --version 显示版本信息。
[输入文件] 指定已排序好的文本文件。如果不指定此项，则从标准读取数据；
[输出文件] 指定输出的文件。如果不指定此选项，则将内容显示到标准输出设备（显示终端）。
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="sort"><a class="header" href="#sort">sort</a></h2>
<pre><code class="language-bash"> file.txt 对file.txt文件中的行进行排序
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="grep"><a class="header" href="#grep">grep</a></h2>
<p>grep（global search regular expression(RE) and print out the line，全面搜索正则表达式并把行打印出来）是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。</p>
<h2 id="选项"><a class="header" href="#选项">选项</a></h2>
<pre><code class="language-text">-a 不要忽略二进制数据。
-A&lt;显示列数&gt; 除了显示符合范本样式的那一行之外，并显示该行之后的内容。
-b 在显示符合范本样式的那一行之外，并显示该行之前的内容。
-c 计算符合范本样式的列数。
-C&lt;显示列数&gt;或-&lt;显示列数&gt;  除了显示符合范本样式的那一列之外，并显示该列之前后的内容。
-d&lt;进行动作&gt; 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep命令将回报信息并停止动作。
-e&lt;范本样式&gt; 指定字符串作为查找文件内容的范本样式。
-E 将范本样式为延伸的普通表示法来使用，意味着使用能使用扩展正则表达式。
-f&lt;范本文件&gt; 指定范本文件，其内容有一个或多个范本样式，让grep查找符合范本条件的文件内容，格式为每一列的范本样式。
-F 将范本样式视为固定字符串的列表。
-G 将范本样式视为普通的表示法来使用。
-h 在显示符合范本样式的那一列之前，不标示该列所属的文件名称。
-H 在显示符合范本样式的那一列之前，标示该列的文件名称。
-i 忽略字符大小写的差别。
-l 列出文件内容符合指定的范本样式的文件名称。
-L 列出文件内容不符合指定的范本样式的文件名称。
-n 在显示符合范本样式的那一列之前，标示出该列的编号。
-q 不显示任何信息。
-R/-r 此参数的效果和指定“-d recurse”参数相同。
-s 不显示错误信息。
-v 反转查找。
-w 只显示全字符合的列。
-x 只显示全列符合的列。
-y 此参数效果跟“-i”相同。
-o 只输出文件中匹配到的部分。
</code></pre>
<h2 id="grep递归搜索文件"><a class="header" href="#grep递归搜索文件">grep递归搜索文件</a></h2>
<pre><code class="language-bash">grep -ir '&lt;script type=&quot;text/javascript&quot; src=&quot;../js/main.js&quot;&gt;&lt;/script&gt;'  # 当前目录下查找字符串
grep &quot;text&quot; . -r -n # .表示当前目录。
echo &quot;hello world&quot; | grep -i &quot;HELLO&quot; #忽略匹配样式中的字符大小写
echo this is a text line | grep -e &quot;is&quot; -e &quot;line&quot; -o # 选项 -e 制动多个匹配样式

grep &quot;main()&quot; . -r --include *.{php,html} # 只在目录中所有的.php和.html文件中递归搜索字符&quot;main()&quot;
grep &quot;main()&quot; . -r --exclude &quot;README&quot; # 在搜索结果中排除所有README文件
grep &quot;main()&quot; . -r --exclude-from filelist # 在搜索结果中排除filelist文件列表里的文件
seq 10 | grep &quot;5&quot; -A 3 # 显示匹配某个结果之后的3行，使用 -A 选项：
seq 10 | grep &quot;5&quot; -B 3 # 显示匹配某个结果之前的3行，使用 -B 选项
seq 10 | grep &quot;5&quot; -C 3 # 显示匹配某个结果的前三行和后三行，使用 -C 选项：
echo -e &quot;a\nb\nc\na\nb\nc&quot; | grep a -A 1 # 如果匹配结果有多个，会用“--”作为各匹配结果之间的分隔符：


</code></pre>
<h2 id="grep命令常见用法"><a class="header" href="#grep命令常见用法">grep命令常见用法</a></h2>
<pre><code class="language-bash">grep &quot;match_pattern&quot; file_name
grep &quot;match_pattern&quot; file_1 file_2 file_3 ...
grep -v &quot;match_pattern&quot; file_name

#标记匹配颜色 --color=auto 选项
grep &quot;match_pattern&quot; file_name --color=auto

#使用正则表达式 -E 选项
grep -E &quot;[1-9]+&quot;
#或
egrep &quot;[1-9]+&quot;

#统计文件或者文本中包含匹配字符串的行数 -c 选项
grep -c &quot;text&quot; file_name

#输出包含匹配字符串的行数 -n 选项
grep &quot;text&quot; -n file_1 file_2

#打印样式匹配所位于的字符或字节偏移
#一行中字符串的字符便宜是从该行的第一个字符开始计算，起始值为0。选项 -b -o 一般总是配合使用。
echo gun is not unix | grep -b -o &quot;not&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="简介"><a class="header" href="#简介">简介</a></h2>
<p>Linux命令：显示文件结尾</p>
<h3 id="命令格式"><a class="header" href="#命令格式">命令格式</a></h3>
<p>tail[必要参数][选择参数][文件]</p>
<h3 id="命令功能"><a class="header" href="#命令功能">命令功能</a></h3>
<p>用于显示指定文件末尾内容，不指定文件时，作为输入信息进行处理。常用查看日志文件。</p>
<h3 id="功能用法"><a class="header" href="#功能用法">功能,用法</a></h3>
<h3 id="标准语法"><a class="header" href="#标准语法">标准语法</a></h3>
<pre><code class="language-bash">tail [ -f ] [ -c Number | -n Number | -m Number | -b Number | -k Number ] [ File ]
命令参数：
-f 循环读取
-q 不显示处理信息
-v 显示详细的处理信息
-c&lt;数目&gt; 显示的字节数
-n&lt;行数&gt; 显示行数
--pid=PID 与-f合用,表示在进程ID,PID死掉之后结束.
-q, --quiet, --silent 从不输出给出文件名的首部
-s, --sleep-interval=S 与-f合用,表示在每次反复的间隔休眠S秒
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="find命令"><a class="header" href="#find命令">find命令</a></h2>
<p>find命令用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。</p>
<h3 id="语法-2"><a class="header" href="#语法-2">语法</a></h3>
<p>find [指定查找目录] [查找规则] [查找完后执行的action]</p>
<h3 id="选项-1"><a class="header" href="#选项-1">选项</a></h3>
<pre><code class="language-bash">-o:逻辑或,两个条件只要满足一个即可
-a:逻辑与,两个条件必须同时满足

-amin&lt;分钟&gt;：查找在指定时间曾被存取过的文件或目录，单位以分钟计算；
-anewer&lt;参考文件或目录&gt;：查找其存取时间较指定文件或目录的存取时间更接近现在的文件或目录；
-atime&lt;24小时数&gt;：查找在指定时间曾被存取过的文件或目录，单位以24小时计算；
-cmin&lt;分钟&gt;：查找在指定时间之时被更改过的文件或目录；
-cnewer&lt;参考文件或目录&gt;查找其更改时间较指定文件或目录的更改时间更接近现在的文件或目录；
-ctime&lt;24小时数&gt;：查找在指定时间之时被更改的文件或目录，单位以24小时计算；
-daystart：从本日开始计算时间；
-depth：从指定目录下最深层的子目录开始查找；
-expty：寻找文件大小为0 Byte的文件，或目录下没有任何子目录或文件的空目录；
-exec&lt;执行指令&gt;：假设find指令的回传值为True，就执行该指令；
-false：将find指令的回传值皆设为False；
-fls&lt;列表文件&gt;：此参数的效果和指定“-ls”参数类似，但会把结果保存为指定的列表文件；
-follow：排除符号连接；
-fprint&lt;列表文件&gt;：此参数的效果和指定“-print”参数类似，但会把结果保存成指定的列表文件；
-fprint0&lt;列表文件&gt;：此参数的效果和指定“-print0”参数类似，但会把结果保存成指定的列表文件；
-fprintf&lt;列表文件&gt;&lt;输出格式&gt;：此参数的效果和指定“-printf”参数类似，但会把结果保存成指定的列表文件；
-fstype&lt;文件系统类型&gt;：只寻找该文件系统类型下的文件或目录；
-gid&lt;群组识别码&gt;：查找符合指定之群组识别码的文件或目录；
-group&lt;群组名称&gt;：查找符合指定之群组名称的文件或目录；
-help或——help：在线帮助；
-ilname&lt;范本样式&gt;：此参数的效果和指定“-lname”参数类似，但忽略字符大小写的差别；
-iname&lt;范本样式&gt;：此参数的效果和指定“-name”参数类似，但忽略字符大小写的差别；
-inum&lt;inode编号&gt;：查找符合指定的inode编号的文件或目录；
-ipath&lt;范本样式&gt;：此参数的效果和指定“-path”参数类似，但忽略字符大小写的差别；
-iregex&lt;范本样式&gt;：此参数的效果和指定“-regexe”参数类似，但忽略字符大小写的差别；
-links&lt;连接数目&gt;：查找符合指定的硬连接数目的文件或目录；
-iname&lt;范本样式&gt;：指定字符串作为寻找符号连接的范本样式；
-ls：假设find指令的回传值为Ture，就将文件或目录名称列出到标准输出；
-maxdepth&lt;目录层级&gt;：设置最大目录层级；
-mindepth&lt;目录层级&gt;：设置最小目录层级；
-mmin&lt;分钟&gt;：查找在指定时间曾被更改过的文件或目录，单位以分钟计算；
-mount：此参数的效果和指定“-xdev”相同；
-mtime&lt;24小时数&gt;：查找在指定时间曾被更改过的文件或目录，单位以24小时计算；
-name&lt;范本样式&gt;：指定字符串作为寻找文件或目录的范本样式；
-newer&lt;参考文件或目录&gt;：查找其更改时间较指定文件或目录的更改时间更接近现在的文件或目录；
-nogroup：找出不属于本地主机群组识别码的文件或目录；
-noleaf：不去考虑目录至少需拥有两个硬连接存在；
-nouser：找出不属于本地主机用户识别码的文件或目录；
-ok&lt;执行指令&gt;：此参数的效果和指定“-exec”类似，但在执行指令之前会先询问用户，若回答“y”或“Y”，则放弃执行命令；
-path&lt;范本样式&gt;：指定字符串作为寻找目录的范本样式；
-perm&lt;权限数值&gt;：查找符合指定的权限数值的文件或目录；
-print：假设find指令的回传值为Ture，就将文件或目录名称列出到标准输出。格式为每列一个名称，每个名称前皆有“./”字符串；
-print0：假设find指令的回传值为Ture，就将文件或目录名称列出到标准输出。格式为全部的名称皆在同一行；
-printf&lt;输出格式&gt;：假设find指令的回传值为Ture，就将文件或目录名称列出到标准输出。格式可以自行指定；
-prune：不寻找字符串作为寻找文件或目录的范本样式;
-regex&lt;范本样式&gt;：指定字符串作为寻找文件或目录的范本样式；
-size&lt;文件大小&gt;：查找符合指定的文件大小的文件；
-true：将find指令的回传值皆设为True；
-type&lt;文件类型&gt;：只寻找符合指定的文件类型的文件；
-uid&lt;用户识别码&gt;：查找符合指定的用户识别码的文件或目录；
-used&lt;日数&gt;：查找文件或目录被更改之后在指定时间曾被存取过的文件或目录，单位以日计算；
-user&lt;拥有者名称&gt;：查找符和指定的拥有者名称的文件或目录；
-version或——version：显示版本信息；
-xdev：将范围局限在先行的文件系统中；
-xtype&lt;文件类型&gt;：此参数的效果和指定“-type”参数类似，差别在于它针对符号连接检查。
</code></pre>
<h3 id="实例-2"><a class="header" href="#实例-2">实例</a></h3>
<pre><code class="language-bash">#列出当前目录及子目录下所有文件和文件夹
find .
find /home -name &quot;*.txt&quot;
find /home -iname &quot;*.txt&quot;
find . -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot;   #当前目录及子目录下查找所有以.txt和.pdf结尾的文件
find /usr/ -path &quot;*local*&quot;              #匹配文件路径或者文件
find . -regex &quot;.*\(\.txt\|\.pdf\)$&quot;     #基于正则表达式匹配文件路径
find . -iregex &quot;.*\(\.txt\|\.pdf\)$&quot;

find /home ! -name &quot;*.txt&quot;              #找出/home下不是以.txt结尾的文件

find . -name &quot;*.erl&quot; -or -name &quot;*.hrl&quot;|xargs cat|wc -l #查看所有文件行数 

# @doc 文本操作 find xargs sed
find . -name rebar.config|xargs sed -i 's/require_otp_vsn,\s\+&quot;\(.\+\)&quot;/require_otp_vsn, &quot;R15B03|R16B*|17|18&quot;/g'
find . -type f | xargs -I {}  sed  '1i ---\ntitle: &quot;{}|&quot;\ndate: 2022-05-12T14:13:01+08:00\n---' {}

find . -type 类型参数
#类型参数
f 普通文件
l 符号连接
d 目录
c 字符设备
b 块设备
s 套接字
p Fifo

find . -maxdepth 3 -type f              #向下最大深度限制为3
find . -mindepth 2 -type f              #搜索出深度距离当前目录至少2个子目录的所有文件
find . -type f 时间戳

#UNIX/Linux文件系统每个文件都有三种时间戳：

访问时间（-atime/天，-amin/分钟）：用户最近一次访问时间。
修改时间（-mtime/天，-mmin/分钟）：文件最后一次修改时间。
变化时间（-ctime/天，-cmin/分钟）：文件数据元（例如权限等）最后一次修改时间。

find . -type f -newer file.log          #找出比file.log修改时间更长的所有文件

#根据文件大小进行匹配
find . -type f -size 文件大小单元
find . -type f -size +10k               #搜索大于10KB的文件
find . -type f -size -10k               #搜索小于10KB的文件
find . -type f -size 10k                #搜索等于10KB的文件
#文件大小单元
b —— 块（512字节）
c —— 字节
w —— 字（2字节）
k —— 千字节
M —— 兆字节
G —— 吉字节

#删除当前目录下所有.txt文件
find . -type f -name &quot;*.txt&quot; -delete

#根据文件权限/所有权进行匹配
find . -type f -perm 777                #当前目录下搜索出权限为777的文件
find . -type f -name &quot;*.php&quot; ! -perm 644 #找出当前目录下权限不是644的php文件
find . -type f -user tom                #找出当前目录用户tom拥有的所有文件
find . -type f -group sunk              #找出当前目录用户组sunk拥有的所有文件
-user 用户名:根据文件的属主名查找文件。
-group 组名:根据文件的属组名查找文件。
-uid n:根据文件属主的 UID 进行查找文件。
-gid n:根据文件属组的 GID 进行查找文件。
-nouser:查询文件属主在/etc/passwd 文件中不存在的文件。
-nogroup:查询文件属组在/etc/group 文件中不存在的文件。
</code></pre>
<h2 id="借助-exec选项与其他命令结合使用"><a class="header" href="#借助-exec选项与其他命令结合使用">借助-exec选项与其他命令结合使用</a></h2>
<pre><code class="language-bash">find .-type f -user root -exec chown tom {} \;  #找出当前目录下所有root的文件，并把所有权更改为用户tom
#上例中，{} 用于与-exec选项结合使用来匹配所有文件，然后会被替换为相应的文件名。

#找出自己家目录下所有的.txt文件并删除
find $HOME/. -name &quot;*.txt&quot; -ok rm {} \;

#查找当前目录下所有.txt文件并把他们拼接起来写入到all.txt文件中
find . -type f -name &quot;*.txt&quot; -exec cat {} \;&gt; all.txt

#将30天前的.log文件移动到old目录中
find . -type f -mtime +30 -name &quot;*.log&quot; -exec cp {} old \;

#找出当前目录下所有.txt文件并以“File:文件名”的形式打印出来
find . -type f -name &quot;*.txt&quot; -exec printf &quot;File: %s\n&quot; {} \;

#因为单行命令中-exec参数中无法使用多个命令，以下方法可以实现在-exec之后接受多条命令
-exec ./text.sh {} \;

find . -maxdepth 1 -name *.jpg -print -exec convert &quot;{}&quot; -resize 80x60 &quot;thumbs/{}&quot; \;
</code></pre>
<h2 id="搜索但跳出指定的目录"><a class="header" href="#搜索但跳出指定的目录">搜索但跳出指定的目录</a></h2>
<pre><code class="language-bash">#查找当前目录或者子目录下所有.txt文件，但是跳过子目录sk
find . -path &quot;./sk&quot; -prune -o -name &quot;*.txt&quot; -print
</code></pre>
<h2 id="find其他技巧收集"><a class="header" href="#find其他技巧收集">find其他技巧收集</a></h2>
<pre><code class="language-bash">#要列出所有长度为零的文件
find . -empty
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="使用iconv库转换文件编码"><a class="header" href="#使用iconv库转换文件编码">使用iconv库，转换文件编码</a></h2>
<pre><code class="language-bash">#!/bin/sh

FILES=$(find . -type f -name '*.*')
for f in $FILES
do
    if test -f $f; then
        CHARSET=&quot;$( file -bi &quot;$f&quot;|awk -F &quot;=&quot; '{print $2}')&quot;
        if [ &quot;$CHARSET&quot; != utf-8 ]; then
            echo -e &quot;\nConverting $f from $CHARSET to utf-8&quot;
            # iconv -f &quot;$CHARSET&quot; -t utf-8 &quot;$f&quot; -o &quot;$f.temp&quot;
            iconv -f GBK -t UTF-8 &quot;$f&quot; -o &quot;$f.temp&quot;
            mv -f &quot;$f.temp&quot; $f
        fi
    else
        echo -e &quot;\nSkipping $f - it's a regular file&quot;;
    fi
done
</code></pre>
<pre><code class="language-bash">#!/bin/bash

// batch_change_GB2312_to_UTF-8

cd directory
find ./ -type f -name &quot;*.java&quot; | while read line;do
echo $line
iconv -f GB2312 -t UTF-8 $line &gt; ${line}.utf8
mv $line ${line}.gb2312
mv ${line}.utf8 $line
done
</code></pre>
<pre><code class="language-bash">find . -name *.java -exec sh -c &quot;iconv -f GBK -t UTF8 {} &gt; /tmp/iconv.tmp&quot; \; -exec mv /tmp/iconv.tmp '{}' \;
```bash
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="系统管理"><a class="header" href="#系统管理">系统管理</a></h2>
<p>系统的整体性能取决于各种资源的平衡，类似木桶理论，某种资源的耗尽会严重阻碍系统的性能。</p>
<p>Linux中需要监控的资源主要有 CPU、主存（内存）、硬盘空间、I/O时间、网络时间、应用程序等。</p>
<p>影响系统性能的主要因素有：
| 因素 | 说明 |
| :--- | :--- |
| 用户态CPU | CPU在用户态运行用户程序所花费的时间，包括库调用，但是不包括内核花费的时间。 |
| 内核态CPU | CPU在内核态运行系统服务所花费的时间。所有的 I/O 操作都需要调用系统服务，程序员可以通过阻塞 I/O 传输来影响这部分 |的时间。
| I | O 时间和网络时间 响应 I/O 请求、处理网络连接所花费的时间。 |
| 内存 | 切换上下文和交换数据（虚拟内存页导入和导出）花费的时间。 |
| 应用程序 | 程序等待运行的时间——CPU正在运行其他程序，等待切换到当前程序。 |</p>
<p>说明：一般认为用户态CPU和内核态CPU花费的时间小于70%时是良好状态。</p>
<p>下面的命令可以用来监控系统性能并作出相应调整：
| 命令 | 说明 |
| :--- | :--- |
| nice | 启动程序时指定进程优先级。 |
| renice | 调整现有进程的优先级。 |
| netstat | 显示各种网络相关信息，包括网络连接情况、路由表、接口状态(Interface Statistics)、masquerade 连接、多播成员(Multicast Memberships)等。实际上，netstat 用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本机各端口的网络连接情况。 |
| time | 检测一个命令运行时间以及资源（CPU、内存、I/O等）使用情况。 |
| uptime | 查看系统负载情况。 |
| ps | 查看系统中进程的资源使用情况（瞬时状态，不是动态监控）。 |
| vmstat | 报告虚拟内存使用情况。 |
| gprof | 精确分析程序的性能，能给出函数调用时间、调用次数、调用关系等。 |
| top | 实时监控系统中各个进程资源的资源使用情况。 |</p>
<p>常用命令组合：</p>
<p>vmstat、sar、mpstat检测是否存在CPU瓶颈；</p>
<p>vmstat、free检测是否存在内存瓶颈；</p>
<p>iostat检测是否存在磁盘I/O瓶颈；</p>
<p>netstat检测是否存在网络I/O瓶颈。</p>
<pre><code class="language-bash">ps -a     显示所有用户的所有进程。
-x     显示无终端的进程。
-u     显示更多信息，类似于 -f 选项。
-e     显示所有进程。

ps -ef|grep mysql 查看带有mysql的进程  
kill kill -9
 ps kill -9 [PID] -9 表示强迫进程立即停止
 
 
系统信息 free -m 将结果以M为单位输出 查看系统中使用和剩馀的内存情况。
 top 运行着的进程和系统资源，包括 CPU、内存以及交换分区使用情况和运行着的任务的总的数量
 uname 命令的 -a 参数用来查看系统的所有信息，包括 机器名，内核名称 &amp; 版本 和一些其它的细节。
         -m 显示机器的处理器架构 
-r 显示正在使用的内核版本
 lsb_release -a 参数查看当前运行的linux的版本信息
 ifconfig 显示当前系统的网络接口信息
 arch 显示机器的处理器架构 
dmidecode -q 显示硬件系统部件 - (SMBIOS / DMI)
 hdparm -i /dev/hda 罗列一个磁盘的架构特性 
hdparm -tT /dev/sda 在磁盘上执行测试性读取操作
 lspci -tv 罗列 PCI 设备  
lsusb -tv 显示 USB 设备
 
adduser newuser 添加新用户
 useradd 添加用户
 usermod 修改用户信息
 userdel 删除用户
 groupadd 添加用户组
 groupmod 修改用户组信息
 groupdel 删除用户组
passwd newuser 为新用户 newuser 创建一个密码
passwd 修改密码
man  man intro －查看 &quot;用户命令介绍&quot;，是一份很简介的linux命令的介绍
 man into 它通常比man 还深入。输入&quot;info info&quot; 命令可得到info页的介绍
 man -k foo 会搜索关于foo的man文件。试试看&quot;man -k nautilus&quot; 是怎样的
 man -f foo 仅仅搜所系统man文件的标题
whatis 
users、who、w 查看当前在线用户
whoami 查看当前用户信息
logout 退出登录 注销
 shutdown 安全关闭系统
 -r –r 10 &quot;message&quot; 将系统服务停掉然后重启 
 -h –h +5 –h 18:00 将系统服务停掉,然后关机 
 -c 取消已经在运行的 shutdown 命令内容
 
 reboot 重新启动系统 
 poweroff 通过断电来关闭系统
 halt 直接关闭系统
 init 0 使用预先定义的脚本关闭系统，关闭前可以清理和更新有关信息
 init 6 重新启动系统
 
 
date  显示系统日期
 date 设置系统时钟时间 
    设置时间为下午14点36分。 # date -s 14:36:00 
    设置时间为1999年11月28号。 # date -s 991128 
    设置时间伟2008年8月8号12:00 # date -s &quot;2008-08-08 12:00:00&quot;
修改完后,记得执行clock -w，把系统时间写入CMOS(硬件) 

 hwclock --show 查看计算机硬件时间
 tzselect 设置时区 hwcolock -w保存 设置硬件时钟
 ntpdate us.pool.ntp.org 同步时间
 clock -w 将时间修改保存到 BIOS 
hostname 修改主机名称


列 描述
UID 进程所属用户的ID，即哪个用户创建了该进程。
PID 进程ID。
PPID 父进程ID，创建该进程的进程称为父进程。
C CPU使用率。
STIME 进程被创建的时间。
TTY 与进程有关的终端类型。
TIME 进程所使用的CPU时间。
CMD 创建该进程的命令。

</code></pre>
<h2 id="常用命令-2"><a class="header" href="#常用命令-2">常用命令</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">命令</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left">adduser</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">exit</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">suspend</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">kill</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">logname</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">procinfo</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">rlogin</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">shutdown</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">swatch</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">chsh</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">vlock</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">newgrp</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">w</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">chfn</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">finger</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">groupdel</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">last</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">logout</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">top</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">rsh</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">rwho</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">tload</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">userconf</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">who</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">renice</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">id</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">useradd</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">fwhios</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">groupmod</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">lastb</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">ps</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">pstree</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">sliplogin</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">sudo</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">logrotate</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">userdel</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">whoami</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">su</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">free</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">date</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">sleep</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">halt</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">login</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">nice</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">reboot</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">screen</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">gitps</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">uname</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">usermod</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">whois</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">skill</td><td style="text-align: left"></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h2 id="crontab"><a class="header" href="#crontab">crontab</a></h2>
<p>每次编辑完某个用户的cron设置后，cron自动在/var/spool/cron下生成一个与此用户同名的文件，<br />
此用户的cron信息都记录在这个文件中，这个文件是不可以直接编辑的，只可以用crontab -e 来编辑。<br />
cron启动后每过一份钟读一次这个文件，检查是否要执行里面的命令。因此此文件修改后不需要重新启动cron服务。</p>
<p>编辑/etc/crontab 文件配置cron</p>
<p>cron服务每分钟不仅要读一次/var/spool/cron内的所有文件，还需要读一次/etc/crontab,因此我们配置这个文件也能运用 cron服务做一些事情。用crontab配置是针对某个用户的，而编辑/etc/crontab是针对系统的任务。</p>
<p>cat /etc/crontab %系统任务调度的配置文件<br />
前四行是用来配置crond任务运行的环境变量，<br />
第一行SHELL变量指定了系统要使用哪个shell，这里是bash，<br />
第二行PATH变量指定了系统执行命令的路径，<br />
第三行MAILTO变量指定了crond的任务执行信息将通过电子邮件发送给root用户，如果MAILTO变量的值为空，则表示不发送任务执行信息给用户，<br />
第四行的HOME变量指定了在执行命令或者脚本时使用的主目录。第六至九行表示的含义将在下个小节详细讲述。这里不在多说。</p>
<p>用户任务调度：用户定期要执行的工作，比如用户数据备份、定时邮件提醒等。用户可以使用 crontab 工具来定制自己的计划任务。所有用户定义的crontab 文件都被保存在 /var/spool/cron目录中。其文件名与用户名一致。</p>
<pre><code class="language-bash">01 ** ** root run-parts /etc/cron.hourly //每小时执行/etc/cron.hourly内的脚本  
02 4 ** * root run-parts /etc/cron.daily //每天执行/etc/cron.daily内的脚本
22 4* *0 root run-parts /etc/cron.weekly //每星期执行/etc/cron.weekly内的脚本
42 4 1* * root run-parts /etc/cron.monthly //每月去执行/etc/cron.monthly内的脚本
</code></pre>
<p>大家注意&quot;run-parts&quot;这个参数了，如果去掉这个参数的话，后面就可以写要运行的某个脚本名，而不是文件夹名了。</p>
<p>crontab文件的含义：<br />
用户所建立的crontab文件中，每一行都代表一项任务，每行的每个字段代表一项设置，它的格式共分为六个字段，前五段是时间设定段，第六段是要执行的命令段，格式如下：<br />
minute   hour   day   month   week   command<br />
其中：<br />
minute： 表示分钟，可以是从0到59之间的任何整数。<br />
hour：表示小时，可以是从0到23之间的任何整数。<br />
day：表示日期，可以是从1到31之间的任何整数。<br />
month：表示月份，可以是从1到12之间的任何整数。<br />
week：表示星期几，可以是从0到7之间的任何整数，这里的0或7代表星期日。<br />
command：要执行的命令，可以是系统命令，也可以是自己编写的脚本文件。</p>
<p>在以上各个字段中，还可以使用以下特殊字符：<br />
星号（<em>）：代表所有可能的值，例如month字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。<br />
逗号（,）：可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9”<br />
中杠（-）：可以用整数之间的中杠表示一个整数范围，例如“2-6”表示“2,3,4,5,6”<br />
正斜线（/）：可以用正斜线指定时间的间隔频率，例如“0-23/2”表示每两小时执行一次。同时正斜线可以和星号一起使用，例如</em>/10，如果用在minute字段，表示每十分钟执行一次。</p>
<h2 id="crontab命令详解"><a class="header" href="#crontab命令详解">Crontab命令详解</a></h2>
<pre><code class="language-bash">crontab -u # 设定某个用户的cron服务，一般root用户在执行这个命令的时候需要此参数
crontab -l # 列出某个用户cron服务的详细内容
crontab -r # 删除某个用户的cron服务
crontab -e # 编辑某个用户的cron服务


比如说root查看自己的cron设置：crontab -u root -l
再例如，root想删除fred的cron设置：crontab -u fred -r
在编辑cron服务时，编辑的内容有一些格式和约定，输入：crontab -u root -e

# 每天早上6点
0 6 ***echo &quot;Good morning.&quot; &gt;&gt; /tmp/test.txt # 注意单纯echo，从屏幕上看不到任何输出，因为cron把任何输出都email到root的信箱了。
# 每两个小时
0 */2** *echo &quot;Have a break now.&quot; &gt;&gt; /tmp/test.txt
# 晚上11点到早上8点之间每两个小时，早上八点
0 23-7/2，8* **echo &quot;Have a good dream：）&quot; &gt;&gt; /tmp/test.txt
# 每天4:30 
30 4** *sh /root/backup.sh &gt;&gt; /dev/null 2&gt;&amp;1
# 每晚的21:30 
30 21* **/usr/local/etc/rc.d/lighttpd restart
# 每月1、10、22日的4 : 45 
45 4 1,10,22** /usr/local/etc/rc.d/lighttpd restart
# 在每天18 : 00至23 : 00之间每隔30分钟 
0,30 18-23 ***/usr/local/etc/rc.d/lighttpd restart
# 每星期六的11 : 00 pm 
0 23 * * 6 /usr/local/etc/rc.d/lighttpd restart
# 每一小时 
* */1*** /usr/local/etc/rc.d/lighttpd restart
# 晚上11点到早上7点之间，每隔一小时 
*23-7/1* ** /usr/local/etc/rc.d/lighttpd restart
# 每月的4号与每周一到周三的11点 
0 11 4 * mon-wed /usr/local/etc/rc.d/lighttpd restart
# 一月一号的4点 
0 4 1 jan * /usr/local/etc/rc.d/lighttpd restart

# 忽略日志输出

0 */3* ** /usr/local/apache2/apachectl restart &gt;/dev/null 2&gt;&amp;1
# “/dev/null 2&gt;&amp;1”表示先将标准输出重定向到/dev/null，然后将标准错误重定向到标准输出，由于标准输出已经重定向到了/dev/null，因此标准错误也会重定向到/dev/null，这样日志输出问题就解决了。
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="nohup"><a class="header" href="#nohup">nohup</a></h2>
<p>用途：不挂断地运行命令。</p>
<p>　　语法：nohup Command [ Arg ... ] [　&amp; ]</p>
<p>描述：nohup 命令运行由 Command 参数和任何相关的 Arg 参数指定的命令，忽略所有挂断（SIGHUP）信号。在注销后使用 nohup 命令运行后台中的程序。要运行后台中的 nohup 命令，添加 &amp; （ 表示&quot;and&quot;的符号）到命令的尾部。</p>
<pre><code class="language-bash">nohup /usr/bin/lantern &amp;
nohup /home/yujian/files/idea-IC-143.1184.17/bin/idea.sh &amp;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="xclip"><a class="header" href="#xclip">xclip</a></h2>
<p>xclip剪切板与终端的通道</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="tmux"><a class="header" href="#tmux">tmux</a></h2>
<pre><code class="language-bash">tmux ls
tmux attach 1
tmux new -s session
tmux new -s session -d #在后台建立会话
tmux ls #列出会话
tmux attach -t session #进入某个会话
 
查看/切换session ctrl+b s
离开Session ctrl+b d
重命名当前Session ctrl+b $
关闭 ctrl+b &amp;
</code></pre>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">分类</th><th style="text-align: left">操作</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left">Ctrl+b</td><td style="text-align: left"></td><td style="text-align: left">激活控制台；此时以下按键生效</td></tr>
<tr><td style="text-align: left">系统操作</td><td style="text-align: left">?</td><td style="text-align: left">列出所有快捷键；按q返回</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left">d</td><td style="text-align: left">脱离当前会话；这样可以暂时返回Shell界面，输入tmux attach能够重新进入之前的会话</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left">D</td><td style="text-align: left">选择要脱离的会话；在同时开启了多个会话时使用</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left">Ctrl+z</td><td style="text-align: left">挂起当前会话</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left">r</td><td style="text-align: left">强制重绘未脱离的会话</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left">s</td><td style="text-align: left">选择并切换会话；在同时开启了多个会话时使用</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left">:</td><td style="text-align: left">进入命令行模式；此时可以输入支持的命令，例如kill-server可以关闭服务器</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left">[</td><td style="text-align: left">进入复制模式；此时的操作与vi/emacs相同，按q/Esc退出</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left">~</td><td style="text-align: left">列出提示信息缓存；其中包含了之前tmux返回的各种提示信息</td></tr>
<tr><td style="text-align: left">窗口操作</td><td style="text-align: left">c</td><td style="text-align: left">创建新窗口</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left">&amp;</td><td style="text-align: left">关闭当前窗口</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left">数字键</td><td style="text-align: left">切换至指定窗口</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left">p</td><td style="text-align: left">切换至上一窗口</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left">n</td><td style="text-align: left">切换至下一窗口</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left">l</td><td style="text-align: left">在前后两个窗口间互相切换</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left">w</td><td style="text-align: left">通过窗口列表切换窗口</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left">,</td><td style="text-align: left">重命名当前窗口；这样便于识别</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left">.</td><td style="text-align: left">修改当前窗口编号；相当于窗口重新排序</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left">f</td><td style="text-align: left">在所有窗口中查找指定文本</td></tr>
<tr><td style="text-align: left">面板操作</td><td style="text-align: left">”</td><td style="text-align: left">将当前面板平分为上下两块</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left">%</td><td style="text-align: left">将当前面板平分为左右两块</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left">x</td><td style="text-align: left">关闭当前面板</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left">!</td><td style="text-align: left">将当前面板置于新窗口；即新建一个窗口，其中仅包含当前面板</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left">Ctrl+方向键</td><td style="text-align: left">以1个单元格为单位移动边缘以调整当前面板大小</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left">Alt+方向键</td><td style="text-align: left">以5个单元格为单位移动边缘以调整当前面板大小</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left">Space</td><td style="text-align: left">在预置的面板布局中循环切换；依次包括even-horizontal、even-vertical、main-horizontal、main-vertical、tiled</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left">q</td><td style="text-align: left">显示面板编号</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left">o</td><td style="text-align: left">在当前窗口中选择下一面板</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left">方向键</td><td style="text-align: left">移动光标以选择面板</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left">{</td><td style="text-align: left">向前置换当前面板</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left">}</td><td style="text-align: left">向后置换当前面板</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left">Alt+o</td><td style="text-align: left">逆时针旋转当前窗口的面板</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left">Ctrl+o</td><td style="text-align: left">顺时针旋转当前窗口的面板</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h2 id="systemd"><a class="header" href="#systemd">systemd</a></h2>
<h2 id="开机执行shell脚本"><a class="header" href="#开机执行shell脚本">开机执行shell脚本</a></h2>
<pre><code class="language-bash">sudo vim /home/yujian/tool/exec-shell.service
[Unit]
Description=exec shell
After=network.target

[Service]
ExecStart=/home/yujian/tool/test.sh

[Install]
WantedBy=multi-user.target

systemctl enable /home/yujian/tool/exec-shell.service # service文件移入系统目录
systemctl start exec-shell.service
systemctl stop exec-shell.service
systemctl status exec-shell.service
systemctl is-active exec-shell.service
systemctl disable exec-shell.service # 移除service文件
systemctl daemon-reload exec-shell.service # 修改service文件后需要刷新缓存

</code></pre>
<p>让我们看一下Linux系统在使用systemd作为引导程序时的开机启动过程的结构性细节。为了简单，我们将在下面按步骤列出来这个过程：</p>
<ol>
<li>
<p>当你打开电源后电脑所做的第一件事情就是BIOS初始化。BIOS会读取引导设备设定，定位并传递系统控制权给MBR（假设硬盘是第一引导设备）。</p>
</li>
<li>
<p>MBR从Grub或LILO引导程序读取相关信息并初始化内核。接下来将由Grub或LILO继续引导系统。如果你在grub配置文件里指定了systemd作为引导管理程序，之后的引导过程将由systemd完成。Systemd使用“target”来处理引导和服务管理过程。这些systemd里的“target”文件被用于分组不同的引导单元以及启动同步进程。</p>
</li>
<li>
<p>systemd执行的第一个目标是default.target。但实际上default.target是指向graphical.target的软链接。Linux里的软链接用起来和Windows下的快捷方式一样。文件Graphical.target的实际位置是/usr/lib/systemd/system/graphical.target。在下面的截图里显示了graphical.target文件的内容。</p>
</li>
<li>
<p>在这个阶段，会启动multi-user.target而这个target将自己的子单元放在目录“/etc/systemd/system/multi-user.target.wants”里。这个target为多用户支持设定系统环境。非root用户会在这个阶段的引导过程中启用。防火墙相关的服务也会在这个阶段启动。&quot;multi-user.target&quot;会将控制权交给另一层“basic.target”。</p>
</li>
<li>
<p>&quot;basic.target&quot;单元用于启动普通服务特别是图形管理服务。它通过/etc/systemd/system/basic.target.wants目录来决定哪些服务会被启动，basic.target之后将控制权交给sysinit.target.</p>
</li>
<li>
<p>&quot;sysinit.target&quot;会启动重要的系统服务例如系统挂载，内存交换空间和设备，内核补充选项等等。sysinit.target在启动过程中会传递给local-fs.target。这个target单元的内容如下面截图里所展示。</p>
</li>
<li>
<p>local-fs.target，这个target单元不会启动用户相关的服务，它只处理底层核心服务。这个target会根据/etc/fstab和/etc/inittab来执行相关操作。</p>
</li>
</ol>
<p>Systemd 支持的 12 种 Unit 文件类型</p>
<blockquote>
<p>.automount：用于控制自动挂载文件系统，相当于 SysV-init 的 autofs 服务<br />
.device：对于 /dev 目录下的设备，主要用于定义设备之间的依赖关系<br />
.mount：定义系统结构层次中的一个挂载点，可以替代过去的 /etc/fstab 配置文件<br />
.path：用于监控指定目录或文件的变化，并触发其它 Unit 运行<br />
.scope：这种 Unit 文件不是用户创建的，而是 Systemd 运行时产生的，描述一些系统服务的分组信息<br />
.service：封装守护进程的启动、停止、重启和重载操作，是最常见的一种 Unit 文件<br />
.slice：用于表示一个 CGroup 的树，通常用户不会自己创建这样的 Unit 文件<br />
.snapshot：用于表示一个由 systemctl snapshot 命令创建的 Systemd Units 运行状态快照<br />
.socket：监控来自于系统或网络的数据消息，用于实现基于数据自动触发服务启动<br />
.swap：定义一个用户做虚拟内存的交换分区<br />
.target：用于对 Unit 文件进行逻辑分组，引导其它 Unit 的执行。它替代了 SysV-init 运行级别的作用，并提供更灵活的基于特定设备事件的启动方式<br />
.timer：用于配置在特定时间触发的任务，替代了 Crontab 的功能</p>
</blockquote>
<p>/etc/systemd/system：系统或用户自定义的配置文件<br />
/run/systemd/system：软件运行时生成的配置文件<br />
/usr/lib/systemd/system：系统或第三方软件安装时添加的配置文件。</p>
<pre><code class="language-bash">systemd-analyze time # 用于显示内核和普通用户空间启动时所花的时间。
systemd-analyze blame # 会列出所有正在运行的单元，按从初始化开始到当前所花的时间排序，通过这种方式你就知道哪些服务在引导过程中要花较长时间来启动。
systemd-analyze verify # 显示在所有系统单元中是否有语法错误。

systemd-analyze plot # 可以用来把整个引导过程写入一个SVG格式文件里。整个引导过程非常长不方便阅读，所以通过这个命令我们可以把输出写入一个文件，之后再查看和分析。下面这个命令就是做这个。
</code></pre>
<p>Unit 文件结构 busybox1.service</p>
<pre><code class="language-text">[Unit]
Description=Hello World
After=docker.service
Requires=docker.service
[Service]
TimeoutStartSec=0
ExecStartPre=-/usr/bin/docker kill busybox1
ExecStartPre=-/usr/bin/docker rm busybox1
ExecStartPre=/usr/bin/docker pull busybox
ExecStart=/usr/bin/docker run --name busybox1 busybox /bin/ sh -c &quot;while true; do echo Hello World; sleep 1; done&quot;
ExecStop=&quot;/usr/bin/docker stop busybox1&quot;
ExecStopPost=&quot;/usr/bin/docker rm busybox1&quot;
[Install]
WantedBy=multi-user.target
</code></pre>
<h2 id="unit-管理"><a class="header" href="#unit-管理">Unit 管理</a></h2>
<p>查看当前系统的所有 Unit</p>
<pre><code class="language-bash"># 列出正在运行的 Unit
$ systemctl list-units

# 列出所有Unit，包括没有找到配置文件的或者启动失败的
$ systemctl list-units --all

# 列出所有没有运行的 Unit
$ systemctl list-units --all --state=inactive

# 列出所有加载失败的 Unit
$ systemctl list-units --failed

# 列出所有正在运行的、类型为 service 的 Unit
$ systemctl list-units --type=service

# 查看 Unit 配置文件的内容
$ systemctl cat docker.service
</code></pre>
<h2 id="查看-unit-的状态"><a class="header" href="#查看-unit-的状态">查看 Unit 的状态</a></h2>
<pre><code class="language-bash">enabled：已建立启动链接
disabled：没建立启动链接
static：该配置文件没有 [Install] 部分（无法执行），只能作为其他配置文件的依赖
masked：该配置文件被禁止建立启动链接
# 显示系统状态
$ systemctl status

# 显示单个 Unit 的状态
$ ystemctl status bluetooth.service

# 显示远程主机的某个 Unit 的状态
$ systemctl -H root@rhel7.example.com status httpd.service
</code></pre>
<h2 id="unit-的管理"><a class="header" href="#unit-的管理">Unit 的管理</a></h2>
<pre><code class="language-bash"># 立即启动一个服务
$ sudo systemctl start apache.service

# 立即停止一个服务
$ sudo systemctl stop apache.service

# 重启一个服务
$ sudo systemctl restart apache.service

# 杀死一个服务的所有子进程
$ sudo systemctl kill apache.service

# 重新加载一个服务的配置文件
$ sudo systemctl reload apache.service

# 重载所有修改过的配置文件
$ sudo systemctl daemon-reload

# 显示某个 Unit 的所有底层参数
$ systemctl show httpd.service

# 显示某个 Unit 的指定属性的值
$ systemctl show -p CPUShares httpd.service

# 设置某个 Unit 的指定属性
$ sudo systemctl set-property httpd.service CPUShares=500
</code></pre>
<h2 id="查看-unit-的依赖关系"><a class="header" href="#查看-unit-的依赖关系">查看 Unit 的依赖关系</a></h2>
<pre><code class="language-bash"># 列出一个 Unit 的所有依赖，默认不会列出 target 类型
$ systemctl list-dependencies nginx.service

# 列出一个 Unit 的所有依赖，包括 target 类型
$ systemctl list-dependencies --all nginx.service
</code></pre>
<h2 id="服务的生命周期"><a class="header" href="#服务的生命周期">服务的生命周期</a></h2>
<p>当一个新的 Unit 文件被放入 /etc/systemd/system/ 或 /usr/lib/systemd/system/ 目录中时，它是不会被自识识别的。</p>
<pre><code class="language-bash"># 服务的激活
systemctl enable：在 /etc/systemd/system/ 建立服务的符号链接，指向 /usr/lib/systemd/system/ 中
systemctl start：依次启动定义在 Unit 文件中的 ExecStartPre、ExecStart 和 ExecStartPost 命令
# 服务的启动和停止
systemctl start：依次启动定义在 Unit 文件中的 ExecStartPre、ExecStart 和 ExecStartPost 命令
systemctl stop：依次停止定义在 Unit 文件中的 ExecStopPre、ExecStop 和 ExecStopPost 命令
systemctl restart：重启服务
systemctl kill：立即杀死服务
# 服务的开机启动和取消
systemctl enable：除了激活服务以外，也可以置服务为开机启动
systemctl disable：取消服务的开机启动
# 服务的修改和移除
systemctl daemon-reload # Systemd 会将 Unit 文件的内容写到缓存中，因此当 Unit 文件被更新时，需要告诉Systemd 重新读取所有的 Unit 文件
systemctl reset-failed # 移除标记为丢失的 Unit 文件。在删除 Unit 文件后，由于缓存的关系，即使通过 daemon-reload 更新了缓存，在 list-units 中依然会显示标记为 not-found 的 Unit。
</code></pre>
<h2 id="日志管理"><a class="header" href="#日志管理">日志管理</a></h2>
<p>Systemd 通过其标准日志服务 Journald 提供的配套程序 journalctl 将其管理的所有后台进程打印到 std:out（即控制台）的输出重定向到了日志文件。</p>
<p>Systemd 的日志文件是二进制格式的，必须使用 Journald 提供的 journalctl 来查看，默认不带任何参数时会输出系统和所有后台进程的混合日志。</p>
<p>默认日志最大限制为所在文件系统容量的 10%，可以修改 /etc/systemd/journald.conf 中的 SystemMaxUse 来指定该最大限制。</p>
<pre><code class="language-bash"># 查看所有日志（默认情况下 ，只保存本次启动的日志）
$ sudo journalctl

# 查看内核日志（不显示应用日志）：--dmesg 或 -k
$ sudo journalctl -k

# 查看系统本次启动的日志（其中包括了内核日志和各类系统服务的控制台输出）：--system 或 -b
$ sudo journalctl -b
$ sudo journalctl -b -0

# 查看上一次启动的日志（需更改设置）
$ sudo journalctl -b -1

# 查看指定服务的日志：--unit 或 -u
$ sudo journalctl -u docker.servcie

# 查看指定服务的日志
$ sudo journalctl /usr/lib/systemd/systemd

# 实时滚动显示最新日志
$ sudo journalctl -f

# 查看指定时间的日志
$ sudo journalctl --since=&quot;2012-10-30 18:17:16&quot;
$ sudo journalctl --since &quot;20 min ago&quot;
$ sudo journalctl --since yesterday
$ sudo journalctl --since &quot;2015-01-10&quot; --until &quot;2015-01-11 03:00&quot;
$ sudo journalctl --since 09:00 --until &quot;1 hour ago&quot;

# 显示尾部的最新 10 行日志：--lines 或 -n
$ sudo journalctl -n

# 显示尾部指定行数的日志
$ sudo journalctl -n 20

# 将最新的日志显示在前面
$ sudo journalctl -r -u docker.service

# 改变输出的格式：--output 或 -o
$ sudo journalctl -r -u docker.service -o json-pretty

# 查看指定进程的日志
$ sudo journalctl _PID=1

# 查看某个路径的脚本的日志
$ sudo journalctl /usr/bin/bash

# 查看指定用户的日志
$ sudo journalctl _UID=33 --since today

# 查看某个 Unit 的日志
$ sudo journalctl -u nginx.service
$ sudo journalctl -u nginx.service --since today

# 实时滚动显示某个 Unit 的最新日志
$ sudo journalctl -u nginx.service -f

# 合并显示多个 Unit 的日志
$ journalctl -u nginx.service -u php-fpm.service --since today

# 查看指定优先级（及其以上级别）的日志，共有 8 级
# 0: emerg
# 1: alert
# 2: crit
# 3: err
# 4: warning
# 5: notice
# 6: info
# 7: debug
$ sudo journalctl -p err -b

# 日志默认分页输出，--no-pager 改为正常的标准输出
$ sudo journalctl --no-pager

# 以 JSON 格式（单行）输出
$ sudo journalctl -b -u nginx.service -o json

# 以 JSON 格式（多行）输出，可读性更好
$ sudo journalctl -b -u nginx.serviceqq
 -o json-pretty

# 显示日志占据的硬盘空间
$ sudo journalctl --disk-usage

# 指定日志文件占据的最大空间
$ sudo journalctl --vacuum-size=1G

# 指定日志文件保存多久
$ sudo journalctl --vacuum-time=1years
</code></pre>
<h2 id="systemd-工具集"><a class="header" href="#systemd-工具集">Systemd 工具集</a></h2>
<p>systemctl：用于检查和控制各种系统服务和资源的状态<br />
bootctl：用于查看和管理系统启动分区<br />
hostnamectl：用于查看和修改系统的主机名和主机信息<br />
journalctl：用于查看系统日志和各类应用服务日志<br />
localectl：用于查看和管理系统的地区信息<br />
loginctl：用于管理系统已登录用户和 Session 的信息<br />
machinectl：用于操作 Systemd 容器<br />
timedatectl：用于查看和管理系统的时间和时区信息<br />
systemd-analyze 显示此次系统启动时运行每个服务所消耗的时间，可以用于分析系统启动过程中的性能瓶颈<br />
systemd-ask-password：辅助性工具，用星号屏蔽用户的任意输入，然后返回实际输入的内容<br />
systemd-cat：用于将其他命令的输出重定向到系统日志<br />
systemd-cgls：递归地显示指定 CGroup 的继承链<br />
systemd-cgtop：显示系统当前最耗资源的 CGroup 单元<br />
systemd-escape：辅助性工具，用于去除指定字符串中不能作为 Unit 文件名的字符<br />
systemd-hwdb：Systemd 的内部工具，用于更新硬件数据库<br />
systemd-delta：对比当前系统配置与默认系统配置的差异<br />
systemd-detect-virt：显示主机的虚拟化类型<br />
systemd-inhibit：用于强制延迟或禁止系统的关闭、睡眠和待机事件<br />
systemd-machine-id-setup：Systemd 的内部工具，用于给 Systemd 容器生成 ID<br />
systemd-notify：Systemd 的内部工具，用于通知服务的状态变化<br />
systemd-nspawn：用于创建 Systemd 容器<br />
systemd-path：Systemd 的内部工具，用于显示系统上下文中的各种路径配置<br />
systemd-run：用于将任意指定的命令包装成一个临时的后台服务运行<br />
systemd-stdio- bridge：Systemd 的内部 工具，用于将程序的标准输入输出重定向到系统总线<br />
systemd-tmpfiles：Systemd 的内部工具，用于创建和管理临时文件目录<br />
systemd-tty-ask-password-agent：用于响应后台服务进程发出的输入密码请求</p>
<h2 id="systemctl"><a class="header" href="#systemctl">systemctl</a></h2>
<pre><code class="language-bash"># 重启系统
$ sudo systemctl reboot

# 关闭系统，切断电源
$ sudo systemctl poweroff

# CPU停止工作
$ sudo systemctl halt

# 暂停系统
$ sudo systemctl suspend

# 让系统进入冬眠状态
$ sudo systemctl hibernate

# 让系统进入交互式休眠状态
$ sudo systemctl hybrid-sleep

# 启动进入救援状态（单用户状态）
$ sudo systemctl rescue
</code></pre>
<h2 id="systemd-analyze"><a class="header" href="#systemd-analyze">systemd-analyze</a></h2>
<pre><code class="language-bash"># 查看启动耗时
$ systemd-analyze

# 查看每个服务的启动耗时
$ systemd-analyze blame

# 显示瀑布状的启动过程流
$ systemd-analyze critical-chain

# 显示指定服务的启动流
$ systemd-analyze critical-chain atd.service
</code></pre>
<h2 id="hostnamectl"><a class="header" href="#hostnamectl">hostnamectl</a></h2>
<pre><code class="language-bash"># 显示当前主机的信息
$ hostnamectl

# 设置主机名。
$ sudo hostnamectl set-hostname rhel7
</code></pre>
<h2 id="timedatectl"><a class="header" href="#timedatectl">timedatectl</a></h2>
<pre><code class="language-bah"># 查看当前时区设置
$ timedatectl

# 显示所有可用的时区
$ timedatectl list-timezones

# 设置当前时区
$ sudo timedatectl set-timezone America/New_York
$ sudo timedatectl set-time YYYY-MM-DD
$ sudo timedatectl set-time HH:MM:SS
</code></pre>
<h2 id="loginctl"><a class="header" href="#loginctl">loginctl</a></h2>
<pre><code class="language-bash"># 列出当前 session
$ loginctl list-sessions

# 列出当前登录用户
$ loginctl list-users

# 列出显示指定用户的信息
$ loginctl show-user ruanyf
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="磁盘管理"><a class="header" href="#磁盘管理">磁盘管理</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">命令</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left">cd</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">edquota</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">mdu</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">mrd</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">mount</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">stat</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">quotacheck</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">quotaon</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">df</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">eject</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">mkdir</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">mzip</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">mmount</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">tree</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">quotaoff</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">dirs</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">mcd</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">mlabel</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">pwd</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">rmdir</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">umount</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">lndir</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">du</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">mdeltree</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">mmd</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">quota</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">rmt</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">ls</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">repquota</td><td style="text-align: left"></td></tr>
</tbody></table>
</div>
<h2 id="磁盘维护"><a class="header" href="#磁盘维护">磁盘维护</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">命令</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left">badblocks</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">ext2ed</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">fdformat</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">mkdosfs</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">mkinitrd</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">swapon</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">mkfs</td><td style="text-align: left">.minix</td></tr>
<tr><td style="text-align: left">mkfs</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">cfdisk</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">fsck</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">hdparm</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">mke2fs</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">mkisofs</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">symlinks</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">fsck</td><td style="text-align: left">.ext2</td></tr>
<tr><td style="text-align: left">sfdisk</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">dd</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">fsck</td><td style="text-align: left">.minix</td></tr>
<tr><td style="text-align: left">mformat</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">mkfs</td><td style="text-align: left">.ext2</td></tr>
<tr><td style="text-align: left">mkswap</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">sync</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">fdisk</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">swapoff</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">e2fsck</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">fsconf</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">mkbootdisk</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">mkfs</td><td style="text-align: left">.msdos</td></tr>
<tr><td style="text-align: left">mpartition</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">mbadblocks</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">losetup</td><td style="text-align: left"></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h2 id="du"><a class="header" href="#du">du</a></h2>
<pre><code class="language-bash">du -h  --max-depth=1
du -h  --max-depth=0


</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="mount"><a class="header" href="#mount">mount</a></h2>
<pre><code class="language-bash">mount /dev/hda2 /mnt/hda2 挂载一个叫做hda2的盘 - 确定目录 '/ mnt/hda2' 已经存在
mount /dev/cdrom /mnt/cdrom 挂载一个cdrom或dvdrom
mount /dev/hdc /mnt/cdrecorder 挂载一个cdrw或dvdrom
mount /dev/hdb /mnt/cdrecorder 挂载一个cdrw或dvdrom
mount -o loop file.iso /mnt/cdrom 挂载一个文件或ISO镜像文件
mount -t vfat /dev/hda5 /mnt/hda5 挂载一个Windows FAT32文件系统
mount /dev/sda1 /mnt/usbdisk 挂载一个usb 捷盘或闪存设备
mount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share 挂载一个windows网络共享磁盘空间 

mount -a # 会/etc/fstab中的项全部挂载，如果有错，则会提示错误，然后根据错误找出原因修改。 
</code></pre>
<h2 id="umount"><a class="header" href="#umount">umount</a></h2>
<pre><code class="language-bash">umount /dev/hda2 卸载一个叫做hda2的盘 - 先从挂载点 '/mnt/hda2' 退出
umount -n /mnt/hda2 运行卸载操作而不写入 /etc/mtab 文件- 当文件为只读或当磁盘写满时非常有用
</code></pre>
<h2 id="fuser"><a class="header" href="#fuser">fuser</a></h2>
<pre><code class="language-bash">fuser -km /mnt/hda2 当设备繁忙时强制卸载
</code></pre>
<h2 id="自动挂载盘"><a class="header" href="#自动挂载盘">自动挂载盘</a></h2>
<pre><code class="language-bash">sudo fdisk -l 查看目前拥有的盘符
sudo vim /etc/fstab 修改fstab文件
设备名称         挂载点           分区类型    挂载选项      dump选项     fsck选项
/dev/sdb6 none swap sw 0       0
/dev/sdb1 /xp auto auto 0         0
/dev/sda7 /work auto auto 0       0
/dev/sdb2 /movie auto auto 0        0

(1)设备名称
 /dev/device就是需要挂载的设备，/hda2就是第一个IDE插槽上的主硬盘的第二个分区。如果是第二个IDE插槽主硬盘的第三个分区，那就是dev/hdc3，具体可以在linux下使用fdisk -l  查看。 

(2)挂载点
mountpoint 就是挂载点。/、 /usr、 swap 都是系统安装时分区的默认挂载点。
 如果你要挂载一个新设备，你就要好好想想了，因为这个新设备将作为文件系统永久的一部分，需要根据FSSTND（文件系统标准），以及它的用，用户需求来决定。比如你想把它做为一个共享资源，放在/home下面就是一个不错选择。 

(3)分区类型
type 是指文件系统类型，下面列举几个常用的： 
Linux file systems: ext2, ext3, jfs, reiserfs, reiser4, xfs, swap.
Windows:
vfat = FAT 32, FAT 16
ntfs= NTFS
Note: For NTFS rw ntfs-3g
CD/DVD/iso: iso9660
Network file systems:
nfs: server:/shared_directory /mnt/nfs nfs &lt;options&gt; 0 0
smb: //win_box/shared_folder /mnt/samba smbfs rw,credentials=/home/user_name/winbox-credentials.txt 0 0
 auto: The file system type (ext3, iso9660, etc) it detected automatically. Usually works. Used for removabledevices (CD/DVD, Floppy drives, or USB/Flash drives) as the file system may vary on thesedevices. 

(4)挂载选项
rules 是指挂载时的规则。下面列举几个常用的：
auto 开机自动挂载
default 按照大多数永久文件系统的缺省值设置挂载定义
noauto 开机不自动挂载
nouser 只有超级用户可以挂载
ro 按只读权限挂载
rw 按可读可写权限挂载
user 任何用户都可以挂载
请注意光驱和软驱只有在装有介质时才可以进行挂载，因此它是noauto 

(5)dump选项
这一项为0，就表示从不备份。如果上次用dump备份，将显示备份至今的天数。 

(6)fsck选项
 order 指fsck（启动时fsck检查的顺序）。为0就表示不检查，（/）分区永远都是1，其它的分区只能从2开始，当数字相同就同时检查（但能有两1）。 
如果我要把第二个IDE插槽主硬盘上的windows C 区挂到文件系统中，那么数据项是：
/dev/hdc1 /c vfat defaults 0 0
(/c 是事先建立的文件夹，作为c盘的挂载点。)

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="文件传输"><a class="header" href="#文件传输">文件传输</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">命令</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left">lprm</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">lpr</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">lpq</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">lpd</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">bye</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">ftp</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">uuto</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">uupick</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">uucp</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">uucico</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">tftp</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">ncftp</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">ftpshut</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">ftpwho</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">ftpcount</td><td style="text-align: left"></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h2 id="磁盘维护-1"><a class="header" href="#磁盘维护-1">磁盘维护</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">命令</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left">apachectl</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">mingetty</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">uustat</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">httpd</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">dnsconf</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">pppstats</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">traceroute</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">netconf</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">pppsetup</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">smbd</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">arpwatch</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">uux</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">ppp-off</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">ifconfig</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">wall</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">samba</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">tty</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">write</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">tcpdump</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">testparm</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">dip</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">telnet</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">netconfig</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">minicom</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">netstat</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">setserial</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">newaliases</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">statserial</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">ytalk</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">smbclient</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">getty</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">uulog</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">nc</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">mesg</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">ping</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">talk</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">uuname</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">efax</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">cu</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">shapecfg</td><td style="text-align: left"></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h2 id="tcpdump"><a class="header" href="#tcpdump">tcpdump</a></h2>
<pre><code class="language-bash">sudo tcpdump -i lo port 8080 and 'tcp[tcpflags] &amp; (tcp-syn|tcp-fin) !=0' -nn  查看本机8080端口的流量

sudo tcpdump -i lo 'port 42442' -vvv -XX



</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="curl"><a class="header" href="#curl">curl</a></h2>
<p>linux curl是一个利用URL规则在命令行下工作的文件传输工具。它支持文件的上传和下载，所以是综合传输工具，但按传统，习惯称url为下载工具。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">命令</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left">-c/--cookie-jar file</td><td style="text-align: left">操作结束后把cookie写入到这个文件中</td></tr>
<tr><td style="text-align: left">-C/--continue-at offset</td><td style="text-align: left">断点续转</td></tr>
<tr><td style="text-align: left">-d/--data data HTTP</td><td style="text-align: left">POST方式传送数据</td></tr>
<tr><td style="text-align: left">--data-binary data</td><td style="text-align: left">以二进制的方式post数据</td></tr>
<tr><td style="text-align: left">-F/--form name=content</td><td style="text-align: left">模拟http表单提交数据</td></tr>
<tr><td style="text-align: left">-form-string name=string</td><td style="text-align: left">模拟http表单提交数据</td></tr>
<tr><td style="text-align: left">-i/--include</td><td style="text-align: left">输出时包括protocol头信息</td></tr>
<tr><td style="text-align: left">-I/--head</td><td style="text-align: left">只显示文档信息</td></tr>
<tr><td style="text-align: left">-o/--output &lt;http.txt&gt;</td><td style="text-align: left">把输出写到该文件中</td></tr>
<tr><td style="text-align: left">-O url get</td><td style="text-align: left">文件</td></tr>
<tr><td style="text-align: left">-#</td><td style="text-align: left">进度条</td></tr>
</tbody></table>
</div>
<pre><code class="language-bash"># 常用curl实例
 
# 上传 %正常的表单提交
 curl -d &quot;user=nickwolfe&amp;password=test&quot; url 
 
 # %multipart/form-data
 curl -H &quot;a:b&quot; -F &quot;filename=@text.txt&quot; -i url 
 
 # %文件二进制上传
 curl -X PUT -H &quot;Content-Type:image/png&quot; \--data-binary @test.jpg -i -o response.html url 
     -i 显示header信息
     -o response.html 把结果写入response.html
 
get curl -o home.html  url
 %模拟表单信息，模拟登录，保存cookie信息
 curl -c ./cookie_c.txt -F log=aaaa -F pwd=****** &lt;url&gt;
 curl -D ./cookie_D.txt -F log=aaaa -F pwd=****** &lt;url&gt;
 % -c(小写)产生的cookie和-D里面的cookie是不一样的
 
通过ftp下载文件 curl -u 用户名:密码 -O &lt;url&gt;
 curl -O ftp://用户名:密码@ip:port/demo/curtain/bbstudy_files/style.css 
通过ftp上传  curl -T test.sql ftp://用户名:密码@ip:port/demo/curtain/bbstudy_files/

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ssh"><a class="header" href="#ssh">ssh</a></h2>
<pre><code class="language-bash"># 安装
yum install SSH
apt install openssl

vim /etc/ssh/sshd_config
systemctl restart sshd

Port 22 #端口
添加一行：Port 23 #多个ssh连接端口
PasswordAuthentication no #禁用密码验证
RSAAuthentication yes #启用密钥验证
PubkeyAuthentication yes
AuthorsizedKeysFile .ssh/authorized_keys #指定公钥数据库文件


ssh localhost -p port #测试
ssh –l user –p 22 britepic.org


ssh-keygen
ssh-keygen -t rsa   # 创建一个默认密钥
ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot; # 创建一个默认密钥
eval &quot;$(ssh-agent -s)&quot;

ssh-copy-id -i ali.pub one@192.168.1.2 # 远程添加密钥

scp file host:/home/user/path
ssh -vvvv # debug模式
ssh-add ~/.ssh/id_rsa # 添加默认密钥


</code></pre>
<h2 id="别名登陆"><a class="header" href="#别名登陆">别名登陆</a></h2>
<pre><code class="language-config">vim ~/.ssh/config
&gt;ssh 别名
Host ali  #别名
HostName 192.168.1.2 #主机名
Port            端口
User root #用户名
PreferredAuthentications publickey
IdentityFile ~/.ssh/ali #密钥文件的路径
</code></pre>
<h2 id="ssh-穿透内网"><a class="header" href="#ssh-穿透内网">ssh 穿透内网</a></h2>
<pre><code class="language-bash">#ssh -NfR 远端主机listen port:远端连回时导向的主机 : 远端连回本地主机时导向主机的port 帐号@远端主机 
#外网服务器:115.159.22.131
#内网服务器：localhost

#内网命令
systemctl start ssh
ssh -v -fCNR 63095:localhost:22 root@115.159.22.131

autossh -M 5678 -NR 63095:localhost:22 root@115.159.22.131

#外网命令
ssh-keygen -t rsa
复制 .pub到内网authorized_keys
ssh -i ~/.ssh/yj_work/115_159_22_131 yj@localhost -p 63095


#反向SSH隧道,只能远端主机登陆
ssh -fN -R [远端主机port]:[远端连回时导向的主机]:[远端连回本地主机时的port] [帐号@远端主机]

yj@yj:~$ssh -fN -R 63095:localhost:22 root@118.24.189.248
root@118.24.189.248:~$netstat -nap | grep 63095
root@118.24.189.248:~$ssh -p 63095 yj@localhost

#反向SSH隧道,所有主机登陆
yj@yj:~$ssh -fN -R 118.24.189.248:63095:localhost:22 
root@118.24.189.248
其他服务器:~$ssh -p 63095 yj@118.24.189.248

#永久反向 SSH 隧道 autossh
yj@yj:~$autossh -M 10900 -fN -o &quot;PubkeyAuthentication=yes&quot; -o &quot;StrictHostKeyChecking=false&quot; -o &quot;PasswordAuthentication=no&quot; -o &quot;ServerAliveInterval 60&quot; -o &quot;ServerAliveCountMax 3&quot; -R 118.24.189.248:63095:localhost:22 root@118.24.189.248
#-M 10900 选项指定中继服务器上的监视端口，用于交换监视 SSH 会话的测试数据。中继服务器上的其它程序不能使用这个端口。
#-fN 选项传递给 ssh 命令，让 SSH 隧道在后台运行。
#-o XXXX 选项让 ssh：
#使用密钥验证，而不是密码验证。
#自动接受（未知）SSH 主机密钥。
#每 60 秒交换 keep-alive 消息。
#没有收到任何响应时最多发送 3 条 keep-alive 消息。

</code></pre>
<pre><code class="language-bash">-1：强制使用ssh协议版本1；
-2：强制使用ssh协议版本2；
-4：强制使用IPv4地址；
-6：强制使用IPv6地址；
-A：开启认证代理连接转发功能；
-a：关闭认证代理连接转发功能；
-b：使用本机指定地址作为对应连接的源ip地址；
-C：请求压缩所有数据；
-F：指定ssh指令的配置文件；
-f：后台执行ssh指令；
-g：允许远程主机连接主机的转发端口；
-i：指定身份文件；
-l：指定连接远程服务器登录用户名；
-N：不执行远程指令；
-o：指定配置选项；
-p：指定远程服务器上的端口；
-q：静默模式；
-X：开启X11转发功能；
-x：关闭X11转发功能；
-y：开启信任X11转发功能。
</code></pre>
<h3 id="安装-1"><a class="header" href="#安装-1">安装</a></h3>
<pre><code class="language-bash">yum install SSH
sudo apt install openssl
systemctl restart sshd
</code></pre>
<h3 id="配置-1"><a class="header" href="#配置-1">配置</a></h3>
<pre><code class="language-bash">vim /etc/ssh/sshd_config

Port 22                     #端口
Port 23                     #多个ssh连接端口 添加一行

PasswordAuthentication no   #禁用密码验证
RSAAuthentication yes       #启用密钥验证
PubkeyAuthentication yes
AuthorsizedKeysFile .ssh/authorized_keys    #指定公钥数据库文件

UseDNS no                   #在最后添加下面一行,关闭 SSH 的 DNS 反解析
GSSAPIAuthentication yes    #改成 no gssapi-with-mic
GatewayPorts clientspecified || yes # 让中继服务器上的 sshd 不仅转发回环地址上的端口，还要转发外部主机的端口。这通过指定中继服务器上运行的 sshd 的 GatewayPorts 实现
PermitRootLogin no          #禁止ROOT远程SSH登录
</code></pre>
<h3 id="创建服务器证书密钥"><a class="header" href="#创建服务器证书密钥">创建服务器证书密钥</a></h3>
<pre><code class="language-bash"># 生成服务器端私钥
$ openssl genrsa -out server.key 4096
$ openssl genrsa -des3 -out server.key 4096 # 带密码

# 创建服务器证书的申请文件 server.csr
openssl req -new -key server.key -out server.csr
# 输出内容为：
# Enter pass phrase for root.key: ← 输入前面创建的密码
# Country Name (2 letter code) [AU]:CN ← 国家代号，中国输入CN
# State or Province Name (full name) [Some-State]:BeiJing ← 省的全名，拼音
# Locality Name (eg, city) []:BeiJing ← 市的全名，拼音
# Organization Name (eg, company) [Internet Widgits Pty Ltd]:MyCompany Corp. ← 公司英文名
# Organizational Unit Name (eg, section) []: ← 可以不输入
# Common Name (eg, YOUR name) []: ← 输入域名，如：iot.conet.com
# Email Address []:admin@mycompany.com ← 电子邮箱，可随意填
# Please enter the following ‘extra’ attributes
# to be sent with your certificate request
# A challenge password []: ← 可以不输入
# An optional company name []: ← 可以不输入
 
# 备份一份服务器密钥文件
cp server.key server.key.org
# 去除文件口令
openssl rsa -in server.key.org -out server.key
# 生成证书文件server.crt
openssl x509 -req -days 365 -in server.csr -signkey server.key -out server.crt


# ssl_certificate        conf.d/key/server.crt;
# ssl_certificate_key    conf.d/key/server.key;
</code></pre>
<h3 id="客户端配置"><a class="header" href="#客户端配置">客户端配置</a></h3>
<pre><code class="language-bash">ssh_config
# 每30秒发送一次心跳检测
ServerAliveInterval 30
# 超过10次都没有成功，就主动断开与服务器的连接
ServerAliveCountMax 10
</code></pre>
<h3 id="服务端配置"><a class="header" href="#服务端配置">服务端配置</a></h3>
<pre><code class="language-bash">sudo vim /etc/ssh/sshd_config
ClientAliveInterval 30 #ClientAliveInterval表示每隔多少秒，服务器端向客户端发送心跳，是的，你没看错。
ClientAliveCountMax 6  #下面的ClientAliveInterval表示上述多少次心跳无响应之后，会认为Client已经断开。
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="基本用法"><a class="header" href="#基本用法">基本用法</a></h2>
<pre><code class="language-bash">tc qdisc show    # 显示
tc qdisc  add dev eth0 root ...... # 加入
tc qdisc  change  dev eth0 root ...... # 修改存在的 qdisc ,记的,加入同一条后只能用 change 来修改
tc qdisc del dev eth0 root  # 删除


tc qdisc add dev eth0 root netem delay 3000ms 延时模拟3000ms
tc qdisc add dev eth0 root netem delay 3000ms 2000ms 延时模拟3000ms+-2000ms
tc qdisc change dev eth0 root netem loss 50% 设置丢包 50%
tc qdisc change dev eth0 root netem loss 50% 80% 设置丢包 50%-80%之间
 
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="firewall-cmd"><a class="header" href="#firewall-cmd">firewall-cmd</a></h2>
<p>firewall-cmd提供了一个动态管理的防火墙，支持网络/防火墙区域来定义网络连接或接口的信任级别。它支持IPv4、IPv6防火墙设置和以太网网桥，并将运行时和永久配置选项分开。它还支持服务或应用程序直接添加防火墙规则的接口。</p>
<p>使用firewalld的好处可以在运行时环境中立即进行更改，不需要重新启动服务或守护程序；使用firewalld D-Bus接口，服务，应用程序和用户都可以轻松调整防火墙设置。界面完整，用于防火墙配置工具firewall-cmd，firewall-config和firewall-applet。</p>
<p>firewall-cmd 是 firewalld的字符界面管理工具，firewalld是centos7的一大特性，最大的好处有两个：支持动态更新，不用重启服务；第二个就是加入了防火墙的“zone”概念。</p>
<p>firewalld跟iptables比起来至少有两大好处：</p>
<ol>
<li>firewalld可以动态修改单条规则，而不需要像iptables那样，在修改了规则后必须得全部刷新才可以生效。</li>
<li>firewalld在使用上要比iptables人性化很多，即使不明白“五张表五条链”而且对TCP/IP协议也不理解也可以实现大部分功能。</li>
</ol>
<p>firewalld自身并不具备防火墙的功能，而是和iptables一样需要通过内核的netfilter来实现，也就是说firewalld和 iptables一样，他们的作用都是用于维护规则，而真正使用规则干活的是内核的netfilter，只不过firewalld和iptables的结构以及使用方法不一样罢了。</p>
<h2 id="基本用法-1"><a class="header" href="#基本用法-1">基本用法</a></h2>
<p><a href="https://linux.cn/article-8098-1.html#3_2383">https://linux.cn/article-8098-1.html#3_2383</a></p>
<pre><code class="language-bash"># 安装firewalld
yum install firewalld firewall-config

# 服务
 service firewalld start
 systemctl start ||enable || stop || disable firewalld

firewall-cmd --version  # 查看版本
firewall-cmd --help     # 查看帮助
man firewall-cmd                               ##查看帮助

 # 常用命令介绍
firewall-cmd --state                           ##查看防火墙状态，是否是running
firewall-cmd --reload                          ##重新载入配置，比如添加规则之后，需要执行此命令 （持久化行该命令后生效）
firewall-cmd --get-zones                       ##列出支持的zone
firewall-cmd --get-services                    ##列出支持的服务，在列表中的服务是放行的
firewall-cmd --query-service ftp               ##查看ftp服务是否支持，返回yes或者no
firewall-cmd --add-service=ftp                 ##临时开放ftp服务
firewall-cmd --add-service=ftp --permanent     ##永久开放ftp服务
firewall-cmd --remove-service=ftp --permanent  ##永久移除ftp服务
firewall-cmd --add-port=80/tcp --permanent     ##永久添加80端口 
iptables -L -n                                 ##查看规则，这个命令是和iptables的相同的



# 重新加载配置
 --permanent
 firewall-cmd --zone=public --add-service=http --permanent(持久化)
 firewall-cmd --zone=public --add-service=http(运行时)
 
 firewall-cmd --zone=public --add-service=http --permanent(持久化)
 

firewall-cmd --get-default-zone # 默认区域 
firewall-cmd --set-default-zone=internal # 修改默认区域
firewall-cmd --get-active-zones # 网络接口使用的区域
firewall-cmd --zone=public --list-all # 特定区域的所有配置
firewall-cmd --list-all-zones 所有区域的配置
firewall-cmd --get-services # 默认的可用服务

</code></pre>
<h2 id="实例-3"><a class="header" href="#实例-3">实例</a></h2>
<pre><code class="language-bash">firewall-cmd --zone=public --add-service=http --permanent # 启用或禁用 HTTP 服务
firewall-cmd --zone=public --remove-service=http --permanent

firewall-cmd --zone=public --add-port=12345-12388/tcp --permanent # 允许或者拒绝任意端口/协议
firewall-cmd --zone=public --remove-port=12345-12388/tcp --permanent

firewall-cmd --zone=public --add-forward-port=port=80:proto=tcp:toport=12345 # 端口转发（在同一台服务器上将 80 端口的流量转发到 12345 端口） 
 
firewall-cmd --zone=public --add-masquerade # 将端口转发到另外一台服务器上 
# 添加转发规则，将本地的 80 端口的流量转发到 IP 地址为 ：123.456.78.9 的远程服务器上的  8080 端口
firewall-cmd --zone=public --add-forward-port=port=80:proto=tcp:toport=8080:toaddr=123.456.78.9

firewall-cmd --zone=public --remove-masquerade

</code></pre>
<h3 id="配置firewalld"><a class="header" href="#配置firewalld">配置firewalld</a></h3>
<pre><code class="language-bash">firewall-cmd --version  # 查看版本
firewall-cmd --help     # 查看帮助

# 查看设置：
firewall-cmd --state  # 显示状态
firewall-cmd --get-active-zones  # 查看区域信息
firewall-cmd --get-zone-of-interface=eth0  # 查看指定接口所属区域
firewall-cmd --panic-on  # 拒绝所有包
firewall-cmd --panic-off  # 取消拒绝状态
firewall-cmd --query-panic  # 查看是否拒绝

firewall-cmd --reload # 更新防火墙规则
firewall-cmd --complete-reload
# 两者的区别就是第一个无需断开连接，就是firewalld特性之一动态添加规则，第二个需要断开连接，类似重启服务


# 将接口添加到区域，默认接口都在public
firewall-cmd --zone=public --add-interface=eth0
# 永久生效再加上 --permanent 然后reload防火墙

# 设置默认接口区域，立即生效无需重启
firewall-cmd --set-default-zone=public

# 查看所有打开的端口：
firewall-cmd --zone=dmz --list-ports

# 加入一个端口到区域：
firewall-cmd --zone=dmz --add-port=8080/tcp
# 若要永久生效方法同上

# 打开一个服务，类似于将端口可视化，服务需要在配置文件中添加，/etc/firewalld 目录下有services文件夹，这个不详细说了，详情参考文档
firewall-cmd --zone=work --add-service=smtp

# 移除服务
firewall-cmd --zone=work --remove-service=smtp

# 显示支持的区域列表
firewall-cmd --get-zones

# 设置为家庭区域
firewall-cmd --set-default-zone=home

# 查看当前区域
firewall-cmd --get-active-zones

# 设置当前区域的接口
firewall-cmd --get-zone-of-interface=enp03s

# 显示所有公共区域（public）
firewall-cmd --zone=public --list-all

# 临时修改网络接口（enp0s3）为内部区域（internal）
firewall-cmd --zone=internal --change-interface=enp03s

# 永久修改网络接口enp03s为内部区域（internal）
firewall-cmd --permanent --zone=internal --change-interface=enp03s
</code></pre>
<p>服务管理</p>
<pre><code class="language-bash"># 显示服务列表  
Amanda, FTP, Samba和TFTP等最重要的服务已经被FirewallD提供相应的服务，可以使用如下命令查看：

firewall-cmd --get-services

# 允许SSH服务通过
firewall-cmd --enable service=ssh

# 禁止SSH服务通过
firewall-cmd --disable service=ssh

# 打开TCP的8080端口
firewall-cmd --enable ports=8080/tcp

# 临时允许Samba服务通过600秒
firewall-cmd --enable service=samba --timeout=600

# 显示当前服务
firewall-cmd --list-services

# 添加HTTP服务到内部区域（internal）
firewall-cmd --permanent --zone=internal --add-service=http
firewall-cmd --reload     # 在不改变状态的条件下重新加载防火墙
</code></pre>
<p>端口管理</p>
<pre><code class="language-bash"># 打开443/TCP端口
firewall-cmd --add-port=443/tcp

# 永久打开3690/TCP端口
firewall-cmd --permanent --add-port=3690/tcp

# 永久打开端口不需要reload
# 临时打开端口后, 执行reload命令本次操作命令会被还原
firewall-cmd --reload

# 查看防火墙，添加的端口也可以看到
firewall-cmd --list-all
</code></pre>
<p>直接模式</p>
<pre><code class="language-bash"># FirewallD包括一种直接模式，使用它可以完成一些工作，例如打开TCP协议的9999端口

firewall-cmd --direct -add-rule ipv4 filter INPUT 0 -p tcp --dport 9000 -j ACCEPT
firewall-cmd --reload

firewall-cmd --add-port=3306/tcp --permanent 
firewall-cmd --reload
firewall-cmd --list-ports
</code></pre>
<h2 id="控制端口--服务"><a class="header" href="#控制端口--服务"><strong>控制端口 / 服务</strong></a></h2>
<p>可以通过两种方式控制端口的开放，一种是指定端口号另一种是指定服务名。虽然开放 http 服务就是开放了 80 端口，但是还是不能通过端口号来关闭，也就是说通过指定服务名开放的就要通过指定服务名关闭；通过指定端口号开放的就要通过指定端口号关闭。还有一个要注意的就是指定端口的时候一定要指定是什么协议，tcp 还是 udp。知道这个之后以后就不用每次先关防火墙了，可以让防火墙真正的生效。</p>
<pre><code class="language-bash">firewall-cmd --add-service=mysql        # 开放mysql端口
firewall-cmd --remove-service=http      # 阻止http端口
firewall-cmd --list-services            # 查看开放的服务
firewall-cmd --add-port=3306/tcp        # 开放通过tcp访问3306
firewall-cmd --remove-port=80tcp        # 阻止通过tcp访问3306
firewall-cmd --add-port=233/udp         # 开放通过udp访问233
firewall-cmd --list-ports               # 查看开放的端口
</code></pre>
<p>伪装 IP</p>
<pre><code class="language-bash">firewall-cmd --query-masquerade # 检查是否允许伪装IP
firewall-cmd --add-masquerade   # 允许防火墙伪装IP
firewall-cmd --remove-masquerade# 禁止防火墙伪装IP
</code></pre>
<h2 id="端口转发"><a class="header" href="#端口转发"><strong>端口转发</strong></a></h2>
<p>端口转发可以将指定地址访问指定的端口时，将流量转发至指定地址的指定端口。转发的目的如果不指定 ip 的话就默认为本机，如果指定了 ip 却没指定端口，则默认使用来源端口。
如果配置好端口转发之后不能用，可以检查下面两个问题：
1.比如我将 80 端口转发至 8080 端口，首先检查本地的 80 端口和目标的 8080 端口是否开放监听了
2.其次检查是否允许伪装 IP，没允许的话要开启伪装 IP</p>
<pre><code class="language-bash">service firewalld start
firewall-cmd --add-forward-port=port=80:proto=tcp:toport=8080   # 将80端口的流量转发至8080
firewall-cmd --add-forward-port=port=80:proto=tcp:toaddr=192.168.0.1 # 将80端口的流量转发至192.168.0.1
firewall-cmd --add-forward-port=port=80:proto=tcp:toaddr=192.168.0.1:toport=8080 # 将80端口的流量转发至192.168.0.1的8080端口


firewall-cmd --zone=public --add-masquerade
firewall-cmd --permanent --zone=public --add-forward-port=port=26199:proto=tcp:toport=3306:toaddr=10.66.195.156
firewall-cmd --permanent --zone=public --add-forward-port=port=26000-26200/tcp
firewall-cmd --zone=public --remove-masquerade

</code></pre>
<ol>
<li>当我们想把某个端口隐藏起来的时候，就可以在防火墙上阻止那个端口访问，然后再开一个不规则的端口，之后配置防火墙的端口转发，将流量转发过去。</li>
<li>端口转发还可以做流量分发，一个防火墙拖着好多台运行着不同服务的机器，然后用防火墙将不同端口的流量转发至不同机器。</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h2 id="openssl创建自签名证书"><a class="header" href="#openssl创建自签名证书">openssl创建自签名证书</a></h2>
<pre><code class="language-bash"># 1.创建根证书私钥长度为2048
openssl genrsa -out ca.key 2048

# 2.利用私钥创建根证书按照提示一路输入：
openssl req -new -x509 -days 36500 -key ca.key -out ca.crt

# 3.创建长度为2048的SSL证书私匙
openssl genrsa -out server.key 2048

# 4.利用刚才的私匙建立SSL证书请求一路向下：
openssl req -new -key server.key -out server.csr

# 6.用CA根证书签署SSL自建证书：
openssl x509 -req -days 3650 -in server.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out server.crt

# 7.查看证书

#(1)查看证书内容：
openssl x509 -in mycacert.crt -text 

#(2)使用CA验证server证书
openssl verify -CAfile ca.cert.pem server.cert.pem

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="nc"><a class="header" href="#nc">nc</a></h2>
<p>功能说明：功能强大的网络工具
语　　法：nc [-hlnruz][-g&lt;网关...&gt;][-G&lt;指向器数目&gt;][-i&lt;延迟秒数&gt;][-o&lt;输出文件&gt;][-p&lt;通信端口&gt;][-s&lt;来源位址&gt;][-v...][-w&lt;超时秒数&gt;][主机名称][通信端口...]
参　　数：
-g&lt;网关&gt;   设置路由器跃程通信网关，最丢哦可设置8个。
-G&lt;指向器数目&gt;   设置来源路由指向器，其数值为4的倍数。
-h   在线帮助。
-i&lt;延迟秒数&gt;   设置时间间隔，以便传送信息及扫描通信端口。
-l   使用监听模式，管控传入的资料。
-n   直接使用IP地址，而不通过域名服务器。
-o&lt;输出文件&gt;   指定文件名称，把往来传输的数据以16进制字码倾倒成该文件保存。
-p&lt;通信端口&gt;   设置本地主机使用的通信端口。
-r   乱数指定本地与远端主机的通信端口。
-s&lt;来源位址&gt;   设置本地主机送出数据包的IP地址。
-u   使用UDP传输协议。
-v   显示指令执行过程。
-w&lt;超时秒数&gt;   设置等待连线的时间。
-z   使用0输入/输出模式，只在扫描通信端口时使用。</p>
<pre><code class="language-bash">#端口扫描
nc -v -w 2 192.168.2.34 -z 21-24

#从192.168.2.33拷贝文件到192.168.2.34
#在192.168.2.34上： nc -l 1234 &gt; test.txt
#在192.168.2.33上： nc 192.168.2.34 &lt; test.txt

#简单聊天工具
#在192.168.2.34上： nc -l 1234
#在192.168.2.33上： nc 192.168.2.34 1234


</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="linux软件"><a class="header" href="#linux软件">Linux软件</a></h2>
<h3 id="配置信息"><a class="header" href="#配置信息">配置信息</a></h3>
<ol>
<li>
<p>ide/ IDE plugins、settings</p>
</li>
<li>
<p>etc/ 配置文件</p>
</li>
<li>
<p>linux 软件配置</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h2 id="idea"><a class="header" href="#idea">IDEA</a></h2>
<pre><code class="language-bash">
https://www.jetbrains.com/zh-cn/idea/download/

</code></pre>
<h2 id="问题"><a class="header" href="#问题">问题</a></h2>
<h3 id="ubuntu-2"><a class="header" href="#ubuntu-2">ubuntu</a></h3>
<pre><code class="language-bash">### ubuntu20.04下无法输入中文
-Drecreate.x11.input.method=true

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="vim"><a class="header" href="#vim">vim</a></h2>
<pre><code class="language-config">syntax on
filetype plugin indent on
set encoding=utf-8
set sw=4
set ts=4
set paste 
set nu
#set nopaste
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p><a href="http://yuez.me/jiang-ni-de-vim-da-zao-cheng-qing-qiao-qiang-da-de-ide/">http://yuez.me/jiang-ni-de-vim-da-zao-cheng-qing-qiao-qiang-da-de-ide/</a></p>
<p><a href="http://www.cnblogs.com/ribavnu/p/3874386.html">http://www.cnblogs.com/ribavnu/p/3874386.html</a></p>
<p>|   |   |  |
| --- | --- | --- | --- |
| pathogen  | 管理插件  | cd ~/  <br/> mkdir .vim <br> mkdir -p ~/.vim/autoload ~/.vim/bundle  <br> cd ~/.vim/autoload/  <br> wget <a href="https://raw.github.com/tpope/vim-pathogen/master/autoload/pathogen.vim">https://raw.github.com/tpope/vim-pathogen/master/autoload/pathogen.vim</a> <br> Git:<a href="https://github.com/tpope/vim-pathogen">https://github.com/tpope/vim-pathogen</a> |
| ~/.vimrc | vim配置文件 | call pathogen#infect() <br>call pathogen#helptags() <br>syntax on<br>filetype plugin indent on |
|vimerl|  |cd ~/.vim/bundle<br>git clone <a href="https://github.com/jimenezrick/vimerl.git">https://github.com/jimenezrick/vimerl.git</a> <br>vimrc中为vimerl配置文件增加以下配置  <br> filetype plugin indent on <br>let g:erlangManPath=&quot;/usr/local/lib/erlang/man&quot;  |
|ctrlp.vim |ctrl p,  提供给力的模糊文件查找. 进而可以把导航树扔掉. |<a href="https://github.com/kien/ctrlp.vim">https://github.com/kien/ctrlp.vim</a> |
|NERDTree |Vim中一款给力导航树插件 – 但我很少用它，因为我在用ctrlp. |<a href="https://github.com/scrooloose/nerdtree">https://github.com/scrooloose/nerdtree</a> |
|NERDTree Tabs |将 NERDTree中打开过的文件添加到标签栏 |<a href="https://github.com/jistr/vim-nerdtree-tabs">https://github.com/jistr/vim-nerdtree-tabs</a> |
|vim-vividchalk |配色 |<a href="https://github.com/tpope/vim-vividchalk">https://github.com/tpope/vim-vividchalk</a> <br>需要在 $HOME/.vimrc 中增加一行命令：colo vividchalk |</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h2 id="acmesh"><a class="header" href="#acmesh">acme.sh</a></h2>
<pre><code class="language-bash">
#!/bin/sh

##crontab -uroot -e
##30 4 * * * sh /root/cron/daily.sh &gt; /root/cron/log_daily.log

## acme.sh

curl  https://get.acme.sh | sh

# 阿里云
export Ali_Key=&quot;aaa&quot;
export Ali_Secret=&quot;bbb&quot;
acme.sh --issue -d 01cs.cc -d *.01cs.cc --dns dns_ali

# 腾讯云 dnspod.cn
export DP_Id=&quot;aaa&quot;
export DP_Key=&quot;bbb&quot;
acme.sh --issue -d 01cs.cc -d *.01cs.cc --dns dns_dp

# 手动添加DNS
acme.sh --issue -d htjicon.com -d *.htjicon.com --yes-I-know-dns-manual-mode-enough-go-ahead-please --dns

# 手动 dns 方式, 手动在域名上添加一条 txt 解析记录, 验证域名所有权.
# 然后 acme.sh 会生成相应的解析记录显示出来, 你只需要在你的域名管理面板中添加这条 txt 记录即可.
#等待解析完成之后, 重新生成证书:
acme.sh --renew -d htjicon.com -d *.htjicon.com --yes-I-know-dns-manual-mode-enough-go-ahead-please
acme.sh --renew -d htjicon.com -d *.htjicon.com --yes-I-know-dns-manual-mode-enough-go-ahead-please --force


# 自动更新
acme.sh --installcert --force -d 01cs.cc -d *.01cs.cc --key-file /usr/local/nginx/conf/01cs.cc/01cs.cc.key --fullchain-file /usr/local/nginx/conf/01cs.cc/fullchain.cer --reloadcmd  &quot;service nginx force-reload&quot;

#nginx使用证书
ssl_certificate_key .acme.sh/htjicon.com/htjicon.com.key 
ssl_certificate     .acme.sh/htjicon.com/fullchain.cer

## 软件更新新版本
acme.sh --upgrade
acme.sh --upgrade  --auto-upgrade #自动升级
acme.sh --upgrade  --auto-upgrade  0 #关闭自动更新

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h2 id="nginxerror排查"><a class="header" href="#nginxerror排查">nginxError排查</a></h2>
<h3 id="错误描述-error-socket_closed_remotely"><a class="header" href="#错误描述-error-socket_closed_remotely">错误描述 {error, socket_closed_remotely}</a></h3>
<h4 id="复现"><a class="header" href="#复现">复现</a></h4>
<p>Leofs（分布式文件存储系统）<br />
Gateway_0 192.168.1.16:8080<br />
Gateway_1 192.168.1.17:8080<br />
100w条 每条500字节数据，由erlang httpc post到任意gateway， 所有数据存储ok</p>
<p>加入nginx，放在192.168.1.16:80，负载 -&gt;<br />
192.168.1.16:8080<br />
192.168.1.17:8080</p>
<p>此时测试<br />
客户端会出现在某次post时{error, socket_closed_remotely}</p>
<h4 id="分析"><a class="header" href="#分析">分析</a></h4>
<p>a.根据错误关键字{error, socket_closed_remotely},发现可能是服务器主动关闭了socket套接字<br />
b.gateway没有问题，加上nginx出现问题，考虑nginx配置是否正确<br />
c.nginx 官方文档<br />
d.google，发现有人遇到类似情况<a href="http://rtbdev.com/2014/03/nginx-proxy-time_wait/">http://rtbdev.com/2014/03/nginx-proxy-time_wait/</a></p>
<h4 id="技术点"><a class="header" href="#技术点">技术点</a></h4>
<p>TCP/IP的TIME_WAIT<br />
Nginx nginx代理使用了短链接的方式和后端交互的原因，使得系统TIME_WAIT的tcp连接很多<br />
shell&gt; ss -ant | awk '{++s[$1]} END {for(k in s) print k,s[k]}'
%查看TIME_WAIT数量</p>
<p>upstream {
keepalive 32;
}</p>
<p>server {
...
location /http/ {
proxy_pass <a href="http://http_backend">http://http_backend</a>;
proxy_http_version 1.1;
proxy_set_header Connection &quot;&quot;;
...
}
}</p>
<h3 id="错误描述-readv-failed-104-connection-reset-by-peer-while-reading-upstream"><a class="header" href="#错误描述-readv-failed-104-connection-reset-by-peer-while-reading-upstream">错误描述 readv() failed (104: Connection reset by peer) while reading upstream</a></h3>
<h4 id="分析-1"><a class="header" href="#分析-1">分析</a></h4>
<p>1.认为是配置问题。（没有查到）<br />
2.检查leofs服务器，发现问题。服务器主动关闭connect，导致keep-alive出现问题</p>
<h4 id="技术点-1"><a class="header" href="#技术点-1">技术点</a></h4>
<p>修改成按照标准的http通讯</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="nginxrewrite规则"><a class="header" href="#nginxrewrite规则">nginxRewrite规则</a></h2>
<p><a href="https://segmentfault.com/a/1190000002797606">https://segmentfault.com/a/1190000002797606</a></p>
<pre><code class="language-bash">location正则写法
一个示例：
location  = / {
  # 精确匹配 / ，主机名后面不能带任何字符串
  [ configuration A ] 
}

location  / {
  # 因为所有的地址都以 / 开头，所以这条规则将匹配到所有请求
  # 但是正则和最长字符串会优先匹配
  [ configuration B ] 
}

location /documents/ {
  # 匹配任何以 /documents/ 开头的地址，匹配符合以后，还要继续往下搜索
  # 只有后面的正则表达式没有匹配到时，这一条才会采用这一条
  [ configuration C ] 
}

location ~ /documents/Abc {
  # 匹配任何以 /documents/ 开头的地址，匹配符合以后，还要继续往下搜索
  # 只有后面的正则表达式没有匹配到时，这一条才会采用这一条
  [ configuration CC ] 
}

location ^~ /images/ {
  # 匹配任何以 /images/ 开头的地址，匹配符合以后，停止往下搜索正则，采用这一条。
  [ configuration D ] 
}

location ~* \.(gif|jpg|jpeg)$ {
  # 匹配所有以 gif,jpg或jpeg 结尾的请求
  # 然而，所有请求 /images/ 下的图片会被 config D 处理，因为 ^~ 到达不了这一条正则
  [ configuration E ] 
}

location /images/ {
  # 字符匹配到 /images/，继续往下，会发现 ^~ 存在
  [ configuration F ] 
}

location /images/abc {
  # 最长字符匹配到 /images/abc，继续往下，会发现 ^~ 存在
  # F与G的放置顺序是没有关系的
  [ configuration G ] 
}

location ~ /images/abc/ {
  # 只有去掉 config D 才有效：先最长匹配 config G 开头的地址，继续往下搜索，匹配到这一条正则，采用
    [ configuration H ] 
}

location ~* /js/.*/\.js
</code></pre>
<p>• 已=开头表示精确匹配<br />
如 A 中只匹配根目录结尾的请求，后面不能带任何字符串。<br />
• ^~ 开头表示uri以某个常规字符串开头，不是正则匹配<br />
• ~ 开头表示区分大小写的正则匹配;<br />
• ~* 开头表示不区分大小写的正则匹配<br />
• / 通用匹配, 如果没有其它匹配,任何请求都会匹配到</p>
<p>顺序 no优先级：</p>
<p>(location =) &gt; (location 完整路径) &gt; (location ^~ 路径) &gt; (location ~,~* 正则顺序) &gt; (location 部分起始路径) &gt; (/)</p>
<p>上面的匹配结果</p>
<p>按照上面的location写法，以下的匹配示例成立：</p>
<p>• / -&gt; config A<br />
精确完全匹配，即使/index.html也匹配不了<br />
• /downloads/download.html -&gt; config B<br />
匹配B以后，往下没有任何匹配，采用B<br />
• /images/1.gif -&gt; configuration D<br />
匹配到F，往下匹配到D，停止往下<br />
• /images/abc/def -&gt; config D<br />
最长匹配到G，往下匹配D，停止往下<br />
你可以看到 任何以/images/开头的都会匹配到D并停止，FG写在这里是没有任何意义的，H是永远轮不到的，这里只是为了说明匹配顺序<br />
• /documents/document.html -&gt; config C<br />
匹配到C，往下没有任何匹配，采用C
• /documents/1.jpg -&gt; configuration E<br />
匹配到C，往下正则匹配到E
• /documents/Abc.jpg -&gt; config CC<br />
最长匹配到C，往下正则顺序匹配到CC，不会往下到E</p>
<h2 id="实际使用建议"><a class="header" href="#实际使用建议">实际使用建议</a></h2>
<pre><code class="language-bash">所以实际使用中，个人觉得至少有三个匹配规则定义，如下：

# 直接匹配网站根，通过域名访问网站首页比较频繁，使用这个会加速处理，官网如是说。  
# 这里是直接转发给后端应用服务器了，也可以是一个静态首页  


# 第一个必选规则
location = / {
    proxy_pass http://tomcat:8080/index
}
# 第二个必选规则是处理静态文件请求，这是nginx作为http服务器的强项
# 有两种配置模式，目录匹配或后缀匹配,任选其一或搭配使用
location ^~ /static/ {
    root /webroot/static/;
}
location ~* \.(gif|jpg|jpeg|png|css|js|ico)$ {
    root /webroot/res/;
}
#第三个规则就是通用规则，用来转发动态请求到后端应用服务器
#非静态文件请求就默认是动态请求，自己根据实际把握
#毕竟目前的一些框架的流行，带.php,.jsp后缀的情况很少了
location / {
    proxy_pass http://tomcat:8080/
}
</code></pre>
<p><a href="http://tengine.taobao.org/book/chapter_02.html">http://tengine.taobao.org/book/chapter_02.html</a></p>
<p><a href="http://nginx.org/en/docs/http/ngx_http_rewrite_module.html">http://nginx.org/en/docs/http/ngx_http_rewrite_module.html</a></p>
<h2 id="rewrite规则"><a class="header" href="#rewrite规则">Rewrite规则</a></h2>
<p>rewrite功能就是，使用nginx提供的全局变量或自己设置的变量，结合正则表达式和标志位实现url重写以及重定向。rewrite只能放在server{},location{},if{}中，并且只能对域名后边的除去传递的参数外的字符串起作用，</p>
<p>例如 <a href="http://seanlook.com/a/we/index.php?id=1&amp;u=str">http://seanlook.com/a/we/index.php?id=1&amp;u=str</a> 只对/a/we/index.php重写。</p>
<p>语法rewrite regex replacement [flag];
如果相对域名或参数字符串起作用，可以使用全局变量匹配，也可以使用proxy_pass反向代理。</p>
<p>表明看rewrite和location功能有点像，都能实现跳转，主要区别在于rewrite是在同一域名内更改获取资源的路径，而location是对一类路径做控制访问或反向代理，可以proxy_pass到其他机器。很多情况下rewrite也会写在location里，它们的执行顺序是：</p>
<ol>
<li>执行server块的rewrite指令</li>
<li>执行location匹配</li>
<li>执行选定的location中的rewrite指令
如果其中某步URI被重写，则重新循环执行1-3，直到找到真实存在的文件；循环超过10次，则返回500 Internal Server Error错误。</li>
</ol>
<h2 id="flag标志位"><a class="header" href="#flag标志位">flag标志位</a></h2>
<p>• last : 相当于Apache的[L]标记，表示完成rewrite
• break : 停止执行当前虚拟主机的后续rewrite指令集
• redirect : 返回302临时重定向，地址栏会显示跳转后的地址
• permanent : 返回301永久重定向，地址栏会显示跳转后的地址</p>
<p>因为301和302不能简单的只返回状态码，还必须有重定向的URL，这就是return指令无法返回301,302的原因了。这里 last 和 break 区别有点难以理解：</p>
<ol>
<li>last一般写在server和if中，而break一般使用在location中</li>
<li>last不终止重写后的url匹配，即新的url会再从server走一遍匹配流程，而break终止重写后的匹配</li>
<li>break和last都能组织继续执行后面的rewrite指令
if指令与全局变量
if判断指令
语法为if(condition){...}，对给定的条件condition进行判断。如果为真，大括号内的rewrite指令将被执行，if条件(conditon)可以是如下任何内容：
• 当表达式只是一个变量时，如果值为空或任何以0开头的字符串都会当做false
• 直接比较变量和内容时，使用=或!=
• ~正则表达式匹配，~*不区分大小写的匹配，!~区分大小写的不匹配
-f和!-f用来判断是否存在文件
-d和!-d用来判断是否存在目录
-e和!-e用来判断是否存在文件或目录
-x和!-x用来判断文件是否可执行
例如：</li>
</ol>
<pre><code class="language-bash">if ($http_user_agent ~ MSIE) {
    rewrite ^(.*)$ /msie/$1 break;
} //如果UA包含&quot;MSIE&quot;，rewrite请求到/msid/目录下

if ($http_cookie ~* &quot;id=([^;]+)(?:;|$)&quot;) {
    set $id $1;
 } //如果cookie匹配正则，设置变量$id等于正则引用部分

if ($request_method = POST) {
    return 405;
} //如果提交方法为POST，则返回状态405（Method not allowed）。return不能返回301,302

if ($slow) {
    limit_rate 10k;
} //限速，$slow可以通过 set 指令设置

if (!-f $request_filename){
    break;
    proxy_pass  &lt;http://127.0.0.1&gt;;
} //如果请求的文件名不存在，则反向代理到localhost 。这里的break也是停止rewrite检查

if ($args ~ post=140){
    rewrite ^ &lt;http://example.com/&gt; permanent;
} //如果query string中包含&quot;post=140&quot;，永久重定向到example.com

location ~* \.(gif|jpg|png|swf|flv)$ {
    valid_referers none blocked www.jefflei.com www.leizhenfang.com;
    if ($invalid_referer) {
        return 404;
    } //防盗链
}


全局变量
 下面是可以用作if判断的全局变量
 • $args ： #这个变量等于请求行中的参数，同$query_string
 • $content_length ： 请求头中的Content-length字段。
 • $content_type ： 请求头中的Content-Type字段。
 • $document_root ： 当前请求在root指令中指定的值。
 • $host ： 请求主机头字段，否则为服务器名称。
 • $http_user_agent ： 客户端agent信息
 • $http_cookie ： 客户端cookie信息
 • $limit_rate ： 这个变量可以限制连接速率。
 • $request_method ： 客户端请求的动作，通常为GET或POST。
 • $remote_addr ： 客户端的IP地址。
 • $remote_port ： 客户端的端口。
 • $remote_user ： 已经经过Auth Basic Module验证的用户名。
 • $request_filename ： 当前请求的文件路径，由root或alias指令与URI请求生成。
 • $scheme ： HTTP方法（如http，https）。
 • $server_protocol ： 请求使用的协议，通常是HTTP/1.0或HTTP/1.1。
 • $server_addr ： 服务器地址，在完成一次系统调用后可以确定这个值。
 • $server_name ： 服务器名称。
 • $server_port ： 请求到达服务器的端口号。
 • $request_uri ： 包含请求参数的原始URI，不包含主机名，如：”/foo/bar.php?arg=baz”。
 • $uri ： 不带请求参数的当前URI，$uri不包含主机名，如”/foo/bar.html”。
 • $document_uri ： 与$uri相同。

例：&lt;http://localhost:88/test1/test2/test.php&gt;
 $host：localhost
 $server_port：88
 $request_uri：&lt;http://localhost:88/test1/test2/test.php&gt;
 $document_uri：/test1/test2/test.php
 $document_root：/var/www/html
 $request_filename：/var/www/html/test1/test2/test.php
</code></pre>
<h2 id="常用正则"><a class="header" href="#常用正则">常用正则</a></h2>
<pre><code class="language-bash"> • . ： 匹配除换行符以外的任意字符
 • ? ： 重复0次或1次
 • + ： 重复1次或更多次
 • * ： 重复0次或更多次
 • \d ：匹配数字
 • ^ ： 匹配字符串的开始
 • $ ： 匹配字符串的介绍
 • {n} ： 重复n次
 • {n,} ： 重复n次或更多次
 • [c] ： 匹配单个字符c
 • [a-z] ： 匹配a-z小写字母的任意一个

# 小括号()之间匹配的内容，可以在后面通过$1来引用，$2表示的是前面第二个()里的内容。正则里面容易让人困惑的是\转义特殊字符。
</code></pre>
<h2 id="rewrite实例"><a class="header" href="#rewrite实例">rewrite实例</a></h2>
<p>例1：</p>
<pre><code class="language-bash">http {
    # 定义image日志格式
    log_format imagelog '[$time_local] ' $image_file ' ' $image_type ' ' $body_bytes_sent ' ' $status;
    # 开启重写日志
    rewrite_log on;

    server {
        root /home/www;

        location / {
                # 重写规则信息
                error_log logs/rewrite.log notice; 
                # 注意这里要用‘’单引号引起来，避免{}
                rewrite '^/images/([a-z]{2})/([a-z0-9]{5})/(.*)\.(png|jpg|gif)$' /data?file=$3.$4;
                # 注意不能在上面这条规则后面加上“last”参数，否则下面的set指令不会执行
                set $image_file $3;
                set $image_type $4;
        }

        location /data {
                # 指定针对图片的日志格式，来分析图片类型和大小
                access_log logs/images.log mian;
                root /data/images;
                # 应用前面定义的变量。判断首先文件在不在，不在再判断目录在不在，如果还不在就跳转到最后一个url里
                try_files /$arg_file /image404.html;
        }
        location = /image404.html {
                # 图片不存在返回特定的信息
                return 404 &quot;image not found\n&quot;;
        }
}
</code></pre>
<p>对形如/images/ef/uh7b3/test.png的请求，重写到/data?file=test.png，于是匹配到location /data，先看/data/images/test.png文件存不存在，如果存在则正常响应，如果不存在则重写tryfiles到新的image404 location，直接返回404状态码。</p>
<p>例2：</p>
<pre><code class="language-bash">rewrite ^/images/(.*)_(\d+)x(\d+)\.(png|jpg|gif)$ /resizer/$1.$4?width=$2&amp;height=$3? last;
</code></pre>
<p>对形如/images/bla_500x400.jpg的文件请求，重写到/resizer/bla.jpg?width=500&amp;height=400地址，并会继续尝试匹配location。</p>
<p>例3：
见 ssl部分页面加密 。</p>
<p>参考
原文链接地址：<a href="http://seanlook.com/2015/05/17/nginx-location-rewrite/">http://seanlook.com/2015/05/17/nginx-location-rewrite/</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="nginx-grpc配置"><a class="header" href="#nginx-grpc配置">nginx Grpc配置</a></h2>
<pre><code class="language-conf">location / {
    grpc_set_header     Content-Type application/grpc;
    grpc_pass           grpc://localhost:50051;

    if ($request_method = 'OPTIONS') {
        add_header 'Access-Control-Allow-Origin' &quot;*&quot;;
        add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS, DELETE';
        add_header 'Access-Control-Allow-Headers' 'DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Content-Transfer-Encoding,Custom-Header-1,X-Accept-Content-Transfer-Encoding,X-Accept-Response-Streaming,X-User-Agent,X-Grpc-Web';
        add_header 'Access-Control-Max-Age' 1728000;
        add_header 'Content-Type' 'text/plain charset=UTF-8';
        add_header 'Content-Length' 0;
        return 204;
    }

    if ($request_method = 'POST') {
        add_header 'Access-Control-Allow-Origin' '*';
        add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS';
        add_header 'Access-Control-Allow-Headers' 'DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Content-Transfer-Encoding,Custom-Header-1,X-Accept-Content-Transfer-Encoding,X-Accept-Response-Streaming,X-User-Agent,X-Grpc-Web';
        add_header 'Access-Control-Expose-Headers' 'Content-Transfer-Encoding,Grpc-Message,Grpc-Status';
    }
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="nginx配置"><a class="header" href="#nginx配置">nginx配置</a></h2>
<pre><code class="language-conf">
#user  nobody; #运行用户
worker_processes  auto; #启动进程,通常设置成和cpu的数量相等

#全局错误日志及PID文件
#error_log  logs/error.log;
#error_log  logs/error.log  notice;
#error_log  logs/error.log  info;
#全局错误日志定义类型，[ debug | info | notice | warn | error | crit ]

#pid        logs/nginx.pid;

#工作模式及连接数上限
events {
    #epoll是多路复用IO(I/O Multiplexing)中的一种方式,
    #参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; epoll模型是Linux 2.6以上版本内核中的高性能网络I/O模型，如果跑在FreeBSD上面，就用kqueue模型
    use   epoll;

    #单个后台worker process进程的最大并发链接数    
    #单个进程最大连接数（最大连接数=连接数*进程数）
    worker_connections 65535;
    #worker_connections  1024;

    # 并发总数是 worker_processes 和 worker_connections 的乘积
    # 即 max_clients = worker_processes * worker_connections
    # 在设置了反向代理的情况下，max_clients = worker_processes * worker_connections / 4  为什么
    # 为什么上面反向代理要除以4，应该说是一个经验值
    # 根据以上条件，正常情况下的Nginx Server可以应付的最大连接数为：4 * 8000 = 32000
    # worker_connections 值的设置跟物理内存大小有关
    # 因为并发受IO约束，max_clients的值须小于系统可以打开的最大文件数
    # 而系统可以打开的最大文件数和内存大小成正比，一般1GB内存的机器上可以打开的文件数大约是10万左右
    # 我们来看看360M内存的VPS可以打开的文件句柄数是多少：
    # $ cat /proc/sys/fs/file-max
    # 输出 34336
    # 32000 &lt; 34336，即并发连接总数小于系统可以打开的文件句柄总数，这样就在操作系统可以承受的范围之内
    # 所以，worker_connections 的值需根据 worker_processes 进程数目和系统可以打开的最大文件总数进行适当地进行设置
    # 使得并发总数小于操作系统可以打开的最大文件数目
    # 其实质也就是根据主机的物理CPU和内存进行配置
    # 当然，理论上的并发总数可能会和实际有所偏差，因为主机还有其他的工作进程需要消耗系统资源。
    # ulimit -SHn 65535
}

http {
    include       mime.types; #设定mime类型,类型由mime.type文件定义
    default_type  application/octet-stream;

    log_format  main  '$remote_addr - $remote_user [$time_local] &quot;$request&quot; '
                      '$status $body_bytes_sent &quot;$http_referer&quot; '
                      '&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;';
    log_format  log_feedback  '[$time_local] $request';
        # $body_bytes_sent, the number of bytes, transmitted to client minus the response headers, variable is compatible with parameter %B of module Apache's mod_log_config (this was called $apache_bytes_sent, before version 0.3.10)
        # $bytes_sent, the number of bytes, transmitted to client
        # $connection, the number of connection
        # $msec, the time with an accuracy to microseconds at the moment of the log entry
        # $pipe, &quot;p&quot; if request was pipelining
        # $request_length, the length of the body of the request
        # $request_time, the time of working on request in seconds
        # $status, status of answer
        # $time_local, local time into common log format.

    access_log  logs/access.log  main;

    ##开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。
    sendfile        on;
    #tcp_nopush     on;

    #keepalive_timeout  0;
    keepalive_timeout  65; #长连接超时时间，单位是秒
    autoindex on; #开启目录列表访问，合适下载服务器，默认关闭。
    tcp_nopush on; #防止网络阻塞
    tcp_nodelay on; #防止网络阻塞


    #gzip模块设置
    gzip  on; # 该指令用于开启或关闭gzip模块(on/off)
    gzip_min_length 1k; # 设置允许压缩的页面最小字节数，页面字节数从header头得content-length中进行获取。默认值是0，不管页面多大都压缩。建议设置成大于1k的字节数，小于1k可能会越压越大。
    # Disables gzipping of responses for requests with “User-Agent” header fields matching any of the specified regular expressions.
    gzip_proxied any;
    # gzip_proxied     expired no-cache no-store private auth;
    gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript application/javascript image/svg+xml  image/jpeg image/gif image/png;
    # 匹配mime类型进行压缩，无论是否指定,”text/html”类型总是会被压缩的。

    gzip_buffers 4 16k; #压缩缓冲区
    # 设置系统获取几个单位的缓存用于存储gzip的压缩结果数据流。4 16k代表以16k为单位，安装原始数据大小以16k为单位的4倍申请内存。
    # gzip_http_version 1.0; #压缩版本（默认1.1，前端如果是squid2.5请使用1.0）
    gzip_comp_level 9; # gzip压缩比，1压缩比最小处理速度最快，9压缩比最大但处理速度最慢(传输快但比较消耗cpu)
    gzip_min_length 1024 # 设置允许压缩的页面最小字节数，页面字节数从header头中的Content-Length中进行获取。默认值是0，不管页面多大都压缩。建议设置成大于1k的字节数，小于1k可能会越压越大。

    gzip_vary on;
    # Enables or disables inserting the “Vary: Accept-Encoding” response header field if the directives gzip, gzip_static, or gunzip are active.
    # 和http头有关系，加个vary头，给代理服务器用的，有的浏览器支持压缩，有的不支持，所以避免浪费不支持的也压缩，所以根据客户端的HTTP头来判断，是否需要压缩
    
    gzip_disable &quot;MSIE [1-6].&quot;;
    
    
    #设定请求缓冲
    client_header_buffer_size    128k; #上传文件大小限制
    large_client_header_buffers  4 128k; #设定请求缓


    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header Host $host;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_http_version 1.1;
    proxy_set_header Connection &quot;&quot;;


    ssl_certificate      /etc/letsencrypt/live/01cs.cc/fullchain.pem;
    ssl_certificate_key  /etc/letsencrypt/live/01cs.cc/privkey.pem;
    # ssl验证相关配置
    ssl_session_timeout  5m;    #缓存有效期
    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4:!DH:!DHE;    #加密算法
    ssl_protocols TLSv1.1 TLSv1.2 TLSv1.3;    #安全链接可选的加密协议
    ssl_prefer_server_ciphers on;   #使用服务器端的首选算法
    add_header          Strict-Transport-Security &quot;max-age=15768000;includeSubDomains&quot;; # max-age=设置在浏览器收到这个请求后的秒的时间内凡是访问这个域名下的请求都使用HTTPS请求。
                                                                            #includeSubDomains 可选  如果这个可选的参数被指定，那么说明此规则也适用于该网站的所有子域名。

    # http -&gt; https
    server {
        listen 80 default_server;
        listen [::]:80 default_server;
        server_name _;

        return 301 https://$host$request_uri;
        #rewrite ^/(.*) https://$host$1 permanent;
        
        #server_name example.com www.example.com;
     #return 301 https://$server_name$request_uri;
    }


    map $http_upgrade $connection_upgrade {
        default upgrade;
        '' close;
    }

    upstream sockets  {
        server 127.0.0.1:26202;
    }

    upstream https  {
        #upstream的负载均衡，weight是权重，可以根据机器配置定义权重。weigth参数表示权值，权值越高被分配到的几率越大。
        ip_hash; #url_hash fair 当负载调度算法为ip_hash时，后端服务器在负载均衡调度中的状态不能是weight和backup。
        server 192.168.1.13:80;
        server 192.168.1.14:80  down; #backup weight=1 max_fails=2 fail_timeout=2;
        server 192.168.1.15:8009  max_fails=3  fail_timeout=20s  weight=3;
    }

    server {
        listen      80;
        listen      [::]:80 ipv6only=on;
        listen      443 ssl http2;
        listen      [::]:443 ssl ipv6only=on http2;
        server_name  www.01cs.cc api.01cs.cc;


        location ^~ /websokect/ {
            proxy_pass http://sockets;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection &quot;upgrade&quot;;
        }
        # 跨域问题
        location /{
            add_header 'Access-Control-Allow-Origin' '*';
            add_header 'Access-Control-Allow-Methods' 'GET,POST,OPTIONS,HEAD,PUT,DELETE';
            root /var/www;
            index index.html;
        }
        # 定义错误提示页面
        error_page   500 502 503 504 /50x.html;
        location = /50x.html {
        }
        # nginx直接返回json
        location /api/user/feedback {
            access_log  logs/feedback.log  log_feedback;
            return 200 '{&quot;status&quot;:0,&quot;message&quot;:&quot;ok&quot;,&quot;data&quot;:&quot;&quot;}';
        }

        #url重写
        # /api/user/feedback
        location ^~ /api/ {
            proxy_pass http://https;      -&gt; /api/user/feedback
            #proxy_pass http://https/;    -&gt; /user/feedback
        }

        # /http/ctrl/user/feedback
        location ^~ /http/ctrl/ {
            proxy_pass http://https/api/; -&gt; /api/user/feedback
        }

        #location ~* (.*)/api/(.*)$ {
        #location ~* /([0-9.]*)/api/(.*)$ {
        location ~* /2.2.1/api/([0-9a-z_]*)/([0-9a-z_]*)(.*)$ {
            proxy_pass http://2.2.1/api/$1?app_id=$2&amp;args=$3;
            
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        }
        #静态文件，nginx自己处理
        location ~ ^/(images|javascript|js|css|flash|media|static)/ {
            #过期30天，静态文件不怎么更新，过期可以设大一点，
            #如果频繁更新，则可以设置得小一点。
            expires 30d; # 1h
        }
        #PHP 脚本请求全部转发到 FastCGI处理. 使用FastCGI默认配置.
        location ~ .php$ {
            fastcgi_pass 127.0.0.1:9000;
            fastcgi_index index.php;
            fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;
            include fastcgi_params;
        }

        #禁止访问 .htxxx 文件
        location ~ /.ht {
            deny all;
        }

        location /nginx-status {
            stub_status on;
            access_log on;
            auth_basic &quot;NginxStatus&quot;;
            auth_basic_user_file confpasswd; #htpasswd文件的内容可以用apache提供的htpasswd工具来产生。
        }
        
    }

    server {
        listen      80;
        #listen      443 ssl;
        server_name  gm.haowenjiao.ai gm.01cs.cc;

        root /var/www/gm;
        index index.html;
        location / {
            try_files $uri $uri/ /index.html;
            # 如果有资源，建议使用 https + http2，配合按需加载可以获得更好的体验 
            # rewrite ^/(.*)$ https://preview.pro.ant.design/$1 permanent;
        }
    }

}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="nginx使用"><a class="header" href="#nginx使用">nginx使用</a></h2>
<pre><code class="language-bash">## ubuntu
sudo apt install -y libpcre3-dev

./configure --with-http_ssl_module --with-http_v2_module --with-http_gzip_static_module

make
sudo make install
</code></pre>
<h2 id="generate-certificates"><a class="header" href="#generate-certificates">Generate Certificates</a></h2>
<pre><code class="language-bash">cd /usr/local/nginx/conf
openssl genrsa -des3 -out server.key 1024
openssl req -new -key server.key -out server.csr
cp server.key server.key.org
openssl rsa -in server.key.org -out server.key
openssl x509 -req -days 365 -in server.csr -signkey server.key -out server.crt


server {

    server_name YOUR_DOMAINNAME_HERE;
    listen 443;
    ssl on;
    ssl_certificate /usr/local/nginx/conf/server.crt;
    ssl_certificate_key /usr/local/nginx/conf/server.key;

}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="nginx使用-1"><a class="header" href="#nginx使用-1">nginx使用</a></h2>
<pre><code class="language-bash">## ubuntu
sudo apt install -y libpcre3-dev

./configure --with-http_ssl_module --with-http_v2_module --with-http_gzip_static_module

make
sudo make install
</code></pre>
<h2 id="generate-certificates-1"><a class="header" href="#generate-certificates-1">Generate Certificates</a></h2>
<pre><code class="language-bash">cd /usr/local/nginx/conf
openssl genrsa -des3 -out server.key 1024
openssl req -new -key server.key -out server.csr
cp server.key server.key.org
openssl rsa -in server.key.org -out server.key
openssl x509 -req -days 365 -in server.csr -signkey server.key -out server.crt


server {

    server_name YOUR_DOMAINNAME_HERE;
    listen 443;
    ssl on;
    ssl_certificate /usr/local/nginx/conf/server.crt;
    ssl_certificate_key /usr/local/nginx/conf/server.key;

}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h2 id="docker-仓库registry"><a class="header" href="#docker-仓库registry">docker 仓库（registry）</a></h2>
<pre><code class="language-bash"># 私有服务：创建私有仓库
docker run -d -p 5000:5000 --restart=always --name registry -v /opt/myregistry:/var/lib/registry registry


#重启docker让修改生效
systemctl restart  docker.service

#Dockerfile打包镜像 https://www.docker.org.cn/docker/docker-206.html

vim Dockerfile
----------------------------------------------------------------
FROM nginx #指定基础镜像，FROM必须为Dockerfile非注释行的第一行。
MAINTAINER      Fisher &quot;fisher@sudops.com&quot; #设置镜像标签

#ENV &lt;key&gt; &lt;value&gt;此方法一次只能设置一个
#ENV &lt;key&gt;=&lt;value&gt; ... 该方法一次可以设置多个环境变量
#例：ENV JAVA_HOME=/home/jdk-8

RUN     /bin/echo 'root:123456' |chpasswd
RUN     useradd runoob
RUN     /bin/echo 'runoob:123456' |chpasswd
RUN     /bin/echo -e &quot;LANG=\&quot;en_US.UTF-8\&quot;&quot; &gt;/etc/default/local

USER root #指定运行容器的用户
WORKDIR /home #工作目录，进入容器后，以 WORKDIR 为当前路径

COPY /usr/local/nginx/html /usr/share/nginx/html

EXPOSE  22 #说明容器暴露的端口，默认协议为 tcp ，若是 udp 协议，则需要在后面添加 udp ，如 80/udp
EXPOSE  80

VOLUME /var/log #设置挂载点，将容器内的路径挂载到宿主机，该挂载方式是将容器内的路径挂载到docker数据路径下

CMD     /usr/sbin/sshd -D #设置容器启动后默认执行的命令，CMD命令会被docker run的参数覆盖。
ENTRYPOINT /usr/local/apache-tomcat-8.5.33/bin/startup.sh #和CMD一样，设置容器启动后默认执行的命令，但是该命令不会被docker run覆盖，会始终执行，CMD会被docker run传入的命令覆盖。
----------------------------------------------------------------
docker build -t test-static ./test #打包新镜像
#-t ：指定要创建的目标镜像名
#./test ：Dockerfile 文件所在目录，可以指定Dockerfile 的绝对路径

docker tag nginx:latest 127.0.0.1:5000/htjicon/nginx
docker images
docker push 127.0.0.1:5000/htjicon/nginx #推送到私有仓库

#将新打标签的镜像上传镜像到仓库
docker push   192.168.1.68:5000/clsn/busybox


# 增量打包镜像
docker ps -a  #查看本地容器
docker run -it -d centos /bin/bash #启动容器，并进入容器内部系统
docker  exec  -it   7b88d2a5edc2 /bin/bash # 进入容器内部系统 CONTAINER_ID
echo &quot;test&quot; &gt; test.txt #修改容器内容
docker cp custom.conf 容器名称:/etc/nginx/conf.d/
docker commit -m=&quot;has update&quot; -a=&quot;runoob&quot; 7b88d2a5edc2 127.0.0.1:5000/htjicon/nginx:v1.3.1  # 产生新的镜像，commit CONTAINER_ID， tag
#-m: 提交的描述信息
#-a: 指定镜像作者
#7b88d2a5edc2 ID
#127.0.0.1:5000/htjicon/nginx:v1.3.1: 指定要创建的目标镜像名
docker image ls # 查看镜像
docker push 127.0.0.1:5000/htjicon/nginx:v1.3.1 #新镜像 推送到私有仓库

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="docker"><a class="header" href="#docker">docker</a></h2>
<h2 id="安装-2"><a class="header" href="#安装-2">安装</a></h2>
<pre><code class="language-bash">wget -qO- https://get.docker.com/ | sh
sudo service docker start
sudo docker run hello-world

</code></pre>
<h2 id="镜像控制"><a class="header" href="#镜像控制">镜像控制</a></h2>
<pre><code class="language-bash">
docker image list
docker image ls # 查看镜像
docker image save centos &gt; docker-centos.tar.gz #导出镜像
docker image rm centos:latest #删除镜像
docker image load -i docker-centos.tar.gz  #导入镜像
docker image inspect centos #查看镜像的详细信息

搜索镜像：docker  search  [OPTIONS]  TERM
docker search centos #搜索官方仓库镜像

上传镜像：docker  push  [OPTIONS]  NAME[:TAG]
docker push 192.168.0.91:5000/htjicon/nginx:v1.3.1 #新镜像 推送到私有仓库

下载镜像：docker  pull  [OPTIONS]  NAME[:TAG]
docker pull centos #获取镜像
docker pull training/webapp  # 载入镜像

提交镜像：docker  commit [OPTIONS]  CONTAINER  NAME[:TAG]
docker commit -m=&quot;has update&quot; -a=&quot;runoob&quot; 7b88d2a5edc2 192.168.0.91:5000/htjicon/nginx:v1.3.1  # 产生新的镜像，commit CONTAINER_ID tag
#-m: 提交的描述信息
#-a: 指定镜像作者
#7b88d2a5edc2 ID
#192.168.0.91:5000/htjicon/nginx:v1.3.1: 指定要创建的目标镜像名

构建镜像：docker  build  [OPTIONS]  PATH

删除镜像：docker  rmi [OPTIONS]  IMAGE  [IMAGE...]

增加镜像标签：docker  tag  SOURCE_IMAGE[:TAG]  TARGET_IMAGE[:TAG]

查看所有镜像：docker  images  [OPTIONS]  [REPOSITORY[:TAG]]

a） 运行容器
docker run -dit -p 8080:80 --name Nginx nginx

b） 修改容器（这里我只是做个演示，所以就复制一下文件，具体修改需要根据你实际情况）
docker cp custom.conf Nginx:/etc/nginx/conf.d/

c） 将容器保存为新的镜像
docker commit Nginx zwx/nginx

</code></pre>
<h2 id="容器控制"><a class="header" href="#容器控制">容器控制</a></h2>
<pre><code class="language-bash">
启动/重启容器：docker start/restart CONTAINER
docker start | stop | restart tag|CONTAINER ID|NAMES

停止/强停容器：docker stop/ kill CONTAINER

删除容器：docker rm [OPTIONS] CONTAINER [CONTAINER...]
docker rm bf08b7f2cd89 # docker rm -f `docker ps -a -q` #删除所有容器

重命名容器：docker rename CONTAINER CONTAINER_NEW

进入容器：docker attach CONTAINER
docker attach 1bf0f43c4d2f

执行容器命令：docker exec CONTAINER COMMAND
docker exec -it 1bf0f43c4d2f  /bin/bash #exec 进入容器方法（推荐使用）
    ps -ef

查看容器日志：docker logs [OPTIONS] CONTAINER
docker logs -f bf08b7f2cd89

查看容器列表：docker ps [OPTIONS]
docker ps -a # 查看你所有容器 -l %查询最后一次创建的容器 -a %所有容器


docker container kill CONTAINER ID #停止容器
docker container inspect 60cbfbc74f8a # 详细信息

docker port bf08b7f2cd89
docker top bf08b7f2cd89
docker inspect bf08b7f2cd89

</code></pre>
<h2 id="容器启动"><a class="header" href="#容器启动">容器启动</a></h2>
<pre><code class="language-bash">
docker run -it nginx:latest  /bin/bash #进入容器方法
docker run -d -P training/webapp python app.py # -d:让容器在后台运行  -P:将容器内部使用的网络端口映射到我们使用的主机上
docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py # -p 是容器内部端口绑定到指定的主机端口
docker run -d -P --name runoob training/webapp python app.py  #--name 容器命名

-d : 后台运行容器，并返回容器ID
-i：以交互模式运行容器，通常与 -t 同时使用
-t：为容器重新分配一个伪输入终端，通常与 -i 同时使用
-v：绑定挂载目录
--name=&quot;mycontainer&quot;: 为容器指定一个名称
--net=&quot;bridge&quot;: 指定容器的网络连接类型，支持如下：

</code></pre>
<h2 id="其他命令"><a class="header" href="#其他命令">其他命令</a></h2>
<pre><code class="language-bash">
docker cp custom.conf 容器名称:/etc/nginx/conf.d/

查看docker信息：docker info
docker命令帮助：docker run --help
复制文件到容器：docker cp custom.conf Nginx:/etc/nginx/conf.d/
更新容器启动项：docker container update --restart=always nginx
查看docker日志：tail -f /var/log/messages

</code></pre>
<h2 id="容器启动进行端口映射"><a class="header" href="#容器启动进行端口映射">容器启动进行端口映射</a></h2>
<pre><code class="language-bash">docker run -d -p 8888:80  nginx:latest  #启动时进行端口映射
-p hostPort:containerPort #端口映射  -p 8080:80
-p ip:hostPort:containerPort #配置监听地址 -p 10.0.0.100:8080:80
-p ip::containerPort #随机分配端口-p 10.0.0.100::80
-p hostPort:containerPort:udp #指定协议-p 8080:80:tcp
-p 81:80 -p 443:443          #指定多个

netstat -lntup #查看使用的端口

</code></pre>
<h2 id="容器数据卷的管理"><a class="header" href="#容器数据卷的管理">容器数据卷的管理</a></h2>
<pre><code class="language-bash">docker run -d -p 80:80 -v /data:/usr/share/nginx/html nginx:latest #挂载卷
docker run -d -p 8080:80 -v /data:/usr/share/nginx/html nginx:latest  #设置共享卷，使用同一个卷启动一个新的容器
docker volume ls #查看卷列表

#创建卷后挂载
docker volume create
docker volume ls
docker volume inspect 1bf0f43c4d2f
docker run -d -p 9000:80 -v clsn:/usr/share/nginx/html nginx:latest #使用卷创建
docker run  -d  -P  --volumes-from 079786c1e297 nginx:latest  #设置卷
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="docker-compose"><a class="header" href="#docker-compose">docker compose</a></h2>
<h2 id="配置文件"><a class="header" href="#配置文件">配置文件</a></h2>
<pre><code class="language-yaml">version: &quot;3&quot;

services:
  htzx:
    image: 127.0.0.1:15000/htzx/iot-device-access-service #指定容器运行的镜像。
    tty: true
    container_name: &quot;iot-device-access-service&quot; #自定义容器名称，而不是生成的默认名称。
    privileged: true
    environment: # 添加环境变量
      - TZ=Asia/Shanghai
    ports:
      - &quot;15020:8080&quot;
    extra_hosts: # 添加主机名映射。类似 docker client --add-host。
      - &quot;consul:192.168.0.1&quot;
    env_file: # 从文件添加环境变量。可以是单个值或列表的多个值。
      - ../env/common.env
    context: ./dir # 上下文路径。
    dockerfile: Dockerfile-alternate # 指定构建镜像的 Dockerfile 文件名。
    args: # 添加构建参数，这是只能在构建过程中访问的环境变量。
      buildno: 1
    labels: # 设置构建镜像的标签。
      - &quot;com.example.description=Accounting webapp&quot;
      - &quot;com.example.department=Finance&quot;
      - &quot;com.example.label-with-empty-value&quot;
    target: prod # 多层构建，可以指定构建哪一层。
    volumes: #将主机的数据卷或着文件挂载到容器里。
      - &quot;/localhost/postgres.sock:/var/run/postgres/postgres.sock&quot;
      - &quot;/localhost/data:/var/lib/postgresql/data&quot;

networks:
  default:
    external:
      name: hangtian
</code></pre>
<h2 id="运行命令"><a class="header" href="#运行命令">运行命令</a></h2>
<pre><code class="language-bash">docker-compose up -d # 后台执行服务

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="docker-网络"><a class="header" href="#docker-网络">docker 网络</a></h2>
<pre><code class="language-bash">
docker network create -d bridge test-net # -d：参数指定 Docker 网络类型，有 bridge、overlay。
docker run -itd --name test1 --network test-net ubuntu /bin/bash #运行一个容器并连接到新建的 test-net 网络
docker run -itd --name test2 --network test-net ubuntu /bin/bash #打开新的终端，再运行一个容器并加入到 test-net 网络:

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h2 id="安装-ubuntu"><a class="header" href="#安装-ubuntu">安装 ubuntu</a></h2>
<pre><code class="language-bash">sudo apt-get install git

#常用命令
git config

git clone url
git clone &lt;repository::指定远程数据库的 URL&gt; &lt;directory::指定新目录的名称&gt; %克隆

git pull %从服务器获取文件，使用 pull 指令进行拉取操作。省略数据库名称的话，会在名为 origin 的数据库进行 pull

git add %现在需要同步的文件
git add -A

git commit %添加到本地数据库
git commit -m &quot;msg&quot;

git push %同步到网络服务器,把本地服务器中的文件同步到网络服务器，push 之前需要 commit

git remote -h
# 修改服务端仓库
git remote rm origin
git remote add origin git@git.oschina.net:fuhu/aya.git
git remote -v #获取服务端仓库

# 查看remote地址，远程分支，还有本地分支与之相对应关系等信息
git remote show origin
# 清理远程仓库不存在的分支
git remote prune origin

# 分支branch 
git branch name %新建分支
git checkout name %进入该分支
git push --set-upstream origin branch_name
git push origin --delete &lt;branchName&gt; %删除远程分支
git branch -d &lt;branchName&gt; %%删除本地分支



## 标签tag 
git tag
git tag -l &quot;v1.8.5*&quot;
git show v1.4
git tag -a v1.0.0 -m &quot;my version 1.0.0&quot;
git push origin v1.0.0
git push origin --tags
git push origin --delete tag &lt;tagname&gt; %删除服务端 tag
git tag -d &lt;tagname&gt; 删除本地 tag
git reset --hard V1.1 本地代码重置到某个 tag


## branch和tag 重复
git push origin :notmaster
git push origin :refs/heads/&lt;branch&gt;
git remote show origin
git remote prune origin


## 合并 git merge 
git checkout master
git merge develop
git push


## 检出 checkout 
git checkout master
git checkout -b version2 v2.0.0
git checkout -b branch_name tag_name


## 撤销 reset 
git reset --hard %重置本地所有改动，保持和服务器版本一致

git reset --soft HEAD^ 撤回 commit 操作，保留代码
git reset --hard commit_id 撤回 commit 操作，重置到 commit_id 版本，改动代码也被重置
git reset --mixed HEAD^ 不删除工作空间改动代码，撤销 commit，并且撤销 git add . 操作
--soft  
 不删除工作空间改动代码，撤销 commit，不撤销 git add .
--hard
删除工作空间改动代码，撤销 commit，撤销 git add .
注意完成这个操作后，就恢复到了上一次的 commit 状态。
git commit --amend 修改注释


## 回退 revert 公共远程分支版本回退
自己的分支回滚直接用 reset
公共分支回滚用 revert
git revert HEAD //撤销最近一次提交
git revert HEAD~1 //撤销上上次的提交，注意：数字从 0 开始
git revert 0ffaacc //撤销 0ffaacc 这次提交
错的太远了直接将代码全部删掉，用正确代码替代


## 服务端部署 服务端创建一个空仓库
git --bare init game.git
# 客户端
git clone root@115.159.22.131:~/git/game.git
git config --global user.name &quot;YOUR NAME&quot;
git config --global user.email &quot;YOUR EMAIL ADDRESS&quot;
git init 初始化
git branch -a 查看分支，列出的分支中，带有*的为本地分支，其他为远程分支
git remote -v
git remote remove origin
git remote add origin root@115.159.22.131:~/git/game.git
git push origin master


## git stash
git stash: 备份当前的工作区的内容，从最近的一次提交中读取相关内容，让工作区保证和上次提交的内容一致。同时，将当前的工作区内容保存到 Git 栈中。

git stash %把当前改动复制一个版本后，重置本地改动到服务器最新版本
git pull origin master %1.更新最新代码（包含冲突文件）2.手动改动代码 3.提交到服务端
git stash pop %复制的版本和最新版本对比。  
 git log master -n 1 --pretty=commit:%H &gt; git_version %生成版本号

git stash pop: 从 Git 栈中读取最近一次保存的内容，恢复工作区的相关内容。由于可能存在多个 Stash 的内容，所以用栈来管理，pop 会从最近的一个 stash 中读取内容并恢复。
git stash list: 显示 Git 栈内的所有备份，可以利用这个列表来决定从那个地方恢复。
git stash clear: 清空 Git 栈。此时使用 gitg 等图形化工具会发现，原来 stash 的哪些节点都消失了。

# cherry-pick
git cherry-pick 4c805e2
复制一个特定的提交到当前分支


## git log %log 指令来确认历史记录是否已更新
git log --oneline --graph
–author=“Alex Kras” ——只显示某个用户的提交任务
–name-only ——只显示变更文件的名称
–oneline——将提交信息压缩到一行显示
–graph ——显示所有提交的依赖树
–reverse ——按照逆序显示提交记录（最先提交的在最前面）
–after ——显示某个日期之后发生的提交
–before ——显示发生某个日期之前的提交
git -log -p filename
git log -L 1,1:some-file.txt
git log --no-merges master.. || it show --no-merges master.. 或者 git log -p --no-merges master..
git log -n 1 --pretty=format:&quot;%h&quot;

git reflog%用来记录你每一次执行的命令

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="install"><a class="header" href="#install">install</a></h2>
<pre><code class="language-bash"># https://gitea.io/zh-cn/


useradd gitea
su gitea
wget -O gitea https://dl.gitea.io/gitea/1.16.0/gitea-1.16.0-linux-amd64
chmod +x gitea
./gitea web
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="frp内网穿透"><a class="header" href="#frp内网穿透">frp内网穿透</a></h1>
<h2 id="资料"><a class="header" href="#资料">资料</a></h2>
<p><a href="https://github.com/fatedier/frp">https://github.com/fatedier/frp</a></p>
<h2 id="配置-2"><a class="header" href="#配置-2">配置</a></h2>
<h2 id="命令"><a class="header" href="#命令">命令</a></h2>
<pre><code class="language-bash">
# 通过 ssh 访问内网机器，假设用户名为 test：
ssh -i ~/.ssh/id_rsa -oPort=60000 yj@127.0.0.1

</code></pre>
<h2 id="安全地暴露内网服务"><a class="header" href="#安全地暴露内网服务">安全地暴露内网服务</a></h2>
<h3 id="服务端"><a class="header" href="#服务端">服务端</a></h3>
<pre><code class="language-bash">#https://gofrp.org/docs/reference/server-configures/

[common]
bind_addr = 0.0.0.0
bind_port = 7000
kcp_bind_port = 7000 # 服务端监听 KCP 协议端口，用于接收采用 KCP 连接的，kcp绑定udp端口

max_pool_count = 2 # 最大连接池大小，默认5

# 权限验证
token = token123 string 鉴权使用的 token 值   客户端需要设置一样的值才能鉴权通过

</code></pre>
<h3 id="客户端"><a class="header" href="#客户端">客户端</a></h3>
<pre><code class="language-bash"># frpc.ini
[common]
server_addr = 192.168.1.100
server_port = 7000
token = token123

[tcp1]
# 本机80端口映射到外网8080端口
type = tcp              # tcp, udp, http, https, stcp, sudp, xtcp, tcpmux
local_ip = 127.0.0.1    # 本地服务 IP
local_port = 80         # 本地服务端口
remote_port = 8080      # 服务端绑定的端口


[tcp2]
# 局域网端口号映射到外网8082端口
type = tcp
local_ip = 192.168.1.85
local_port = 51005
remote_port = 8082


## 负载均衡
# frpc.ini
[test1]
type = tcp
local_port = 8080
remote_port = 80
group = web
group_key = 123

[test2]
type = tcp
local_port = 8081
remote_port = 80
group = web
group_key = 123

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="google-protocol-buffer"><a class="header" href="#google-protocol-buffer">google protocol buffer</a></h2>
<h2 id="例子"><a class="header" href="#例子">例子</a></h2>
<pre><code class="language-proto">syntax = &quot;proto3&quot;;
// 注释
message SearchRequest {
    // 分配标识号 [1,15] 1byte  [16,2047] 2byte 1-2^29=536,870,911  [19000－19999]不可用 (从FieldDescriptor::kFirstReservedNumber 到 FieldDescriptor::kLastReservedNumber)
    // singular：一个格式良好的消息应该有0个或者1个这种字段（但是不能超过1个）。

    // repeated：在一个格式良好的消息中，这种字段可以重复任意多次（包括0次）。重复的值的顺序会被保留。
    repeated int32 d = 4 [packed=true];

    // reserved:注明已被废弃的字段编号和字段名称. 
    reserved 2, 15, 9 to 11;  
    reserved &quot;foo&quot;, &quot;bar&quot;;

    string query = 1;
    int32 page_number = 2;
    int32 result_per_page = 3;
}
</code></pre>
<h2 id="标量数值类型"><a class="header" href="#标量数值类型">标量数值类型</a></h2>
<div class="table-wrapper"><table><thead><tr><th>.proto Type</th><th>Notes</th><th>C++ Type</th><th>Java Type</th><th>Python Type[2]</th><th>Go Type</th><th>Ruby Type</th><th>C# Type</th><th>PHP Type</th></tr></thead><tbody>
<tr><td>double</td><td>double</td><td>double</td><td>float</td><td>float64</td><td>Float</td><td>double</td><td>float</td><td></td></tr>
<tr><td>float</td><td>float</td><td>float</td><td>float</td><td>float32</td><td>Float</td><td>float</td><td>float</td><td></td></tr>
<tr><td>int32</td><td>使用变长编码，对于负值的效率很低，如果你的域有可能有负值，请使用sint64替代</td><td>int32</td><td>int</td><td>int</td><td>int32</td><td>Fixnum 或者 Bignum（根据需要）</td><td>int</td><td>integer</td></tr>
<tr><td>uint32</td><td>使用变长编码</td><td>uint32</td><td>int</td><td>int/long</td><td>uint32</td><td>Fixnum 或者 Bignum（根据需要）</td><td>uint</td><td>integer</td></tr>
<tr><td>uint64</td><td>使用变长编码</td><td>uint64</td><td>long</td><td>int/long</td><td>uint64</td><td>Bignum</td><td>ulong</td><td>integer/string</td></tr>
<tr><td>sint32</td><td>使用变长编码，这些编码在负值时比int32高效的多</td><td>int32</td><td>int</td><td>int</td><td>int32</td><td>Fixnum 或者 Bignum（根据需要）</td><td>int</td><td>integer</td></tr>
<tr><td>sint64</td><td>使用变长编码，有符号的整型值。编码时比通常的int64高效。</td><td>int64</td><td>long</td><td>int/long</td><td>int64</td><td>Bignum</td><td>long</td><td>integer/string</td></tr>
<tr><td>fixed32</td><td>总是4个字节，如果数值总是比总是比228大的话，这个类型会比uint32高效。</td><td>uint32</td><td>int</td><td>int</td><td>uint32</td><td>Fixnum 或者 Bignum（根据需要）</td><td>uint</td><td>integer</td></tr>
<tr><td>fixed64</td><td>总是8个字节，如果数值总是比总是比256大的话，这个类型会比uint64高效。</td><td>uint64</td><td>long</td><td>int/long</td><td>uint64</td><td>Bignum</td><td>ulong</td><td>integer/string</td></tr>
<tr><td>sfixed32</td><td>总是4个字节</td><td>int32</td><td>int</td><td>int</td><td>int32</td><td>Fixnum 或者 Bignum（根据需要）</td><td>int</td><td>integer</td></tr>
<tr><td>sfixed64</td><td>总是8个字节</td><td>int64</td><td>long</td><td>int/long</td><td>int64</td><td>Bignum</td><td>long</td><td>integer/string</td></tr>
<tr><td>bool</td><td>bool</td><td>boolean</td><td>bool</td><td>bool</td><td>TrueClass/FalseClass</td><td>bool</td><td>boolean</td><td></td></tr>
<tr><td>string</td><td>一个字符串必须是UTF-8编码或者7-bit ASCII编码的文本。</td><td>string</td><td>String</td><td>str/unicode</td><td>string</td><td>String (UTF-8)</td><td>string</td><td>string</td></tr>
<tr><td>bytes</td><td>可能包含任意顺序的字节数据。</td><td>string</td><td>ByteString</td><td>str</td><td>[]byte</td><td>String (ASCII-8BIT)</td><td>ByteString</td><td>string</td></tr>
</tbody></table>
</div>
<h2 id="默认值"><a class="header" href="#默认值">默认值</a></h2>
<pre><code class="language-text">对于string，默认是一个空string
对于bytes，默认是一个空的bytes
对于bool，默认是false
对于数值类型，默认是0
对于枚举，默认是第一个定义的枚举值，必须为0;
对于消息类型（message），域没有被设置，确切的消息是根据语言确定的，详见generated code guide
</code></pre>
<h2 id="枚举"><a class="header" href="#枚举">枚举</a></h2>
<pre><code class="language-proto">// corpus的值可能是UNIVERSAL，WEB，IMAGES，LOCAL，NEWS，PRODUCTS或VIDEO中的一个
// 每个枚举类型必须将其第一个类型映射为0
// 枚举常量必须在32位整型值的范围内,因为enum值是使用可变编码方式的，对负数不够高效，因此不推荐在enum中使用负数
// 将不同的枚举常量指定位相同的值。如果这样做你需要将allow_alias设定位true
enum EnumAllowingAlias {
  option allow_alias = true;
  UNKNOWN = 0;
  STARTED = 1;
  RUNNING = 1; // RUNNING 是 STARTED 的别名
}
message SearchRequest {
  string query = 1;
  int32 page_number = 2;
  int32 result_per_page = 3;
  enum Corpus {
    UNIVERSAL = 0;
    WEB = 1;
    IMAGES = 2;
    LOCAL = 3;
    NEWS = 4;
    PRODUCTS = 5;
    VIDEO = 6;
  }
  Corpus corpus = 4;
}
</code></pre>
<h2 id="使用其他消息类型"><a class="header" href="#使用其他消息类型">使用其他消息类型</a></h2>
<pre><code class="language-proto">// 你可以将其他消息类型用作字段类型。
message SearchResponse {
  repeated Result results = 1;
}
message Result {
  string url = 1;
  string title = 2;
  repeated string snippets = 3;
}
</code></pre>
<h2 id="导入定义"><a class="header" href="#导入定义">导入定义</a></h2>
<pre><code class="language-proto">import &quot;myproject/other_protos.proto&quot;;

vim fun3.proto
    import public &quot;fun1.proto&quot;;
    import  &quot;fun2.proto&quot;;

vim fun4.proto
    import &quot;fun3.proto&quot;; // 可以直接使用fun3.proto和 fun1.proto
</code></pre>
<h2 id="嵌套类型"><a class="header" href="#嵌套类型">嵌套类型</a></h2>
<pre><code class="language-proto">message SearchResponse {
  message Result {
    string url = 1;
    string title = 2;
    repeated string snippets = 3;
  }
  repeated Result results = 1;
}

message SomeOtherMessage {
  SearchResponse.Result result = 1;
}

message Outer {                  // Level 0
  message MiddleAA {  // Level 1
    message Inner {   // Level 2
      int64 ival = 1;
      bool  booly = 2;
    }
  }
  message MiddleBB {  // Level 1
    message Inner {   // Level 2
      int32 ival = 1;
      bool  booly = 2;
    }
  }
}
</code></pre>
<h2 id="更新一个消息类型"><a class="header" href="#更新一个消息类型">更新一个消息类型</a></h2>
<pre><code class="language-text">官方指南翻译

不要更改任何现有字段的字段编号.
如果添加新的字段, 仍然可以使用新生成的代码解析旧的 message 格式. 但应该自行处理新加字段的默认值.
使用新代码创建的 message 也可以被旧代码解析, 那些新字段会被忽略.

字段可以被删除, 只要不要复用那些字段编号. 要重命名字段, 可以给旧字段添加 OBSOLETE_ 前缀,
或者将字段编号设置为 reserved.

int32, uint32, int64, uint64, bool 是相互兼容的类型.
sint32 和 sint64 是相互兼容的, 但不兼容其他 int 类型.
string 和 bytes 可以是兼容的, 只要 bytes 是有效的 UTF-8.
嵌入的 message 可以和 bytes 兼容, 如果 bytes 包含 message 的编码后的版本.
fixed32 和 sfixed32 兼容, fixed64 和 sfixed64 兼容.
enum 在 wire 格式上兼容 int32, uint32, int64, uint64(如果值不合适会被截断). 当 message 被反序列化时,
客户端代码可以用不同的方式对待它们. 比如, 未识别的 proto3 的 enum 类型将会保存在 message 中, 但它如何

表示是语言特定的. int 字段总是会保留它的值.

将一个单个值更改为新 oneof 的成员是安全的且二进制兼容的. 移动多个字段到一个新的 oneof 可能是安全的,
如果你确保没有 code 被多次设置. 移动任何字段到一个已存在的 oneof 是不安全的.

</code></pre>
<h2 id="any"><a class="header" href="#any">Any</a></h2>
<pre><code class="language-proto">// Any类型消息允许你在没有指定他们的.proto定义的情况下使用消息作为一个嵌套类型。一个Any类型包括一个可以被序列化bytes类型的任意消息，以及一个URL作为一个全局标识符和解析消息类型。为了使用Any类型，你需要导入import google/protobuf/any.proto。
import &quot;google/protobuf/any.proto&quot;;
message ErrorStatus {
  string message = 1;
  repeated google.protobuf.Any details = 2;
}
</code></pre>
<h2 id="map"><a class="header" href="#map">Map</a></h2>
<pre><code class="language-proto">map&lt;key_type, value_type&gt; map_field = N;
map&lt;string, Project&gt; projects = 3;

Map的字段可以是repeated。
序列化后的顺序和map迭代器的顺序是不确定的，所以你不要期望以固定顺序处理Map
当为.proto文件产生生成文本格式的时候，map会按照key 的顺序排序，数值化的key会按照数值排序。
从序列化中解析或者融合时，如果有重复的key则后一个key不会被使用，当从文本格式中解析map时，如果存在重复的key。
</code></pre>
<h2 id="package"><a class="header" href="#package">Package</a></h2>
<h2 id="定义服务service"><a class="header" href="#定义服务service">定义服务(Service)</a></h2>
<pre><code class="language-proto">service SearchService {
  rpc Search (SearchRequest) returns (SearchResponse);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="网络管理命令"><a class="header" href="#网络管理命令">网络管理命令</a></h2>
<pre><code class="language-bash"># 下载整个网页 无法下载通过js引用的文件
wget -r -p -np -k https://developer.zuoshouyisheng.com/

##=curl====================================================
curl -X PUT -v -d '{}' &quot;http://192.168.67.12:63001/config?a=b&quot;

# ss

# netstat

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="svn"><a class="header" href="#svn">svn</a></h2>
<pre><code class="language-bash">

## 安装svnserver
yum -y install subversion 
 
## 初始化 
cd project
 mkdir svn
 cd svn
 svnadmin create project_svn
 
## 启动
 svnserve -d -r /root/project/svn
 svnserve -d -r /root/project/svn --listen-port 8086
 svnserve -d -r  /root/project/svn
checkout svn checkout svn://127.0.0.1/ project_svn

## Vim passwd 
 yujian = enter123
 huyuwei = enter123
Vim authz [groups]
 
 admin_group = gm,admin,yujian,wumanyu
 
 [haowenjiao:/Client]
 @client = rw
 
 [[project]:/]
 @admin_group = rw
 * =
 
 ## 所有权限
 [/]
 * = rw
Vim svnserve.conf 
 anon-access = none
 auth-access = write
 password-db = passwd
 authz-db = authz
 realm = /svn/the_repository

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ntpd"><a class="header" href="#ntpd">ntpd</a></h2>
<p>ntpd服务的相关设置文件如下：</p>
<p>1./etc/ntp.conf：这个是NTP daemon的主要设文件，也是 NTP 唯一的设定文件。</p>
<p>2./usr /share/zoneinfo/:在这个目录下的文件其实是规定了各主要时区的时间设定文件，例如北京地区的时区设定文件在/usr/share/zoneinfo/Asia/Beijing 就是了。这个目录里面的文件与底下要谈的两个文件(clock 与localtime)是有关系的。</p>
<p>3./etc/sysconfig/clock：这个文件其实也不包含在NTP 的 daemon 当中，因为这个是linux的主要时区设定文件。每次开机后，Linux 会自动的读取这个文件来设定自己系统所默认要显示的时间。</p>
<p>4./etc /localtime：这个文件就是“本地端的时间配置文件”。刚刚那个clock 文件里面规定了使用的时间设置文件(ZONE) 为/usr/share/zoneinfo/Asia/Beijing ，所以说，这就是本地端的时间了，此时， Linux系统就会将Beijing那个文件另存为一份/etc/localtime文件，所以未来我们的时间显示就会以Beijing那个时间设定文件为准。</p>
<p>5./etc/timezone：系统时区文件</p>
<pre><code>下面重点说说 /etc/ntp.conf文件的设置。在 NTP Server 的设定上面，其实最好不要对 Internet 无限制的开放，尽量仅提供您自己内部的 Client 端联机进行网络校时就好。此外， NTP Server 总也是需要网络上面较为准确的主机来自行更新自己的时间啊，所以在我们的 NTP Server 上面也要找一部最靠近自己的 Time Server 来进行自我校正。事实上， NTP 这个服务也是Server/Client 的一种模式。
</code></pre>
<h2 id="命令-1"><a class="header" href="#命令-1">命令</a></h2>
<pre><code class="language-bash">
\cp -r /usr/share/zoneinfo/Asia/Shanghai /etc/localtime # 时区设置为东八区


#Debian系统安装NTP校时包：
sudo apt-get install -y ntpdate ntp

#CentOS系统安装NTP校时包：
yum -y install ntpdate ntp #安装ntp


vim /etc/ntp.conf
server cn.pool.ntp.org
restrict default nomodifynotrapnoquery
restrict 127.0.0.1　　 # 开启内部递归网络接口 lo
restrict 192.168.9.0 mask 255.255.255.0 nomodify notrap #在内部子网里面的客户端可以 进行网络校时，但不能修改NTP服务器的时间参数


ntpdate cn.pool.ntp.org &amp;&amp; hwclock -w                   # 通过对时服务器核对时间，并写入硬件

# 对时服务器
# cn.pool.ntp.org us.pool.ntp.org
# time.windows.com
# ntpupdate.tencentyun.com


#!/bin/bash
#备份源文件
mv /etc/localtime /etc/localtimebak
#修改时区为东八区
ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
#安装ntp服务
yum -y install ntpdate ntp
#修改/etc/ntp.conf 
cat &lt;&lt; EOF  &gt;&gt; /etc/ntp.conf 
server cn.pool.ntp.org
server time-a.nist.gov
server time.windows.com
server time.nist.gov
EOF
#调试查看时间差异
ntpdate -d cn.pool.ntp.org
#同步时间
ntpdate cn.pool.ntp.org &amp;&amp; echo &quot;SYNC_HWCLOCK=yes&quot; &gt;&gt;/etc/sysconfig/ntpd || echo &quot;Setting Filed!&quot;
#自启动
chkconfig --levels 235 ntpd on
/etc/init.d/ntpd start
echo `date`


</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="personal-etc"><a class="header" href="#personal-etc">personal etc</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id=""><a class="header" href="#"></a></h1>
<h2 id="依赖"><a class="header" href="#依赖">依赖</a></h2>
<h2 id="运行"><a class="header" href="#运行">运行</a></h2>
<h2 id="联系"><a class="header" href="#联系">联系</a></h2>
<p>wuyanyi09@gmail.com</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_line_numbers = true;
        </script>
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
    </body>
</html>
