
## nginx配置

```conf

#user  nobody; #运行用户
worker_processes  auto; #启动进程,通常设置成和cpu的数量相等

#全局错误日志及PID文件
#error_log  logs/error.log;
#error_log  logs/error.log  notice;
#error_log  logs/error.log  info;
#全局错误日志定义类型，[ debug | info | notice | warn | error | crit ]

#pid        logs/nginx.pid;

#工作模式及连接数上限
events {
    #epoll是多路复用IO(I/O Multiplexing)中的一种方式,
    #参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; epoll模型是Linux 2.6以上版本内核中的高性能网络I/O模型，如果跑在FreeBSD上面，就用kqueue模型
    use   epoll;

    #单个后台worker process进程的最大并发链接数    
    #单个进程最大连接数（最大连接数=连接数*进程数）
    worker_connections 65535;
    #worker_connections  1024;

    # 并发总数是 worker_processes 和 worker_connections 的乘积
    # 即 max_clients = worker_processes * worker_connections
    # 在设置了反向代理的情况下，max_clients = worker_processes * worker_connections / 4  为什么
    # 为什么上面反向代理要除以4，应该说是一个经验值
    # 根据以上条件，正常情况下的Nginx Server可以应付的最大连接数为：4 * 8000 = 32000
    # worker_connections 值的设置跟物理内存大小有关
    # 因为并发受IO约束，max_clients的值须小于系统可以打开的最大文件数
    # 而系统可以打开的最大文件数和内存大小成正比，一般1GB内存的机器上可以打开的文件数大约是10万左右
    # 我们来看看360M内存的VPS可以打开的文件句柄数是多少：
    # $ cat /proc/sys/fs/file-max
    # 输出 34336
    # 32000 < 34336，即并发连接总数小于系统可以打开的文件句柄总数，这样就在操作系统可以承受的范围之内
    # 所以，worker_connections 的值需根据 worker_processes 进程数目和系统可以打开的最大文件总数进行适当地进行设置
    # 使得并发总数小于操作系统可以打开的最大文件数目
    # 其实质也就是根据主机的物理CPU和内存进行配置
    # 当然，理论上的并发总数可能会和实际有所偏差，因为主机还有其他的工作进程需要消耗系统资源。
    # ulimit -SHn 65535
}

http {
    include       mime.types; #设定mime类型,类型由mime.type文件定义
    default_type  application/octet-stream;

    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';
    log_format  log_feedback  '[$time_local] $request';
        # $body_bytes_sent, the number of bytes, transmitted to client minus the response headers, variable is compatible with parameter %B of module Apache's mod_log_config (this was called $apache_bytes_sent, before version 0.3.10)
        # $bytes_sent, the number of bytes, transmitted to client
        # $connection, the number of connection
        # $msec, the time with an accuracy to microseconds at the moment of the log entry
        # $pipe, "p" if request was pipelining
        # $request_length, the length of the body of the request
        # $request_time, the time of working on request in seconds
        # $status, status of answer
        # $time_local, local time into common log format.

    access_log  logs/access.log  main;

    ##开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。
    sendfile        on;
    #tcp_nopush     on;

    #keepalive_timeout  0;
    keepalive_timeout  65; #长连接超时时间，单位是秒
    autoindex on; #开启目录列表访问，合适下载服务器，默认关闭。
    tcp_nopush on; #防止网络阻塞
    tcp_nodelay on; #防止网络阻塞


    #gzip模块设置
    gzip  on; # 该指令用于开启或关闭gzip模块(on/off)
    gzip_min_length 1k; # 设置允许压缩的页面最小字节数，页面字节数从header头得content-length中进行获取。默认值是0，不管页面多大都压缩。建议设置成大于1k的字节数，小于1k可能会越压越大。
    # Disables gzipping of responses for requests with “User-Agent” header fields matching any of the specified regular expressions.
    gzip_proxied any;
    # gzip_proxied     expired no-cache no-store private auth;
    gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript application/javascript image/svg+xml  image/jpeg image/gif image/png;
    # 匹配mime类型进行压缩，无论是否指定,”text/html”类型总是会被压缩的。

    gzip_buffers 4 16k; #压缩缓冲区
    # 设置系统获取几个单位的缓存用于存储gzip的压缩结果数据流。4 16k代表以16k为单位，安装原始数据大小以16k为单位的4倍申请内存。
    # gzip_http_version 1.0; #压缩版本（默认1.1，前端如果是squid2.5请使用1.0）
    gzip_comp_level 9; # gzip压缩比，1压缩比最小处理速度最快，9压缩比最大但处理速度最慢(传输快但比较消耗cpu)
    gzip_min_length 1024 # 设置允许压缩的页面最小字节数，页面字节数从header头中的Content-Length中进行获取。默认值是0，不管页面多大都压缩。建议设置成大于1k的字节数，小于1k可能会越压越大。

    gzip_vary on;
    # Enables or disables inserting the “Vary: Accept-Encoding” response header field if the directives gzip, gzip_static, or gunzip are active.
    # 和http头有关系，加个vary头，给代理服务器用的，有的浏览器支持压缩，有的不支持，所以避免浪费不支持的也压缩，所以根据客户端的HTTP头来判断，是否需要压缩
    
    gzip_disable "MSIE [1-6].";
    
    
    #设定请求缓冲
    client_header_buffer_size    128k; #上传文件大小限制
    large_client_header_buffers  4 128k; #设定请求缓


    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header Host $host;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_http_version 1.1;
    proxy_set_header Connection "";


    ssl_certificate      /etc/letsencrypt/live/01cs.cc/fullchain.pem;
    ssl_certificate_key  /etc/letsencrypt/live/01cs.cc/privkey.pem;
    # ssl验证相关配置
    ssl_session_timeout  5m;    #缓存有效期
    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4:!DH:!DHE;    #加密算法
    ssl_protocols TLSv1.1 TLSv1.2 TLSv1.3;    #安全链接可选的加密协议
    ssl_prefer_server_ciphers on;   #使用服务器端的首选算法
    add_header          Strict-Transport-Security "max-age=15768000;includeSubDomains"; # max-age=设置在浏览器收到这个请求后的秒的时间内凡是访问这个域名下的请求都使用HTTPS请求。
                                                                            #includeSubDomains 可选  如果这个可选的参数被指定，那么说明此规则也适用于该网站的所有子域名。

    # http -> https
    server {
        listen 80 default_server;
        listen [::]:80 default_server;
        server_name _;

        return 301 https://$host$request_uri;
        #rewrite ^/(.*) https://$host$1 permanent;
        
        #server_name example.com www.example.com;
     #return 301 https://$server_name$request_uri;
    }


    map $http_upgrade $connection_upgrade {
        default upgrade;
        '' close;
    }

    upstream sockets  {
        server 127.0.0.1:26202;
    }

    upstream https  {
        #upstream的负载均衡，weight是权重，可以根据机器配置定义权重。weigth参数表示权值，权值越高被分配到的几率越大。
        ip_hash; #url_hash fair 当负载调度算法为ip_hash时，后端服务器在负载均衡调度中的状态不能是weight和backup。
        server 192.168.1.13:80;
        server 192.168.1.14:80  down; #backup weight=1 max_fails=2 fail_timeout=2;
        server 192.168.1.15:8009  max_fails=3  fail_timeout=20s  weight=3;
    }

    server {
        listen      80;
        listen      [::]:80 ipv6only=on;
        listen      443 ssl http2;
        listen      [::]:443 ssl ipv6only=on http2;
        server_name  www.01cs.cc api.01cs.cc;


        location ^~ /websokect/ {
            proxy_pass http://sockets;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";
        }
        # 跨域问题
        location /{
            add_header 'Access-Control-Allow-Origin' '*';
            add_header 'Access-Control-Allow-Methods' 'GET,POST,OPTIONS,HEAD,PUT,DELETE';
            root /var/www;
            index index.html;
        }
        # 定义错误提示页面
        error_page   500 502 503 504 /50x.html;
        location = /50x.html {
        }
        # nginx直接返回json
        location /api/user/feedback {
            access_log  logs/feedback.log  log_feedback;
            return 200 '{"status":0,"message":"ok","data":""}';
        }

        #url重写
        # /api/user/feedback
        location ^~ /api/ {
            proxy_pass http://https;      -> /api/user/feedback
            #proxy_pass http://https/;    -> /user/feedback
        }

        # /http/ctrl/user/feedback
        location ^~ /http/ctrl/ {
            proxy_pass http://https/api/; -> /api/user/feedback
        }

        #location ~* (.*)/api/(.*)$ {
        #location ~* /([0-9.]*)/api/(.*)$ {
        location ~* /2.2.1/api/([0-9a-z_]*)/([0-9a-z_]*)(.*)$ {
            proxy_pass http://2.2.1/api/$1?app_id=$2&args=$3;
            
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        }
        #静态文件，nginx自己处理
        location ~ ^/(images|javascript|js|css|flash|media|static)/ {
            #过期30天，静态文件不怎么更新，过期可以设大一点，
            #如果频繁更新，则可以设置得小一点。
            expires 30d; # 1h
        }
        #PHP 脚本请求全部转发到 FastCGI处理. 使用FastCGI默认配置.
        location ~ .php$ {
            fastcgi_pass 127.0.0.1:9000;
            fastcgi_index index.php;
            fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;
            include fastcgi_params;
        }

        #禁止访问 .htxxx 文件
        location ~ /.ht {
            deny all;
        }

        location /nginx-status {
            stub_status on;
            access_log on;
            auth_basic "NginxStatus";
            auth_basic_user_file confpasswd; #htpasswd文件的内容可以用apache提供的htpasswd工具来产生。
        }
        
    }

    server {
        listen      80;
        #listen      443 ssl;
        server_name  gm.haowenjiao.ai gm.01cs.cc;

        root /var/www/gm;
        index index.html;
        location / {
            try_files $uri $uri/ /index.html;
            # 如果有资源，建议使用 https + http2，配合按需加载可以获得更好的体验 
            # rewrite ^/(.*)$ https://preview.pro.ant.design/$1 permanent;
        }
    }

}
```
