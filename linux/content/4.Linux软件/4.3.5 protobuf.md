---
title: "protobuf"
menuTitle: "protobuf"
weight: 0
date: 2019-08-30T15:13:01+08:00
---
## google protocol buffer

## 例子

```proto
syntax = "proto3";
// 注释
message SearchRequest {
    // 分配标识号 [1,15] 1byte  [16,2047] 2byte 1-2^29=536,870,911  [19000－19999]不可用 (从FieldDescriptor::kFirstReservedNumber 到 FieldDescriptor::kLastReservedNumber)
    // singular：一个格式良好的消息应该有0个或者1个这种字段（但是不能超过1个）。
    // repeated：在一个格式良好的消息中，这种字段可以重复任意多次（包括0次）。重复的值的顺序会被保留。
    // reserved:保留标识符 reserved 2, 15, 9 to 11;  reserved "foo", "bar";
    string query = 1;
    int32 page_number = 2;
    int32 result_per_page = 3;
}
```

## 标量数值类型

| \.proto Type | Notes                                    | C\+\+ Type | Java Type  | Python Type\[2\] | Go Type              | Ruby Type              | C\# Type   | PHP Type       |
|--------------|------------------------------------------|------------|------------|------------------|----------------------|------------------------|------------|----------------|
| double       | double                                   | double     | float      | float64          | Float                | double                 | float      |
| float        | float                                    | float      | float      | float32          | Float                | float                  | float      |
| int32        | 使用变长编码，对于负值的效率很低，如果你的域有可能有负值，请使用sint64替代 | int32      | int        | int              | int32                | Fixnum 或者 Bignum（根据需要） | int        | integer        |
| uint32       | 使用变长编码                                   | uint32     | int        | int/long         | uint32               | Fixnum 或者 Bignum（根据需要） | uint       | integer        |
| uint64       | 使用变长编码                                   | uint64     | long       | int/long         | uint64               | Bignum                 | ulong      | integer/string |
| sint32       | 使用变长编码，这些编码在负值时比int32高效的多                | int32      | int        | int              | int32                | Fixnum 或者 Bignum（根据需要） | int        | integer        |
| sint64       | 使用变长编码，有符号的整型值。编码时比通常的int64高效。           | int64      | long       | int/long         | int64                | Bignum                 | long       | integer/string |
| fixed32      | 总是4个字节，如果数值总是比总是比228大的话，这个类型会比uint32高效。  | uint32     | int        | int              | uint32               | Fixnum 或者 Bignum（根据需要） | uint       | integer        |
| fixed64      | 总是8个字节，如果数值总是比总是比256大的话，这个类型会比uint64高效。  | uint64     | long       | int/long         | uint64               | Bignum                 | ulong      | integer/string |
| sfixed32     | 总是4个字节                                   | int32      | int        | int              | int32                | Fixnum 或者 Bignum（根据需要） | int        | integer        |
| sfixed64     | 总是8个字节                                   | int64      | long       | int/long         | int64                | Bignum                 | long       | integer/string |
| bool         | bool                                     | boolean    | bool       | bool             | TrueClass/FalseClass | bool                   | boolean    |
| string       | 一个字符串必须是UTF\-8编码或者7\-bit ASCII编码的文本。     | string     | String     | str/unicode      | string               | String \(UTF\-8\)      | string     | string         |
| bytes        | 可能包含任意顺序的字节数据。                           | string     | ByteString | str              | \[\]byte             | String \(ASCII\-8BIT\) | ByteString | string         |

## 默认值

```text
对于string，默认是一个空string
对于bytes，默认是一个空的bytes
对于bool，默认是false
对于数值类型，默认是0
对于枚举，默认是第一个定义的枚举值，必须为0;
对于消息类型（message），域没有被设置，确切的消息是根据语言确定的，详见generated code guide
```

## 枚举

```proto
// corpus的值可能是UNIVERSAL，WEB，IMAGES，LOCAL，NEWS，PRODUCTS或VIDEO中的一个
// 每个枚举类型必须将其第一个类型映射为0
// 枚举常量必须在32位整型值的范围内,因为enum值是使用可变编码方式的，对负数不够高效，因此不推荐在enum中使用负数
// 将不同的枚举常量指定位相同的值。如果这样做你需要将allow_alias设定位true
enum EnumAllowingAlias {
  option allow_alias = true;
  UNKNOWN = 0;
  STARTED = 1;
  RUNNING = 1;
}
message SearchRequest {
  string query = 1;
  int32 page_number = 2;
  int32 result_per_page = 3;
  enum Corpus {
    UNIVERSAL = 0;
    WEB = 1;
    IMAGES = 2;
    LOCAL = 3;
    NEWS = 4;
    PRODUCTS = 5;
    VIDEO = 6;
  }
  Corpus corpus = 4;
}
```

## 使用其他消息类型

```proto
// 你可以将其他消息类型用作字段类型。
message SearchResponse {
  repeated Result results = 1;
}
message Result {
  string url = 1;
  string title = 2;
  repeated string snippets = 3;
}
```

## 导入定义

```proto
import "myproject/other_protos.proto";

vim fun3.proto
    import public "fun1.proto";
    import  "fun2.proto";

vim fun4.proto
    import "fun3.proto"; // 可以直接使用fun3.proto和 fun1.proto
```

## 嵌套类型

```proto
message SearchResponse {
  message Result {
    string url = 1;
    string title = 2;
    repeated string snippets = 3;
  }
  repeated Result results = 1;
}

message SomeOtherMessage {
  SearchResponse.Result result = 1;
}

message Outer {                  // Level 0
  message MiddleAA {  // Level 1
    message Inner {   // Level 2
      int64 ival = 1;
      bool  booly = 2;
    }
  }
  message MiddleBB {  // Level 1
    message Inner {   // Level 2
      int32 ival = 1;
      bool  booly = 2;
    }
  }
}
```

## 更新一个消息类型

```text
如果一个已有的消息格式已无法满足新的需求——如，要在消息中添加一个额外的字段——但是同时旧版本写的代码仍然可用。不用担心！更新消息而不破坏已有代码是非常简单的。在更新时只要记住以下的规则即可。

不要更改任何已有的字段的数值标识。

如果你增加新的字段，使用旧格式的字段仍然可以被你新产生的代码所解析。你应该记住这些元素的默认值这样你的新代码就可以以适当的方式和旧代码产生的数据交互。相似的，通过新代码产生的消息也可以被旧代码解析：只不过新的字段会被忽视掉。注意，未被识别的字段会在反序列化的过程中丢弃掉，所以如果消息再被传递给新的代码，新的字段依然是不可用的（这和proto2中的行为是不同的，在proto2中未定义的域依然会随着消息被序列化）

非required的字段可以移除——只要它们的标识号在新的消息类型中不再使用（更好的做法可能是重命名那个字段，例如在字段前添加“OBSOLETE_”前缀，那样的话，使用的.proto文件的用户将来就不会无意中重新使用了那些不该使用的标识号）。

int32, uint32, int64, uint64,和bool是全部兼容的，这意味着可以将这些类型中的一个转换为另外一个，而不会破坏向前、 向后的兼容性。如果解析出来的数字与对应的类型不相符，那么结果就像在C++中对它进行了强制类型转换一样（例如，如果把一个64位数字当作int32来 读取，那么它就会被截断为32位的数字）。

sint32和sint64是互相兼容的，但是它们与其他整数类型不兼容。

string和bytes是兼容的——只要bytes是有效的UTF-8编码。

嵌套消息与bytes是兼容的——只要bytes包含该消息的一个编码过的版本。

fixed32与sfixed32是兼容的，fixed64与sfixed64是兼容的。

枚举类型与int32，uint32，int64和uint64相兼容（注意如果值不相兼容则会被截断），然而在客户端反序列化之后他们可能会有不同的处理方式，例如，未识别的proto3枚举类型会被保留在消息中，但是他的表示方式会依照语言而定。int类型的字段总会保留他们的
```

## Any

```proto
// Any类型消息允许你在没有指定他们的.proto定义的情况下使用消息作为一个嵌套类型。一个Any类型包括一个可以被序列化bytes类型的任意消息，以及一个URL作为一个全局标识符和解析消息类型。为了使用Any类型，你需要导入import google/protobuf/any.proto。
import "google/protobuf/any.proto";
message ErrorStatus {
  string message = 1;
  repeated google.protobuf.Any details = 2;
}
```

## Map

```proto
map<key_type, value_type> map_field = N;
map<string, Project> projects = 3;

Map的字段可以是repeated。
序列化后的顺序和map迭代器的顺序是不确定的，所以你不要期望以固定顺序处理Map
当为.proto文件产生生成文本格式的时候，map会按照key 的顺序排序，数值化的key会按照数值排序。
从序列化中解析或者融合时，如果有重复的key则后一个key不会被使用，当从文本格式中解析map时，如果存在重复的key。
```

## Package

## 定义服务(Service)

```proto
service SearchService {
  rpc Search (SearchRequest) returns (SearchResponse);
}
```
