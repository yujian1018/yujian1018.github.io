---
title: "protobuf"
menuTitle: "protobuf"
weight: 0
date: 2019-08-30T15:13:01+08:00
---
## google protocol buffer

## 例子

```proto
syntax = "proto3";
// 注释
message SearchRequest {
    // 分配标识号 [1,15] 1byte  [16,2047] 2byte 1-2^29=536,870,911  [19000－19999]不可用 (从FieldDescriptor::kFirstReservedNumber 到 FieldDescriptor::kLastReservedNumber)
    // singular：一个格式良好的消息应该有0个或者1个这种字段（但是不能超过1个）。

    // repeated：在一个格式良好的消息中，这种字段可以重复任意多次（包括0次）。重复的值的顺序会被保留。
    repeated int32 d = 4 [packed=true];

    // reserved:注明已被废弃的字段编号和字段名称. 
    reserved 2, 15, 9 to 11;  
    reserved "foo", "bar";

    string query = 1;
    int32 page_number = 2;
    int32 result_per_page = 3;
}
```

## 标量数值类型

| \.proto Type | Notes                                    | C\+\+ Type | Java Type  | Python Type\[2\] | Go Type              | Ruby Type              | C\# Type   | PHP Type       |
|--------------|------------------------------------------|------------|------------|------------------|----------------------|------------------------|------------|----------------|
| double       | double                                   | double     | float      | float64          | Float                | double                 | float      |
| float        | float                                    | float      | float      | float32          | Float                | float                  | float      |
| int32        | 使用变长编码，对于负值的效率很低，如果你的域有可能有负值，请使用sint64替代 | int32      | int        | int              | int32                | Fixnum 或者 Bignum（根据需要） | int        | integer        |
| uint32       | 使用变长编码                                   | uint32     | int        | int/long         | uint32               | Fixnum 或者 Bignum（根据需要） | uint       | integer        |
| uint64       | 使用变长编码                                   | uint64     | long       | int/long         | uint64               | Bignum                 | ulong      | integer/string |
| sint32       | 使用变长编码，这些编码在负值时比int32高效的多                | int32      | int        | int              | int32                | Fixnum 或者 Bignum（根据需要） | int        | integer        |
| sint64       | 使用变长编码，有符号的整型值。编码时比通常的int64高效。           | int64      | long       | int/long         | int64                | Bignum                 | long       | integer/string |
| fixed32      | 总是4个字节，如果数值总是比总是比228大的话，这个类型会比uint32高效。  | uint32     | int        | int              | uint32               | Fixnum 或者 Bignum（根据需要） | uint       | integer        |
| fixed64      | 总是8个字节，如果数值总是比总是比256大的话，这个类型会比uint64高效。  | uint64     | long       | int/long         | uint64               | Bignum                 | ulong      | integer/string |
| sfixed32     | 总是4个字节                                   | int32      | int        | int              | int32                | Fixnum 或者 Bignum（根据需要） | int        | integer        |
| sfixed64     | 总是8个字节                                   | int64      | long       | int/long         | int64                | Bignum                 | long       | integer/string |
| bool         | bool                                     | boolean    | bool       | bool             | TrueClass/FalseClass | bool                   | boolean    |
| string       | 一个字符串必须是UTF\-8编码或者7\-bit ASCII编码的文本。     | string     | String     | str/unicode      | string               | String \(UTF\-8\)      | string     | string         |
| bytes        | 可能包含任意顺序的字节数据。                           | string     | ByteString | str              | \[\]byte             | String \(ASCII\-8BIT\) | ByteString | string         |

## 默认值

```text
对于string，默认是一个空string
对于bytes，默认是一个空的bytes
对于bool，默认是false
对于数值类型，默认是0
对于枚举，默认是第一个定义的枚举值，必须为0;
对于消息类型（message），域没有被设置，确切的消息是根据语言确定的，详见generated code guide
```

## 枚举

```proto
// corpus的值可能是UNIVERSAL，WEB，IMAGES，LOCAL，NEWS，PRODUCTS或VIDEO中的一个
// 每个枚举类型必须将其第一个类型映射为0
// 枚举常量必须在32位整型值的范围内,因为enum值是使用可变编码方式的，对负数不够高效，因此不推荐在enum中使用负数
// 将不同的枚举常量指定位相同的值。如果这样做你需要将allow_alias设定位true
enum EnumAllowingAlias {
  option allow_alias = true;
  UNKNOWN = 0;
  STARTED = 1;
  RUNNING = 1; // RUNNING 是 STARTED 的别名
}
message SearchRequest {
  string query = 1;
  int32 page_number = 2;
  int32 result_per_page = 3;
  enum Corpus {
    UNIVERSAL = 0;
    WEB = 1;
    IMAGES = 2;
    LOCAL = 3;
    NEWS = 4;
    PRODUCTS = 5;
    VIDEO = 6;
  }
  Corpus corpus = 4;
}
```

## 使用其他消息类型

```proto
// 你可以将其他消息类型用作字段类型。
message SearchResponse {
  repeated Result results = 1;
}
message Result {
  string url = 1;
  string title = 2;
  repeated string snippets = 3;
}
```

## 导入定义

```proto
import "myproject/other_protos.proto";

vim fun3.proto
    import public "fun1.proto";
    import  "fun2.proto";

vim fun4.proto
    import "fun3.proto"; // 可以直接使用fun3.proto和 fun1.proto
```

## 嵌套类型

```proto
message SearchResponse {
  message Result {
    string url = 1;
    string title = 2;
    repeated string snippets = 3;
  }
  repeated Result results = 1;
}

message SomeOtherMessage {
  SearchResponse.Result result = 1;
}

message Outer {                  // Level 0
  message MiddleAA {  // Level 1
    message Inner {   // Level 2
      int64 ival = 1;
      bool  booly = 2;
    }
  }
  message MiddleBB {  // Level 1
    message Inner {   // Level 2
      int32 ival = 1;
      bool  booly = 2;
    }
  }
}
```

## 更新一个消息类型

```text
官方指南翻译

不要更改任何现有字段的字段编号.
如果添加新的字段, 仍然可以使用新生成的代码解析旧的 message 格式. 但应该自行处理新加字段的默认值.
使用新代码创建的 message 也可以被旧代码解析, 那些新字段会被忽略.

字段可以被删除, 只要不要复用那些字段编号. 要重命名字段, 可以给旧字段添加 OBSOLETE_ 前缀,
或者将字段编号设置为 reserved.

int32, uint32, int64, uint64, bool 是相互兼容的类型.
sint32 和 sint64 是相互兼容的, 但不兼容其他 int 类型.
string 和 bytes 可以是兼容的, 只要 bytes 是有效的 UTF-8.
嵌入的 message 可以和 bytes 兼容, 如果 bytes 包含 message 的编码后的版本.
fixed32 和 sfixed32 兼容, fixed64 和 sfixed64 兼容.
enum 在 wire 格式上兼容 int32, uint32, int64, uint64(如果值不合适会被截断). 当 message 被反序列化时,
客户端代码可以用不同的方式对待它们. 比如, 未识别的 proto3 的 enum 类型将会保存在 message 中, 但它如何

表示是语言特定的. int 字段总是会保留它的值.

将一个单个值更改为新 oneof 的成员是安全的且二进制兼容的. 移动多个字段到一个新的 oneof 可能是安全的,
如果你确保没有 code 被多次设置. 移动任何字段到一个已存在的 oneof 是不安全的.

```

## Any

```proto
// Any类型消息允许你在没有指定他们的.proto定义的情况下使用消息作为一个嵌套类型。一个Any类型包括一个可以被序列化bytes类型的任意消息，以及一个URL作为一个全局标识符和解析消息类型。为了使用Any类型，你需要导入import google/protobuf/any.proto。
import "google/protobuf/any.proto";
message ErrorStatus {
  string message = 1;
  repeated google.protobuf.Any details = 2;
}
```

## Map

```proto
map<key_type, value_type> map_field = N;
map<string, Project> projects = 3;

Map的字段可以是repeated。
序列化后的顺序和map迭代器的顺序是不确定的，所以你不要期望以固定顺序处理Map
当为.proto文件产生生成文本格式的时候，map会按照key 的顺序排序，数值化的key会按照数值排序。
从序列化中解析或者融合时，如果有重复的key则后一个key不会被使用，当从文本格式中解析map时，如果存在重复的key。
```

## Package

## 定义服务(Service)

```proto
service SearchService {
  rpc Search (SearchRequest) returns (SearchResponse);
}
```
