<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>cpp笔记</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">介绍</a></li><li class="chapter-item expanded "><a href="1. 学习/_index.html"><strong aria-hidden="true">1.</strong> 学习</a></li><li class="chapter-item expanded "><a href="2. 基础/_index.html"><strong aria-hidden="true">2.</strong> 基础</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="2. 基础/2.1 c++变量.html"><strong aria-hidden="true">2.1.</strong> 2.1 c++变量</a></li><li class="chapter-item expanded "><a href="2. 基础/2.2 数据类型.html"><strong aria-hidden="true">2.2.</strong> 2.2 数据类型</a></li><li class="chapter-item expanded "><a href="2. 基础/2.3 转义字符.html"><strong aria-hidden="true">2.3.</strong> 2.3 转义字符</a></li><li class="chapter-item expanded "><a href="2. 基础/2.4 运算符.html"><strong aria-hidden="true">2.4.</strong> 2.4 运算符</a></li><li class="chapter-item expanded "><a href="2. 基础/2.5 控制结构.html"><strong aria-hidden="true">2.5.</strong> 2.5 控制结构</a></li><li class="chapter-item expanded "><a href="2. 基础/2.6 Class.html"><strong aria-hidden="true">2.6.</strong> 2.6 Class</a></li><li class="chapter-item expanded "><a href="2. 基础/2.7 关键字.html"><strong aria-hidden="true">2.7.</strong> 2.7 关键字</a></li><li class="chapter-item expanded "><a href="2. 基础/2.8 函数模板.html"><strong aria-hidden="true">2.8.</strong> 2.8 函数模板</a></li><li class="chapter-item expanded "><a href="2. 基础/2.9 数据结构.html"><strong aria-hidden="true">2.9.</strong> 2.9 数据结构</a></li><li class="chapter-item expanded "><a href="2. 基础/2.10 预处理指令.html"><strong aria-hidden="true">2.10.</strong> 2.10 预处理指令</a></li><li class="chapter-item expanded "><a href="2. 基础/2.11 指针.html"><strong aria-hidden="true">2.11.</strong> 2.11 指针</a></li><li class="chapter-item expanded "><a href="2. 基础/2.12 结构体、共用体和位运算.html"><strong aria-hidden="true">2.12.</strong> 2.12 结构体、共用体和位运算</a></li></ol></li><li class="chapter-item expanded "><a href="3. 库函数/_index.html"><strong aria-hidden="true">3.</strong> 库函数</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/3.1 C标准库.html"><strong aria-hidden="true">3.1.</strong> 3.1 C标准库</a></li><li class="chapter-item expanded "><a href="3. 库函数/3.10 signal.html"><strong aria-hidden="true">3.2.</strong> 3.10 signal</a></li><li class="chapter-item expanded "><a href="3. 库函数/3.11 stdarg.html"><strong aria-hidden="true">3.3.</strong> 3.11 stdarg</a></li><li class="chapter-item expanded "><a href="3. 库函数/3.12 stddef.html"><strong aria-hidden="true">3.4.</strong> 3.12 stddef</a></li><li class="chapter-item expanded "><a href="3. 库函数/3.13 stdio.html"><strong aria-hidden="true">3.5.</strong> 3.13 stdio</a></li><li class="chapter-item expanded "><a href="3. 库函数/3.14 stdlib.html"><strong aria-hidden="true">3.6.</strong> 3.14 stdlib</a></li><li class="chapter-item expanded "><a href="3. 库函数/3.15 string.html"><strong aria-hidden="true">3.7.</strong> 3.15 string</a></li><li class="chapter-item expanded "><a href="3. 库函数/3.16 time.html"><strong aria-hidden="true">3.8.</strong> 3.16 time</a></li><li class="chapter-item expanded "><a href="3. 库函数/3.17 printf.html"><strong aria-hidden="true">3.9.</strong> 3.17 printf</a></li><li class="chapter-item expanded "><a href="3. 库函数/3.18 文件操作.html"><strong aria-hidden="true">3.10.</strong> 3.18 文件操作</a></li><li class="chapter-item expanded "><a href="3. 库函数/3.18 文件读写函数.html"><strong aria-hidden="true">3.11.</strong> 3.18 文件读写函数</a></li><li class="chapter-item expanded "><a href="3. 库函数/3.2 sstream.html"><strong aria-hidden="true">3.12.</strong> 3.2 sstream</a></li><li class="chapter-item expanded "><a href="3. 库函数/3.3 assert.html"><strong aria-hidden="true">3.13.</strong> 3.3 assert</a></li><li class="chapter-item expanded "><a href="3. 库函数/3.4 ctype.html"><strong aria-hidden="true">3.14.</strong> 3.4 ctype</a></li><li class="chapter-item expanded "><a href="3. 库函数/3.5 float.html"><strong aria-hidden="true">3.15.</strong> 3.5 float</a></li><li class="chapter-item expanded "><a href="3. 库函数/3.6 limits.html"><strong aria-hidden="true">3.16.</strong> 3.6 limits</a></li><li class="chapter-item expanded "><a href="3. 库函数/3.7 locale.html"><strong aria-hidden="true">3.17.</strong> 3.7 locale</a></li><li class="chapter-item expanded "><a href="3. 库函数/3.8 math.html"><strong aria-hidden="true">3.18.</strong> 3.8 math</a></li><li class="chapter-item expanded "><a href="3. 库函数/3.9 setjmp.html"><strong aria-hidden="true">3.19.</strong> 3.9 setjmp</a></li></ol></li><li class="chapter-item expanded "><a href="4. 内置工具/_index.html"><strong aria-hidden="true">4.</strong> 内置工具</a></li><li class="chapter-item expanded "><a href="5. 进阶/_index.html"><strong aria-hidden="true">5.</strong> 进阶</a></li><li class="chapter-item expanded "><a href="6. 项目/_index.html"><strong aria-hidden="true">6.</strong> 项目</a></li><li class="chapter-item expanded "><a href="7. 项目研究/_index.html"><strong aria-hidden="true">7.</strong> 项目研究</a></li><li class="chapter-item expanded "><a href="8. 资料整理/_index.html"><strong aria-hidden="true">8.</strong> 资料整理</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">cpp笔记</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/yujian1018/yujian1018.github.io/tree/master/cpp" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>好记性不如烂笔头 c-cpp笔记</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="c"><a class="header" href="#c">c++</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h3 id="c-1"><a class="header" href="#c-1">c++</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h2 id="变量"><a class="header" href="#变量">变量</a></h2>
<p>标识（Identifiers）
有效标识由
字母(letter)，
数字(digits)和
下划线 ( _ )组成。
标识的长度没有限制，但是有些编译器只取前32个字符（剩下的字符会被忽略）。</p>
<p>空格(spaces)，标点(punctuation marks)和符号(symbols) 都不可以出现在标识中。
只有字母(letters)，数字(digits) 和下划线(<em>)是合法的。并且变量标识必须以字母开头。标识也可能以下划线（</em>）开头，但这种标识通常是保留给为外部连接用的。标识不可以以数字开头。</p>
<p>必须注意的另一条规则是当你给变量起名字时不可以和C++语言的关键字或你所使用的编译器的特殊关键字同名，因为这样与这些关键字产生混淆。</p>
<p>标准保留关键字</p>
<pre><code class="language-c++">asm, auto, bool, break, case, catch, char, class, const, const_cast, continue, default, delete, do, double, dynamic_cast, else, enum, explicit, extern, false, float, for, friend, goto, if, inline, int, long, mutable, namespace, new, operator, private, protected, public, register, reinterpret_cast, return, short, signed, sizeof, static, static_cast, struct, switch, template, this, throw, true, try, typedef, typeid, typename, union, unsigned, using, virtual, void, volatile, wchar_t, while

and, and_eq, bitand, bitor, compl, not, not_eq, or, or_eq, xor, xor_eq
</code></pre>
<p>栈。变量，局部变量，参数变量
堆。new delete
自由存储区 用户主动申请的malloc
全局/静态存储区  全局变量，静态变量
常量存储区。 定义的常量</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="数据类型"><a class="header" href="#数据类型">数据类型</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">名称</th><th style="text-align: left">字节数</th><th style="text-align: left">描述</th><th style="text-align: left">范围</th></tr></thead><tbody>
<tr><td style="text-align: left">Char</td><td style="text-align: left">1</td><td style="text-align: left">字符（character）或整数（integer ）， 8位（bits）长</td><td style="text-align: left">有符号（signed）: -128 到 127<br>  无符号（unsigned）: 0 到 255</td></tr>
<tr><td style="text-align: left">short int (short)</td><td style="text-align: left">2</td><td style="text-align: left">短整数（integer ）16位（bits）长</td><td style="text-align: left">有符号（signed）: -32768 到 32767 <br>  无符号（unsigned）: 0 到 65535</td></tr>
<tr><td style="text-align: left">long int (long)</td><td style="text-align: left">4</td><td style="text-align: left">长整数（integer ）32位（bits）长</td><td style="text-align: left">有符号（signed）:-2147483648 到 2147483647 <br> 无符号（unsigned）: 0 到 4294967295</td></tr>
<tr><td style="text-align: left">int</td><td style="text-align: left">4</td><td style="text-align: left">整数（integer）</td><td style="text-align: left">有符号(signed): -2147483648 到 2147483647 <br> 无符号（unsigned): 0 到 4294967295</td></tr>
<tr><td style="text-align: left">float</td><td style="text-align: left">4</td><td style="text-align: left">浮点数（floating point number）</td><td style="text-align: left">3.4e + / - 38 （7 个数字（7digits））</td></tr>
<tr><td style="text-align: left">double</td><td style="text-align: left">8</td><td style="text-align: left">双精度浮点数（double precision floating point number）</td><td style="text-align: left">1.7e + / - 308 (15 digits)</td></tr>
<tr><td style="text-align: left">long double</td><td style="text-align: left">8</td><td style="text-align: left">长双精度浮点数（long double precision floating point number）</td><td style="text-align: left">1.7e + / - 308 (15 digits)</td></tr>
<tr><td style="text-align: left">bool</td><td style="text-align: left">1</td><td style="text-align: left">布尔Boolean值。它只能是真(true)或假(false)两值之一。</td><td style="text-align: left">true 或 false</td></tr>
<tr><td style="text-align: left">wchar_t</td><td style="text-align: left">2</td><td style="text-align: left">宽字符(Wide character) 。这是为存储两字节(2 bytes) 长的国际字符而设计的类型。</td><td style="text-align: left">一个宽字符（1 wide characters） <br> * 字节数一列和范围一列可能根据程序编译和运行的系统不同而有所不同。<br> 这里列出的数值是多数32位系统的常用数据。<br> 对于其他系统，通常的说法是整型(int)具有根据系统结构建议的自然长度（即一个字one word的长度），而4中整型数据char, short, int, long的长度必须是递增的，也就是说按顺序每一类型必须大于等于其前面一个类型的长度。<br> 同样的规则也适用于浮点数类型float, double和 long double，也是按递增顺序。</td></tr>
</tbody></table>
</div>
<p>除以上列出的基本数据类型外，还有指针（pointer）和void 参数表示类型，我们将在后面看到。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">说明</th><th style="text-align: left">字符型</th><th style="text-align: left">短整型</th><th style="text-align: left">整型</th><th style="text-align: left">长整型</th><th style="text-align: left">单精度浮点型</th><th style="text-align: left">双精度浮点型</th><th style="text-align: left">无类型</th></tr></thead><tbody>
<tr><td style="text-align: left">数据类型</td><td style="text-align: left">char</td><td style="text-align: left">short</td><td style="text-align: left">int</td><td style="text-align: left">long</td><td style="text-align: left">float</td><td style="text-align: left">double</td><td style="text-align: left">void</td></tr>
</tbody></table>
</div>
<p>在32位环境中，各种数据类型的长度一般如下：</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">说明</th><th style="text-align: left">字符型</th><th style="text-align: left">短整型</th><th style="text-align: left">整型</th><th style="text-align: left">长整型</th><th style="text-align: left">单精度浮点型</th><th style="text-align: left">双精度浮点型</th></tr></thead><tbody>
<tr><td style="text-align: left">数据类型</td><td style="text-align: left">char</td><td style="text-align: left">short</td><td style="text-align: left">int</td><td style="text-align: left">long</td><td style="text-align: left">float</td><td style="text-align: left">double</td></tr>
<tr><td style="text-align: left">长度</td><td style="text-align: left">1</td><td style="text-align: left">2</td><td style="text-align: left">4</td><td style="text-align: left">4</td><td style="text-align: left">4</td><td style="text-align: left">8</td></tr>
</tbody></table>
</div>
<h2 id="整数"><a class="header" href="#整数">整数</a></h2>
<pre><code>int 称为整型，short 称为短整型，long 称为长整型，它们的长度（所占字节数）关系为：
short &lt;= int &lt;= long
它们具体占用几个字节C语言并没有规定，C语言只做了宽泛的限制：
short 至少占用2个字节。
int 建议为一个机器字长。32位环境下机器字长为4字节，64位环境下机器字长为8字节。
short 的长度不能大于 int，long 的长度不能小于 int。
在64位环境下，不同的操作系统会有不同的结果，如下所示（长度以字节计）：
</code></pre>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">操作系统</th><th style="text-align: left">short</th><th style="text-align: left">int</th><th style="text-align: left">long</th></tr></thead><tbody>
<tr><td style="text-align: left">Win64</td><td style="text-align: left">2</td><td style="text-align: left">4</td><td style="text-align: left">4</td></tr>
<tr><td style="text-align: left">类Unix系统（包括 Unix、Linux、OS X、BSD、Solaris 等）</td><td style="text-align: left">2</td><td style="text-align: left">4</td><td style="text-align: left">8</td></tr>
</tbody></table>
</div>
<pre><code>int a_length = sizeof a;
int b_length = sizeof(int);

unsigned 定义无符号，不设置符号位

十进制数由 0~9 十个数字组成，没有前缀. 237、-568、65535、1627
进制数由 0~7 八个数字组成，必须以0开头，即以0作为八进制数的前缀。015（十进制为13）、-0101（十进制为-65）、0177777（十进制为65535）
十六进制数由数字0~9、字母A~F或a~f组成，前缀为0X或0x。0X2A（十进制为42）、-0XA0（十进制为-160)、0xffff（十进制为65535）

可以用后缀L或l来表示长整型数.
十进制长整型数：158L、358000L
八进制长整型数：012L、077L、0200000L
十六进制长整型数：0X15L (十进制为21)、0XA5L、0X10000L

可以用后缀U或u来表示无符号数，例如 358u、0x38Au等
</code></pre>
<h2 id="浮点数"><a class="header" href="#浮点数">浮点数</a></h2>
<pre><code>float 称为单精度浮点数，double 称为双精度浮点数。不像整数，小数的长度始终是固定的，float 占用4个字节，double 占用8个字节

将整数赋值给 float 变量时会转换为小数

float b=0.302f;
小数默认为 double 类型，加上后缀f才是float类型。
</code></pre>
<h2 id="字符"><a class="header" href="#字符">字符</a></h2>
<pre><code>char 称为字符类型，只能用单引号' '来包围，不能用双引号&quot; &quot;包围。
而字符串只能用双引号&quot; &quot;包围，不能用单引号' '包围。
</code></pre>
<h2 id="数据类型转换"><a class="header" href="#数据类型转换">数据类型转换</a></h2>
<pre><code>数据类型转换就是将数据（变量、表达式的结果）从一种类型转换到另一种类型。例如，为了保存小数你可以将int类型的变量转换为double类型。

数据类型转换的一般格式为：
(type_name) expression
type_name为要转换到的数据类型，expression为表达式。

类型转换运算符( )的优先级高于/
(double) sum / count会先将 sum 转换为 double 类型，然后再进行除法运算。如果写作(double) (sum / count)，那么运行结果就是 3.000000

这种由程序员显式进行的转换称为强制类型转换。
除了强制类型转换，在不同数据类型的混合运算中编译器也会隐式地进行数据类型转换，称为自动类型转换。

自动类型转换遵循下面的规则：
1.若参与运算的数据类型不同，则先转换成同一类型，然后进行运算。
2.转换按数据长度增加的方向进行，以保证精度不降低。例如int型和long型运算时，先把int量转成long型后再进行运算。
3.所有的浮点运算都是以双精度进行的，即使仅含float单精度量运算的表达式，也要先转换成double型，再作运算。
4.Char型和short型参与运算时，必须先转换成int型。
5.在赋值运算中，赋值号两边的数据类型不同时，需要把右边表达式的类型将转换为左边变量的类型。如果右边表达式的数据类型长度比左边长时，将丢失一部分数据，这样会降低精度。
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="转义字符"><a class="header" href="#转义字符">转义字符</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">符号</th><th style="text-align: left">描述</th><th style="text-align: left">ASCII码值（十进制）</th></tr></thead><tbody>
<tr><td style="text-align: left">\n</td><td style="text-align: left">换行(LF) ，将当前位置移到下一行开头</td><td style="text-align: left">010</td></tr>
<tr><td style="text-align: left">\r</td><td style="text-align: left">回车(CR) ，将当前位置移到本行开头</td><td style="text-align: left">013</td></tr>
<tr><td style="text-align: left">\t</td><td style="text-align: left">水平制表(HT) （跳到下一个TAB位置）</td><td style="text-align: left">009</td></tr>
<tr><td style="text-align: left">\v</td><td style="text-align: left">垂直制表(VT)</td><td style="text-align: left">011</td></tr>
<tr><td style="text-align: left">\b</td><td style="text-align: left">backspace 退格(BS) ，将当前位置移到前一列</td><td style="text-align: left">008</td></tr>
<tr><td style="text-align: left">\f</td><td style="text-align: left">page feed 换页(FF)，将当前位置移到下页开头</td><td style="text-align: left">012</td></tr>
<tr><td style="text-align: left">\a</td><td style="text-align: left">响铃(BEL) 警告alert (beep)</td><td style="text-align: left">007</td></tr>
<tr><td style="text-align: left">'</td><td style="text-align: left">单引号single quotes (')</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">&quot;</td><td style="text-align: left">双引号double quotes (&quot;)</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">?</td><td style="text-align: left">问号question (?)</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">\</td><td style="text-align: left">反斜杠inverted slash ()</td><td style="text-align: left"></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h2 id="运算符"><a class="header" href="#运算符">运算符</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">优先级</th><th style="text-align: left">运算符</th><th style="text-align: left">名称或含义</th><th style="text-align: left">使用形式</th><th style="text-align: left">结合方向</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left">1</td><td style="text-align: left">[]</td><td style="text-align: left">数组下标</td><td style="text-align: left">数组名[常量表达式]</td><td style="text-align: left">左到右</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left">()</td><td style="text-align: left">圆括号</td><td style="text-align: left">（表达式）/函数名(</td><td style="text-align: left">形参表)</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left">.</td><td style="text-align: left">成员选择（对象）</td><td style="text-align: left">对象.成员名</td><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left">-&gt;</td><td style="text-align: left">成员选择（指针）</td><td style="text-align: left">对象指针-&gt;</td><td style="text-align: left">成员名</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">2</td><td style="text-align: left">-</td><td style="text-align: left">负号运算符</td><td style="text-align: left">-表达式</td><td style="text-align: left">右到左</td><td style="text-align: left">单目运算符</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left">(类型)</td><td style="text-align: left">强制类型转换</td><td style="text-align: left">(数据类型)表达式</td><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left">++</td><td style="text-align: left">自增运算符</td><td style="text-align: left">++变量名/变量名++</td><td style="text-align: left"></td><td style="text-align: left">单目运算符</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left">--</td><td style="text-align: left">自减运算符</td><td style="text-align: left">--变量名/变量名--</td><td style="text-align: left"></td><td style="text-align: left">单目运算符</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left">*</td><td style="text-align: left">取值运算符</td><td style="text-align: left">*指针变量</td><td style="text-align: left"></td><td style="text-align: left">单目运算符</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left">&amp;</td><td style="text-align: left">取地址运算符</td><td style="text-align: left">&amp;变量名</td><td style="text-align: left"></td><td style="text-align: left">单目运算符</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left">!</td><td style="text-align: left">逻辑非运算符</td><td style="text-align: left">!表达式</td><td style="text-align: left"></td><td style="text-align: left">单目运算符</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left">~</td><td style="text-align: left">按位取反运算符</td><td style="text-align: left">~表达式</td><td style="text-align: left"></td><td style="text-align: left">单目运算符</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left">sizeof</td><td style="text-align: left">长度运算符</td><td style="text-align: left">sizeof(表达式)</td><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">3</td><td style="text-align: left">/</td><td style="text-align: left">除</td><td style="text-align: left">表达式/表达式</td><td style="text-align: left">左到右</td><td style="text-align: left">双目运算符</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left">*</td><td style="text-align: left">乘</td><td style="text-align: left">表达式*表达式</td><td style="text-align: left"></td><td style="text-align: left">双目运算符</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left">%</td><td style="text-align: left">余数（取模）</td><td style="text-align: left">整型表达式/整型表达式</td><td style="text-align: left"></td><td style="text-align: left">双目运算符</td></tr>
<tr><td style="text-align: left">4</td><td style="text-align: left">+</td><td style="text-align: left">加</td><td style="text-align: left">表达式+表达式</td><td style="text-align: left">左到右</td><td style="text-align: left">双目运算符</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left">-</td><td style="text-align: left">减</td><td style="text-align: left">表达式-表达式</td><td style="text-align: left"></td><td style="text-align: left">双目运算符</td></tr>
<tr><td style="text-align: left">5</td><td style="text-align: left">&lt;&lt;</td><td style="text-align: left">左移</td><td style="text-align: left">变量&lt;&lt;表达式</td><td style="text-align: left">左到右</td><td style="text-align: left">双目运算符</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left">&gt;&gt;</td><td style="text-align: left">右移</td><td style="text-align: left">变量&gt;&gt;表达式</td><td style="text-align: left"></td><td style="text-align: left">双目运算符</td></tr>
<tr><td style="text-align: left">6</td><td style="text-align: left">&gt;</td><td style="text-align: left">大于</td><td style="text-align: left">表达式&gt;表达式</td><td style="text-align: left">左到右</td><td style="text-align: left">双目运算符</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left">&gt;=</td><td style="text-align: left">大于等于</td><td style="text-align: left">表达式&gt;=表达式</td><td style="text-align: left"></td><td style="text-align: left">双目运算符</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left">&lt;</td><td style="text-align: left">小于</td><td style="text-align: left">表达式&lt;表达式</td><td style="text-align: left"></td><td style="text-align: left">双目运算符</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left">&lt;=</td><td style="text-align: left">小于等于</td><td style="text-align: left">表达式&lt;=表达式</td><td style="text-align: left"></td><td style="text-align: left">双目运算符</td></tr>
<tr><td style="text-align: left">7</td><td style="text-align: left">==</td><td style="text-align: left">等于</td><td style="text-align: left">表达式==表达式</td><td style="text-align: left">左到右</td><td style="text-align: left">双目运算符</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left">!=</td><td style="text-align: left">不等于</td><td style="text-align: left">表达式!= 表达式</td><td style="text-align: left"></td><td style="text-align: left">双目运算符</td></tr>
<tr><td style="text-align: left">8</td><td style="text-align: left">&amp;</td><td style="text-align: left">按位与</td><td style="text-align: left">表达式&amp;表达式</td><td style="text-align: left">左到右</td><td style="text-align: left">双目运算符</td></tr>
<tr><td style="text-align: left">9</td><td style="text-align: left">^</td><td style="text-align: left">按位异或</td><td style="text-align: left">表达式^表达式</td><td style="text-align: left">左到右</td><td style="text-align: left">双目运算符</td></tr>
<tr><td style="text-align: left">10</td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left">按位或</td><td style="text-align: left">表达式</td><td style="text-align: left">表达式</td></tr>
<tr><td style="text-align: left">11</td><td style="text-align: left">&amp;&amp;</td><td style="text-align: left">逻辑与</td><td style="text-align: left">表达式&amp;&amp;表达式</td><td style="text-align: left">左到右</td><td style="text-align: left">双目运算符</td></tr>
<tr><td style="text-align: left">12</td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left">逻辑或</td><td style="text-align: left">表达式</td></tr>
<tr><td style="text-align: left">13</td><td style="text-align: left">?:</td><td style="text-align: left">条件运算符</td><td style="text-align: left">表达式1? 表达式2: 表达式3</td><td style="text-align: left">右到左</td><td style="text-align: left">三目运算符</td></tr>
<tr><td style="text-align: left">14</td><td style="text-align: left">=</td><td style="text-align: left">赋值运算符</td><td style="text-align: left">变量=表达式</td><td style="text-align: left">右到左</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left">/=</td><td style="text-align: left">除后赋值</td><td style="text-align: left">变量/=表达式</td><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left">*=</td><td style="text-align: left">乘后赋值</td><td style="text-align: left">变量*=表达式</td><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left">%=</td><td style="text-align: left">取模后赋值</td><td style="text-align: left">变量%=表达式</td><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left">+=</td><td style="text-align: left">加后赋值</td><td style="text-align: left">变量+=表达式</td><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left">-=</td><td style="text-align: left">减后赋值</td><td style="text-align: left">变量-=表达式</td><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left">&lt;&lt;=</td><td style="text-align: left">左移后赋值</td><td style="text-align: left">变量&lt;&lt;=表达式</td><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left">&gt;&gt;=</td><td style="text-align: left">右移后赋值</td><td style="text-align: left">变量&gt;&gt;=表达式</td><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left">&amp;=</td><td style="text-align: left">按位与后赋值</td><td style="text-align: left">变量&amp;=表达式</td><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left">^=</td><td style="text-align: left">按位异或后赋值</td><td style="text-align: left">变量^=表达式</td><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left">|=</td><td style="text-align: left">按位或后赋值</td><td style="text-align: left">变量|=表达式</td><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">15</td><td style="text-align: left">,</td><td style="text-align: left">逗号运算符</td><td style="text-align: left">表达式,表达式,…</td><td style="text-align: left">左到右</td><td style="text-align: left">从左向右顺序运算</td></tr>
</tbody></table>
</div>
<pre><code class="language-c++">赋值Assignation (=)

数学运算符Arithmetic operators ( +, -, *, /, % )

+ 加addition

- 减subtraction

* 乘multiplication

/ 除division

% 取模module

组合运算符Compound assignation operators (+=, -=, *=, /=, %=, &gt;&gt;=, &lt;&lt;=, &amp;=, ^=, |=)

递增和递减Increase and decrease

关系运算符Relational operators ( ==, !=, &gt;, &lt;, &gt;=, &lt;= )
== 相等Equal
!= 不等Different
&gt; 大于Greater than
&lt; 小于Less than
&gt;= 大于等于Greater or equal than
&lt;= 小于等于Less or equal than

逻辑运算符Logic operators ( !, &amp;&amp;, || )
运算符 ! 等同于boolean 运算NOT （取非），它只有一个操作数(operand)，写在它的右边。它做的唯一工作就是取该操作数的反面值，也就是说如果操作数值为真true，那么运算后值变为假false，如果操作数值为假false，则运算结果为真true。它就好像是说取与操作数相反的值。

逗号运算符

位运算符Bitwise Operators ( &amp;, |, ^, ~, &lt;&lt;, &gt;&gt; )

变量类型转换运算符Explicit type casting operators

sizeof()

其它运算符

在本教程后面的章节里我们将看到更多的运算符，比如指向指针的运算或面向对象编程特有的运算，等等

运算符的优先度 Precedence of operators
</code></pre>
<h2 id="运算符重载"><a class="header" href="#运算符重载">运算符重载</a></h2>
<pre><code class="language-c++">operator+(const complex &amp; A)const

1) 首先，并不是所有的运算符都可以重载。能够重载的运算符包括：
+  -  *  /  %  ^  &amp;  |  ~  !  =  &lt;  &gt;  +=  -=  *=  /=  %=  ^=  &amp;=  |=
&lt;&lt;  &gt;&gt;  &lt;&lt;=  &gt;&gt;=  ==  !=  &lt;=  &gt;=  &amp;&amp;  ||  ++  --  ,  -&gt;*  -&gt;  ()  []
new  new[]  delete  delete[]

上述操作符中，[] 是下标操作符，() 是函数调用操作符。自增自减操作符的前置和后置形式都可以重载。长度运算符”sizeof“、条件运算符”: ?“、成员选择符”.“、对象选择符”.*“和域解析操作符”::“不能被重载。

2) 重载不能改变运算符的优先级和结合性

c4 = c1 + c2 * c3;语句等同于c4 = c1 + ( c2 * c3 )

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="控制结构"><a class="header" href="#控制结构">控制结构</a></h2>
<h3 id="1if"><a class="header" href="#1if">1.if</a></h3>
<pre><code class="language-c++">if(true){

}else if(true){

}else{

}
</code></pre>
<h3 id="2switch"><a class="header" href="#2switch">2.switch</a></h3>
<pre><code class="language-c++">int switch_on = 1;
switch(switch_on){
    case 1:
        printf(&quot;this case is 1\n&quot;);
        break;
    default:
        break;
}
</code></pre>
<h3 id="3for"><a class="header" href="#3for">3.for</a></h3>
<pre><code class="language-c++">for(int i=0; i&lt;=100; i++&gt;){
    printf(&quot;i:%d!\n&quot;, i);
}

int i;
for(i=0; i&lt;=0; i-=10000){
    printf(&quot;i:%d!\n&quot;, i);
}
return 0;
</code></pre>
<h3 id="4while"><a class="header" href="#4while">4.while</a></h3>
<pre><code class="language-c++">int m = 0;
while(m &lt;100&gt;){
    m++;
}

#include &lt;iostream.h&gt;
int main ()
{
int n;
cout &lt;&lt; &quot;Enter the starting number &gt; &quot;;
cin &gt;&gt; n;
while (n&gt;0) {
cout &lt;&lt; n &lt;&lt; &quot;, &quot;;
--n;
}
cout &lt;&lt; &quot;FIRE!&quot;;
return 0;
}
</code></pre>
<h3 id="do-while"><a class="header" href="#do-while">do while</a></h3>
<pre><code>do-while循环与while循环的不同在于：它会先执行循环体，然后再判断表达式是否为真，如果为真则继续循环；如果为假，则终止循环。因此，do-while 循环至少要执行一次循环体。
</code></pre>
<pre><code class="language-c++">
do{
    语句块
}while(表达式);

int i=1, sum=0;
do{
 sum+=i;
 i++;
}while(i&lt;=100);
printf(&quot;%d\n&quot;, sum);
return 0;
</code></pre>
<h3 id="5break"><a class="header" href="#5break">5.break</a></h3>
<pre><code>break与continue的对比：break 用来结束所有循环，循环语句不再有执行的机会；continue 用来结束本次循环，直接跳到下一次循环，如果循环条件成立，还会继续循环。
</code></pre>
<p>条件结构Conditional structure: if and else</p>
<p>重复结构 Iteration structures 或循环loops</p>
<p>while (表达式expression) 语句statement</p>
<p>do 语句statement while (条件condition);</p>
<p>它的功能与while 循环一抹一样，除了在do-while循环中是先执行statement 然后才检查条件condition ，而不想while循环中先检查条件然后才执行statement。这样，即使条件condition从来没有被满足过，statement 仍至少被执行一次。例如，下面的程序重复输出（echoes）用户输入的任何数值，直到用户输入0为止</p>
<pre><code class="language-c++"># include &lt;iostream.h&gt;

int main ()

{

unsigned long n;

do {

cout &lt;&lt; &quot;Enter number (0 to end): &quot;;

cin &gt;&gt; n;

cout &lt;&lt; &quot;You entered: &quot; &lt;&lt; n &lt;&lt; &quot;\n&quot;;

} while (n != 0);

return 0;

}
</code></pre>
<p>for (initialization; condition; increase) statement;</p>
<p>分支控制和跳转(Bifurcation of control and jumps)</p>
<p>break 语句</p>
<p>通过使用break语句，即使在结束条件没有满足的情况下，我们也可以跳出一个循环。它可以被用来结束一个无限循环（infinite loop），或强迫循环在其自然结束之前结束。例如，我们想要在倒计数自然结束之前强迫它停止（也许因为一个引擎故障）</p>
<p>continue 语句</p>
<p>continue语句使得程序跳过当前循环中剩下的部分而直接进入下一次循环，就好像循环中语句块的结尾已经到了使得循环进入下一次重复。</p>
<p>goto 语句</p>
<p>通过使用goto语句可以使程序从一点跳转到另外一点。你必须谨慎只用这条语句，因为它的执行可以忽略任何嵌套限制。</p>
<p>exit 函数</p>
<p>exit是一个在cstdlib (stdlib.h)库中定义的函数。</p>
<p>exit的目的是一个特定的退出代码来结束程序的运行</p>
<p>选择结构The selective Structure: switch</p>
<p>switch 语句的语法比较特殊。它的目标是对一个表达式检查多个可能常量值，有些像我们在本节开头学习的把几个if 和else if 语句连接起来的结构。</p>
<h3 id="异常"><a class="header" href="#异常">异常</a></h3>
<pre><code class="language-c++">Try{}
Catch(exception e){
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="class"><a class="header" href="#class">Class</a></h2>
<h3 id="构造函数"><a class="header" href="#构造函数">构造函数</a></h3>
<p>构造函数的参数初始化表</p>
<h3 id="析构函数"><a class="header" href="#析构函数">析构函数</a></h3>
<h3 id="this指针详解"><a class="header" href="#this指针详解">this指针详解</a></h3>
<h3 id="静态成员变量和静态成员函数"><a class="header" href="#静态成员变量和静态成员函数">静态成员变量和静态成员函数</a></h3>
<p>一般情况下，如果有N个同类的对象，那么每一个对象都分别有自己的成员变量，不同对象的成员变量各自有值，互不相干。但是有时我们希望有某一个或几个成员变量为所有对象共有，这样可以实现数据共享。</p>
<p>可以使用全局变量来达到共享数据的目的。例如在一个程序文件中有多个函数，每一个函数都可以改变全局变量的值，全局变量的值为各函数共享。但是用全局变量的安全性得不到保证，由于在各处都可以自由地修改全局变量的值，很有可能偶然失误，全局变量的值就被修改，导致程序的失败。因此在实际开发中很少使用全局变量。</p>
<p>如果想在同类的多个对象之间实现数据共享，也不要用全局变量，那么可以使用静态成员变量。</p>
<p>初始化实例时，填写静态变量改变规则</p>
<pre><code class="language-c++">class Student{
private:
    char *name;
    int age;
    float score;
    static int num;  //将num定义为静态成员变量
public:
    Student(char *, int, float);
    void say();
};
</code></pre>
<h3 id="继承"><a class="header" href="#继承">继承</a></h3>
<p>权限，继承方式
派生类的构造和析构函数
名字遮蔽
多继承</p>
<h3 id="虚基类"><a class="header" href="#虚基类">虚基类</a></h3>
<p>virtual</p>
<h3 id="基类和派生类的赋值"><a class="header" href="#基类和派生类的赋值">基类和派生类的赋值</a></h3>
<p>注意指针对象</p>
<h3 id="虚析构函数"><a class="header" href="#虚析构函数">虚析构函数</a></h3>
<p>注意内存回收</p>
<h3 id="纯虚函数和抽象类"><a class="header" href="#纯虚函数和抽象类">纯虚函数和抽象类</a></h3>
<p>纯虚函数没有函数体，只有函数声明，在虚函数声明结尾加上=0，表明此函数为纯虚函数。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="关键字"><a class="header" href="#关键字">关键字</a></h2>
<h3 id="const"><a class="header" href="#const">const</a></h3>
<p>在类中，如果你不希望某些数据被修改，可以借助 const 关键字加以限定。const 可以用来修饰成员变量、成员函数、对象以及对象的引用。</p>
<h3 id="virtual"><a class="header" href="#virtual">virtual</a></h3>
<p>虚基类</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">关键字</th><th style="text-align: left">说明</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: left">#define</td><td style="text-align: left">宏定义，末尾没有分号结尾</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">&amp;</td><td style="text-align: left">地址符&amp;，用以获得变量的地址</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">*</td><td style="text-align: left">指针运算符（或称“间接访问” 运算符）</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">auto</td><td style="text-align: left">声明自动变量</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">short</td><td style="text-align: left">声明短整型变量或函数</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">int</td><td style="text-align: left">声明整型变量或函数</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">long</td><td style="text-align: left">声明长整型变量或函数</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">float</td><td style="text-align: left">声明浮点型变量或函数</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">double</td><td style="text-align: left">声明双精度变量或函数</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">char</td><td style="text-align: left">声明字符型变量或函数</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">struct</td><td style="text-align: left">声明结构体变量或函数</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">union</td><td style="text-align: left">声明共用数据类型</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">enum</td><td style="text-align: left">声明枚举类型</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">typedef</td><td style="text-align: left">用以给数据类型取别名</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">const</td><td style="text-align: left">声明只读变量</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">unsigned</td><td style="text-align: left">声明无符号类型变量或函数</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">signed</td><td style="text-align: left">声明有符号类型变量或函数</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">extern</td><td style="text-align: left">声明变量是在其他文件正声明</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">register</td><td style="text-align: left">声明寄存器变量</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">static</td><td style="text-align: left">声明静态变量</td><td style="text-align: left">首先static的最主要功能是隐藏，其次因为static变量存放在静态存储区，所以它具备持久性和默认值0。</td></tr>
<tr><td style="text-align: left">volatile</td><td style="text-align: left">说明变量在程序执行中可被隐含地改变</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">void</td><td style="text-align: left">声明函数无返回值或无参数，声明无类型指针</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">if</td><td style="text-align: left">条件语句</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">else</td><td style="text-align: left">条件语句否定分支（与 if 连用）</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">switch</td><td style="text-align: left">用于开关语句</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">case</td><td style="text-align: left">开关语句分支</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">for</td><td style="text-align: left">一种循环语句</td><td style="text-align: left">for(int i = 0; i&lt;300; i++){}</td></tr>
<tr><td style="text-align: left">do</td><td style="text-align: left">循环语句的循环体</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">while</td><td style="text-align: left">循环语句的循环条件</td><td style="text-align: left">while(condition){}</td></tr>
<tr><td style="text-align: left">goto</td><td style="text-align: left">无条件跳转语句</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">continue</td><td style="text-align: left">结束当前循环，开始下一轮循环</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">break</td><td style="text-align: left">跳出当前循环,完全跳出循环，不再往下执行，执行循环体外面的代码</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">default</td><td style="text-align: left">开关语句中的“其他”分支</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">sizeof</td><td style="text-align: left">计算数据类型长度</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">return</td><td style="text-align: left">子程序返回语句（可以带参数，也可不带参数）循环条件</td><td style="text-align: left"></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><pre><code class="language-c++">template&lt;typename T&gt;
T max(T a, T b, T c) {
    if (a &gt; b) a = b;
    if (a &gt; c) a = c;
    return a;
}

int main() {
    cout &lt;&lt; max(10, 11, 12) &lt;&lt; endl;
    return 0;
}

模板类

#include &lt;iostream&gt;

using namespace std;

template&lt;typename M, typename N&gt;
class point {
private:
    M x;
    N y;
public:
    point() : x(0), y(0) {}

    point(M x, N y) : x(x), y(y) {}

    void set_xy(M x, N y);

    M get_x();

    N get_y();
};

template&lt;typename M, typename N&gt;
void point&lt;M, N&gt;::set_xy(M x, N y) {
    this-&gt;x = x;
    this-&gt;y = y;
}

template&lt;typename M, typename N&gt;
M point&lt;M, N&gt;::get_x() {
    return x;
}
int main() {
    point&lt;int, float &gt; p(10, 12.3);
     Point&lt;float, float&gt; *p = new Point&lt;float, int&gt;(10.6, 109);
    cout &lt;&lt; p.get_x() &lt;&lt; endl;
    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="array"><a class="header" href="#array">Array</a></h2>
<pre><code>int a[10]={12, 19, 22 , 993, 344}; 
int a[10] = {0};
char c[10] = {0};
float f[10] = {0};

float level[2], sum; 
    定义一个两个参数的数组，并且参数只能是float型 

C语言规定，数组名就代表了该数组的地址。
C语言还规定，数组名所代表的地址为第0个元素的地址，例如char c[10];，c就代表c[0]的地址。第0个元素的地址就是数组的起始地址，称为首地址。也就是说，数组名表示数组的首地址。

数组的定义格式为：
type arrayName[length]
type 为数据类型，arrayName 为数组名，length 为数组长度。 需要注意的是：
在不支持C99的编译器中，length 必须是一个数值常量，不能是变量，例如 VC6.0、VS2010 等；在支持C99的编译器中，length 还可以是变量，例如 C-Free 5.0、GCC等。
数组在内存中占用一段连续的空间，数组名表示的是这段内存空间的首地址。

2) 访问数组中某个元素的格式为：
arrayName[index]
index 为数组下标。注意 index 的值必须大于等于零，并且小于数组长度，否则会发生数组越界，出现意想不到的错误。
</code></pre>
<h2 id="2变元向量"><a class="header" href="#2变元向量">2.变元向量</a></h2>
<pre><code>argv[] 
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="预处理指令"><a class="header" href="#预处理指令">预处理指令</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">指令</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left">#</td><td style="text-align: left">空指令，无任何效果</td></tr>
<tr><td style="text-align: left">#include</td><td style="text-align: left">包含一个源代码文件</td></tr>
<tr><td style="text-align: left">#define</td><td style="text-align: left">定义宏</td></tr>
<tr><td style="text-align: left">#undef</td><td style="text-align: left">取消已定义的宏</td></tr>
<tr><td style="text-align: left">#if</td><td style="text-align: left">如果给定条件为真，则编译下面代码</td></tr>
<tr><td style="text-align: left">#ifdef</td><td style="text-align: left">如果宏已经定义，则编译下面代码</td></tr>
<tr><td style="text-align: left">#ifndef</td><td style="text-align: left">如果宏没有定义，则编译下面代码</td></tr>
<tr><td style="text-align: left">#elif</td><td style="text-align: left">如果前面的#if给定条件不为真，当前条件为真，则编译下面代码</td></tr>
<tr><td style="text-align: left">#endif</td><td style="text-align: left">结束一个#if……#else条件编译块</td></tr>
</tbody></table>
</div>
<pre><code>#include
使用库函数之前，应该用#include引入对应的头文件。这种以#号开头的命令称为预处理命令。
使用尖括号&lt; &gt;和双引号&quot; &quot;的区别在于头文件的搜索路径不同，包含标准库的头文件一般用尖括号，包含自定义的头文件一般用双引号。


#define
宏定义是由源程序中的宏定义命令#define完成的，宏代换是由预处理程序完成的。

宏定义的一般形式为：
#define  宏名  字符串
#表示这是一条预处理命令，所有的预处理命令都以#开头。define是预处理命令。宏名是标识符的一种，命名规则和标识符相同。字符串可以是常数、表达式等。
这里所说的字符串是一般意义上的字符序列，不要和C语言中的字符串等同，它不需要双引号。
程序中反复使用的表达式就可以使用宏定义

带参数宏定义
带参宏定义的一般形式为：#define 宏名(形参列表) 字符串
例如：
#define M(y) y*y+3*y  //宏定义
// Code
k=M(5);  //宏调用


条件编译
第一种形式的格式为：
#ifdef  标识符
    程序段1
#else
    程序段2
#endif

它的功能是，如果标识符已被 #define 命令定义过则对程序段1进行编译；否则对程序段2进行编译。如果没有程序段2（它为空），本格式中的#else可以没有，即可以写为：

#ifdef  标识符
    程序段
#endif


第二种形式的格式为：
#ifndef 标识符
    程序段1 
#else 
    程序段2 
#endif
它的功能是，如果标识符未被#define命令定义过则对程序段1进行编译，否则对程序段2进行编译。


第三种形式的格式为：
#if 常量表达式
    程序段1
#else 
    程序段2
#endif
它的功能是，如常量表达式的值为真（非0），则对程序段1 进行编译，否则对程序段2进行编译。因此可以使程序在不同条件下，完成不同的功能。
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="指针"><a class="header" href="#指针">指针</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">定义</th><th style="text-align: left">含义</th></tr></thead><tbody>
<tr><td style="text-align: left">int i;</td><td style="text-align: left">定义整型变量 i。</td></tr>
<tr><td style="text-align: left">int *p;</td><td style="text-align: left">p为指向整型数据的指针变量。</td></tr>
<tr><td style="text-align: left">int a[n];</td><td style="text-align: left">定义整型数组a，它有n个元素。</td></tr>
<tr><td style="text-align: left">int *p[n];</td><td style="text-align: left">定义指针数组p，它由n个指向整型数据的指针元素组成。</td></tr>
<tr><td style="text-align: left">int (*p)[n];</td><td style="text-align: left">p为指向含n个元素的一维数组的指针变量。</td></tr>
<tr><td style="text-align: left">int f();</td><td style="text-align: left">f 为一个返回整型的函数。</td></tr>
<tr><td style="text-align: left">int *p();</td><td style="text-align: left">p为一个返回指针的函数，该指针指向整型数据。</td></tr>
<tr><td style="text-align: left">int (*p)();</td><td style="text-align: left">p为指向函数的指针，该函数返回一个整型值。</td></tr>
<tr><td style="text-align: left">int **p;</td><td style="text-align: left">p是一个指针变量，它又指向另外一个指针变量，该指针变量指向整型数据。</td></tr>
</tbody></table>
</div>
<pre><code>1) 指针变量可以加（减）一个整数，例如p++、p+i、p-=i。

一个指针变量加（减）一个整数并不是简单地将原值加（减）一个整数，而是将该指针变量的原值（是一个地址）和它指向的变量所占用的内存单元字节数加（减）。

2) 指针变量赋值：将一个变量的地址赋给一个指针变量。
    1. p=&amp;a;  //将变量a的地址赋给p
    2. p=array;  //将数组array的首地址赋给p
    3. p=&amp;array[i];  //将数组array第i个元素的地址赋给p
    4. p=max;  //max为已定义的函数，将max的入口地址赋给p
    5. p1=p2;  //p1和p2都是指针变量，将p2的值赋给p1
注意，不能将一个数值直接赋给指针变量，例如p=1000;是没有意义的，一般会引起程序崩溃。

3) 指针变量可以有空值，即该指针变量不指向任何变量，如p=NULL;。

4) 两个指针变量可以相减：如果两个指针变量指向同一个数组的元素，则两个指针变量值之差是两个指针之间的元素个数。


&amp;：取地址运算符；
*：指针运算符（或称“间接访问” 运算符）。


Int *array
array=array+2, 在数组中，当前指针向下移动两位
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="结构体struct"><a class="header" href="#结构体struct">结构体（Struct）</a></h2>
<pre><code class="language-c++">struct stu{
    char *name;  //姓名
    int num;  //学号
    char sex;  //性别
    float score;  //成绩
};

struct stu s1
s1.name = &quot;aa&quot;
s1.num=123

// 结构体数组
struct stu{
    char *name;
    int num;
    char sex;
    float score;
}class[5] = {
    {&quot;Li ping&quot;, 5, 'M', 45},
    {&quot;Zhang ping&quot;, 4, 'M', 62.5},
    {&quot;He fang&quot;, 1, 'F', 92.5},
    {&quot;Cheng ling&quot;, 2, 'F', 87},
    {&quot;Wang ming&quot;, 3, 'M', 58}
};

// 结构体和指针

struct stu{
    char *name;
    int num;
    char sex;
    float score;
} *pstu, stu1, stu2;

(*pstu).num pstu-&gt;num

// 枚举（Enum）
#include &lt;stdio.h&gt;
int main(){
    enum week{
        sun, mon, tue, wed, thu, fri, sat
    } a, b, c;
    a = sun;
    b = mon;
    c = tue;
    printf(&quot;%d, %d, %d\n&quot;,a,b,c);
    return 0;
}

## 共用体（共同体）

```c++
typedef 语言类型定义符

typedef int INTEGER;
INTEGER a, b;
a = 1;
b = 2;
</code></pre>
<h2 id="位运算"><a class="header" href="#位运算">位运算</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">运算符</th><th style="text-align: left">说明</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: left">&amp;</td><td style="text-align: left">按位与</td><td style="text-align: left">只有参与&amp;运算的两个位都为1时，结果才为1，否则为0</td></tr>
<tr><td style="text-align: left">|</td><td style="text-align: left">按位或</td><td style="text-align: left">参与或运算</td></tr>
<tr><td style="text-align: left">^</td><td style="text-align: left">按位异或</td><td style="text-align: left">参与异或运算^的两个二进制位不同时，结果为1，相同时结果为0。</td></tr>
<tr><td style="text-align: left">~</td><td style="text-align: left">取反</td><td style="text-align: left">取反运算符~为单目运算符，右结合性，作用是对参与运算的数的各二进位按位取反。</td></tr>
<tr><td style="text-align: left">&lt;&lt;</td><td style="text-align: left">左移</td><td style="text-align: left">左移运算符&lt;&lt;用来把操作数的各二进位全部左移若干位，高位丢弃，低位补0。</td></tr>
<tr><td style="text-align: left">&gt;&gt;</td><td style="text-align: left">右移</td><td style="text-align: left">右移运算符&gt;&gt;用来把操作数的各二进位全部右移若干位，低位丢弃，高位补0（或1）。</td></tr>
</tbody></table>
</div>
<pre><code class="language-c++">位域或位段
struct bs{
    unsigned a:4;
    unsigned :0;  //空域
    unsigned b:4;  //从下一单元开始存放
    unsigned c:4
}
struct k{
    int a:1;
    int  :2;  //该2位不能使用
    int b:3;
    int c:2;
};

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="c-2"><a class="header" href="#c-2">c++</a></h3>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th style="text-align: left">头文件</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left">stdio.h</td><td style="text-align: left">义了用于输入和输出的函数、类型和宏。</td></tr>
<tr><td style="text-align: left">stdlib.h</td><td style="text-align: left">包含了C语言的中最常用的系统函数。</td></tr>
<tr><td style="text-align: left">string.h</td><td style="text-align: left">包含了C语言的最常用的字符串操作函数。</td></tr>
<tr><td style="text-align: left">ctype.h</td><td style="text-align: left">主要提供两类重要的函数：字符测试函数和字符大小转化函数。</td></tr>
<tr><td style="text-align: left">assert.h</td><td style="text-align: left">提供C语言断言功能，唯一的目的是提供宏assert的定义。</td></tr>
<tr><td style="text-align: left">limits.h</td><td style="text-align: left">指明了基本数据类型的取值范围。</td></tr>
<tr><td style="text-align: left">stddef.h</td><td style="text-align: left">定义了一些标准定义，许多定义也会出现在其他的头文件里。</td></tr>
<tr><td style="text-align: left">time.h</td><td style="text-align: left">获取时间与日期，对时间与日期数据操作及格式化的头文件。</td></tr>
<tr><td style="text-align: left">float.h</td><td style="text-align: left">定义了浮点型数值的最大最小限。</td></tr>
<tr><td style="text-align: left">math.h</td><td style="text-align: left">义了与数学计算有关的函数。</td></tr>
<tr><td style="text-align: left">error.h</td><td style="text-align: left">误处理。</td></tr>
<tr><td style="text-align: left">locale.h</td><td style="text-align: left">定义了本地化设置相关的函数。</td></tr>
<tr><td style="text-align: left">setjmp.h</td><td style="text-align: left">定义了一种特别的函数调用和函数返回顺序的方式。</td></tr>
<tr><td style="text-align: left">signal.h</td><td style="text-align: left">提供了一些函数用以处理执行过程中所产生的信号。</td></tr>
<tr><td style="text-align: left">stdarg.h</td><td style="text-align: left">可变参数列表，定义了一些宏，当函数参数未知时去获取函数的参数。</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h2 id="简介"><a class="header" href="#简介">简介</a></h2>
<pre><code>signal.h 头文件定义了一个变量类型 sig_atomic_t、两个函数调用和一些宏来处理程序执行期间报告的不同信号。
</code></pre>
<h2 id="库变量"><a class="header" href="#库变量">库变量</a></h2>
<pre><code>下面是头文件 signal.h 中定义的变量类型：
序号 变量 &amp; 描述
1 sig_atomic_t 
这是 int 类型，在信号处理程序中作为变量使用。它是一个对象的整数类型，该对象可以作为一个原子实体访问，即使存在异步信号时，该对象可以作为一个原子实体访问。
</code></pre>
<h2 id="库宏"><a class="header" href="#库宏">库宏</a></h2>
<pre><code>下面是头文件 signal.h 中定义的宏，这些宏将在下列两个函数中使用。SIG_ 宏与 signal 函数一起使用来定义信号的功能。
序号 宏 &amp; 描述
1 SIG_DFL
默认的信号处理程序。
2 SIG_ERR
表示一个信号错误。
3 SIG_IGN
忽视信号。
SIG 宏用于表示以下各种条件的信号码：
序号 宏 &amp; 描述
1 SIGABRT
程序异常终止。
2 SIGFPE
算术运算出错，如除数为 0 或溢出。
3 SIGILL
非法函数映象，如非法指令。
4 SIGINT
中断信号，如 ctrl-C。
5 SIGSEGV
非法访问存储器，如访问不存在的内存单元。
6 SIGTERM
发送给本程序的终止请求信号。
</code></pre>
<h2 id="库函数"><a class="header" href="#库函数">库函数</a></h2>
<pre><code>下面是头文件 signal.h 中定义的函数：
序号 函数 &amp; 描述
1 void (*signal(int sig, void (*func)(int)))(int)
该函数设置一个函数来处理信号，即信号处理程序。
2 int raise(int sig)
该函数会促使生成信号 sig。sig 参数与 SIG 宏兼容。
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-c++">#include&lt;stdarg.h&gt;
#include&lt;stdio.h&gt;

int sum(int, ...);

int main(void)
{
   printf(&quot;10、20 和 30 的和 = %d\n&quot;,  sum(3, 10, 20, 30) );
   printf(&quot;4、20、25 和 30 的和 = %d\n&quot;,  sum(4, 4, 20, 25, 30) );

   return 0;
}

int sum(int num_args, ...)
{
   int val = 0;
   va_list ap;
   int i;

   va_start(ap, num_args);
   for(i = 0; i &lt; num_args; i++)
   {
      val += va_arg(ap, int);
   }
   va_end(ap);
 
   return val;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="简介-1"><a class="header" href="#简介-1">简介</a></h2>
<pre><code>stddef .h 头文件定义了各种变量类型和宏。这些定义中的大部分也出现在其它头文件中。
</code></pre>
<h2 id="库变量-1"><a class="header" href="#库变量-1">库变量</a></h2>
<pre><code>下面是头文件 stddef.h 中定义的变量类型：
序号 变量 &amp; 描述
1 ptrdiff_t
这是有符号整数类型，它是两个指针相减的结果。
2 size_t 
这是无符号整数类型，它是 sizeof 关键字的结果。
3 wchar_t 
这是一个宽字符常量大小的整数类型。
</code></pre>
<h2 id="库宏-1"><a class="header" href="#库宏-1">库宏</a></h2>
<pre><code>下面是头文件 stddef.h 中定义的宏：
序号 宏 &amp; 描述
1 NULL
这个宏是一个空指针常量的值。
2 offsetof(type, member-designator)
这会生成一个类型为 size_t 的整型常量，它是一个结构成员相对于结构开头的字节偏移量。成员是由 member-designator 给定的，结构的名称是在 type 中给定的。
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="atoiatolatof"><a class="header" href="#atoiatolatof">atoi，atol，atof</a></h2>
<pre><code>atoi()会扫描参数nptr字符串，检测到第一个数字或正负符号时开始做类型转换，之后检测到非数字或结束符 \0 时停止转换，返回整型数。
</code></pre>
<h2 id="itoa"><a class="header" href="#itoa">itoa</a></h2>
<pre><code>功能:把一整数转换为字符串
用法:char *itoa(int value, char *string, int radix);
详细解释:itoa是英文integer to array(将int整型数转化为一个字符串,并将值保存在数组string中)的缩写.
参数：
　　value: 待转化的整数。
　　radix: 是基数的意思,即先将value转化为radix进制的数，范围介于2-36，比如10表示10进制，16表示16进制。
　　* string: 保存转换后得到的字符串。
　　返回值：
　　char * : 指向生成的字符串， 同*string。
　　备注:该函数的头文件是&quot;stdlib.h&quot;
</code></pre>
<h2 id="四舍五入"><a class="header" href="#四舍五入">四舍五入</a></h2>
<pre><code class="language-c++"> if( x &gt; 0.0 )
                 return (int)( x + 0.5 );
         else
                 return (int)( x - 0.5 );
</code></pre>
<pre><code>头文件：#include &lt;stdio.h&gt;
scanf() 函数用来格式化输入数据，即按用户指定的格式从键盘上把数据读入到指定的变量中。其原型为：
int scanf ( char * format [ ,argument, ... ]);
【参数】format为格式化控制字符串，可以由三类字符构成。

1) 格式化说明符

------------------------------------------------------------

格式字符           说明
------------------------------------------------------------

%a                 读入一个浮点值(仅C99有效)
%A                 同上
%c                 读入一个字符
%d                 读入十进制整数
%i                 读入十进制，八进制，十六进制整数
%o                 读入八进制整数
%x                 读入十六进制整数
%X                 同上
%c                 读入一个字符
%s                 读入一个字符串
%f                 读入一个浮点数
%F                 同上
%e                 同上
%E                 同上
%g                 同上
%G                 同上
%p                 读入一个指针
%u                 读入一个无符号十进制整数
%n                 至此已读入值的等价字符数
%[]                 扫描字符集合
%%                读%符号

另外，还有附加格式说明字符，用于追加在上面的格式说明符后面
-----------------------------------------------------------------

修饰符                       说明
-----------------------------------------------------------------

L/l                          长度修饰符，输入&quot;长&quot;数据
h                            长度修饰符，输入&quot;短&quot;数据
W                           整型常数，指定输入数据所占宽度

* 星号，空读一个数据

hh                          同 h，但仅对C99有效
ll                             同 l，但仅对C99有效

2) 空白字符
空白字符会使scanf()函数在读操作中略去输入中的一个或多个空白字符，空白符可以是space,tab,newline等等，直到第一个非空白符出现为止。

3) 非空白字符
一个非空白字符会使scanf()函数在读入时剔除掉与这个非空白字符相同的字符。
argument 为需要读入的所有变量的地址。
注意，是变量地址，而不是变量标识符：
如果是一般的变量，通常要在变量名前加上&quot;&amp;&quot;取得地址，但输出时是用变量名。
如果是数组，用数组名就代表了该数组的首地址，输出时也是用数组名
如果是指针，直接用指针名本身，不要加上“*”，输出时也用该指针即可。
【返回值】成功则返回被赋值的参数的个数。如果 format 和 argument 匹配错误，或者遇到结束符，那么返回值可能小于参数的个数。
如果读取发生错误，将会返回 EOF，并设置错误标识，后续可以通过 ferror() 检测。
如果遇到结束符，将会设置文件结束标识，后续可以通过 feof() 检测。
如果在读取宽字符的时候发生编码错误，那么将会把 errno 设置为  EILSEQ。

格式字符串
格式字符串的一般形式为：
    %[*][输入数据宽度][长度]类型
其中有方括号[]的项为任选项。各项的意义如下。

1) 类型
表示输入数据的类型，其格式符和意义如下表所示
格式 字符意义
d 输入十进制整数
o 输入八进制整数
x 输入十六进制整数
u 输入无符号十进制整数
f或e 输入实型数(用小数形式或指数形式)
c 输入单个字符
s 输入字符串
2) “*”符
用以表示该输入项，读入后不赋予相应的变量，即跳过该输入值。如：
scanf(&quot;%d %*d %d&quot;,&amp;a,&amp;b);
当输入为：1   2   3时，把1赋予a，2被跳过，3赋予b。

3) 宽度
用十进制整数指定输入的宽度（即字符数）。例如：
scanf(&quot;%5d&quot;,&amp;a);
输入12345678只把12345赋予变量a，其余部分被截去。又如：
scanf(&quot;%4d%4d&quot;,&amp;a,&amp;b);
输入12345678将把1234赋予a，而把5678赋予b。
4) 长度
长度格式符为l和h，l表示输入长整型数据（如%ld）和双精度浮点数（如%lf）。h表示输入短整型数据。
使用scanf函数还必须注意以下几点：
scanf函数中没有精度控制，如：scanf(&quot;%5.2f&quot;,&amp;a);是非法的。不能企图用此语句输入小数为2位的实数。
scanf中要求给出变量地址，如给出变量名则会出错。如 scanf(&quot;%d&quot;,a);是非法的，应改为scnaf(&quot;%d&quot;,&amp;a);才是合法的。
在输入多个数值数据时，若格式控制串中没有非格式字符作输入数据之间的间隔则可用空格，TAB或回车作间隔。C编译在碰到空格，TAB，回车或非法数据(如对“%d”输入“12A”时，A即为非法数据)时即认为该数据结束。
在输入字符数据时，若格式控制串中无非格式字符，则认为所有输入的字符均为有效字符。
例如：
scanf(&quot;%c%c%c&quot;,&amp;a,&amp;b,&amp;c);
输入 d、e、f 则把'd'赋予a，' ' 赋予b，'e'赋予c。只有当输入为 def 时，才能把'd'赋于a，'e'赋予b，'f'赋予c。
如果在格式控制中加入空格作为间隔，如：
scanf (&quot;%c %c %c&quot;,&amp;a,&amp;b,&amp;c);
则输入时各数据之间可加空格。
【例4-8】

# include &lt;stdio.h&gt;

int main(void)
{
    char a,b;
    printf(&quot;input character a,b\n&quot;);
    scanf(&quot;%c%c&quot;,&amp;a,&amp;b);
    printf(&quot;%c%c\n&quot;,a,b);
    return 0;
}
由于scanf函数&quot;%c%c&quot;中没有空格，输入M  N，结果输出只有M。而输入改为MN时则可输出MN两字符。
【例4-9】

# include &lt;stdio.h&gt;

int main(void){
    char a,b;
    printf(&quot;input character a,b\n&quot;);
    scanf(&quot;%c %c&quot;,&amp;a,&amp;b);
    printf(&quot;\n%c%c\n&quot;,a,b);
    return 0;
}
本例表示scanf格式控制串&quot;%c %c&quot;之间有空格时，输入的数据之间可以有空格间隔。
5) 如果格式控制串中有非格式字符则输入时也要输入该非格式字符。
例如：
scanf(&quot;%d,%d,%d&quot;,&amp;a,&amp;b,&amp;c);
其中用非格式符“ , ”作间隔符，故输入时应为：5,6,7。又如：
scanf(&quot;a=%d,b=%d,c=%d&quot;,&amp;a,&amp;b,&amp;c);
则输入应为：a=5,b=6,c=7。
</code></pre>
<h2 id="简介-2"><a class="header" href="#简介-2">简介</a></h2>
<pre><code>stdio .h 头文件定义了三个变量类型、一些宏和各种函数来执行输入和输出。
</code></pre>
<h2 id="库变量-2"><a class="header" href="#库变量-2">库变量</a></h2>
<pre><code>下面是头文件 stdio.h 中定义的变量类型：
序号 变量 &amp; 描述
1 size_t 
这是无符号整数类型，它是 sizeof 关键字的结果。
2 FILE 
这是一个适合存储文件流信息的对象类型。
3 fpos_t 
这是一个适合存储文件中任何位置的对象类型。
</code></pre>
<h2 id="库宏-2"><a class="header" href="#库宏-2">库宏</a></h2>
<pre><code>下面是头文件 stdio.h 中定义的宏：
序号 宏 &amp; 描述
1 NULL
这个宏是一个空指针常量的值。
2 _IOFBF、_IOLBF 和 _IONBF 
这些宏扩展了带有特定值的整型常量表达式，并适用于 setvbuf 函数的第三个参数。
3 BUFSIZ
这个宏是一个整数，该整数代表了 setbuf 函数使用的缓冲区大小。
4 EOFM 
这个宏是一个表示已经到达文件结束的负整数。
5 FOPEN_MAX 
这个宏是一个整数，该整数代表了系统可以同时打开的文件数量。
6 FILENAME_MAX 
这个宏是一个整数，该整数代表了字符数组可以存储的文件名的最大长度。如果实现没有任何限制，则该值应为推荐的最大值。
7 L_tmpnam 
这个宏是一个整数，该整数代表了字符数组可以存储的由 tmpnam 函数创建的临时文件名的最大长度。
8 SEEK_CUR、SEEK_END 和 SEEK_SET 
这些宏是在These macros are used in the fseek 函数中使用，用于在一个文件中定位不同的位置。
9 TMP_MAX 
这个宏是 tmpnam 函数可生成的独特文件名的最大数量。
10 stderr、stdin 和 stdout 
这些宏是指向 FILE 类型的指针，分别对应于标准错误、标准输入和标准输出流。
</code></pre>
<h2 id="库函数-1"><a class="header" href="#库函数-1">库函数</a></h2>
<pre><code>下面是头文件 stdio.h 中定义的函数：
为了更好地理解函数，请按照下面的序列学习这些函数，因为第一个函数中创建的文件会在后续的函数中使用到。
序号 函数 &amp; 描述
1 int fclose(FILE *stream)
关闭流 stream。刷新所有的缓冲区。
2 void clearerr(FILE *stream)
清除给定流 stream 的文件结束和错误标识符。
3 int feof(FILE *stream)
测试给定流 stream 的文件结束标识符。
4 int ferror(FILE *stream)
测试给定流 stream 的错误标识符。
5 int fflush(FILE *stream)
刷新流 stream 的输出缓冲区。
6 int fgetpos(FILE *stream, fpos_t *pos)
获取流 stream 的当前文件位置，并把它写入到 pos。
7 FILE *fopen(const char *filename, const char *mode)
使用给定的模式 mode 打开 filename 所指向的文件。
8 size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream)
从给定流 stream 读取数据到 ptr 所指向的数组中。
9 FILE *freopen(const char *filename, const char *mode, FILE *stream)
把一个新的文件名 filename 与给定的打开的流 stream 关联，同时关闭流中的旧文件。
10 int fseek(FILE *stream, long int offset, int whence)
设置流 stream 的文件位置为给定的偏移 offset，参数 offset 意味着从给定的 whence 位置查找的字节数。
11 int fsetpos(FILE *stream, const fpos_t *pos)
设置给定流 stream 的文件位置为给定的位置。参数 pos 是由函数 fgetpos 给定的位置。
12 long int ftell(FILE *stream)
返回给定流 stream 的当前文件位置。
13 size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream)
把 ptr 所指向的数组中的数据写入到给定流 stream 中。
14 int remove(const char *filename)
删除给定的文件名 filename，以便它不再被访问。
15 int rename(const char *old_filename, const char *new_filename)
把 old_filename 所指向的文件名改为 new_filename。
16 void rewind(FILE *stream)
设置文件位置为给定流 stream 的文件的开头。
17 void setbuf(FILE *stream, char *buffer)
定义流 stream 应如何缓冲。
18 int setvbuf(FILE *stream, char *buffer, int mode, size_t size)
另一个定义流 stream 应如何缓冲的函数。
19 FILE *tmpfile(void)
以二进制更新模式(wb+)创建临时文件。
20 char *tmpnam(char *str)
生成并返回一个有效的临时文件名，该文件名之前是不存在的。
21 int fprintf(FILE *stream, const char *format, ...)
发送格式化输出到流 stream 中。
22 int printf(const char *format, ...)
发送格式化输出到标准输出 stdout。
23 int sprintf(char *str, const char *format, ...)
发送格式化输出到字符串。
24 int vfprintf(FILE *stream, const char *format, va_list arg)
使用参数列表发送格式化输出到流 stream 中。
25 int vprintf(const char *format, va_list arg)
使用参数列表发送格式化输出到标准输出 stdout。
26 int vsprintf(char *str, const char *format, va_list arg)
使用参数列表发送格式化输出到字符串。
27 int fscanf(FILE *stream, const char *format, ...)
从流 stream 读取格式化输入。
28 int scanf(const char *format, ...)
从标准输入 stdin 读取格式化输入。
29 int sscanf(const char *str, const char *format, ...)
从字符串读取格式化输入。
30 int fgetc(FILE *stream)
从指定的流 stream 获取下一个字符（一个无符号字符），并把位置标识符往前移动。
31 char *fgets(char *str, int n, FILE *stream)
从指定的流 stream 读取一行，并把它存储在 str 所指向的字符串内。当读取 (n-1) 个字符时，或者读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定。
32 int fputc(int char, FILE *stream)
把参数 char 指定的字符（一个无符号字符）写入到指定的流 stream 中，并把位置标识符往前移动。
33 int fputs(const char *str, FILE *stream)
把字符串写入到指定的流 stream 中，但不包括空字符。
34 int getc(FILE *stream)
从指定的流 stream 获取下一个字符（一个无符号字符），并把位置标识符往前移动。
35 int getchar(void)
从标准输入 stdin 获取一个字符（一个无符号字符）。
36 char *gets(char *str)
从标准输入 stdin 读取一行，并把它存储在 str 所指向的字符串中。当读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定。
37 int putc(int char, FILE *stream)
把参数 char 指定的字符（一个无符号字符）写入到指定的流 stream 中，并把位置标识符往前移动。
38 int putchar(int char)
把参数 char 指定的字符（一个无符号字符）写入到标准输出 stdout 中。
39 int puts(const char *str)
把一个字符串写入到标准输出 stdout，直到空字符，但不包括空字符。换行符会被追加到输出中。
40 int ungetc(int char, FILE *stream)
把字符 char（一个无符号字符）推入到指定的流 stream 中，以便它是下一个被读取到的字符。
41 void perror(const char *str)
把一个描述性错误消息输出到标准错误 stderr。首先输出字符串 str，后跟一个冒号，然后是一个空格。
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="简介-3"><a class="header" href="#简介-3">简介</a></h2>
<p>stdli   b .h 头文件定义了四个变量类型、一些宏和各种通用工具函数。</p>
<h2 id="库变量-3"><a class="header" href="#库变量-3">库变量</a></h2>
<pre><code>下面是头文件 stdlib.h 中定义的变量类型：
序号 变量 &amp; 描述
1 size_t 
这是无符号整数类型，它是 sizeof 关键字的结果。
2 wchar_t 
这是一个宽字符常量大小的整数类型。
3 div_t 
这是 div 函数返回的结构。
4 ldiv_t 
这是 ldiv 函数返回的结构。
</code></pre>
<h2 id="库宏-3"><a class="header" href="#库宏-3">库宏</a></h2>
<pre><code>下面是头文件 stdlib.h 中定义的宏：
序号 宏 &amp; 描述
1 NULL
这个宏是一个空指针常量的值。
2 EXIT_FAILURE
这是 exit 函数失败时要返回的值。
3 EXIT_SUCCESS
这是 exit 函数成功时要返回的值。
4 RAND_MAX 
这个宏是 rand 函数返回的最大值。
5 MB_CUR_MAX 
这个宏表示在多字节字符集中的最大字符数，不能大于 MB_LEN_MAX。
</code></pre>
<h2 id="库函数-2"><a class="header" href="#库函数-2">库函数</a></h2>
<pre><code>下面是头文件 stdlib.h 中定义的函数：
序号 函数 &amp; 描述
1 double atof(const char *str)
把参数 str 所指向的字符串转换为一个浮点数（类型为 double 型）。
2 int atoi(const char *str)
把参数 str 所指向的字符串转换为一个整数（类型为 int 型）。
3 long int atol(const char *str)
把参数 str 所指向的字符串转换为一个长整数（类型为 long int 型）。
4 double strtod(const char *str, char **endptr)
把参数 str 所指向的字符串转换为一个浮点数（类型为 double 型）。
5 long int strtol(const char *str, char **endptr, int base)
把参数 str 所指向的字符串转换为一个长整数（类型为 long int 型）。
6 unsigned long int strtoul(const char *str, char **endptr, int base)
把参数 str 所指向的字符串转换为一个无符号长整数（类型为 unsigned long int 型）。
7 void *calloc(size_t nitems, size_t size)
分配所需的内存空间，并返回一个指向它的指针。
8 void free(void *ptr)
释放之前调用 calloc、malloc 或 realloc 所分配的内存空间。
9 void *malloc(size_t size)
分配所需的内存空间，并返回一个指向它的指针。
10 void *realloc(void *ptr, size_t size)
尝试重新调整之前调用 malloc 或 calloc 所分配的 ptr 所指向的内存块的大小。
11 void abort(void)
使一个异常程序终止。
12 int atexit(void (*func)(void))
当程序正常终止时，调用指定的函数 func。
13 void exit(int status)
使程序正常终止。
14 char *getenv(const char *name)
搜索 name 所指向的环境字符串，并返回相关的值给字符串。
15 int system(const char *string)
由 string 指定的命令传给要被命令处理器执行的主机环境。
16 void *bsearch(const void *key, const void *base, size_t nitems, size_t size, int (*compar)(const void *, const void *))
执行二分查找。
17 void qsort(void *base, size_t nitems, size_t size, int (*compar)(const void *, const void*))
数组排序。
18 int abs(int x)
返回 x 的绝对值。
19 div_t div(int numer, int denom)
分子除以分母。
20 long int labs(long int x)
返回 x 的绝对值。
21 ldiv_t ldiv(long int numer, long int denom)
分子除以分母。
22 int rand(void)
返回一个范围在 0 到 RAND_MAX 之间的伪随机数。
23 void srand(unsigned int seed)
该函数播种由函数 rand 使用的随机数发生器。
24 int mblen(const char *str, size_t n)
返回参数 str 所指向的多字节字符的长度。
25 size_t mbstowcs(schar_t *pwcs, const char *str, size_t n)
把参数 str 所指向的多字节字符的字符串转换为参数 pwcs 所指向的数组。
26 int mbtowc(whcar_t *pwc, const char *str, size_t n)
检查参数 str 所指向的多字节字符。
27 size_t wcstombs(char *str, const wchar_t *pwcs, size_t n)
把数组 pwcs 中存储的编码转换为多字节字符，并把它们存储在字符串 str 中。
28 int wctomb(char *str, wchar_t wchar)
检查对应于参数 wchar 所给出的多字节字符的编码。
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="简介-4"><a class="header" href="#简介-4">简介</a></h2>
<pre><code>string .h 头文件定义了一个变量类型、一个宏和各种操作字符数组的函数。
</code></pre>
<h2 id="库变量-4"><a class="header" href="#库变量-4">库变量</a></h2>
<pre><code>下面是头文件 string.h 中定义的变量类型：
序号 变量 &amp; 描述
1 size_t 
这是无符号整数类型，它是 sizeof 关键字的结果。
</code></pre>
<h2 id="库宏-4"><a class="header" href="#库宏-4">库宏</a></h2>
<pre><code>下面是头文件 string.h 中定义的宏：
序号 宏 &amp; 描述
1 NULL
这个宏是一个空指针常量的值。
</code></pre>
<h2 id="库函数-3"><a class="header" href="#库函数-3">库函数</a></h2>
<pre><code>下面是头文件 string.h 中定义的函数：
序号 函数 &amp; 描述
1 void *memchr(const void *str, int c, size_t n)
在参数 str 所指向的字符串的前 n 个字节中搜索第一次出现字符 c（一个无符号字符）的位置。
2 int memcmp(const void *str1, const void *str2, size_t n)
把 str1 和 str2 的前 n 个字节进行比较。
3 void *memcpy(void *dest, const void *src, size_t n)
从 src 复制 n 个字符到 dest。
4 void *memmove(void *dest, const void *src, size_t n)
另一个用于从 str2 复制 n 个字符到 str1 的函数。
5 void *memset(void *str, int c, size_t n)
复制字符 c（一个无符号字符）到参数 str 所指向的字符串的前 n 个字符。
6 char *strcat(char *dest, const char *src)
把 src 所指向的字符串追加到 dest 所指向的字符串的结尾。
7 char *strncat(char *dest, const char *src, size_t n)
把 src 所指向的字符串追加到 dest 所指向的字符串的结尾，直到 n 字符长度为止。
8 char *strchr(const char *str, int c)
在参数 str 所指向的字符串中搜索第一次出现字符 c（一个无符号字符）的位置。
9 int strcmp(const char *str1, const char *str2)
把 str1 所指向的字符串和 str2 所指向的字符串进行比较。
10 int strncmp(const char *str1, const char *str2, size_t n)
把 str1 和 str2 进行比较，最多比较前 n 个字节。
11 int strcoll(const char *str1, const char *str2)
把 str1 和 str2 进行比较，结果取决于 LC_COLLATE 的位置设置。
12 char *strcpy(char *dest, const char *src)
把 src 所指向的字符串复制到 dest。
13 char *strncpy(char *dest, const char *src, size_t n)
把 src 所指向的字符串复制到 dest，最多复制 n 个字符。
14 size_t strcspn(const char *str1, const char *str2)
检索字符串 str1 开头连续有几个字符都不含字符串 str2 中的字符。
15 char *strerror(int errnum)
从内部数组中搜索错误号 errnum，并返回一个指向错误消息字符串的指针。
16 size_t strlen(const char *str)
计算字符串 str 的长度，直到空结束字符，但不包括空结束字符。
17 char *strpbrk(const char *str1, const char *str2)
检索字符串 str1 中第一个匹配字符串 str2 中字符的字符，不包含空结束字符。也就是说，依次检验字符串 str1 中的字符，当被检验字符在字符串 str2 中也包含时，则停止检验，并返回该字符位置。
18 char *strrchr(const char *str, int c)
在参数 str 所指向的字符串中搜索最后一次出现字符 c（一个无符号字符）的位置。
19 size_t strspn(const char *str1, const char *str2)
检索字符串 str1 中第一个不在字符串 str2 中出现的字符下标。
20 char *strstr(const char *haystack, const char *needle)
在字符串 haystack 中查找第一次出现字符串 needle（不包含空结束字符）的位置。
21 char *strtok(char *str, const char *delim)
分解字符串 str 为一组字符串，delim 为分隔符。
22 size_t strxfrm(char *dest, const char *src, size_t n)
根据程序当前的区域选项中的 LC_COLLATE 来转换字符串 src 的前 n 个字符，并把它们放置在字符串 dest 中。
</code></pre>
<h2 id="strlen"><a class="header" href="#strlen">strlen</a></h2>
<pre><code>strlen 是 string length 的缩写，用来获得字符串的长度。所谓长度，就是包含多少个字符（不包括字符串结束标志 '\0'）。
语法格式为：strlen(arrayName);
strlen 将返回字符串的长度，它是一个整数。
</code></pre>
<h2 id="strcat"><a class="header" href="#strcat">strcat</a></h2>
<pre><code>strcat 是 string catenate 的缩写，意思是把两个字符串拼接在一起，语法格式为：
strcat(arrayName1, arrayName2);
arrayName1、arrayName2 为需要拼接的字符串。
</code></pre>
<h2 id="strcpy"><a class="header" href="#strcpy">strcpy</a></h2>
<pre><code>strcpy 是 string copy 的缩写，意思是字符串复制，语法格式为：
strcpy(arrayName1, arrayName2);
strcpy 会把 arrayName2 中的字符串拷贝到 arrayName1 中，串结束标志 '\0' 也一同拷贝。
</code></pre>
<h2 id="strcmp"><a class="header" href="#strcmp">strcmp</a></h2>
<pre><code>strcmp 是 string compare 的缩写，意思是字符串比较，语法格式为：
strcmp(arrayName1, arrayName2);
arrayName1 和 arrayName2 是需要比较的两个字符串。

字符本身没有大小之分，strcmp() 是以各个字符在ASCII 码表上对应的数值进行比较的。strcmp() 首先将 arrayName1 中第0个字符的 ASCII 码值减去 arrayName2 中第0个字符的 ASCII 码值，若差值为 0，则说明两个字符相同，再继续比较下个字符，若差值不为 0 则将差值返回。例如字符串&quot;Ac&quot;和&quot;ba&quot;比较则会返回字符&quot;A&quot;(65)和'b'(98)的差值(－33)。

返回值：若 arrayName1 和 arrayName2 相同，则返回0；若 arrayName1 大于 arrayName2，则返回大于 0 的值；若 arrayName1 小于 arrayName2，则返回小于0 的值。
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="简介-5"><a class="header" href="#简介-5">简介</a></h2>
<pre><code>time.h 头文件定义了四个变量类型、两个宏和各种操作日期和时间的函数。
</code></pre>
<h2 id="库变量-5"><a class="header" href="#库变量-5">库变量</a></h2>
<pre><code>下面是头文件 time.h 中定义的变量类型：
序号 变量 &amp; 描述
1 size_t 
是无符号整数类型，它是 sizeof 关键字的结果。
2 clock_t 
这是一个适合存储处理器时间的类型。
3 time_t is 
这是一个适合存储日历时间类型。
4 struct tm 
这是一个用来保存时间和日期的结构。
tm 结构的定义如下：
struct tm {
int tm_sec;         /* 秒，范围从 0 到 59  */
int tm_min;         /* 分，范围从 0 到 59  */
int tm_hour;        /* 小时，范围从 0 到 23  */
int tm_mday;        /* 一月中的第几天，范围从 1 到 31 */
int tm_mon;         /* 月，范围从 0 到 11  */
int tm_year;        /* 自 1900 年起的年数  */
int tm_wday;        /* 一周中的第几天，范围从 0 到 6 */
int tm_yday;        /* 一年中的第几天，范围从 0 到 365 */
int tm_isdst;       /* 夏令时    */
};
</code></pre>
<h2 id="库宏-5"><a class="header" href="#库宏-5">库宏</a></h2>
<pre><code>下面是头文件 time.h 中定义的宏：
序号 宏 &amp; 描述
1 NULL
这个宏是一个空指针常量的值。
2 CLOCKS_PER_SEC 
这个宏表示每秒的处理器时钟个数。
</code></pre>
<h2 id="库函数-4"><a class="header" href="#库函数-4">库函数</a></h2>
<pre><code>下面是头文件 time.h 中定义的函数：
序号 函数 &amp; 描述
1 char *asctime(const struct tm *timeptr)
返回一个指向字符串的指针，它代表了结构 timeptr 的日期和时间。
2 clock_t clock(void)
返回程序执行起（一般为程序的开头），处理器时钟所使用的时间。
3 char *ctime(const time_t *timer)
返回一个表示当地时间的字符串，当地时间是基于参数 timer。
4 double difftime(time_t time1, time_t time2)
返回 time1 和 time2 之间相差的秒数 (time1-time2)。
5 struct tm *gmtime(const time_t *timer)
timer 的值被分解为 tm 结构，并用协调世界时（UTC）也被称为格林尼治标准时间（GMT）表示。
6 struct tm *localtime(const time_t *timer)
timer 的值被分解为 tm 结构，并用本地时区表示。
7 time_t mktime(struct tm *timeptr)
把 timeptr 所指向的结构转换为一个依据本地时区的 time_t 值。
8 size_t strftime(char *str, size_t maxsize, const char *format, const struct tm *timeptr)
根据 format 中定义的格式化规则，格式化结构 timeptr 表示的时间，并把它存储在 str 中。
9 time_t time(time_t *timer)
计算当前日历时间，并把它编码成 time_t 格式。
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="格式字符串"><a class="header" href="#格式字符串">格式字符串</a></h2>
<pre><code>在Turbo C中格式字符串的一般形式为：

%[标志][输出最小宽度][.精度][长度]类型。
%[flags][width][.precision]type
其中方括号[]中的项为可选项。


1) 类型。 也就是以什么类型输出，比如 %d、%f、%c，type 就分别对应 d、f、c；%-9d中 type 对应 d。type 必须有。

格式字符 意义 
c 输出单个字符 
s 输出字符串 
f 以小数形式输出单、双精度实数 默认保留六位小数，不足六位以 0 补齐，超过六位按四舍五入截断
d 以十进制形式输出带符号整数(正数不输出符号) 
o  以八进制形式输出无符号整数(不输出前缀0) 
x,X 以十六进制形式输出无符号整数(不输出前缀Ox) 
u 以十进制形式输出无符号整数 
e,E 以指数形式输出单、双精度实数 
g,G 以%f或%e中较短的输出宽度输出单、双精度实数 


2) 标志。标志字符为 -、+、# 和空格四种，其意义下表所示：

标志字符 含  义
- 左对齐
+ 输出符号（正号或负号）
空格 输出值为正时冠以空格，为负时冠以负号
# 对c、s、d、u类无影响；
对o类，在输出时加前缀o；
对x类，在输出时加前缀0x；
对e、g、f 类当结果有小数时才给出小数点。


3) 输出最小宽度。width 表示最小输出宽度，也就是占几个字符的位置；%-9d中 width 对应 9。
用十进制整数来表示输出的最少位数。若实际位数多于定义的宽度，则按实际位数输出，若实际位数少于定义的宽度则补以空格或0。

4) 精度
精度格式符以“.”开头，后跟十进制整数。
本项的意义是：如果输出数字，则表示小数的位数；
如果输出的是字符，则表示输出字符的个数；
若实际位数大于所定义的精度数，则截去超过的部分。
不足的宽度以 0 补齐

5) 长度
长度格式符为h、l两种，h表示按短整型量输出，l表示按长整型量输出。

例子：
int a=15;
long float b=123.1234567;
double c=12345678.1234567;

char d='p';

printf(&quot;a=%d\n&quot;, a);
printf(&quot;a(%%d)=%d, a(%%5d)=%5d, a(%%o)=%o, a(%%x)=%x\n\n&quot;,a,a,a,a);  // %% 可以输出 %
printf(&quot;a=%f\n&quot;, b);
printf(&quot;b(%%f)=%f, b(%%lf)=%lf, b(%%5.4lf)=%5.4lf, b(%%e)=%e\n\n&quot;,b,b,b,b);
printf(&quot;c=%f\n&quot;, c);
printf(&quot;c(%%lf)=%lf, c(%%f)=%f, c(%%8.4lf)=%8.4lf\n\n&quot;,c,c,c);
printf(&quot;d=%c\n&quot;, d);
printf(&quot;d(%%c)=%c, d(%%8c)=%8c\n&quot;,d,d);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code>1. 文件和流的关系

C将每个文件简单地作为顺序字节流。每个文件用文件结束符结束，或者在特定字节数的地方结束，这个特定的字节数可以存储在系统维护的管理数据结构中。当打开文件时，就建立了和文件的关系。

在开始执行程序的时候，将自动打开3个文件和相关的流：标准输入流、标准输出流和标准错误。流提供了文件和程序的通信通道。打开一个文件将返回指向FILE结构(在stdio.h中定义)的指针，它包含用于处理文件的信息，也就是说，这个结构包含文件描述符。文件描述符是操作系统数组(打开文件列表的索引)。每个数组元素包含一个文件控制块(FCB, File Control Block)，操作系统用它来管理特定的文件。

标准输入、标准输出和标准错误是用文件指针stdin、stdout和stderr来处理的。

C语言把磁盘文件看成是字符（或字节）的序列，按照存储信息的形式来说，文件主要是有文本文件和二进制文件。文本文件由一个个字符组成，每个字节存放一个ASCII码制，代表一个字符。二进制文件把内存中的数据按其在内存中的存储形式原样放入磁盘空间。

二进制文件以及文本文件都可以看做是“数据流”。

2. C语言文件管理的实现

C程序用不同的FILE结构管理每个文件。程序员可以使用文件，但不需要知道FILE结构的细节。实际上，FILE结构是间接地操作系统的文件控制块(FCB)来实现对文件的操作的。例如FILE结构体中的_file实际上就是一个文件描述符，作为进入打开文件表索引的整数。

3. 操作系统文件管理简介

文件是存放在物理磁盘上的，包括文件控制块(FCB)和数据块。文件控制块通常包括文件权限、日期（创建、读取、修改）、拥有者、文件大小、数据块信息。数据块用来存储实际的内容。对于打开的文件，操作系统是这样管理的：

1

系统维护了两张表，一张是系统级打开文件表，一张是进程级打开文件表（每个进程有一个）。

系统级打开文件表复制了文件控制块的信息等；进程级打开文件表保存了指向系统级文件表的指针及其他信息。

系统级文件表每一项都保存一个计数器，即该文件打开的次数。我们初次打开一个文件时，系统首先查看该文件是否已在系统级文件表中，如果不在，则创建该项信息，否则，计数器加1。当我们关闭一个文件时，相应的计数也会减1，当减到0时，系统将系统级文件表中的项删除。

进程打开一个文件时，会在进程级文件表中添加一项。每项的信息包括当前文件偏移量（读写文件的位置）、存取权限、和一个指向系统级文件表中对应文件项的指针。系统级文件表中的每一项通过文件描述符（一个非负整数）来标识。

FILE结构体中的_file成员应该是指向进程级打开文件表，然后，通过进程级打开文件表可以找到系统级打开文件表，进而可以通过FCB操作物理磁盘上面的文件。

每打开一次文件，哪怕多次打开的都是同一个文件，进程级打开文件表中应该都会添加一个记录。如果是打开的是同一个文件，这多条记录对应着同一个物理磁盘文件。由于每一次打开文件所进行的操作都是通过进程级打开文件表中不同的记录来实现的，这样，相当于每次打开文件的操作是相对独立的。

4. 缓冲区

当我们从键盘输入数据的时候，数据并不是直接被我们得到，而是放在了缓冲区中，然后我们从缓冲区中得到我们想要的数据 。如果我们通过setbuf()或setvbuf()函数将缓冲区设置10个字节的大小，而我们从键盘输入了20个字节大小的数据，这样我们输入的前10个数据会放在缓冲区中，因为我们设置的缓冲区的大小只能够装下10个字节大小的数据，装不下20个字节大小的数据。那么剩下的那10个字节大小的数据怎么办呢？暂时放在了输入流中。请看下图：



上面的箭头表示的区域就相当是一个输入流，红色的地方相当于一个开关，这个开关可以控制往深绿色区域（标注的是缓冲区）里放进去的数据，输入20个字节的数据只往缓冲区中放进去了10个字节，剩下的10个字节的数据就被停留在了输入流里！等待下去往缓冲区中放入！接下来系统是如何来控制这个缓冲区呢？
再说一下 FILE 结构体中几个相关成员的含义：
    cnt  // 剩余的字符，如果是输入缓冲区，那么就表示缓冲区中还有多少个字符未被读取
    ptr  // 下一个要被读取的字符的地址
    base  // 缓冲区基地址
在上面我们向缓冲区中放入了10个字节大小的数据，FILE结构体中的 cnt 变为了10 ，说明此时缓冲区中有10个字节大小的数据可以读，同时我们假设缓冲区的基地址也就是 base 是0x00428e60 ，它是不变的 ，而此时 ptr 的值也为0x00428e60 ，表示从0x00428e60这个位置开始读取数据，当我们从缓冲区中读取5个数据的时候，cnt 变为了5 ，表示缓冲区还有5个数据可以读，ptr 则变为了0x0042e865表示下次应该从这个位置开始读取缓冲区中的数据 ，如果接下来我们再读取5个数据的时候，cnt 则变为了0 ，表示缓冲区中已经没有任何数据了，ptr 变为了0x0042869表示下次应该从这个位置开始从缓冲区中读取数据，但是此时缓冲区中已经没有任何数据了，所以要将输入流中的剩下的那10个数据放进来，这样缓冲区中又有了10个数据，此时 cnt 变为了10 ，注意了刚才我们讲到 ptr 的值是0x00428e69 ，而当缓冲区中重新放进来数据的时候这个 ptr 的值变为了0x00428e60 ，这是因为当缓冲区中没有任何数据的时候要将 ptr 这个值进行一下刷新，使其指向缓冲区的基地址也就是0x0042e860这个值！因为下次要从这个位置开始读取数据！
在这里有点需要说明：当我们从键盘输入字符串的时候需要敲一下回车键才能够将这个字符串送入到缓冲区中，那么敲入的这个回车键(\r)会被转换为一个换行符\n，这个换行符\n也会被存储在缓冲区中并且被当成一个字符来计算！比如我们在键盘上敲下了123456这个字符串，然后敲一下回车键（\r）将这个字符串送入了缓冲区中，那么此时缓冲区中的字节个数是7 ，而不是6。
缓冲区的刷新就是将指针 ptr 变为缓冲区的基地址 ，同时 cnt 的值变为0 ，因为缓冲区刷新后里面是没有数据的！

5. 缓冲区操作（设置、清除）

(1).清除文件缓冲区函数： int fflush(FILE *stream); int flushall(); fflush()函数将清除由stream指向的文件缓冲区里的内容，常用于写完一些数据后，立即用该函数清除缓冲区，以免误操作时，破坏原来的数据。 flushall()将清除所有打开文件所对应的文件缓冲区。

(2).设置文件缓冲区函数 void setbuf(FILE *stream,char *buf); void setvbuf(FILE *stream,char *buf,int type,unsigned size); 这两个函数将使得打开文件后，用户可建立自己的文件缓冲区，而不使用fopen()函数打开文件设定的默认缓冲区。

程序输出有两种方式：一种是即时处理方式，另一种是先暂存起来，然后再大块写入的方式，前者往往造成较高的系统负担。因此，c语言实现通常都允许程序员进行实际的写操作之前控制产生的输出数据量。这种控制能力一般是通过库函数setbuf实现的。如果buf是一个大小适当的字符数组，那么：setbuf(stdout，buf);语句将通知输入/输出库，所有写入到stdout的输出都应该使用buf作为输出缓冲区，直到buf缓冲区被填满或者程序员直接调用fflush（译注：对于由写操作打开的文件，调用fflush将导致输出缓冲区的内容被实际地写入该文件），buf缓冲区中的内容才实际写入到stdout中。缓冲区的大小由系统头文件&lt;stdio.h&gt;中的BUFSIZ定义。

函数setvbuf()用来设定文件流的缓冲区，其原型为：int setvbuf(FILE * stream, char * buf, int type, unsigned size);【参数】stream为文件流指针，buf为缓冲区首地址，type为缓冲区类型，size为缓冲区内字节的数量。
参数类型type说明如下：

    _IOFBF (满缓冲)：当缓冲区为空时，从流读入数据。或当缓冲区满时，向流写入数据。

    _IOLBF (行缓冲)：每次从流中读入一行数据或向流中写入—行数据。

    _IONBF (无缓冲)：直接从流中读入数据或直接向流中写入数据，而没有缓冲区。

【返回值】成功返回0，失败返回非0。

setbuf()和setvbuf()函数的实际意义在于：用户打开一个文件后，可以建立自己的文件缓冲区，而不必使用fopen()函数打开文件时设定的默认缓冲区。这样就可以让用户自己来控制缓冲区，包括改变缓冲区大小、定时刷新缓冲区、改变缓冲区类型、删除流中默认的缓冲区、为不带缓冲区的流开辟缓冲区等。

说明：在打开文件流后，读取内容之前，调用setvbuf()可以用来设置文件流的缓冲区。

文件的随机读写函数

前面介绍的文件的字符/字符串读写，均是进行文件的顺序读写，即总是从文件的开头开始进行读写。这显然不能满足我们的要求，C语言提供了移动文件指针和随机读写的函数，它们是：移动文件指针函数： long ftell(FILE *stream); int rewind(FILE *stream); fseek(FILE *stream,long offset,int origin); 函数ftell()用来得到文件指针离文件开头的偏移量。当返回值是-1时表示出错。rewind()函数用于文件指针移到文件的开头，当移动成功时，返回0，否则返回一个非0值。fseek()函数用于把文件指针以origin为起点移动offset个字节，其中origin指出的位置可有以下几种： origin 数值 代表的具体位置 SEEK_SET 0 文件开头 SEEK_CUR 1 文件指针当前位置 SEEK_END 2 文件尾 例如： fseek(fp,10L,0); 把文件指针从文件开头移到第10字节处，由于offset参数要求是长整型数，故其数后带L。 fseek(fp,-15L,2); 把文件指针从文件尾向前移动15字节。

6. 文件操作相关函数

一、打开文件操作：FILE *fopen(char *filename, char *mode)
    filename： 采用绝对或相对路径的目标文件名
    mode： 文件的类型和操作要求
    返回值： 目标文件指针或空指针值NULL(打开异常时)

文件类型 ：t (text): 文本文件（可省略不写）；   b (banary): 二进制文件

    从文件编码的方式来看，文件可分为ASCII码文件和二进制码文件两种。

    ASCII文件也称为文本文件，这种文件在磁盘中存放时每个字符对应一个字节，用于存放对应的ASCII码。ASCII码文件可在屏幕上按字符显示。二进制文件是按二进制的编码方式来存放文件的。
    二进制文件虽然也可在屏幕上显示，但其内容无法读懂。
    C系统在处理这些文件时，并不区分类型，都看成是字符流，按字节进行处理。输入输出字符流的开始和结束只由程序控制而不受物理符号(如回车符)的控制。 因此也把这种文件称作“流式文件”。把一个文本文件读入内存时，要将ASCII码转换成二进制码， 而把文件以文本方式写入磁盘时，也要把二进制码转换成ASCII码，因此文本文件的读写要花费较多的转换时间。对二进制文件的读写不存在这种转换。

文件操作类型：r (read): 读【目标文件必须存在，否则报错】
                    w (write): 写【目标不存在时自动创建】
                    a (append): 追加【目标文件必须存在，否则报错】
                    + : 读和写

操作类型组合方式

                                                                    操     作     说      明                                                            

&quot;rt&quot;

只读打开一个文本文件，只允许读数据

&quot;wt&quot;

只写打开或建立一个文本文件，只允许写数据

&quot;at&quot;

追加打开一个文本文件，并在文件末尾写数据

&quot;rb&quot;

只读打开一个二进制文件，只允许读数据

&quot;wb&quot;

只写打开或建立一个二进制文件，只允许写数据

&quot;ab&quot;

追加打开一个二进制文件，并在文件末尾写数据

&quot;rt+&quot;

读写打开一个文本文件，允许读和写

&quot;wt+&quot;

读写打开或建立一个文本文件，允许读写

&quot;at+&quot;

读写打开一个文本文件，允许读，或在文件末追加数据

&quot;rb+&quot;

读写打开一个二进制文件，允许读和写

&quot;wb+&quot;

读写打开或建立一个二进制文件，允许读和写

&quot;ab+&quot;

读写打开一个二进制文件，允许读，或在文件末追加数据

2) 凡用“r”打开一个文件时，该文件必须已经存在，且只能从该文件读出。
3) 用“w”打开的文件只能向该文件写入。若打开的文件不存在，则以指定的文件名建立该文件，若打开的文件已经存在，则将该文件删去，重建一个新文件。
4) 若要向一个已存在的文件追加新的信息，只能用“a”方式打开文件。但此时该文件必须是存在的，否则将会出错。
5) 在打开一个文件时，如果出错，fopen将返回一个空指针值NULL。在程序中可以用这一信息来判别是否完成打开文件的工作，并作相应的处理。

二、关闭文件操作：int fclose(FILE *fp)
    fp： 待关闭文件的文件指针。返回值： 0（正常关闭），非0（关闭异常）

三、 读字符函数： int fgetc(FILE *fp)
    fp： 待读文件的文件指针。返回值： 读出字符的ASCII码或EOF(文件结束时)

    fgetc函数的功能是从指定的文件中读一个字符。在文件内部有一个位置指针。用来指向文件的当前读写字节。在文件打开时，该指针总是指向文件的第一个字节。使用fgetc 函数后， 该位置指针将向后移动一个字节。文件结束时，该指针指向EOF， 因此可连续多次使用fgetc函数，读取多个字符直至遇到EOF为止。 应注意文件指针和文件内部的位置指针不是一回事。文件指针是指向整个文件的，须在程序中定义说明，只要不重新赋值，文件指针的值是不变的。文件内部的位置指针用以指示文件内部的当前读写位置，每读写一次，该指针均向后移动，它不需在程序中定义说明，而是由系统自动设置的。

对于fgetc函数的使用有以下几点说明：1) 在fgetc函数调用中，读取的文件必须是以读或读写方式打开的。2) 读取字符的结果也可以不向字符变量赋值， 例如： fgetc(fp); 但是读出的字符不能保存。3) 在文件内部有一个位置指针。用来指向文件的当前读写字节。在文件打开时，该指针总是指向文件的第一个字节。使用fgetc 函数后，该位置指针将向后移动一个字节。因此可连续多次使用fgetc函数，读取多个字符。

四、 写字符函数： int fputc(int ch, file *fp)
    ch： 待写入文件的字符的ASCII码。fp： 待写文件的文件指针。返回值： 如写入成功则返回写入的字符， 否则返回EOF。

putc函数的使用也要说明几点：1) 被写入的文件可以用写、读写、追加方式打开，用写或读写方式写入字符从文件首开始。如需保留原有文件内容，希望写入的字符被写入的文件若不存在，则创建该文件。2) 每写入一个字符，文件内部位置指针向后移动一个字节。3) fputc函数有一个返回值，如写入成功则返回写入的字符，否则返回一个EOF。可用此来判断写符，写入一个文件，再把该文件内容读出显示在屏幕上。

五、读字符串函数：char *fgets(char *str, int num, FILE *fp)
    str： 保存从文件读取出来的字符串。num： 表示从文件中读出的字符串不超过 n-1个字符。在读入的最后一个字符后加上串结束标志'/0'。fp： 待读文件的文件指针。返回值： 字符数组的首地址或者NULL（当读到文件末尾或发生错误时返回）
    功能描述： 读字符串函数fgets函数的功能是从指定的文件中读一个字符串到字符数组中，如：fgets(str,n,fp)的意义是从fp所指的文件中读出n-1个字符送入字符数组str中。

    对fgets函数有两点说明：1. 在读出n-1个字符之前，如遇到了换行符或EOF，则读出结束。2. fgets函数也有返回值，其返回值是字符数组的首地址。

六、写字符串函数： int fputs(char *str, file *fp)
    str： 待写入文件的字符串。fp： 待写文件的文件指针。返回值： 非负整数（成功），EOF(失败) 。
    功能描述： fputs函数的功能是向指定的文件写入一个字符串

七、数据块读写函数： int fwrite(void *buf, int size, int count, FILE *fp) | int fread(void *buf, int size, int count, FILE *fp)
    buf： 在fread函数中，它表示存放输入数据的首地址。在fwrite函数中，它表示存放输出数据的首地址。size： 表示数据块的字节。count： 表示要读写的数据块块数。fp：表示文件指针 。返回： 已读取或已写入的数据块块数
八、 格式化读写函数 int fscanf(FILE *fp, char *format,…) | int fprintf(FILE *fp, char *format,…)
    fscanf函数，fprintf函数与前面使用的scanf和printf 函数的功能相似，都是格式化读写函数。 两者的区别在于 fscanf 函数和fprintf函数的读写对象不是键盘和显示器，而是磁盘文件。

九、文件的随机读写
    前面介绍的对文件的读写方式都是顺序读写， 即读写文件只能从头开始，顺序读写各个数据。 但在实际问题中常要求只读写文件中某一指定的部分。 为了解决这个问题可移动文件内部的位置指针到需要读写的位置，再进行读写，这种读写称为随机读写。 实现随机读写的关键是要按要求移动位置指针，这称为文件的定位。文件定位移动文件内部位置指针的函数主要有两个， 即 rewind 函数和fseek函数。
rewind函数前面已多次使用过，其调用形式为： rewind(文件指针)； 它的功能是把文件内部的位置指针移到文件首。 下面主要介绍fseek函数。
    fseek函数用来移动文件内部位置指针，其调用形式为： fseek(文件指针，位移量，起始点)； 其中：“文件指针”指向被移动的文件。 “位移量”表示移动的字节数，要求位移量是long型数据，以便在文件长度大于64KB 时不会出错。当用常量表示位移量时，要求加后缀“L”。“起始点”表示从何处开始计算位移量，规定的起始点有三种：文件首，当前位置和文件尾。其表示方法如下：

起始点    表示符号    数字表示
──────────────────────────
文件首    SEEK—SET    0
当前位置   SEEK—CUR     1
文件末尾   SEEK—END     2

十、文件检测函数

    C语言中常用的文件检测函数有以下几个。一、文件结束检测函数feof函数调用格式： feof(文件指针)； 功能：判断文件是否处于文件结束位置，如文件结束，则返回值为1，否则为0。二、读写文件出错检测函数ferror函数调用格式： ferror(文件指针)； 功能：检查文件在用各种输入输出函数进行读写时是否出错。 如ferror返回值为0表示未出错，否则表示有错。三、文件出错标志和文件结束标志置0函数clearerr函数调用格式： clearerr(文件指针); 功能：本函数用于清除出错标志和文件结束标志，使它们为0值。
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="文件读写函数"><a class="header" href="#文件读写函数">文件读写函数</a></h2>
<pre><code>fopen FILE *fopen(char *filename, char *mode); 函数用来打开一个文件
fclose int fclose(FILE *fp);  
fgetc() int fgetc (FILE *fp); 函数每次只能读写一个字符
fputc() int fputc ( int ch, FILE *fp ); 函数每次只能读写一个字符
fgets char *fgets ( char *str, int n, FILE *fp ); 有局限性，每次最多只能从文件中读取一行内容，因为 fgets 遇到换行符就结束读取。
fputs int fputs( char *str, FILE *fp ); 
fread size_t fread ( void *ptr, size_t size, size_t count, FILE *fp );  读取多行内容
fwrite size_t fwrite ( void * ptr, size_t size, size_t count, FILE *fp ); 
rewind(fp); void rewind ( FILE *fp ); //将文件中的位置指针重新定位到文件开头
fseek()  int fseek ( FILE *fp, long offset, int origin ); 来将位置指针移动到任意位置
        offset 为偏移量，也就是要移动的字节数。之所以为 long 类型，是希望移动的范围更大，能处理的文件更大
        origin 为起始位置
        
        文件开头 SEEK_SET 0
        当前位置 SEEK_CUR 1
        文件末尾 SEEK_END 2
fscanf int fscanf ( FILE *fp, char * format, ... ); FILE *fp;
        int i, j;
        char *str, ch;
        fscanf(fp, &quot;%d %s&quot;, &amp;i, str);
        fprintf(fp,&quot;%d %c&quot;, j, ch);
fprintf() int fprintf ( FILE *fp, char * format, ... ); 
        
        


它的原型为：FILE *fopen(char *filename, char *mode);
Filename为文件名（包括文件路径），mode为打开方式，它们都是字符串。
fopen() 会获取文件信息，包括文件名、文件状态、当前读写位置等，并将这些信息保存到一个FILE类型的结构体变量中，然后将该变量的地址返回。
FILE是在stdio.h头文件中定义的一个结构体，用来保存文件信息。
如果希望接收 fopen() 的返回值，就需要定义一个 FILE 类型的指针。
例如：
FILE *fp = (&quot;demo.txt&quot;, &quot;r&quot;);表示以“只读”方式打开当前目录下的 demo.txt 文件，并使 fp 指向该文件，这样就可以通过 fp 来操作 demo.txt 了。
fp 通常被称为文件指针。
又如：FILE *fp = fopen(&quot;D:\\demo.txt&quot;,&quot;rb&quot;);表示以二进制方式打开 D 盘下的 demo.txt 文件，允许读和写。


打开方式 说明
r 以只读方式打开文件，只允许读取，不允许写入。该文件必须存在。
r+ 以读/写方式打开文件，允许读取和写入。该文件必须存在。
rb+ 以读/写方式打开一个二进制文件，允许读/写数据。
rt+ 以读/写方式打开一个文本文件，允许读和写。
w 以只写方式打开文件，若文件存在则长度清为0，即该文件内容消失，若不存在则创建该文件。
w+ 以读/写方式打开文件，若文件存在则文件长度清为零，即该文件内容会消失。若文件不存在则建立该文件。
a 以追加的方式打开只写文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾，即文件原先的内容会被保留（EOF符保留)。
a+ 以追加方式打开可读/写的文件。若文件不存在，则会建立该文件，如果文件存在，则写入的数据会被加到文件尾后，即文件原先的内容会被保留（原来的EOF符 不保留)。
wb 以只写方式打开或新建一个二进制文件，只允许写数据。
wb+ 以读/写方式打开或建立一个二进制文件，允许读和写。
wt+ 以读/写方式打开或建立一个文本文件，允许读写。
at+ 以读/写方式打开一个文本文件，允许读或在文本末追加数据。
ab+ 以读/写方式打开一个二进制文件，允许读或在文件末追加数据。


1) 文件打开方式由r、w、a、t、b、+ 六个字符拼成，各字符的含义是：
    • r(read)：读
    • w(write)：写
    • a(append)：追加
    • t(text)：文本文件，可省略不写
    • b(banary)：二进制文件
    • +：读和写

2) 如果没有“b”字符，文件以文本方式打开。

3) 凡用“r”打开一个文件时，该文件必须已经存在。

4) 在打开一个文件时，如果出错，fopen将返回一个空指针值NULL。在程序中可以用这一信息来判别是否完成打开文件的工作，并作相应的处理。

5) 把一个文本文件读入内存时，要将ASCII码转换成二进制码，而把文件以文本方式写入磁盘时，也要把二进制码转换成ASCII码，因此文本文件的读写要花费较多的转换时间。对二进制文件的读写不存在这种转换。

6) 标准输入文件 stdin（键盘）、标准输出文件 stdout（显示器）、标准错误文件 stderr（显示器）是由系统打开的，可直接使用。
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="sstream"><a class="header" href="#sstream">sstream</a></h2>
<p><sstream>库定义了三种类：istringstream、ostringstream和stringstream</p>
<p>stringstream通常是用来做数据转换的。</p>
<p>相比c库的转换，它更加安全，自动和直接。</p>
<pre><code class="language-c++">#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;iostream&gt; 

int main()
{
    std::stringstream stream;
    std::string result;
    int i = 1000;
    stream &lt;&lt; i; //将int输入流
    stream &gt;&gt; result; //从stream中抽取前面插入的int值
    std::cout &lt;&lt; result &lt;&lt; std::endl; // print the string &quot;1000&quot;
    stream.clear(); //在进行多次转换前，必须清除stream
} 

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-c++">#include &lt;assert.h&gt;
#include &lt;stdio.h&gt;

int main() {
    int a;
    char str[50];

    printf(&quot;请输入一个整数值： &quot;);
    scanf(&quot;%d\n&quot;, &amp;a);

    assert(a &gt;= 10);
    printf(&quot;输入的整数是：%d\n&quot;, a);

    printf(&quot;请输入字符串： &quot;);
    scanf(&quot;%s\n&quot;, &amp;str);
    assert(str != NULL);
    printf(&quot;输入的字符串是： %s\n&quot;, str);

    return 0;
}


a.out: assert.c:15: main: Assertion `a &gt;= 10' failed.
已放弃 (核心已转储)

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="简介-6"><a class="header" href="#简介-6">简介</a></h2>
<pre><code>C 标准库的 ctype.h 头文件提供了一些函数，可用于测试和映射字符。
这些函数接受 int 作为参数，它的值必须是 EOF 或表示为一个无符号字符。
如果参数 c 满足描述的条件，则这些函数返回非零（true）。如果参数 c 不满足描述的条件，则这些函数返回零。
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="简介-7"><a class="header" href="#简介-7">简介</a></h2>
<pre><code>C 标准库的 float.h 头文件包含了一组与浮点值相关的依赖于平台的常量。这些常量是由 ANSI C 提出的，这让程序更具有可移植性。在讲解这些常量之前，最好先弄清楚浮点数是由下面四个元素组成的：
组件 组件描述
S 符号 ( +/- )
b 指数表示的基数，2 表示二进制，10 表示十进制，16 表示十六进制，等等...
e 指数，一个介于最小值 emin 和最大值 emax 之间的整数。
p 精度，基数 b 的有效位数
基于以上 4 个组成部分，一个浮点数的值如下：
floating-point = ( S ) p x be
或
floating-point = (+/-) precision x baseexponent
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="简介-8"><a class="header" href="#简介-8">简介</a></h2>
<pre><code>limits.h 头文件决定了各种变量类型的各种属性。定义在该头文件中的宏限制了各种变量类型（比如 char、int 和 long）的值。
这些限制指定了变量不能存储任何超出这些限制的值，例如一个无符号可以存储的最大值是 255。
库宏
下面的值是特定实现的，且是通过 #define 指令来定义的，这些值都不得低于下边所给出的值。
</code></pre>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">宏</th><th style="text-align: left">值</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: left">CHAR_BIT</td><td style="text-align: left">8</td><td style="text-align: left">定义一个字节的比特数。</td></tr>
<tr><td style="text-align: left">SCHAR_MIN</td><td style="text-align: left">-128</td><td style="text-align: left">定义一个有符号字符的最小值。</td></tr>
<tr><td style="text-align: left">SCHAR_MAX</td><td style="text-align: left">127</td><td style="text-align: left">定义一个有符号字符的最大值。</td></tr>
<tr><td style="text-align: left">UCHAR_MAX</td><td style="text-align: left">255</td><td style="text-align: left">定义一个无符号字符的最大值。</td></tr>
<tr><td style="text-align: left">CHAR_MIN</td><td style="text-align: left">0</td><td style="text-align: left">定义类型 char 的最小值，如果 char 表示负值，则它的值等于 SCHAR_MIN，否则等于0。</td></tr>
<tr><td style="text-align: left">CHAR_MAX</td><td style="text-align: left">127</td><td style="text-align: left">定义类型 char 的最大值，如果 char 表示负值，则它的值等于 SCHAR_MAX，否则等于UCHAR_MAX。</td></tr>
<tr><td style="text-align: left">MB_LEN_MAX</td><td style="text-align: left">1</td><td style="text-align: left">定义多字节字符中的最大字节数。</td></tr>
<tr><td style="text-align: left">SHRT_MIN</td><td style="text-align: left">-32768</td><td style="text-align: left">定义一个短整型的最小值。</td></tr>
<tr><td style="text-align: left">SHRT_MAX</td><td style="text-align: left">+32767</td><td style="text-align: left">定义一个短整型的最大值。</td></tr>
<tr><td style="text-align: left">USHRT_MAX</td><td style="text-align: left">65535</td><td style="text-align: left">定义一个无符号短整型的最大值。</td></tr>
<tr><td style="text-align: left">INT_MIN</td><td style="text-align: left">-32768</td><td style="text-align: left">定义一个整型的最小值。</td></tr>
<tr><td style="text-align: left">INT_MAX</td><td style="text-align: left">+32767</td><td style="text-align: left">定义一个整型的最大值。</td></tr>
<tr><td style="text-align: left">UINT_MAX</td><td style="text-align: left">65535</td><td style="text-align: left">定义一个无符号整型的最大值。</td></tr>
<tr><td style="text-align: left">LONG_MIN</td><td style="text-align: left">-2147483648</td><td style="text-align: left">定义一个长整型的最小值。</td></tr>
<tr><td style="text-align: left">LONG_MAX</td><td style="text-align: left">+2147483647</td><td style="text-align: left">定义一个长整型的最大值。</td></tr>
<tr><td style="text-align: left">ULONG_MAX</td><td style="text-align: left">4294967295</td><td style="text-align: left">定义一个无符号长整型的最大值。</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h2 id="简介-9"><a class="header" href="#简介-9">简介</a></h2>
<pre><code>locale.h 头文件定义了特定地域的设置，比如日期格式和货币符号。接下来我们将介绍一些宏，以及一个重要的结构 struct lconv 和两个重要的函数。
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="简介-10"><a class="header" href="#简介-10">简介</a></h2>
<pre><code>math.h 头文件定义了各种数学函数和一个宏。在这个库中所有可用的功能都带有一个 double 类型的参数，且都返回 double 类型的结果。
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="简介-11"><a class="header" href="#简介-11">简介</a></h2>
<pre><code>setjmp.h 头文件定义了宏 setjmp()、函数 longjmp() 和变量类型 jmp_buf，该变量类型会绕过正常的函数调用和返回规则。
</code></pre>
<h2 id="库变量-6"><a class="header" href="#库变量-6">库变量</a></h2>
<pre><code>下面列出了头文件 setjmp.h 中定义的变量：
序号 变量 &amp; 描述
1 jmp_buf 
这是一个用于存储宏 setjmp() 和函数 longjmp() 相关信息的数组类型。
</code></pre>
<h2 id="库宏-6"><a class="header" href="#库宏-6">库宏</a></h2>
<pre><code>下面是这个库中定义的唯一的一个宏：
序号 宏 &amp; 描述
1 int setjmp(jmp_buf environment)
这个宏把当前环境保存在变量 environment 中，以便函数 longjmp() 后续使用。如果这个宏直接从宏调用中返回，则它会返回零，但是如果它从 longjmp() 函数调用中返回，则它会返回一个非零值。
</code></pre>
<h2 id="库函数-5"><a class="header" href="#库函数-5">库函数</a></h2>
<pre><code>下面是头文件 setjmp.h 中定义的唯一的一个函数：
序号 函数 &amp; 描述
1 void longjmp(jmp_buf environment, int value)
该函数恢复最近一次调用 setjmp() 宏时保存的环境，jmp_buf 参数的设置是由之前调用 setjmp() 生成的。
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="c-3"><a class="header" href="#c-3">c++</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h3 id="c-4"><a class="header" href="#c-4">c++</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h3 id="c-5"><a class="header" href="#c-5">c++</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h3 id="c-6"><a class="header" href="#c-6">c++</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h3 id="c-7"><a class="header" href="#c-7">c++</a></h3>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_line_numbers = true;
        </script>
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
    </body>
</html>
