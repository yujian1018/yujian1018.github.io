<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>2.基础 on My New Hugo Site</title>
    <link>https://yujian1018.github.io/book/erlang/2.%E5%9F%BA%E7%A1%80/</link>
    <description>Recent content in 2.基础 on My New Hugo Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 30 Aug 2019 10:56:29 +0800</lastBuildDate>
    
	<atom:link href="https://yujian1018.github.io/book/erlang/2.%E5%9F%BA%E7%A1%80/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>2.1 Erlang终端</title>
      <link>https://yujian1018.github.io/book/erlang/2.%E5%9F%BA%E7%A1%80/2.1-erlang%E7%BB%88%E7%AB%AF/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/erlang/2.%E5%9F%BA%E7%A1%80/2.1-erlang%E7%BB%88%E7%AB%AF/</guid>
      <description>在unix终端中输入erl来打开Erlang终端。Erlang终端简称（Eshell) 在windows中我们可以通过单击&amp;quot;开始&amp;quot;菜单中的Erlang运行图标来打开。
当进入Eshell中，请尝试输入一些整数，在表达式的最后需要使用英文句号(句点)来终止，然后按回车键执行：
1&amp;gt; -234. -234 2&amp;gt; 2#1010. 10 3&amp;gt; $A. 65 如果在输入结束时没有输入句点，那么Eshell就不会对你的输入值进行求值，并会继续接收你后续输入的信息，知道输入句点并且按下回车键执行
4&amp;gt; 5- 4&amp;gt; 4&amp;gt; 4. 1 1&amp;gt; 和 2&amp;gt; 都是命令提示符，这表明Erlang已经准备好接受输入。当你按下回车键且结束行也使用了句点，那么Erlang就会对你所输人的内容进行求值，如果成功的话，就会显示出结果。请注意各种不同的整数表达式都转换和显示为十进制形式。如果你输人一个无效的表达式，你会得到一个错误，比如:
4&amp;gt; 5-. * 5: syntax error before: &amp;#39;.&amp;#39; 5&amp;gt; q(). 要从一个错误中故复，只需要多按几次回车键，海加上句点，最后再按下回车键。如果你想退出Erlang终端窗口，那么请输入
5&amp;gt; q(). 并加上句点。
  在Erlang Shell中可以方便的做进制转换:Base#Value Base的范围2~16 2#101011
  Erlang Shell中查询ASCII码 $1 $a $A $\n $}
  Erlang Shell中释放变量使用f() 定义record使用rd(),读取shell输入使用io:read/1可以接受输入Erlang term
  Erlang Shell中接受消息使用flush() 自己的Pid是self() 查看进程信息使用processes() i() 但是不要在进程非常多的场景使用,会消耗大量内存
  使用 CTRL ＋ \ 或 init:stop()， 可以退出Erlang，</description>
    </item>
    
    <item>
      <title>2.2 基础语法</title>
      <link>https://yujian1018.github.io/book/erlang/2.%E5%9F%BA%E7%A1%80/2.2-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/erlang/2.%E5%9F%BA%E7%A1%80/2.2-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</guid>
      <description>注释 注释不会被编译
单行注释，你可以在任何地方使用以 %% 开头的单行注释。 多行注释等同于单行注释
%%  if test(A, B) -&amp;gt; if (A &amp;gt; 1) andalso (B &amp;gt; 1) -&amp;gt; 1; true -&amp;gt; 2 end.  if语句会对Guard子句做catch,所以 if 1/0 -&amp;gt;a; true -&amp;gt;b end.的返回值是b而不是抛出异常 if的Guard子句放在变量里就可以让异常抛出来:G=1/0 , if G-&amp;gt;a; true -&amp;gt;b end. Guard subexpressions resulting in a runtime error are treated as returning false. Guard可以使用, ; 表达多个条件if X=:=1,Y&amp;lt;2;X+Y&amp;lt;4 -&amp;gt;ok; true -&amp;gt;error end.  case a(Arg) -&amp;gt; case Arg of undefined -&amp;gt; A = 1, B = 2; {ok, arg} -&amp;gt; A = 3, B = 4 end, A + B.</description>
    </item>
    
    <item>
      <title>2.2.1 异常处理</title>
      <link>https://yujian1018.github.io/book/erlang/2.%E5%9F%BA%E7%A1%80/2.2.1-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/erlang/2.%E5%9F%BA%E7%A1%80/2.2.1-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</guid>
      <description>即便是Erlang程序员也难免会写出有问题的程序。代码中的语法错误（和一些语义错误）可以借助编译器检测出来，但程序仍可能含有逻辑错误。对需求理解的偏差或对需求实现的不完备所造成的逻辑错误只能通过大量的一致性测试来检测。其他的错误则以运行时错误的形式出现。 函数是在Erlang进程中执行的。函数可能出于多种原因而失败，比如： * 一次匹配操作失败 * 使用错误的参数调用BIF * 我们可能打算对一个算术表达式求值，然而其中的一个项式并不是数值 Erlang本身当然无法修正这些情况，但它为程序员提供了一些检测和处理失败情况的机制。借助这些机制，程序员可以设计出健壮和容错的系统。Erlang具备如下机制： * 监视表达式的求值 * 监视其他进程的行为 * 捕获对未定义函数的求值 Catch和Throw catch和throw提供了一种表达式求值的监视机制，可以用于 &amp;gt; 处理顺序代码中的错误（catch） &amp;gt; 函数的非本地返回（catch结合throw） 表达式求值失败（如一次匹配失败）的一般后果是导致求值进程的异常退出。通过以下方式可以借助catch来更改这个默认行为： catch Expression 若表达式的求值过程没有发生错误，则catch Expression返回Expression的值。于是catch atom_to_list(abc)会返回[97,98,99]、catch 22会返回22。 若求值过程失败，catch Expression将返回元组{&amp;#39;EXIT&amp;#39;, Reason}，其中Reason是用于指明错误原因的原子式。于是catch an_atom - 2会返回{&amp;#39;EXIT&amp;#39;, badarith}、catch atom_to_list(123)会返回{&amp;#39;EXIT&amp;#39;, badarg}。 函数执行结束后，控制流程便返还者。throw/1可以令控制流程跳过调用者。如果我们像上述的那样计算catch Expression，并在Expression的求值过程中调用throw/1，则控制流程将直接返回至catch。注意catch可以嵌套；在嵌套的情况下，一次失败或throw将返回至最近的catch处。在catch之外调用throw/1将导致运行时错误。 下面的例子描述了catch和throw的行为。定义函数foo/1： foo(1) -&amp;gt; hello; foo(2) -&amp;gt; throw({myerror, abc}); foo(3) -&amp;gt; tuple_to_list(a); foo(4) -&amp;gt; exit({myExit, 222}). 假设在不使用catch的情况下，一个进程标识为Pid的进程执行了这个函数，则： foo(1) 返回hello。 foo(2) 执行throw({myerror,abc})。由于不在catch的作用域内，执行foo(2)的进程将出错退出。 foo(3) 执行foo(3)的进程执行BIF tuple_to_list(a)。这个BIF用于将元组转换为列表。在这个例子中，参数不是元组，因此该进程将出错退出。 foo(4) 执行BIF exit/1。由于不在catch的范围内，执行foo(4)的函数将退出。很快我们就会看到参数{myExit,222}的用途。 foo(5) 执行foo(5)的进程将出错退出，因为函数foo/1的首部无法匹配foo(5)。 现在让我们来看看在catch的作用域内对foo/1以相同的参数进行求值会发生什么： demo(X) -&amp;gt; case catch foo(X) of {myerror, Args} -&amp;gt; {user_error, Args}; {&amp;#39;EXIT&amp;#39;, What} -&amp;gt; {caught_error, What}; Other -&amp;gt; Other end.</description>
    </item>
    
    <item>
      <title>2.3 数据类型</title>
      <link>https://yujian1018.github.io/book/erlang/2.%E5%9F%BA%E7%A1%80/2.3-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/erlang/2.%E5%9F%BA%E7%A1%80/2.3-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid>
      <description>1. 变量 1.变量不变 在erlang中的变量只能被赋值一次，变量第一个字母要是大写的。 在erlang中变量是不可变的，也没有共享内存的概念，也没有锁。
2.模式匹配 符号”=”是值类型匹配操作(带有赋值的意思)。（pattern matching）
 2.整数 一个整数
-234 0 10 10000000 2#1010 -16#EA $a $A $\n 1&amp;gt; Color = 16#F09A29. 15768105 2&amp;gt; Pixel = &amp;lt;&amp;lt;Color:24&amp;gt;&amp;gt;. &amp;lt;&amp;lt;240,154,41&amp;gt;&amp;gt; Erlang中整型数据的计算是精确的，整型变量可代表的数据长度仅受限于可用的内存。 Erlang中可表达和使用任意大的整数。当一个整数大到一个word不能容纳的时候，Erlang内部会自动把它转换成用多个word表示的bignums类型。 可以用下面3种不同的语法来表达一个整型数值。
 传统语法:这种写法是我们最为熟悉的，比如1112. 12375、-23427都是整数。 K进制整数:不以10为进制的整数可以用语法K#Digits来表示。因此我们可以写一个二 进制数2#00101010或者一个16进制数16#af6bfa23。对于大于10进制的整数，用字符abc&amp;hellip;(或 ABC二。)来表示数值10. 11, 12等。这种语法所能表示的最高进制为36进制。 $语法:语法$C表示ASCII字符C的整数值，因此$a是97的简写，$1是49的简写，等等。 紧随$之后，我们还可以使用表5-1中描述的任何转义符。因此$\n就是10, $^c是3，等等。 下面是一些整数的例子: 0 -65 2#010001110 ~8#377 16#fe34 16#FE34 36#wow (它们的值分别是0 -65 142 -255 65076 65076和423680)  Base#Value符号表示基数不是10的整数 Base是一个介于2～16的整数
 3. 浮点数    整数除法示例: 4 div 2。</description>
    </item>
    
    <item>
      <title>2.4 运算符</title>
      <link>https://yujian1018.github.io/book/erlang/2.%E5%9F%BA%E7%A1%80/2.4-%E8%BF%90%E7%AE%97%E7%AC%A6/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/erlang/2.%E5%9F%BA%E7%A1%80/2.4-%E8%BF%90%E7%AE%97%E7%AC%A6/</guid>
      <description>转义符 \b 退格 \d 删除 \e 转义 \f 换页 \n 新行 \r 换行 \s 空格 \t 制表符 \v 纵向制表符 \&amp;#39; 单引号 \&amp;#34; 双引号 \\ 反斜杠 \C C的ASCII码（C是一个字符） 操作符 X&amp;gt;Y X大于Y X&amp;lt;Y X小于Y X=&amp;lt;Y X小于等于Y X&amp;gt;=Y X大于等于Y X==Y X等于Y X/=Y X不等于Y X=:=Y X全等于Y 值和类型都必须相同 2 =:= 2.0 -&amp;gt; false X=/=Y X不全等于Y number&amp;lt;atom&amp;lt;reference&amp;lt;fun&amp;lt;port&amp;lt;pid&amp;lt;tuple&amp;lt;list&amp;lt;binary 布尔表达式 and 两个参数都是真，返回真 andalso 如果第一个参数是假，返回假 or orelse 如果第一个参数是真，返回真。 xor “异或”：如果两个参数的任何一个参数是真，并且另一个是假，那么返回真 not 一元否定运算符：如果参数是假，那么就返回真 算术表达式 | 操作 | 描述 | 优先级 | | --- | --- | --- | | +X | 一元操作符 + | 1 | | -X | 一元操作符 1 | 2 | | X*Y | X*Y | 2 | | X/Y | X/Y(浮点数相除) | 2 | | X div Y | X整除Y | 2 | | X rem Y | X除Y取余数 | 2 | | bnot X | 对X按位取反 | 2 | | X band Y | 对X和Y安位取与 | 2 | | X+Y | | 3 | | X-Y | | 3 | | X bor Y | 对X和Y按位取或 | 3 | | X bxor Y | 对X和Y按位进行异或 | 3 | | X bsl N | 对X按位左移N位 | 3 | | XbsrN | 对X按位右移N位 | 3 | 2 bsl 5 将整数2左移5位。2转化为二进制10向左移5位变为1000000 转化为10进制64 2 bsr 5 将整数2右移5位。原理相同 band,bor,bxor,bnot 位逻辑运算符。 X band (bnot Y)会在X中将Y所占用的位清零 一元操作符＋和-拥有最高的优先级:其次是乘、除和取余数操作，而加法和减法的优先级别最低。 </description>
    </item>
    
    <item>
      <title>2.5 模块属性</title>
      <link>https://yujian1018.github.io/book/erlang/2.%E5%9F%BA%E7%A1%80/2.5-%E6%A8%A1%E5%9D%97%E5%B1%9E%E6%80%A7/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/erlang/2.%E5%9F%BA%E7%A1%80/2.5-%E6%A8%A1%E5%9D%97%E5%B1%9E%E6%80%A7/</guid>
      <description>模块属性 -module(modname). -import(...). -export(...). -compile(Options). -compile(export_all)%属性经常被使用在调试程序中。 -compile( {parse_transform, Module} ). -vsn(Version). %最后一个选项为增加编译选项，Options可以是单个选项或者选项列表。 -vsn(Version).%中的Version可以是任意字符条目。 vim attrs.erl
-module(attrs). -vsn(1234). -author({joe，armstrong}). -purpose(&amp;#34;example of attributes&amp;#34;). -export( [fac/1]). -type player_id() :: neg_integer(). -callback fun( PlayerId::player_id() ) -&amp;gt; boolean(). fac(1) -&amp;gt; 1; fac(N) -&amp;gt; N*fac(N一1). $ erlc attrs.erl $ erl -pa ./ 1&amp;gt; attrs:module_info(). [{exports，[{fac，1}，{rnodul a_ info，0}，{rnodul e_i nfo，1}]}， {imports，[]}， {attributes，[{vsn，[1234]}， {author，[{joe，armstrong}]}， {purpose，&amp;#34;example of attributes&amp;#34;}]}， {compile，[{options，[{cwd，&amp;#34;/home/joe/2006/book/JAERLANG/Book/code&amp;#34;}， {outdir，&amp;#34;/home/joe/2006/book/JAERLANG/Book/code&amp;#34;}]}， {version，&amp;#34;4.4.3&amp;#34;}， {time，{2007，2，21，19，23，48}}， {source，&amp;#34;/home/joe/2006/book/JAERLANG/Book/code/attrs.erl&amp;#34;}]}] 2&amp;gt; attrs:module_info(attributes). [{vsn，[1234]}，{author，[{joe，armstrong}]}，{purpose，&amp;#34;example of attributes&amp;#34;}] 3&amp;gt; beam_ lib:chunks(&amp;#34;attrs.</description>
    </item>
    
  </channel>
</rss>