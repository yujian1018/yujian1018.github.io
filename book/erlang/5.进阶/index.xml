<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>5.进阶 on My New Hugo Site</title>
    <link>http://example.org/5.%E8%BF%9B%E9%98%B6/</link>
    <description>Recent content in 5.进阶 on My New Hugo Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 30 Aug 2019 10:56:29 +0800</lastBuildDate>
    
	<atom:link href="http://example.org/5.%E8%BF%9B%E9%98%B6/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>5</title>
      <link>http://example.org/5.%E8%BF%9B%E9%98%B6/5.1tcp%E7%B2%98%E5%8C%85%E5%A4%A7%E5%B0%8F%E7%AB%AF/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>http://example.org/5.%E8%BF%9B%E9%98%B6/5.1tcp%E7%B2%98%E5%8C%85%E5%A4%A7%E5%B0%8F%E7%AB%AF/</guid>
      <description>1.粘包问题 数据连包问题，这个在client/server的通讯中很常见。就是，当client在极短的时间内发送多个包给server，这时server在接收数据的时候可能发生连包问题，就一次性接收这几个包的数据，导致数据都粘连在一起。
这里先讨论{packet, raw}或者{packet,0}的情况，分别看下{active, Boolean}的两种方式：
gen_tcp对socket数据封包的获取有以下2种方式，
1、{active, false} 方式通过 gen_tcp:recv(Socket, Length) -&amp;gt; {ok, Data} | {error, Reason} 来接收。 gen_tcp:recv/2,3，如果封包的类型是{packet, raw}或者{packet,0}，就需要显式的指定长度，否则封包的长度是对端决定的，长度只能设置为0。如果长度Length设置为0，gen_tcp:recv/2,3会取出Socket接收缓冲区所有的数据
2、{active, true} 方式以消息形式{tcp, Socket, Data} | {tcp_closed, Socket} 主动投递给线程。 缓存区有多少数据，都会全部以消息{tcp, Socket, Data} 投递给线程。
以上就会导致数据连包问题，那么如何解决呢？
{packet, PacketType}
现在再来看下 {packet, PacketType}，erlang的解释如下： raw | 0 没有封包，即不管数据包头，而是根据Length参数接收数据。
1 | 2 | 4 表示包头的长度，分别是1,2,4个字节（2,4以大端字节序，无符号表示），当设置了此参数时，接收到数据后将自动剥离对应长度的头部，只保留Body。
asn1 | cdr | sunrm | fcgi |tpkt|line 设置以上参数时，应用程序将保证数据包头部的正确性，但是在gen_tcp:recv/2,3接收到的数据包中并不剥离头部。
http | http_bin 设置以上参数，收到的数据将被erlang:decode_packet/3格式化，在被动模式下将收到{ok, HttpPacket},主动模式下将收到{http, Socket, HttpPacket}.
{packet, N} 也就是说，如果packet属性为1,2,4，可以保证server端一次接收的数据包大小。
下面我们以 {packet, 2} 做讨论。 gen_tcp 通信传输的数据将包含两部分：包头+数据。gen_tcp:send/2发送数据时，erlang会计算要发送数据的大小，把大小信息存放到包头中，然后封包发送出去。 所以在接收数据时，要根据包头信息，判断接收数据大小。使用gen_tcp:recv/2,3接收数据时，erlang会自动处理包头，获取封包数据。</description>
    </item>
    
    <item>
      <title>5</title>
      <link>http://example.org/5.%E8%BF%9B%E9%98%B6/5.2rebar%E5%8F%91%E5%B8%83%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>http://example.org/5.%E8%BF%9B%E9%98%B6/5.2rebar%E5%8F%91%E5%B8%83%E7%B3%BB%E7%BB%9F/</guid>
      <description>以发布ping为例 1.获取源码+deps，并且完成编译
2生成配置文件 cd ~ mkdir rel cd rel ../rebar create-node nodeid=ping
3.修改原始配置文件, reltool.config lib_dirs %配置deps库路径，必须配置打包应用的路径 {lib_dirs, [&amp;quot;../&amp;quot;, &amp;ldquo;../deps/&amp;quot;, &amp;ldquo;../apps/&amp;quot;]}
{incl_cond, exclude}, %该选项需要列出需要的erlang lib库 {incl_cond, derived}, %该选项默认erlang lib库，不需要自己写
{rel, &amp;ldquo;game&amp;rdquo;, &amp;ldquo;1&amp;rdquo;, %版本号
{app, ranck, [{mod_cond, app}, {incl_cond, include}]} %第三方库或者app配置
{app, game, [{incl_cond, include}, {lib_dir, &amp;ldquo;..&amp;quot;}]}, %或者配置该应用的路径
rebar.config {sub_dirs, [&amp;ldquo;rel&amp;rdquo;]}.
4.生成系统 cd rel ../rebar generate
release_handler:which_releases(). %%查看当前版本
5.热更
&amp;lt;4&amp;gt;生成版本1.0.0 修改了代码，此时需要热更 源打包文件夹重命名成rel_1.0.0
a.修改配置文件 ping.app.src %修改版本号 reltool.config %修改版本号 b.重新release cd rel ../rebar generate .</description>
    </item>
    
    <item>
      <title>5</title>
      <link>http://example.org/5.%E8%BF%9B%E9%98%B6/5.3erlangvm%E5%BF%83%E8%B7%B3/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>http://example.org/5.%E8%BF%9B%E9%98%B6/5.3erlangvm%E5%BF%83%E8%B7%B3/</guid>
      <description>erlang心跳机制
什么是erlang心跳机制？这是erlang运行时系统定期监控系统是否正常运行的程序。 erlang为什么要心跳机制？我们都知道，erlang有很多进程监督树，启动了很多supervisor来保证process的高可靠性， 但如果连emulator也死掉了，那erlang也就回天乏术了， 所以这时只能靠heart 来重新启动erlang。
1. C:\&amp;gt;erl -heart -env HEART_COMMAND &amp;quot;erl -heart&amp;quot; 2. Eshell V5.10.2 (abort with ^G) 3. 1&amp;gt;  这时候你可以按 CTRL + C 挂起erlang，或者直接关闭 erlang shell 窗口，系统都会重新打开erlang shell
erlang心跳原理 erlang心跳机制的实现原理是启动一个 heart 进程，通过定时发送特定消息来检查erlang是否正常回应，收不到回应则判断erlang没有正常工作。 erlang心跳参数 参数项 说明 注意 HEART_COMMAND 心跳监控程序发现erlang没正常运行时执行的命令 在Windows下还可以调用其他进程或命令 HEART_BEAT_TIMEOUT 心跳超时，如果监控程序发出的检查消息在这个时间没有得到回应，就会执行 HEART_COMMAND 命令，默认60秒，有效范围 10 ~ 65535 如果调整系统时间，而且超过了这个限定，erlang进程也会被重启 ERL_CRASH_DUMP_SECONDS 用以控制erlangg崩溃时写日志的行为。0表示不写日志；-1表示写完日志再重启erlang；其他表示写入的等待完成时间，如果还没写完也将强制重启。默认0 如果这个参数没有设置，erlang就不会写crash日志
 % 获取 HEART_COMMAND 命令
2. 1&amp;gt; heart:get_cmd().
3. {ok,&amp;ldquo;erl -heart&amp;rdquo;}
4.
5. % 设置临时 HEART_COMMAND 命令</description>
    </item>
    
    <item>
      <title>5</title>
      <link>http://example.org/5.%E8%BF%9B%E9%98%B6/5.4erlanggc/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>http://example.org/5.%E8%BF%9B%E9%98%B6/5.4erlanggc/</guid>
      <description>二进制存储
erlang二进制数据在内存中有两种存在形式，当数据大小不到 64 bytes，就直接存在进程堆内，如果超过了64 bytes，就被保存到进程外的共享堆里，可以给节点内所有进程共享。
erlang有两种二进制容器：heap binaries和refc binaries。
heap binaries 这个就是进程堆二进制，是一些比较小的二进制数据，每个数据大小不超过64bytes，这些数据保存在进程堆内。对于这里的二进制数据，垃圾回收走的是进程堆数据的回收机制，参考这里。如果发给其他进程的消息含有这些数据，erlang将直接复制一份到别的进程堆内。
refc binaries 官方的叫法是引用计数二进制，就是对于那些超过64bytes的二进制数据，他们如果直接保存在进程堆内，将导致进程频繁的gc，比较大的数据复制来复制去开销也很大。所以，erlang将这些数据保存在进程外的共享堆，再把这个二进制数据的地址给拥有这个数据的进程。所以，进程堆内保存的是这个二进制数据的引用，叫ProcBin。如果进程把这个二进制数据发给其他进程，erlang也不再复制整个二进制数据，而是直接再生成一份ProcBin到别的进程堆内。那么，这个二进制数据就可以多个进程的ProcBin引用，当没有一个ProcBin引用到这个二进制数据，这个二进制就被erlang回收。
所以，这种二进制数据的gc的是引用计数的回收机制。注意了，ProcBin是进程堆内数据，走的是进程堆数据的回收方式。
进程间存储 使用分代</description>
    </item>
    
    <item>
      <title>5</title>
      <link>http://example.org/5.%E8%BF%9B%E9%98%B6/5.5erlangtime/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>http://example.org/5.%E8%BF%9B%E9%98%B6/5.5erlangtime/</guid>
      <description>os:timestamp() 获取到的时间为操作系统的时间，不做任何修正；
而erlang:now()，每次获取都会确保生成了唯一的时间，就是说，erlang:now()在实现上对时间做了一个校正，每次都生成一个单调向前的唯一值。
主要是这3个特点：
特点
说明
单调向前
erlang:now() 获取的时间是单调向前，就算系统时间倒退了，也不会影响这个函数的使用。（时间依旧是向前的，较之前几乎没有偏差）
唯一性
erlang:now() 获取的值都是唯一的，不会重复出现2个相同的值。
间隔修正
两次 erlang:now() 调用的间隔都可以被利用来修正erlang时间。
erlang 时间校正 时间校正的作用： 在开始这段内容前，讲讲时间校正的作用
  时间单调向前： 举个例子，说明时间倒退问题： 比如，游戏中会统计今天和昨天杀怪的总数量，跨零点时要把今天杀怪字段的数量写到昨天的字段，然后将今天的置0。跨零点后，如果时间倒退了几秒钟，然后就会重复跨零点。那么，今天的数量会覆盖昨天的数量，导致昨天的数量被清零。
  时间平稳： 同样举个例子，说明时间不平稳问题： 比如，erlang开发中，经常都会出现一个进程call另一个进程的场景，一般是5秒超时，假如时间突然加快了5秒，就相当于没有等待操作完成，就直接超时了。当然这是很不合理的
  假如操作系统时间出现了改变，erlang不会立刻改变内部时间为系统时间，而是将时间轻微加快或减慢，最终和系统时间保持一致。就算系统时间突然倒退到以前的某个时间，但时间总是向前这点是不会改变的，所以，erlang只是预期在将来某个时间和系统时间达成一致，而不会倒退时间。
erlang是怎么校正时间的？ erlang内部时间会和系统挂钟时间保持同步，当系统挂钟时间突然改变时，erlang会比较两个时间的差异，让内部的时间的同步值轻微变大或变小，幅度最大是1%，就是说，VM经历 1s 实际上可能就是 0.99s 或者1.01s。当系统时间改变了1分钟，erlang会花100分钟来慢慢校正，并最终和系统时间保持同步。
哪些函数受到时间校正影响？ erlang:now/0 The infamous erlang:now/0 function uses time correction so that differences between two &amp;ldquo;now-timestamps&amp;rdquo; will correspond to other timeouts in the system. erlang:now/0 also holds other properties, discussed later. receive &amp;hellip; after Timeouts on receive uses time correction to determine a stable timeout interval.</description>
    </item>
    
    <item>
      <title>5</title>
      <link>http://example.org/5.%E8%BF%9B%E9%98%B6/5.6erlang%E5%90%AF%E5%8A%A8/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>http://example.org/5.%E8%BF%9B%E9%98%B6/5.6erlang%E5%90%AF%E5%8A%A8/</guid>
      <description>官方文档：http://www.erlang.org/doc/man/erl.html
erlang启动参数有3种：emulator flags, flags 和plain arguments。
emulator flags 是以“+”开头的，用来控制虚拟机的行为，附送一个非常实用的例子：
erl +p 100000 #	最大进程数 erl -pa ebin +K true #开启epoll调度，在linux中开启epoll，会大大增加调度的效率 +A 10 #异步线程池大小默认10 +sbt db #绑定调度器，绑定后调度器的任务队列不会在各个CPU线程之间跃迁，结合sub使用，可以让CPU负载均衡的同时也避免了大量的跃迁发生。	注意：一个linux系统中，最好只有一个evm开启此选项，若同时有多个erlang虚拟机在系统中运行，还是关闭为好 +sub true #开启CPU负载均衡，false的时候是采用的CPU密集调度策略，优先在某个CPU线程上运行任务，直到该CPU负载较高为止。 +sbwt very_long #此选项设置为eager后，CPU将更频繁的被唤醒，可以增加CPU利用率 +swt very_low +Mulmbcs 32767 +Mumbcgs 1 +Musmbcs 2047 +spp true	#开启并行port并行调度队列，当开启后会大大增加系统吞吐量，如果关闭，则会牺牲吞吐量换取更低的延迟。 +zdbbl 65536	分布式erlang的端口buffer大小，当buffer满的时候，向分布式的远程端口发送消息会阻塞 +e Number Ets表的最大数量 +ec 强制Ets表启动压缩 +fnl 如果文件使用了ISO-latin-1编码 +fnu(w|i|e) 文件使用utf8编码 +fna(w|i|e) 和当前系统一致 +hms Size 指定erlang进程的默认最小堆内存大小 +hmbs Size 指定进程默认二进制虚拟内存堆大小 +hpds Size initial process dictionary size flags 是以“-”开头的， 是erlang运行时系统的参数，可以用init:get_argument/1获得。 plain arguments 普通参数，在第一个flag参数前，或在&amp;ndash; flag之后，-extra后的参数都是普通参数。</description>
    </item>
    
    <item>
      <title>5</title>
      <link>http://example.org/5.%E8%BF%9B%E9%98%B6/5.7erlang%E7%B3%BB%E7%BB%9F%E9%99%90%E5%88%B6/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>http://example.org/5.%E8%BF%9B%E9%98%B6/5.7erlang%E7%B3%BB%E7%BB%9F%E9%99%90%E5%88%B6/</guid>
      <description>ets表	1400	erl -env ERL_MAX_ETS_TABLES 1000000 erl +e 1000000 并发数	erl +P 1000000 erlang:system_info(process_limit).	2^18=262144 最大值为2^27-1=134217727	erlang实际使用的进程数量限制可能比你设置的要大得多，这是因为erlang运行系统选择的进程数量限制通常是2的幂 有效范围是1024-134217727 打开文件数	linux并发读取文件最大数量 erlang:system_info(min_heap_size). {min_heap_size,233} min_heap_size是进程最小堆大小这个参数两个地方会用到， 第一处是erlang初始化进程堆大小， 第二处是gc后堆收缩后维持的最小值， erlang:system_info(min_bin_vheap_size).	{min_bin_vheap_size,46368}	min_bin_vheap_size是进程最小虚拟二进制堆大小，这两个参数都是以word为单位。 初始化足够大的初始内存，可以减少轻度gc的次数，减少反复申请和回收内存的开销 erlang:system_info(fullsweep_after). {fullsweep_after,65535}	fullsweep_after控制深扫描的频率 这个参数确定多少次gc后执行一次深度gc，默认值为65536，有点大了 erlang:system_info(check_io).	erlang:statistics(garbage_collection).	{433,750604,0}	erlang:statistics(io).	{{input,3020851},{output,31981}}	节点名称限制	一个节点的远程节点的最大数目是由可用于节点名称atom的最大数目的限制，换句话说，节点名称限制数量取决于atom的最大数量。另外，节点名称长度也和atom有关，不能超过255个字符。 节点连接限制	能够同时连接的最大节点数是由节点名称限制，可用端口限制，或者可用socket限制共同决定 atom的最大数量	设置erlang系统最大能够处理的原子（atom）数量，默认是1048576 通过配置erlang启动参数（标志+t）可以改变进程数量限制 一个atom最多能有255个字符 tuple中最大元素数量	2^26=67108863个 二进制数据(binary)的大小限制 32位机器上最大不超过 2^29-1 = 536870911 个字节 64位机器上最大不超过 2^61-1 = 2305843009213693951 个字节 果超出限制，erlang位语法（bit syntax）将无法工作，直接抛出 system_limit 异常 一个Erlang节点最大分配的数据空间大小	Erlang运行时系统可以使用到32（或64）位地址空间，事实上，操作系统对单个进程的使用空间做了限制 同时打开的端口数量限制	erlang对同时打开的端口数量做出了限制。默认是65536，Windows下是8096。有效值范围是1024-134217727 erlang:system_info(port_limit)	可以通过环境变量ERL_MAX_PORTS修改，或者配置erlang启动参数（标志+Q）修改 erlang实际使用的端口数量限制可能比你设置的要大得多，这是因为erlang运行系统选择的端口数量限制通常是2的幂 同时打开的文件和socket数量限制	能同时打开的最大文件和socket数量取决于最大能打开的端口数量，以及操作系统的设定和限制 dets表存储限制	单个dets文件大小不能超过2G，在64位的系统也有此限制，mnesia也受到这个限制 The unit of measurement is memory words.</description>
    </item>
    
  </channel>
</rss>