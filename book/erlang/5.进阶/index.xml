<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>进阶 on 清水的小站</title>
    <link>https://yujian1018.github.io/book/erlang/5.%E8%BF%9B%E9%98%B6.html</link>
    <description>Recent content in 进阶 on 清水的小站</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Fri, 30 Aug 2019 10:56:29 +0800</lastBuildDate><atom:link href="https://yujian1018.github.io/book/erlang/5.%E8%BF%9B%E9%98%B6/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>TCP粘包、大小端</title>
      <link>https://yujian1018.github.io/book/erlang/5.%E8%BF%9B%E9%98%B6/5.1tcp%E7%B2%98%E5%8C%85%E5%A4%A7%E5%B0%8F%E7%AB%AF.html</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/erlang/5.%E8%BF%9B%E9%98%B6/5.1tcp%E7%B2%98%E5%8C%85%E5%A4%A7%E5%B0%8F%E7%AB%AF.html</guid>
      <description>1.粘包问题 数据连包问题，这个在client/server的通讯中很常见。就是，当client在极短的时间内发送多个包给server，这时s</description>
    </item>
    
    <item>
      <title>rebar发布系统</title>
      <link>https://yujian1018.github.io/book/erlang/5.%E8%BF%9B%E9%98%B6/5.2rebar%E5%8F%91%E5%B8%83%E7%B3%BB%E7%BB%9F.html</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/erlang/5.%E8%BF%9B%E9%98%B6/5.2rebar%E5%8F%91%E5%B8%83%E7%B3%BB%E7%BB%9F.html</guid>
      <description>以发布ping为例 1.获取源码+deps，并且完成编译 2生成配置文件 cd ~ mkdir rel cd rel ../rebar create-node nodeid=ping 3.修改原始配置文件, reltool.config lib_dirs %配置deps库路径，必须配</description>
    </item>
    
    <item>
      <title>ErlangVM心跳</title>
      <link>https://yujian1018.github.io/book/erlang/5.%E8%BF%9B%E9%98%B6/5.3erlangvm%E5%BF%83%E8%B7%B3.html</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/erlang/5.%E8%BF%9B%E9%98%B6/5.3erlangvm%E5%BF%83%E8%B7%B3.html</guid>
      <description>erlang心跳机制 什么是erlang心跳机制？这是erlang运行时系统定期监控系统是否正常运行的程序。 erlang为什么要心跳机制？我们</description>
    </item>
    
    <item>
      <title>ErlangGC</title>
      <link>https://yujian1018.github.io/book/erlang/5.%E8%BF%9B%E9%98%B6/5.4erlanggc.html</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/erlang/5.%E8%BF%9B%E9%98%B6/5.4erlanggc.html</guid>
      <description>二进制存储 erlang二进制数据在内存中有两种存在形式，当数据大小不到 64 bytes，就直接存在进程堆内，如果超过了64 bytes，就被保存到</description>
    </item>
    
    <item>
      <title>ErlangTime</title>
      <link>https://yujian1018.github.io/book/erlang/5.%E8%BF%9B%E9%98%B6/5.5erlangtime.html</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/erlang/5.%E8%BF%9B%E9%98%B6/5.5erlangtime.html</guid>
      <description>os:timestamp() 获取到的时间为操作系统的时间，不做任何修正； 而erlang:now()，每次获取都会确保生成了唯一的时间，就是说，erlang:now()</description>
    </item>
    
    <item>
      <title>Erlang系统限制</title>
      <link>https://yujian1018.github.io/book/erlang/5.%E8%BF%9B%E9%98%B6/5.7erlang%E7%B3%BB%E7%BB%9F%E9%99%90%E5%88%B6.html</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/erlang/5.%E8%BF%9B%E9%98%B6/5.7erlang%E7%B3%BB%E7%BB%9F%E9%99%90%E5%88%B6.html</guid>
      <description>ets表 1400 erl -env ERL_MAX_ETS_TABLES 1000000 erl +e 1000000 并发数 erl +P 1000000 erlang:system_info(process_limit). 2^18=262144 最大值为2^27-1=134217727 erlang实际使用的进程数量限制可能比你设置的要大得多，这</description>
    </item>
    
  </channel>
</rss>
