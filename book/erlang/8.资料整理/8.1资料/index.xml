<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>8.1资料 on My New Hugo Site</title>
    <link>https://yujian1018.github.io/book/erlang/8.%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/8.1%E8%B5%84%E6%96%99/</link>
    <description>Recent content in 8.1资料 on My New Hugo Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 30 Aug 2019 10:56:29 +0800</lastBuildDate>
    
	<atom:link href="https://yujian1018.github.io/book/erlang/8.%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/8.1%E8%B5%84%E6%96%99/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>8.1.1Erlang的调度原理</title>
      <link>https://yujian1018.github.io/book/erlang/8.%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/8.1%E8%B5%84%E6%96%99/8.1.1erlang%E7%9A%84%E8%B0%83%E5%BA%A6%E5%8E%9F%E7%90%86/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/erlang/8.%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/8.1%E8%B5%84%E6%96%99/8.1.1erlang%E7%9A%84%E8%B0%83%E5%BA%A6%E5%8E%9F%E7%90%86/</guid>
      <description>原文 http://jlouisramblings.blogspot.com/2013/01/how-erlang-does-scheduling.html 免爬墙链接 http://www.dikutal.dk/blog/jlouis/how-erlang-does-scheduling
Jesper Louis Andersen，2013年1月12日
我用这篇文章解释一下Erlang和其他语言运行时相比不同之处。我还要解释为什么Erlang往往会牺牲吞吐换取更低的延迟。 太长了，我懒得读（译者注：原文TL;DR表示too long, didn’t read。原作者可能是在参与和别人的讨论中写的这篇文章，“懒得读”表现出一种“懒得跟你们争了”的有趣心态。校园网爬墙速度太慢，所以没有验证。）——Erlang和其他语言运行时不同之处在于关注的重点不同。本文描述了为什么进程很少的时候往往看上去似乎性能很差，但是进程很多的时候却表现得很好。
老是有人会问Erlang调度的原理。本文只是对Erlang真正调度原理的简单概述，但是描述了Erlang对其进程的操作方式。注意我这里讨论的是Erlang R15。未来Erlang可能会发生很大的变化，但是不论是Erlang还是其他系统，事物总是会朝着更好的方向发展。
从操作系统的角度来说，Erlang通常在机器上的每一个处理器核心上跑一个线程。每一个线程运行一个调度器。这种设定是为了确保机器上所有的核心都可以为Erlang系统卖力。通过+sbt参数可以将处理器核心和调度器绑定，也就是说调度器不会在众多核心之间跳来跳去。调度器绑定仅限于现代操作系统，因此OS X自然做不到。要实现调度器绑定，说明Erlang系统了解处理器的拓扑结构以及处理器相关的亲缘性，由于高速缓存以及迁移时间等原因，这些信息非常重要。设置+sbt参数通常都可以提升系统的速度。而且有的时候还能提升不少。
+A参数定义了异步线程池中异步线程的数量。驱动程序可以通过异步线程池中的线程执行阻塞的操作，这样调度器可以在线程池中有些线程阻塞的情况下依然执行其他有用的工作。最值得注意的是，文件驱动程序通过线程池加速文件I/O，而网络I/O则没有使用线程池。
以上内容是从操作系统内核的角度描述的，下面我们来理清Erlang进程（隶属于用户空间）的概念。通过调用spawn(fun worker/0)可以构建一个新的进程，Erlang系统会在用户空间分配进程控制块。一个进程通常需要大约600多个字节，而且32位系统和64位系统会有不同。可运行的进程放在调度器的运行队列中，之后获得时间片的时候就可以运行。 在深入描述单个调度器之前，我先简要地描述一下迁移（migration）的工作原理。每过一段时间，调度器就会通过一个非常复杂的过程在调度器之间迁移一些进程。这种启发式迁移的目标就是为了平衡多个调度器的负载，使得所有的核心都能得到充分的利用。这个平衡算法还要考虑工作量是否足够大，是否大到需要启动一些新的调度器。如果没那么大的话，那么最好让那些调度器保持关闭状态，因为反正那些线程也没有工作可做。关闭调度器意味着处理器核心可以进入节能状态，甚至关闭核心。没错，Erlang会尽可能地节省电源消耗。如果调度器做完了工作，还会从其他调度器“窃取”工作（work-steal）。细节请参见[1]。
重要：在R15中，调度器的启动和停止是有延迟（lagged）的。因为Erlang/OTP深知启动或停止一个调度器的开销非常大，所以不是真正需要的话是不会采取行动的。假设某一个调度器现在无事可做，那么系统不会立即将这个调度器设置为睡眠状态，而是会自旋等待一阵子，期待有任务会立即到达。如果有任务到达，那么调度器可以以低延迟立即开始处理任务。换句话说，不能使用top(1)这类工具或通过操作系统内核来测量系统执行的效率，而是必须使用Erlang系统的内部调用来测量。正因为这个原因，有不少人错误地认为R15不如R14高效。
每一个调度器都运行两类作业：进程作业和port作业。这些作业运行的时候是带有优先级的，就像操作系统内核一样，因此也会面对和操作系统内核一样的担忧和启发式调度。进程可以标记高优先级和低优先级等优先级。进程作业执行一个进程一小段时间。port作业考虑的是port。如果你不知道port是什么，我简单解释一下port：port就是Erlang中一种和外部世界通信的机制。文件、网络套接字、和其他程序之间建立的管道，在Erlang中都是通过port实现的。开发者可以在Erlang系统中添加“port驱动程序”来支持新的port类型，不过这就要求编写C语言代码了。调度器还要对网络套接字进行轮询（polling），这样才能从网络中读取数据。
进程和端口都有一个“reduction预算”，即2000个reduction。系统中的任何操作都要消耗reduction。这些操作包括循环中的函数调用、BIF（内建函数）的调用、进程中堆的垃圾回收[注1]、存取ETS和发送消息等（发送消息要考虑接收者的邮箱大小，邮箱越大发送的代价越高）。顺便提一下，会扣除reduction的地方遍及整个Erlang系统。比如Erlang的正则表达式库就做了修改，即使这个库是用C语言编写的，其中也添加了扣除reduction的相关代码。因此如果你有一个非常耗时的正则表达式，那么这个正则表达式的操作也会扣除reduction，所以在运行的过程中有可能会被抢占好几次。port也不例外！在一个port上执行I/O操作会消耗reduction，发送分布式消息也会消耗reduction，不胜枚举。开发者花了大量时间确保系统中产生的每一步进度都会消耗reduction[注2]。
实际上，这就是为什么我说Erlang是真正能够实现抢占式多任务并且能真正做好软实时的少数语言之一的原因。Erlang更看重的是低延迟而不是单纯的吞吐量，这在程序设计语言运行时中是不多见的。
准确地说，抢占（preemption）[2]指的是调度器能够强制剥夺任务的执行。所有基于协作（cooperation）的多任务都是做不到抢占的，例如Python的twisted库、Node.js和LWT（Ocaml）等。但是更有意思的是，Go（golang.org）和Haskell（GHC）也都不是完全抢占式的。Go只有在通信的时候会发生上下文切换，因此一个密集的循环就会霸占整个处理器核心。GHC会在内存分配的时候发生切换（不得不承认内存分配是Haskell程序中一个非常频繁的操作）。这些系统的问题在于，将处理器核心霸占一段时间的后果就是影响系统的响应延迟——想象一下这两种语言执行数组操作的时候的情景。
这就引出了软实时（soft-realtime）[3]的概念，软实时指的是如果无法满足时间截止线需求的时候会导致系统服务水准降级（而不是整个失败）。假设在运行队列中有500有100个进程。第一个进程正在做一个耗时50毫秒的数组操作。在Go或Haskell/GHC[注3]中，这意味着任务2-100都需要至少50ms。而在Erlang中则不同，任务1有2000个reduction的预算，相当于大约1ms的时间。然后用完reduction预算后，任务1会被放回运行队列，这样任务2-任务100就有机会运行。这自然意味着所有的任务都有公平的时间份额。
Erlang是为保证低延迟软实时的特性而精心打造的。2000的reduction预算很低，会导致很多小的上下文切换。耗时长的BIF在计算过程中被抢占的代价非常高昂。但是这样可以保证Erlang在系统负载更高的情况下能够优雅地降级。对于像Ericsson这样在乎低延迟的公司来说，这也意味着别无选择了。你不可能神奇地找到另外一种为吞吐量打造的语言同时也获得低延迟的好处，你必须为之付出努力。如果低延迟对你来说很重要，那么平心而论，不选Erlang反而显得很奇怪了。
[1] &amp;ldquo;Characterizing the Scalability of Erlang VM on Many-core Processors&amp;quot;http://kth.diva-portal.org/smash/record.jsf?searchId=2&amp;amp;pid=diva2:392243 [2] http://en.wikipedia.org/wiki/Preemption_(computing) [3] http://en.wikipedia.org/wiki/Real-time_computing [注1] 进程堆是每个进程私有的，因此一个进程不会对其他进程的GC时间造成太大影响。 [注2] 这段话也点明了为什么要小心耗时长的NIF的原因。NIF默认不会被抢占，而且也不会贡献reduction计数器。因此耗时长的NIF会引入系统延迟。 [注3] 这里考虑单核心的情况，多核心能在一定程度上“掩盖”单核心的这个问题，但是问题依然存在。</description>
    </item>
    
    <item>
      <title>8</title>
      <link>https://yujian1018.github.io/book/erlang/8.%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/8.1%E8%B5%84%E6%96%99/8.1.2%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/erlang/8.%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/8.1%E8%B5%84%E6%96%99/8.1.2%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/</guid>
      <description>erlang 是开源的，很多人都研究过源代码。但是，从erlang代码到c代码，这是个不小的跨度，而且代码也比较复杂。所以这里，我利用一些时间，整理下 erlang代码的执行过程，从erlang代码编译过程，到代码执行过程做讲解，然后重点讲下虚拟机执行代码的原理。将本篇文章，献给所有喜欢erlang的人。
erlang代码编译过程 erlang对开发者是友好的，从erlang程序文件编译成能被erlang虚拟机识别的beam文件，在这个编译过程还对开发者暴露中间代码。借助这个中间代码，我们就可以逐步探究erlang代码的执行过程。 这是erlnag的编译过程，当然，最开始和大多数编译器一样，首先会将程序文件转换成语法树，但这个转换对我们来说阅读的意义不大，所以归结于以上3个过程。
  erlang核心代码 确切的叫法是Core Erlang，使用了类似Haskell 的语法，而且每个变量都用“Let” 声明。在erlang shell通过以下方式可以获取模块的Core Erlang代码，将会生成test.core文件 c(test, to_core). 实际上core文件可以直接编译成beam文件，如下： c(test, from_core).
  erlang汇编码 这 个是erlang代码编译成beam前的汇编代码，虽然在erlang打包成beam，以及加载到VM时会进一步优化，但汇编码实际上可以看成 erlang代码到c代码的纽带。但理解汇编码而不是很容易，这里要知道erlang VM的设计基于寄存器，其中有两类重要的寄存器，传递参数的x寄存器，和在函数内用作本地变量的y寄存器。在erlang shell通过以下方式可以获取模块的汇编代码，将会生成test.S文件 c(test, to_asm). 或是 c(test, ‘S‘). 当然，S文件也支持编译成beam文件，如下： c(test, from_asm).
  erlang BEAM beam文件是不可阅读的，只是给VM识别，内容包括了代码，原子，导入导出函数，属性，编译信息等数据块。
  erlang运行时代码 运行时代码是指模块加载到VM后的代码，erlang对开发者暴露了底层的接口。当模块加载后，在erlang shell下通过以下方式可以获取模块的运行时代码，就会生成test.dis文件 erts_debug:df(test).
  这里，细心的同学会发现，通过对比erlang汇编码和运行时代码，发现指令代码是不完全相同的。一方面，erlang会对指令进一步做优化；另 外，erlang使用了两种指令集，有限指令集和扩展指令集，在beam文件使用了有限指令集，然后在加载到VM时展开为扩展指令集。有论文说是为了减少 Beam的大小，这点我没有做过实质性的探究，我只是觉得有限指令集比较短，更容易阅读被人理解。关于有限指令集和扩展指令集的差别，我在文章最后的拓展阅读做了讨论。
erlang代码从编译到执行过程
前面介绍了erlang代码编译的过程，现在再来说明erlang代码从编译到执行的完整过程。文章erlang版本以R16B02作说明。 这里，erlang代码先被编译成beam，然后加载到VM中，最后再被模拟器所识别和调用。 其中，beam文件的加载过程会将beam的字节码形式的数据转成Threaded code和数据。前面也提到，beam文件的字节码数据包含有代码块，这里是将指令展开，转成Threaded code（线索化代码），每条指令包含了opcode（操作码）和operands（操作数），另外还对operands做修正，比如调用外部函数，这里会找到这个外部函数的导出地址，这样每次代码执行的时候就不用再去函数表查找到这个函数，就可以直接执行代码。
Beam 的加载逻辑是在 beam_load.c 完成的，指令集的转换在beam_opcodes.c做了映射，而beam_opcodes.c文件是在编译Erlang源码过程有Perl脚本 beam_makeops根据ops.tab生成的。所有有限指令集可以在genop.tab找到。
File Path beam_makeops erts/emulator/utils/ ops.tab erts/emulator/beam/ beam_opcodes.c erts/emulator/&amp;lt;machine&amp;gt;/opt/smp/ beam_load.</description>
    </item>
    
    <item>
      <title>8</title>
      <link>https://yujian1018.github.io/book/erlang/8.%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/8.1%E8%B5%84%E6%96%99/8.1.3smp/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/erlang/8.%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/8.1%E8%B5%84%E6%96%99/8.1.3smp/</guid>
      <description>以下是一些Erlang SMP实现的细节和与性能与伸缩性相关一些简单介绍。
几周之内还有有一个关于多核如何运作以及未来如何发展的更详细的介绍。我打算将一些内容放在我的报告中，将于9月27日的ICFP2008，Erlang Workshop在Victoria BC展示给大家。
没有SMP支持的Erlang VM只有1个运行在主处理线程中的调度器。该调度器从运行队列（run-queue）中取出可以运行的Erlang进程以及IO任务，而且因为只有一个线程访问他们所以无须锁定任何数据。
而带有SMP支持的Erlang VM可以有一个或多个调度器，每个运行在一个线程中。调度器从同一个公共运行队列中取出可运行的Erlang进程和IO任务。在SMP VM中所有的共享数据结构都会由锁进行保护，运行队列就是这样一个由锁保护的数据结构。
从OTP R12B开始，如果操作系统报告有多于1个的CPU（或者核心）VM的SMP版本会自动启动，并且根据CPU或者核心的数量启动同样数量的调度器。
你可以从“erl”命令打印出来的第一行看到它选择了哪些参数。例如：
Erlang (BEAM) emulator version 5.6.4 [source] [smp:4] [asynch-threads:0] ….. 其中“[smp:4]”表示SMP VM运行了4个调度器。 默认值可以用“-smp [enable|disable|auto]”来替换，auto是默认的。如果smp被启用了（-smp enable），要设置调度器的数量可以使用“+S Number”其中Number是调度器的数量（1到1024）
注意1：运行多于CPU或核心总数的调度器不会有任何提升。 注意2：在某些操作系统中一个进程可使用的CPU或者核心的数量可以被限制。例如，在Linux中，命令“taskset”就可以 实现这个功能。Erlang VM目前还只能探测CPU或者核心的总数，不会考虑“taskset”所设置的掩码。正因如此，例如可能会出现（已经出现过了）即使Erlang VM运行了4个调度器，也只使用了2个核心。OS会进行限制因为它要考虑“taskset”所设置的掩码。
每个Erlang VM的调度器都运行于一个OS线程上，是OS来决定线程是否执行在不同的核心上。一般来说OS会很好地处理这个问题并且会保证线程在执行期间运行于同一个核心上。 Erlang进程会被不同的调度器运行，因为他们是从一个公共运行队列中被取出，由首先可用的调度器运行。
性能和伸缩性 只有一个调度器的SMP VM要比非SMP的VM稍微慢那么一点点。SMP VM内部需要用到各种锁，不过只要不存在锁的争用，那么由锁引起的开销不会非常大（就是锁争用上面需要花时间）。这也解释了为何在某些情况下，运行多个只有一个调度器的SMP VM要比包含多个调度器的单一SMP VM更加高效。当然运行多个VM要求应用可以按照多个并行任务的方式运行并且之间没有或者几乎不通讯。 一个程序是否能在多核上的SMP VM中良好地进行提升很大程度上取决于程序的性质，某些程序可以保持线性提升至8核甚至16核，同时其他某些程序基本不能提升，连2核都不行。实际应用中很多程序都能在主流市场的核心数上得到提升，见下文。
若并行的持续“通话”由每个核心一个或多个Erlang进程来表示，实际的支持大量通话的电信产品已经先现出在双核和四核处理器上不俗的伸缩性。注意，这些产品是在SMP VM和多核处理器出现很久以前按照普通的Erlang风格来写的，他们也能无须任何修改甚至不需重新编译代码就能从Erlang SMP VM中获益。
SMP性能得到持续改进 SMP实现正被不断改进以便能得到更好的性能和伸缩性。在每个服务发布版R12B-1,2,3,4,5…,R13B等等中，你都能发现新的优化。
一些已知的瓶颈 单一的常见运行队列随着CPU或核心的数量的增加会成为一个显著的瓶颈。 这从4核开始往上就会显现出来，不过4核仍然可以为多数应用程序提供不错的性能。我们正在从事一个每个调度器一个运行队列的解决方法作为目前最重要的改进。 Ets表格会引入锁。在R12B-4之前在每次对一个ets-table的访问中会用到两个锁，但是在R12B-4中meta-table的锁被优化过，可以显著减少争用（前面已经提到争用是有很大代价的）。如果很多Erlang进程访问同一个表格，就会有很多锁争用造成性能降低尤其当这些进程主要工作是访问ets-table。锁存在于表级而非记录级。注意！这也会影响到Mnesia因为Mnesia用到了很多ets-table。
我们关于SMP的策略 当我们开始实现SMP VM的最初，我们就确定了策略：“首先让它可以运行，然后测量，然后优化”。自从2006年五月我们发布了第一个稳定的SMP VM（R11B）以来，我们一直遵循着这个策略。 还有更多已知的东西可以改进，我们会按照性能的收益大小先后各个击破。 我们将主要的精力放在多核（大于4）上更好的连续伸缩性上。
卓越典范 即使SMP系统有还有一些已知的瓶颈不过已经有不错的整体性能和伸缩性，同时我相信在让程序员利用多核机器事半功倍方面，我们是一个卓越的典范。
SMP Erlang 用来决定它在多核CPU下如何运行
$erl -smp +S n -smp 启动SMP +S n 使用N个调度器来运行Erlang，每一个Erlang调度器都是一个完整的虚拟机，它拥有所有其他虚拟机的信息。如果忽略这个参数，它就默认为SMP机器中逻辑处理器的数量 </description>
    </item>
    
  </channel>
</rss>