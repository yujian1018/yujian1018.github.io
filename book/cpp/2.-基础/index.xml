<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>2.基础 on My New Hugo Site</title>
    <link>https://yujian1018.github.io/book/cpp/2.-%E5%9F%BA%E7%A1%80/</link>
    <description>Recent content in 2.基础 on My New Hugo Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 30 Aug 2019 15:13:01 +0800</lastBuildDate>
    
	<atom:link href="https://yujian1018.github.io/book/cpp/2.-%E5%9F%BA%E7%A1%80/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>2.1 c&#43;&#43;变量</title>
      <link>https://yujian1018.github.io/book/cpp/2.-%E5%9F%BA%E7%A1%80/2.1-c&#43;&#43;%E5%8F%98%E9%87%8F/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/cpp/2.-%E5%9F%BA%E7%A1%80/2.1-c&#43;&#43;%E5%8F%98%E9%87%8F/</guid>
      <description>变量 标识（Identifiers） 有效标识由 字母(letter)， 数字(digits)和 下划线 ( _ )组成。 标识的长度没有限制，但是有些编译器只取前32个字符（剩下的字符会被忽略）。
空格(spaces)，标点(punctuation marks)和符号(symbols) 都不可以出现在标识中。 只有字母(letters)，数字(digits) 和下划线()是合法的。并且变量标识必须以字母开头。标识也可能以下划线（）开头，但这种标识通常是保留给为外部连接用的。标识不可以以数字开头。
必须注意的另一条规则是当你给变量起名字时不可以和C++语言的关键字或你所使用的编译器的特殊关键字同名，因为这样与这些关键字产生混淆。
标准保留关键字
asm, auto, bool, break, case, catch, char, class, const, const_cast, continue, default, delete, do, double, dynamic_cast, else, enum, explicit, extern, false, float, for, friend, goto, if, inline, int, long, mutable, namespace, new, operator, private, protected, public, register, reinterpret_cast, return, short, signed, sizeof, static, static_cast, struct, switch, template, this, throw, true, try, typedef, typeid, typename, union, unsigned, using, virtual, void, volatile, wchar_t, whileand, and_eq, bitand, bitor, compl, not, not_eq, or, or_eq, xor, xor_eq栈。变量，局部变量，参数变量 堆。new delete 自由存储区 用户主动申请的malloc 全局/静态存储区 全局变量，静态变量 常量存储区。 定义的常量</description>
    </item>
    
    <item>
      <title>2.2 数据类型</title>
      <link>https://yujian1018.github.io/book/cpp/2.-%E5%9F%BA%E7%A1%80/2.2-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/cpp/2.-%E5%9F%BA%E7%A1%80/2.2-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid>
      <description>数据类型    名称 字节数 描述 范围     Char 1 字符（character）或整数（integer ）， 8位（bits）长 有符号（signed）: -128 到 127无符号（unsigned）: 0 到 255   short int (short) 2 短整数（integer ）16位（bits）长 有符号（signed）: -32768 到 32767 无符号（unsigned）: 0 到 65535   long int (long) 4 长整数（integer ）32位（bits）长 有符号（signed）:-2147483648 到 2147483647 无符号（unsigned）: 0 到 4294967295   int 4 整数（integer） 有符号(signed): -2147483648 到 2147483647 无符号（unsigned): 0 到 4294967295   float 4 浮点数（floating point number） 3.</description>
    </item>
    
    <item>
      <title>2.3 转义字符</title>
      <link>https://yujian1018.github.io/book/cpp/2.-%E5%9F%BA%E7%A1%80/2.3-%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/cpp/2.-%E5%9F%BA%E7%A1%80/2.3-%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6/</guid>
      <description>转义字符    符号 描述 ASCII码值（十进制）     \n 换行(LF) ，将当前位置移到下一行开头 010   \r 回车(CR) ，将当前位置移到本行开头 013   \t 水平制表(HT) （跳到下一个TAB位置） 009   \v 垂直制表(VT) 011   \b backspace 退格(BS) ，将当前位置移到前一列 008   \f page feed 换页(FF)，将当前位置移到下页开头 012   \a 响铃(BEL) 警告alert (beep) 007   &#39; 单引号single quotes (&#39;)    &amp;quot; 双引号double quotes (&amp;quot;)    ? 问号question (?</description>
    </item>
    
    <item>
      <title>2.4 运算符</title>
      <link>https://yujian1018.github.io/book/cpp/2.-%E5%9F%BA%E7%A1%80/2.4-%E8%BF%90%E7%AE%97%E7%AC%A6/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/cpp/2.-%E5%9F%BA%E7%A1%80/2.4-%E8%BF%90%E7%AE%97%E7%AC%A6/</guid>
      <description>运算符    优先级 运算符 名称或含义 使用形式 结合方向 说明     1 [] 数组下标 数组名[常量表达式] 左到右     () 圆括号 （表达式）/函数名( 形参表)     . 成员选择（对象） 对象.成员名      -&amp;gt; 成员选择（指针） 对象指针-&amp;gt; 成员名    2 - 负号运算符 -表达式 右到左 单目运算符    (类型) 强制类型转换 (数据类型)表达式      ++ 自增运算符 ++变量名/变量名++  单目运算符    &amp;ndash; 自减运算符 &amp;ndash;变量名/变量名&amp;ndash;  单目运算符    * 取值运算符 *指针变量  单目运算符    &amp;amp; 取地址运算符 &amp;amp;变量名  单目运算符    !</description>
    </item>
    
    <item>
      <title>2.5 控制结构</title>
      <link>https://yujian1018.github.io/book/cpp/2.-%E5%9F%BA%E7%A1%80/2.5-%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/cpp/2.-%E5%9F%BA%E7%A1%80/2.5-%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/</guid>
      <description>控制结构 1.if if(true){}else if(true){}else{}2.switch int switch_on = 1;switch(switch_on){case 1:printf(&amp;#34;this case is 1\n&amp;#34;);break;default:break;}3.for for(int i=0; i&amp;lt;=100; i++&amp;gt;){printf(&amp;#34;i:%d!\n&amp;#34;, i);}int i;for(i=0; i&amp;lt;=0; i-=10000){printf(&amp;#34;i:%d!\n&amp;#34;, i);}return 0;4.while int m = 0;while(m &amp;lt;100&amp;gt;){m++;}#include &amp;lt;iostream.h&amp;gt;int main (){int n;cout &amp;lt;&amp;lt; &amp;#34;Enter the starting number &amp;gt; &amp;#34;;cin &amp;gt;&amp;gt; n;while (n&amp;gt;0) {cout &amp;lt;&amp;lt; n &amp;lt;&amp;lt; &amp;#34;, &amp;#34;;--n;}cout &amp;lt;&amp;lt; &amp;#34;FIRE!</description>
    </item>
    
    <item>
      <title>2.6 Class</title>
      <link>https://yujian1018.github.io/book/cpp/2.-%E5%9F%BA%E7%A1%80/2.6-class/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/cpp/2.-%E5%9F%BA%E7%A1%80/2.6-class/</guid>
      <description>Class 构造函数 构造函数的参数初始化表
析构函数 this指针详解 静态成员变量和静态成员函数 一般情况下，如果有N个同类的对象，那么每一个对象都分别有自己的成员变量，不同对象的成员变量各自有值，互不相干。但是有时我们希望有某一个或几个成员变量为所有对象共有，这样可以实现数据共享。
可以使用全局变量来达到共享数据的目的。例如在一个程序文件中有多个函数，每一个函数都可以改变全局变量的值，全局变量的值为各函数共享。但是用全局变量的安全性得不到保证，由于在各处都可以自由地修改全局变量的值，很有可能偶然失误，全局变量的值就被修改，导致程序的失败。因此在实际开发中很少使用全局变量。
如果想在同类的多个对象之间实现数据共享，也不要用全局变量，那么可以使用静态成员变量。
初始化实例时，填写静态变量改变规则
class Student{private:char *name;int age;float score;static int num; //将num定义为静态成员变量public:Student(char *, int, float);void say();};继承 权限，继承方式 派生类的构造和析构函数 名字遮蔽 多继承
虚基类 virtual
基类和派生类的赋值 注意指针对象
虚析构函数 注意内存回收
纯虚函数和抽象类 纯虚函数没有函数体，只有函数声明，在虚函数声明结尾加上=0，表明此函数为纯虚函数。</description>
    </item>
    
    <item>
      <title>2.7 关键字</title>
      <link>https://yujian1018.github.io/book/cpp/2.-%E5%9F%BA%E7%A1%80/2.7-%E5%85%B3%E9%94%AE%E5%AD%97/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/cpp/2.-%E5%9F%BA%E7%A1%80/2.7-%E5%85%B3%E9%94%AE%E5%AD%97/</guid>
      <description>关键字 const 在类中，如果你不希望某些数据被修改，可以借助 const 关键字加以限定。const 可以用来修饰成员变量、成员函数、对象以及对象的引用。
virtual 虚基类
   关键字 说明 描述     #define 宏定义，末尾没有分号结尾    &amp;amp; 地址符&amp;amp;，用以获得变量的地址    * 指针运算符（或称“间接访问” 运算符）    auto 声明自动变量    short 声明短整型变量或函数    int 声明整型变量或函数    long 声明长整型变量或函数    float 声明浮点型变量或函数    double 声明双精度变量或函数    char 声明字符型变量或函数    struct 声明结构体变量或函数    union 声明共用数据类型    enum 声明枚举类型    typedef 用以给数据类型取别名    const 声明只读变量    unsigned 声明无符号类型变量或函数    signed 声明有符号类型变量或函数    extern 声明变量是在其他文件正声明    register 声明寄存器变量    static 声明静态变量 首先static的最主要功能是隐藏，其次因为static变量存放在静态存储区，所以它具备持久性和默认值0。   volatile 说明变量在程序执行中可被隐含地改变    void 声明函数无返回值或无参数，声明无类型指针    if 条件语句    else 条件语句否定分支（与 if 连用）    switch 用于开关语句    case 开关语句分支    for 一种循环语句 for(int i = 0; i&amp;lt;300; i++){}   do 循环语句的循环体    while 循环语句的循环条件 while(condition){}   goto 无条件跳转语句    continue 结束当前循环，开始下一轮循环    break 跳出当前循环,完全跳出循环，不再往下执行，执行循环体外面的代码    default 开关语句中的“其他”分支    sizeof 计算数据类型长度    return 子程序返回语句（可以带参数，也可不带参数）循环条件     </description>
    </item>
    
    <item>
      <title>2.10 预处理指令</title>
      <link>https://yujian1018.github.io/book/cpp/2.-%E5%9F%BA%E7%A1%80/2.10-%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/cpp/2.-%E5%9F%BA%E7%A1%80/2.10-%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4/</guid>
      <description>预处理指令    指令 说明     # 空指令，无任何效果   #include 包含一个源代码文件   #define 定义宏   #undef 取消已定义的宏   #if 如果给定条件为真，则编译下面代码   #ifdef 如果宏已经定义，则编译下面代码   #ifndef 如果宏没有定义，则编译下面代码   #elif 如果前面的#if给定条件不为真，当前条件为真，则编译下面代码   #endif 结束一个#if……#else条件编译块    #include使用库函数之前，应该用#include引入对应的头文件。这种以#号开头的命令称为预处理命令。使用尖括号&amp;lt; &amp;gt;和双引号&amp;quot; &amp;quot;的区别在于头文件的搜索路径不同，包含标准库的头文件一般用尖括号，包含自定义的头文件一般用双引号。#define宏定义是由源程序中的宏定义命令#define完成的，宏代换是由预处理程序完成的。宏定义的一般形式为：#define 宏名 字符串#表示这是一条预处理命令，所有的预处理命令都以#开头。define是预处理命令。宏名是标识符的一种，命名规则和标识符相同。字符串可以是常数、表达式等。这里所说的字符串是一般意义上的字符序列，不要和C语言中的字符串等同，它不需要双引号。程序中反复使用的表达式就可以使用宏定义带参数宏定义带参宏定义的一般形式为：#define 宏名(形参列表) 字符串例如：#define M(y) y*y+3*y //宏定义// Codek=M(5); //宏调用条件编译第一种形式的格式为：#ifdef 标识符程序段1#else程序段2#endif它的功能是，如果标识符已被 #define 命令定义过则对程序段1进行编译；否则对程序段2进行编译。如果没有程序段2（它为空），本格式中的#else可以没有，即可以写为：#ifdef 标识符程序段#endif第二种形式的格式为：#ifndef 标识符程序段1 #else 程序段2 #endif它的功能是，如果标识符未被#define命令定义过则对程序段1进行编译，否则对程序段2进行编译。第三种形式的格式为：#if 常量表达式程序段1#else 程序段2#endif它的功能是，如常量表达式的值为真（非0），则对程序段1 进行编译，否则对程序段2进行编译。因此可以使程序在不同条件下，完成不同的功能。 </description>
    </item>
    
    <item>
      <title>2.11 指针</title>
      <link>https://yujian1018.github.io/book/cpp/2.-%E5%9F%BA%E7%A1%80/2.11-%E6%8C%87%E9%92%88/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/cpp/2.-%E5%9F%BA%E7%A1%80/2.11-%E6%8C%87%E9%92%88/</guid>
      <description>指针    定义 含义     int i; 定义整型变量 i。   int *p; p为指向整型数据的指针变量。   int a[n]; 定义整型数组a，它有n个元素。   int *p[n]; 定义指针数组p，它由n个指向整型数据的指针元素组成。   int (*p)[n]; p为指向含n个元素的一维数组的指针变量。   int f(); f 为一个返回整型的函数。   int *p(); p为一个返回指针的函数，该指针指向整型数据。   int (*p)(); p为指向函数的指针，该函数返回一个整型值。   int **p; p是一个指针变量，它又指向另外一个指针变量，该指针变量指向整型数据。    1) 指针变量可以加（减）一个整数，例如p++、p+i、p-=i。一个指针变量加（减）一个整数并不是简单地将原值加（减）一个整数，而是将该指针变量的原值（是一个地址）和它指向的变量所占用的内存单元字节数加（减）。2) 指针变量赋值：将一个变量的地址赋给一个指针变量。1. p=&amp;amp;a; //将变量a的地址赋给p2. p=array; //将数组array的首地址赋给p3. p=&amp;amp;array[i]; //将数组array第i个元素的地址赋给p4.</description>
    </item>
    
    <item>
      <title>2.12 结构体、共用体和位运算</title>
      <link>https://yujian1018.github.io/book/cpp/2.-%E5%9F%BA%E7%A1%80/2.12-%E7%BB%93%E6%9E%84%E4%BD%93%E5%85%B1%E7%94%A8%E4%BD%93%E5%92%8C%E4%BD%8D%E8%BF%90%E7%AE%97/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/cpp/2.-%E5%9F%BA%E7%A1%80/2.12-%E7%BB%93%E6%9E%84%E4%BD%93%E5%85%B1%E7%94%A8%E4%BD%93%E5%92%8C%E4%BD%8D%E8%BF%90%E7%AE%97/</guid>
      <description>结构体（Struct） struct stu{char *name; //姓名 int num; //学号 char sex; //性别 float score; //成绩};struct stu s1s1.name = &amp;#34;aa&amp;#34;s1.num=123// 结构体数组struct stu{char *name;int num;char sex;float score;}class[5] = {{&amp;#34;Li ping&amp;#34;, 5, &amp;#39;M&amp;#39;, 45},{&amp;#34;Zhang ping&amp;#34;, 4, &amp;#39;M&amp;#39;, 62.5},{&amp;#34;He fang&amp;#34;, 1, &amp;#39;F&amp;#39;, 92.5},{&amp;#34;Cheng ling&amp;#34;, 2, &amp;#39;F&amp;#39;, 87},{&amp;#34;Wang ming&amp;#34;, 3, &amp;#39;M&amp;#39;, 58}};// 结构体和指针struct stu{char *name;int num;char sex;float score;} *pstu, stu1, stu2;(*pstu).</description>
    </item>
    
    <item>
      <title>2.8 函数模板</title>
      <link>https://yujian1018.github.io/book/cpp/2.-%E5%9F%BA%E7%A1%80/2.8-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/cpp/2.-%E5%9F%BA%E7%A1%80/2.8-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/</guid>
      <description>template&amp;lt;typename T&amp;gt;T max(T a, T b, T c) {if (a &amp;gt; b) a = b;if (a &amp;gt; c) a = c;return a;}int main() {cout &amp;lt;&amp;lt; max(10, 11, 12) &amp;lt;&amp;lt; endl;return 0;}模板类#include &amp;lt;iostream&amp;gt;using namespace std;template&amp;lt;typename M, typename N&amp;gt;class point {private:M x;N y;public:point() : x(0), y(0) {}point(M x, N y) : x(x), y(y) {}void set_xy(M x, N y);M get_x();N get_y();};template&amp;lt;typename M, typename N&amp;gt;void point&amp;lt;M, N&amp;gt;::set_xy(M x, N y) {this-&amp;gt;x = x;this-&amp;gt;y = y;}template&amp;lt;typename M, typename N&amp;gt;M point&amp;lt;M, N&amp;gt;::get_x() {return x;}int main() {point&amp;lt;int, float &amp;gt; p(10, 12.</description>
    </item>
    
    <item>
      <title>2.9 数据结构</title>
      <link>https://yujian1018.github.io/book/cpp/2.-%E5%9F%BA%E7%A1%80/2.9-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/cpp/2.-%E5%9F%BA%E7%A1%80/2.9-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid>
      <description>Array int a[10]={12, 19, 22 , 993, 344}; int a[10] = {0};char c[10] = {0};float f[10] = {0};float level[2], sum; 定义一个两个参数的数组，并且参数只能是float型 C语言规定，数组名就代表了该数组的地址。C语言还规定，数组名所代表的地址为第0个元素的地址，例如char c[10];，c就代表c[0]的地址。第0个元素的地址就是数组的起始地址，称为首地址。也就是说，数组名表示数组的首地址。数组的定义格式为：type arrayName[length]type 为数据类型，arrayName 为数组名，length 为数组长度。 需要注意的是：在不支持C99的编译器中，length 必须是一个数值常量，不能是变量，例如 VC6.0、VS2010 等；在支持C99的编译器中，length 还可以是变量，例如 C-Free 5.0、GCC等。数组在内存中占用一段连续的空间，数组名表示的是这段内存空间的首地址。2) 访问数组中某个元素的格式为：arrayName[index]index 为数组下标。注意 index 的值必须大于等于零，并且小于数组长度，否则会发生数组越界，出现意想不到的错误。 2.变元向量 argv[]  </description>
    </item>
    
  </channel>
</rss>