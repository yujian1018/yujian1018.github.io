<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C-CPP on My New Hugo Site</title>
    <link>https://yujian1018.github.io/book/cpp/</link>
    <description>Recent content in C-CPP on My New Hugo Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 30 Aug 2019 10:56:29 +0800</lastBuildDate>
    
	<atom:link href="https://yujian1018.github.io/book/cpp/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>2.1 c&#43;&#43;变量</title>
      <link>https://yujian1018.github.io/book/cpp/2.-%E5%9F%BA%E7%A1%80/2.1-c&#43;&#43;%E5%8F%98%E9%87%8F/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/cpp/2.-%E5%9F%BA%E7%A1%80/2.1-c&#43;&#43;%E5%8F%98%E9%87%8F/</guid>
      <description>变量 标识（Identifiers） 有效标识由 字母(letter)， 数字(digits)和 下划线 ( _ )组成。 标识的长度没有限制，但是有些编译器只取前32个字符（剩下的字符会被忽略）。
空格(spaces)，标点(punctuation marks)和符号(symbols) 都不可以出现在标识中。 只有字母(letters)，数字(digits) 和下划线()是合法的。并且变量标识必须以字母开头。标识也可能以下划线（）开头，但这种标识通常是保留给为外部连接用的。标识不可以以数字开头。
必须注意的另一条规则是当你给变量起名字时不可以和C++语言的关键字或你所使用的编译器的特殊关键字同名，因为这样与这些关键字产生混淆。
标准保留关键字
asm, auto, bool, break, case, catch, char, class, const, const_cast, continue, default, delete, do, double, dynamic_cast, else, enum, explicit, extern, false, float, for, friend, goto, if, inline, int, long, mutable, namespace, new, operator, private, protected, public, register, reinterpret_cast, return, short, signed, sizeof, static, static_cast, struct, switch, template, this, throw, true, try, typedef, typeid, typename, union, unsigned, using, virtual, void, volatile, wchar_t, whileand, and_eq, bitand, bitor, compl, not, not_eq, or, or_eq, xor, xor_eq栈。变量，局部变量，参数变量 堆。new delete 自由存储区 用户主动申请的malloc 全局/静态存储区 全局变量，静态变量 常量存储区。 定义的常量</description>
    </item>
    
    <item>
      <title>2.2 数据类型</title>
      <link>https://yujian1018.github.io/book/cpp/2.-%E5%9F%BA%E7%A1%80/2.2-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/cpp/2.-%E5%9F%BA%E7%A1%80/2.2-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid>
      <description>数据类型    名称 字节数 描述 范围     Char 1 字符（character）或整数（integer ）， 8位（bits）长 有符号（signed）: -128 到 127无符号（unsigned）: 0 到 255   short int (short) 2 短整数（integer ）16位（bits）长 有符号（signed）: -32768 到 32767 无符号（unsigned）: 0 到 65535   long int (long) 4 长整数（integer ）32位（bits）长 有符号（signed）:-2147483648 到 2147483647 无符号（unsigned）: 0 到 4294967295   int 4 整数（integer） 有符号(signed): -2147483648 到 2147483647 无符号（unsigned): 0 到 4294967295   float 4 浮点数（floating point number） 3.</description>
    </item>
    
    <item>
      <title>2.3 转义字符</title>
      <link>https://yujian1018.github.io/book/cpp/2.-%E5%9F%BA%E7%A1%80/2.3-%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/cpp/2.-%E5%9F%BA%E7%A1%80/2.3-%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6/</guid>
      <description>转义字符    符号 描述 ASCII码值（十进制）     \n 换行(LF) ，将当前位置移到下一行开头 010   \r 回车(CR) ，将当前位置移到本行开头 013   \t 水平制表(HT) （跳到下一个TAB位置） 009   \v 垂直制表(VT) 011   \b backspace 退格(BS) ，将当前位置移到前一列 008   \f page feed 换页(FF)，将当前位置移到下页开头 012   \a 响铃(BEL) 警告alert (beep) 007   &#39; 单引号single quotes (&#39;)    &amp;quot; 双引号double quotes (&amp;quot;)    ? 问号question (?</description>
    </item>
    
    <item>
      <title>2.4 运算符</title>
      <link>https://yujian1018.github.io/book/cpp/2.-%E5%9F%BA%E7%A1%80/2.4-%E8%BF%90%E7%AE%97%E7%AC%A6/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/cpp/2.-%E5%9F%BA%E7%A1%80/2.4-%E8%BF%90%E7%AE%97%E7%AC%A6/</guid>
      <description>运算符    优先级 运算符 名称或含义 使用形式 结合方向 说明     1 [] 数组下标 数组名[常量表达式] 左到右     () 圆括号 （表达式）/函数名( 形参表)     . 成员选择（对象） 对象.成员名      -&amp;gt; 成员选择（指针） 对象指针-&amp;gt; 成员名    2 - 负号运算符 -表达式 右到左 单目运算符    (类型) 强制类型转换 (数据类型)表达式      ++ 自增运算符 ++变量名/变量名++  单目运算符    &amp;ndash; 自减运算符 &amp;ndash;变量名/变量名&amp;ndash;  单目运算符    * 取值运算符 *指针变量  单目运算符    &amp;amp; 取地址运算符 &amp;amp;变量名  单目运算符    !</description>
    </item>
    
    <item>
      <title>2.5 控制结构</title>
      <link>https://yujian1018.github.io/book/cpp/2.-%E5%9F%BA%E7%A1%80/2.5-%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/cpp/2.-%E5%9F%BA%E7%A1%80/2.5-%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/</guid>
      <description>控制结构 1.if if(true){}else if(true){}else{}2.switch int switch_on = 1;switch(switch_on){case 1:printf(&amp;#34;this case is 1\n&amp;#34;);break;default:break;}3.for for(int i=0; i&amp;lt;=100; i++&amp;gt;){printf(&amp;#34;i:%d!\n&amp;#34;, i);}int i;for(i=0; i&amp;lt;=0; i-=10000){printf(&amp;#34;i:%d!\n&amp;#34;, i);}return 0;4.while int m = 0;while(m &amp;lt;100&amp;gt;){m++;}#include &amp;lt;iostream.h&amp;gt;int main (){int n;cout &amp;lt;&amp;lt; &amp;#34;Enter the starting number &amp;gt; &amp;#34;;cin &amp;gt;&amp;gt; n;while (n&amp;gt;0) {cout &amp;lt;&amp;lt; n &amp;lt;&amp;lt; &amp;#34;, &amp;#34;;--n;}cout &amp;lt;&amp;lt; &amp;#34;FIRE!</description>
    </item>
    
    <item>
      <title>2.6 Class</title>
      <link>https://yujian1018.github.io/book/cpp/2.-%E5%9F%BA%E7%A1%80/2.6-class/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/cpp/2.-%E5%9F%BA%E7%A1%80/2.6-class/</guid>
      <description>Class 构造函数 构造函数的参数初始化表
析构函数 this指针详解 静态成员变量和静态成员函数 一般情况下，如果有N个同类的对象，那么每一个对象都分别有自己的成员变量，不同对象的成员变量各自有值，互不相干。但是有时我们希望有某一个或几个成员变量为所有对象共有，这样可以实现数据共享。
可以使用全局变量来达到共享数据的目的。例如在一个程序文件中有多个函数，每一个函数都可以改变全局变量的值，全局变量的值为各函数共享。但是用全局变量的安全性得不到保证，由于在各处都可以自由地修改全局变量的值，很有可能偶然失误，全局变量的值就被修改，导致程序的失败。因此在实际开发中很少使用全局变量。
如果想在同类的多个对象之间实现数据共享，也不要用全局变量，那么可以使用静态成员变量。
初始化实例时，填写静态变量改变规则
class Student{private:char *name;int age;float score;static int num; //将num定义为静态成员变量public:Student(char *, int, float);void say();};继承 权限，继承方式 派生类的构造和析构函数 名字遮蔽 多继承
虚基类 virtual
基类和派生类的赋值 注意指针对象
虚析构函数 注意内存回收
纯虚函数和抽象类 纯虚函数没有函数体，只有函数声明，在虚函数声明结尾加上=0，表明此函数为纯虚函数。</description>
    </item>
    
    <item>
      <title>2.7 关键字</title>
      <link>https://yujian1018.github.io/book/cpp/2.-%E5%9F%BA%E7%A1%80/2.7-%E5%85%B3%E9%94%AE%E5%AD%97/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/cpp/2.-%E5%9F%BA%E7%A1%80/2.7-%E5%85%B3%E9%94%AE%E5%AD%97/</guid>
      <description>关键字 const 在类中，如果你不希望某些数据被修改，可以借助 const 关键字加以限定。const 可以用来修饰成员变量、成员函数、对象以及对象的引用。
virtual 虚基类
   关键字 说明 描述     #define 宏定义，末尾没有分号结尾    &amp;amp; 地址符&amp;amp;，用以获得变量的地址    * 指针运算符（或称“间接访问” 运算符）    auto 声明自动变量    short 声明短整型变量或函数    int 声明整型变量或函数    long 声明长整型变量或函数    float 声明浮点型变量或函数    double 声明双精度变量或函数    char 声明字符型变量或函数    struct 声明结构体变量或函数    union 声明共用数据类型    enum 声明枚举类型    typedef 用以给数据类型取别名    const 声明只读变量    unsigned 声明无符号类型变量或函数    signed 声明有符号类型变量或函数    extern 声明变量是在其他文件正声明    register 声明寄存器变量    static 声明静态变量 首先static的最主要功能是隐藏，其次因为static变量存放在静态存储区，所以它具备持久性和默认值0。   volatile 说明变量在程序执行中可被隐含地改变    void 声明函数无返回值或无参数，声明无类型指针    if 条件语句    else 条件语句否定分支（与 if 连用）    switch 用于开关语句    case 开关语句分支    for 一种循环语句 for(int i = 0; i&amp;lt;300; i++){}   do 循环语句的循环体    while 循环语句的循环条件 while(condition){}   goto 无条件跳转语句    continue 结束当前循环，开始下一轮循环    break 跳出当前循环,完全跳出循环，不再往下执行，执行循环体外面的代码    default 开关语句中的“其他”分支    sizeof 计算数据类型长度    return 子程序返回语句（可以带参数，也可不带参数）循环条件     </description>
    </item>
    
    <item>
      <title>2.10 预处理指令</title>
      <link>https://yujian1018.github.io/book/cpp/2.-%E5%9F%BA%E7%A1%80/2.10-%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/cpp/2.-%E5%9F%BA%E7%A1%80/2.10-%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4/</guid>
      <description>预处理指令    指令 说明     # 空指令，无任何效果   #include 包含一个源代码文件   #define 定义宏   #undef 取消已定义的宏   #if 如果给定条件为真，则编译下面代码   #ifdef 如果宏已经定义，则编译下面代码   #ifndef 如果宏没有定义，则编译下面代码   #elif 如果前面的#if给定条件不为真，当前条件为真，则编译下面代码   #endif 结束一个#if……#else条件编译块    #include使用库函数之前，应该用#include引入对应的头文件。这种以#号开头的命令称为预处理命令。使用尖括号&amp;lt; &amp;gt;和双引号&amp;quot; &amp;quot;的区别在于头文件的搜索路径不同，包含标准库的头文件一般用尖括号，包含自定义的头文件一般用双引号。#define宏定义是由源程序中的宏定义命令#define完成的，宏代换是由预处理程序完成的。宏定义的一般形式为：#define 宏名 字符串#表示这是一条预处理命令，所有的预处理命令都以#开头。define是预处理命令。宏名是标识符的一种，命名规则和标识符相同。字符串可以是常数、表达式等。这里所说的字符串是一般意义上的字符序列，不要和C语言中的字符串等同，它不需要双引号。程序中反复使用的表达式就可以使用宏定义带参数宏定义带参宏定义的一般形式为：#define 宏名(形参列表) 字符串例如：#define M(y) y*y+3*y //宏定义// Codek=M(5); //宏调用条件编译第一种形式的格式为：#ifdef 标识符程序段1#else程序段2#endif它的功能是，如果标识符已被 #define 命令定义过则对程序段1进行编译；否则对程序段2进行编译。如果没有程序段2（它为空），本格式中的#else可以没有，即可以写为：#ifdef 标识符程序段#endif第二种形式的格式为：#ifndef 标识符程序段1 #else 程序段2 #endif它的功能是，如果标识符未被#define命令定义过则对程序段1进行编译，否则对程序段2进行编译。第三种形式的格式为：#if 常量表达式程序段1#else 程序段2#endif它的功能是，如常量表达式的值为真（非0），则对程序段1 进行编译，否则对程序段2进行编译。因此可以使程序在不同条件下，完成不同的功能。 </description>
    </item>
    
    <item>
      <title>2.11 指针</title>
      <link>https://yujian1018.github.io/book/cpp/2.-%E5%9F%BA%E7%A1%80/2.11-%E6%8C%87%E9%92%88/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/cpp/2.-%E5%9F%BA%E7%A1%80/2.11-%E6%8C%87%E9%92%88/</guid>
      <description>指针    定义 含义     int i; 定义整型变量 i。   int *p; p为指向整型数据的指针变量。   int a[n]; 定义整型数组a，它有n个元素。   int *p[n]; 定义指针数组p，它由n个指向整型数据的指针元素组成。   int (*p)[n]; p为指向含n个元素的一维数组的指针变量。   int f(); f 为一个返回整型的函数。   int *p(); p为一个返回指针的函数，该指针指向整型数据。   int (*p)(); p为指向函数的指针，该函数返回一个整型值。   int **p; p是一个指针变量，它又指向另外一个指针变量，该指针变量指向整型数据。    1) 指针变量可以加（减）一个整数，例如p++、p+i、p-=i。一个指针变量加（减）一个整数并不是简单地将原值加（减）一个整数，而是将该指针变量的原值（是一个地址）和它指向的变量所占用的内存单元字节数加（减）。2) 指针变量赋值：将一个变量的地址赋给一个指针变量。1. p=&amp;amp;a; //将变量a的地址赋给p2. p=array; //将数组array的首地址赋给p3. p=&amp;amp;array[i]; //将数组array第i个元素的地址赋给p4.</description>
    </item>
    
    <item>
      <title>2.12 结构体、共用体和位运算</title>
      <link>https://yujian1018.github.io/book/cpp/2.-%E5%9F%BA%E7%A1%80/2.12-%E7%BB%93%E6%9E%84%E4%BD%93%E5%85%B1%E7%94%A8%E4%BD%93%E5%92%8C%E4%BD%8D%E8%BF%90%E7%AE%97/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/cpp/2.-%E5%9F%BA%E7%A1%80/2.12-%E7%BB%93%E6%9E%84%E4%BD%93%E5%85%B1%E7%94%A8%E4%BD%93%E5%92%8C%E4%BD%8D%E8%BF%90%E7%AE%97/</guid>
      <description>结构体（Struct） struct stu{char *name; //姓名 int num; //学号 char sex; //性别 float score; //成绩};struct stu s1s1.name = &amp;#34;aa&amp;#34;s1.num=123// 结构体数组struct stu{char *name;int num;char sex;float score;}class[5] = {{&amp;#34;Li ping&amp;#34;, 5, &amp;#39;M&amp;#39;, 45},{&amp;#34;Zhang ping&amp;#34;, 4, &amp;#39;M&amp;#39;, 62.5},{&amp;#34;He fang&amp;#34;, 1, &amp;#39;F&amp;#39;, 92.5},{&amp;#34;Cheng ling&amp;#34;, 2, &amp;#39;F&amp;#39;, 87},{&amp;#34;Wang ming&amp;#34;, 3, &amp;#39;M&amp;#39;, 58}};// 结构体和指针struct stu{char *name;int num;char sex;float score;} *pstu, stu1, stu2;(*pstu).</description>
    </item>
    
    <item>
      <title>3.1 C标准库</title>
      <link>https://yujian1018.github.io/book/cpp/3.-%E5%BA%93%E5%87%BD%E6%95%B0/3.1-c%E6%A0%87%E5%87%86%E5%BA%93/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/cpp/3.-%E5%BA%93%E5%87%BD%E6%95%B0/3.1-c%E6%A0%87%E5%87%86%E5%BA%93/</guid>
      <description>   头文件 说明     stdio.h 义了用于输入和输出的函数、类型和宏。   stdlib.h 包含了C语言的中最常用的系统函数。   string.h 包含了C语言的最常用的字符串操作函数。   ctype.h 主要提供两类重要的函数：字符测试函数和字符大小转化函数。   assert.h 提供C语言断言功能，唯一的目的是提供宏assert的定义。   limits.h 指明了基本数据类型的取值范围。   stddef.h 定义了一些标准定义，许多定义也会出现在其他的头文件里。   time.h 获取时间与日期，对时间与日期数据操作及格式化的头文件。   float.h 定义了浮点型数值的最大最小限。   math.h 义了与数学计算有关的函数。   error.h 误处理。   locale.h 定义了本地化设置相关的函数。   setjmp.h 定义了一种特别的函数调用和函数返回顺序的方式。   signal.h 提供了一些函数用以处理执行过程中所产生的信号。   stdarg.h 可变参数列表，定义了一些宏，当函数参数未知时去获取函数的参数。    </description>
    </item>
    
    <item>
      <title>3.2 sstream</title>
      <link>https://yujian1018.github.io/book/cpp/3.-%E5%BA%93%E5%87%BD%E6%95%B0/3.2-sstream/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/cpp/3.-%E5%BA%93%E5%87%BD%E6%95%B0/3.2-sstream/</guid>
      <description>sstream 库定义了三种类：istringstream、ostringstream和stringstream
stringstream通常是用来做数据转换的。
相比c库的转换，它更加安全，自动和直接。
#include &amp;lt;string&amp;gt;#include &amp;lt;sstream&amp;gt;#include &amp;lt;iostream&amp;gt; int main(){std::stringstream stream;std::string result;int i = 1000;stream &amp;lt;&amp;lt; i; //将int输入流 stream &amp;gt;&amp;gt; result; //从stream中抽取前面插入的int值 std::cout &amp;lt;&amp;lt; result &amp;lt;&amp;lt; std::endl; // print the string &amp;#34;1000&amp;#34; stream.clear(); //在进行多次转换前，必须清除stream} </description>
    </item>
    
    <item>
      <title>3.3 assert</title>
      <link>https://yujian1018.github.io/book/cpp/3.-%E5%BA%93%E5%87%BD%E6%95%B0/3.3-assert/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/cpp/3.-%E5%BA%93%E5%87%BD%E6%95%B0/3.3-assert/</guid>
      <description>#include &amp;lt;assert.h&amp;gt;#include &amp;lt;stdio.h&amp;gt;int main() {int a;char str[50];printf(&amp;#34;请输入一个整数值： &amp;#34;);scanf(&amp;#34;%d\n&amp;#34;, &amp;amp;a);assert(a &amp;gt;= 10);printf(&amp;#34;输入的整数是：%d\n&amp;#34;, a);printf(&amp;#34;请输入字符串： &amp;#34;);scanf(&amp;#34;%s\n&amp;#34;, &amp;amp;str);assert(str != NULL);printf(&amp;#34;输入的字符串是： %s\n&amp;#34;, str);return 0;}a.out: assert.c:15: main: Assertion `a &amp;gt;= 10&amp;#39; failed.已放弃 (核心已转储)</description>
    </item>
    
    <item>
      <title>3.4 ctype</title>
      <link>https://yujian1018.github.io/book/cpp/3.-%E5%BA%93%E5%87%BD%E6%95%B0/3.4-ctype/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/cpp/3.-%E5%BA%93%E5%87%BD%E6%95%B0/3.4-ctype/</guid>
      <description>简介 C 标准库的 ctype.h 头文件提供了一些函数，可用于测试和映射字符。这些函数接受 int 作为参数，它的值必须是 EOF 或表示为一个无符号字符。如果参数 c 满足描述的条件，则这些函数返回非零（true）。如果参数 c 不满足描述的条件，则这些函数返回零。 </description>
    </item>
    
    <item>
      <title>3.5 float</title>
      <link>https://yujian1018.github.io/book/cpp/3.-%E5%BA%93%E5%87%BD%E6%95%B0/3.5-float/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/cpp/3.-%E5%BA%93%E5%87%BD%E6%95%B0/3.5-float/</guid>
      <description>简介 C 标准库的 float.h 头文件包含了一组与浮点值相关的依赖于平台的常量。这些常量是由 ANSI C 提出的，这让程序更具有可移植性。在讲解这些常量之前，最好先弄清楚浮点数是由下面四个元素组成的：组件 组件描述S 符号 ( +/- )b 指数表示的基数，2 表示二进制，10 表示十进制，16 表示十六进制，等等...e 指数，一个介于最小值 emin 和最大值 emax 之间的整数。p 精度，基数 b 的有效位数基于以上 4 个组成部分，一个浮点数的值如下：floating-point = ( S ) p x be或floating-point = (+/-) precision x baseexponent </description>
    </item>
    
    <item>
      <title>3.6 limits</title>
      <link>https://yujian1018.github.io/book/cpp/3.-%E5%BA%93%E5%87%BD%E6%95%B0/3.6-limits/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/cpp/3.-%E5%BA%93%E5%87%BD%E6%95%B0/3.6-limits/</guid>
      <description>简介 limits.h 头文件决定了各种变量类型的各种属性。定义在该头文件中的宏限制了各种变量类型（比如 char、int 和 long）的值。这些限制指定了变量不能存储任何超出这些限制的值，例如一个无符号可以存储的最大值是 255。库宏下面的值是特定实现的，且是通过 #define 指令来定义的，这些值都不得低于下边所给出的值。    宏 值 描述     CHAR_BIT 8 定义一个字节的比特数。   SCHAR_MIN -128 定义一个有符号字符的最小值。   SCHAR_MAX 127 定义一个有符号字符的最大值。   UCHAR_MAX 255 定义一个无符号字符的最大值。   CHAR_MIN 0 定义类型 char 的最小值，如果 char 表示负值，则它的值等于 SCHAR_MIN，否则等于0。   CHAR_MAX 127 定义类型 char 的最大值，如果 char 表示负值，则它的值等于 SCHAR_MAX，否则等于UCHAR_MAX。   MB_LEN_MAX 1 定义多字节字符中的最大字节数。   SHRT_MIN -32768 定义一个短整型的最小值。   SHRT_MAX +32767 定义一个短整型的最大值。   USHRT_MAX 65535 定义一个无符号短整型的最大值。   INT_MIN -32768 定义一个整型的最小值。   INT_MAX +32767 定义一个整型的最大值。   UINT_MAX 65535 定义一个无符号整型的最大值。   LONG_MIN -2147483648 定义一个长整型的最小值。   LONG_MAX +2147483647 定义一个长整型的最大值。   ULONG_MAX 4294967295 定义一个无符号长整型的最大值。    </description>
    </item>
    
    <item>
      <title>3.7 locale</title>
      <link>https://yujian1018.github.io/book/cpp/3.-%E5%BA%93%E5%87%BD%E6%95%B0/3.7-locale/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/cpp/3.-%E5%BA%93%E5%87%BD%E6%95%B0/3.7-locale/</guid>
      <description>简介 locale.h 头文件定义了特定地域的设置，比如日期格式和货币符号。接下来我们将介绍一些宏，以及一个重要的结构 struct lconv 和两个重要的函数。 </description>
    </item>
    
    <item>
      <title>3.10 signal</title>
      <link>https://yujian1018.github.io/book/cpp/3.-%E5%BA%93%E5%87%BD%E6%95%B0/3.10-signal/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/cpp/3.-%E5%BA%93%E5%87%BD%E6%95%B0/3.10-signal/</guid>
      <description>简介 signal.h 头文件定义了一个变量类型 sig_atomic_t、两个函数调用和一些宏来处理程序执行期间报告的不同信号。 库变量 下面是头文件 signal.h 中定义的变量类型：序号 变量 &amp;amp; 描述1 sig_atomic_t 这是 int 类型，在信号处理程序中作为变量使用。它是一个对象的整数类型，该对象可以作为一个原子实体访问，即使存在异步信号时，该对象可以作为一个原子实体访问。 库宏 下面是头文件 signal.h 中定义的宏，这些宏将在下列两个函数中使用。SIG_ 宏与 signal 函数一起使用来定义信号的功能。序号 宏 &amp;amp; 描述1 SIG_DFL默认的信号处理程序。2 SIG_ERR表示一个信号错误。3 SIG_IGN忽视信号。SIG 宏用于表示以下各种条件的信号码：序号 宏 &amp;amp; 描述1 SIGABRT程序异常终止。2 SIGFPE算术运算出错，如除数为 0 或溢出。3 SIGILL非法函数映象，如非法指令。4 SIGINT中断信号，如 ctrl-C。5 SIGSEGV非法访问存储器，如访问不存在的内存单元。6 SIGTERM发送给本程序的终止请求信号。 库函数 下面是头文件 signal.h 中定义的函数：序号 函数 &amp;amp; 描述1 void (*signal(int sig, void (*func)(int)))(int)该函数设置一个函数来处理信号，即信号处理程序。2 int raise(int sig)该函数会促使生成信号 sig。sig 参数与 SIG 宏兼容。 </description>
    </item>
    
    <item>
      <title>3.11 stdarg</title>
      <link>https://yujian1018.github.io/book/cpp/3.-%E5%BA%93%E5%87%BD%E6%95%B0/3.11-stdarg/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/cpp/3.-%E5%BA%93%E5%87%BD%E6%95%B0/3.11-stdarg/</guid>
      <description>#include&amp;lt;stdarg.h&amp;gt;#include&amp;lt;stdio.h&amp;gt;int sum(int, ...);int main(void){printf(&amp;#34;10、20 和 30 的和 = %d\n&amp;#34;, sum(3, 10, 20, 30) );printf(&amp;#34;4、20、25 和 30 的和 = %d\n&amp;#34;, sum(4, 4, 20, 25, 30) );return 0;}int sum(int num_args, ...){int val = 0;va_list ap;int i;va_start(ap, num_args);for(i = 0; i &amp;lt; num_args; i++){val += va_arg(ap, int);}va_end(ap);return val;}</description>
    </item>
    
    <item>
      <title>3.12 stddef</title>
      <link>https://yujian1018.github.io/book/cpp/3.-%E5%BA%93%E5%87%BD%E6%95%B0/3.12-stddef/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/cpp/3.-%E5%BA%93%E5%87%BD%E6%95%B0/3.12-stddef/</guid>
      <description>简介 stddef .h 头文件定义了各种变量类型和宏。这些定义中的大部分也出现在其它头文件中。 库变量 下面是头文件 stddef.h 中定义的变量类型：序号 变量 &amp;amp; 描述1 ptrdiff_t这是有符号整数类型，它是两个指针相减的结果。2 size_t 这是无符号整数类型，它是 sizeof 关键字的结果。3 wchar_t 这是一个宽字符常量大小的整数类型。 库宏 下面是头文件 stddef.h 中定义的宏：序号 宏 &amp;amp; 描述1 NULL这个宏是一个空指针常量的值。2 offsetof(type, member-designator)这会生成一个类型为 size_t 的整型常量，它是一个结构成员相对于结构开头的字节偏移量。成员是由 member-designator 给定的，结构的名称是在 type 中给定的。 </description>
    </item>
    
    <item>
      <title>3.13 stdio</title>
      <link>https://yujian1018.github.io/book/cpp/3.-%E5%BA%93%E5%87%BD%E6%95%B0/3.13-stdio/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/cpp/3.-%E5%BA%93%E5%87%BD%E6%95%B0/3.13-stdio/</guid>
      <description>atoi，atol，atof atoi()会扫描参数nptr字符串，检测到第一个数字或正负符号时开始做类型转换，之后检测到非数字或结束符 \0 时停止转换，返回整型数。 itoa 功能:把一整数转换为字符串用法:char *itoa(int value, char *string, int radix);详细解释:itoa是英文integer to array(将int整型数转化为一个字符串,并将值保存在数组string中)的缩写.参数：value: 待转化的整数。radix: 是基数的意思,即先将value转化为radix进制的数，范围介于2-36，比如10表示10进制，16表示16进制。* string: 保存转换后得到的字符串。返回值：char * : 指向生成的字符串， 同*string。备注:该函数的头文件是&amp;quot;stdlib.h&amp;quot; 四舍五入 if( x &amp;gt; 0.0 )return (int)( x + 0.5 );elsereturn (int)( x - 0.5 );头文件：#include &amp;lt;stdio.h&amp;gt;scanf() 函数用来格式化输入数据，即按用户指定的格式从键盘上把数据读入到指定的变量中。其原型为：int scanf ( char * format [ ,argument, ... ]);【参数】format为格式化控制字符串，可以由三类字符构成。1) 格式化说明符------------------------------------------------------------格式字符 说明------------------------------------------------------------%a 读入一个浮点值(仅C99有效)%A 同上%c 读入一个字符%d 读入十进制整数%i 读入十进制，八进制，十六进制整数%o 读入八进制整数%x 读入十六进制整数%X 同上%c 读入一个字符%s 读入一个字符串%f 读入一个浮点数%F 同上%e 同上%E 同上%g 同上%G 同上%p 读入一个指针%u 读入一个无符号十进制整数%n 至此已读入值的等价字符数%[] 扫描字符集合%% 读%符号另外，还有附加格式说明字符，用于追加在上面的格式说明符后面-----------------------------------------------------------------修饰符 说明-----------------------------------------------------------------L/l 长度修饰符，输入&amp;quot;长&amp;quot;数据h 长度修饰符，输入&amp;quot;短&amp;quot;数据W 整型常数，指定输入数据所占宽度* 星号，空读一个数据hh 同 h，但仅对C99有效ll 同 l，但仅对C99有效2) 空白字符空白字符会使scanf()函数在读操作中略去输入中的一个或多个空白字符，空白符可以是space,tab,newline等等，直到第一个非空白符出现为止。3) 非空白字符一个非空白字符会使scanf()函数在读入时剔除掉与这个非空白字符相同的字符。argument 为需要读入的所有变量的地址。注意，是变量地址，而不是变量标识符：如果是一般的变量，通常要在变量名前加上&amp;quot;&amp;amp;&amp;quot;取得地址，但输出时是用变量名。如果是数组，用数组名就代表了该数组的首地址，输出时也是用数组名如果是指针，直接用指针名本身，不要加上“*”，输出时也用该指针即可。【返回值】成功则返回被赋值的参数的个数。如果 format 和 argument 匹配错误，或者遇到结束符，那么返回值可能小于参数的个数。如果读取发生错误，将会返回 EOF，并设置错误标识，后续可以通过 ferror() 检测。如果遇到结束符，将会设置文件结束标识，后续可以通过 feof() 检测。如果在读取宽字符的时候发生编码错误，那么将会把 errno 设置为 EILSEQ。格式字符串格式字符串的一般形式为：%[*][输入数据宽度][长度]类型其中有方括号[]的项为任选项。各项的意义如下。1) 类型表示输入数据的类型，其格式符和意义如下表所示格式 字符意义d 输入十进制整数o 输入八进制整数x 输入十六进制整数u 输入无符号十进制整数f或e 输入实型数(用小数形式或指数形式)c 输入单个字符s 输入字符串2) “*”符用以表示该输入项，读入后不赋予相应的变量，即跳过该输入值。如：scanf(&amp;quot;%d %*d %d&amp;quot;,&amp;amp;a,&amp;amp;b);当输入为：1 2 3时，把1赋予a，2被跳过，3赋予b。3) 宽度用十进制整数指定输入的宽度（即字符数）。例如：scanf(&amp;quot;%5d&amp;quot;,&amp;amp;a);输入12345678只把12345赋予变量a，其余部分被截去。又如：scanf(&amp;quot;%4d%4d&amp;quot;,&amp;amp;a,&amp;amp;b);输入12345678将把1234赋予a，而把5678赋予b。4) 长度长度格式符为l和h，l表示输入长整型数据（如%ld）和双精度浮点数（如%lf）。h表示输入短整型数据。使用scanf函数还必须注意以下几点：scanf函数中没有精度控制，如：scanf(&amp;quot;%5.</description>
    </item>
    
    <item>
      <title>3.14 stdlib</title>
      <link>https://yujian1018.github.io/book/cpp/3.-%E5%BA%93%E5%87%BD%E6%95%B0/3.14-stdlib/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/cpp/3.-%E5%BA%93%E5%87%BD%E6%95%B0/3.14-stdlib/</guid>
      <description>简介 stdli b .h 头文件定义了四个变量类型、一些宏和各种通用工具函数。
库变量 下面是头文件 stdlib.h 中定义的变量类型：序号 变量 &amp;amp; 描述1 size_t 这是无符号整数类型，它是 sizeof 关键字的结果。2 wchar_t 这是一个宽字符常量大小的整数类型。3 div_t 这是 div 函数返回的结构。4 ldiv_t 这是 ldiv 函数返回的结构。 库宏 下面是头文件 stdlib.h 中定义的宏：序号 宏 &amp;amp; 描述1 NULL这个宏是一个空指针常量的值。2 EXIT_FAILURE这是 exit 函数失败时要返回的值。3 EXIT_SUCCESS这是 exit 函数成功时要返回的值。4 RAND_MAX 这个宏是 rand 函数返回的最大值。5 MB_CUR_MAX 这个宏表示在多字节字符集中的最大字符数，不能大于 MB_LEN_MAX。 库函数 下面是头文件 stdlib.h 中定义的函数：序号 函数 &amp;amp; 描述1 double atof(const char *str)把参数 str 所指向的字符串转换为一个浮点数（类型为 double 型）。2 int atoi(const char *str)把参数 str 所指向的字符串转换为一个整数（类型为 int 型）。3 long int atol(const char *str)把参数 str 所指向的字符串转换为一个长整数（类型为 long int 型）。4 double strtod(const char *str, char **endptr)把参数 str 所指向的字符串转换为一个浮点数（类型为 double 型）。5 long int strtol(const char *str, char **endptr, int base)把参数 str 所指向的字符串转换为一个长整数（类型为 long int 型）。6 unsigned long int strtoul(const char *str, char **endptr, int base)把参数 str 所指向的字符串转换为一个无符号长整数（类型为 unsigned long int 型）。7 void *calloc(size_t nitems, size_t size)分配所需的内存空间，并返回一个指向它的指针。8 void free(void *ptr)释放之前调用 calloc、malloc 或 realloc 所分配的内存空间。9 void *malloc(size_t size)分配所需的内存空间，并返回一个指向它的指针。10 void *realloc(void *ptr, size_t size)尝试重新调整之前调用 malloc 或 calloc 所分配的 ptr 所指向的内存块的大小。11 void abort(void)使一个异常程序终止。12 int atexit(void (*func)(void))当程序正常终止时，调用指定的函数 func。13 void exit(int status)使程序正常终止。14 char *getenv(const char *name)搜索 name 所指向的环境字符串，并返回相关的值给字符串。15 int system(const char *string)由 string 指定的命令传给要被命令处理器执行的主机环境。16 void *bsearch(const void *key, const void *base, size_t nitems, size_t size, int (*compar)(const void *, const void *))执行二分查找。17 void qsort(void *base, size_t nitems, size_t size, int (*compar)(const void *, const void*))数组排序。18 int abs(int x)返回 x 的绝对值。19 div_t div(int numer, int denom)分子除以分母。20 long int labs(long int x)返回 x 的绝对值。21 ldiv_t ldiv(long int numer, long int denom)分子除以分母。22 int rand(void)返回一个范围在 0 到 RAND_MAX 之间的伪随机数。23 void srand(unsigned int seed)该函数播种由函数 rand 使用的随机数发生器。24 int mblen(const char *str, size_t n)返回参数 str 所指向的多字节字符的长度。25 size_t mbstowcs(schar_t *pwcs, const char *str, size_t n)把参数 str 所指向的多字节字符的字符串转换为参数 pwcs 所指向的数组。26 int mbtowc(whcar_t *pwc, const char *str, size_t n)检查参数 str 所指向的多字节字符。27 size_t wcstombs(char *str, const wchar_t *pwcs, size_t n)把数组 pwcs 中存储的编码转换为多字节字符，并把它们存储在字符串 str 中。28 int wctomb(char *str, wchar_t wchar)检查对应于参数 wchar 所给出的多字节字符的编码。 </description>
    </item>
    
    <item>
      <title>3.15 string</title>
      <link>https://yujian1018.github.io/book/cpp/3.-%E5%BA%93%E5%87%BD%E6%95%B0/3.15-string/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/cpp/3.-%E5%BA%93%E5%87%BD%E6%95%B0/3.15-string/</guid>
      <description>简介 string .h 头文件定义了一个变量类型、一个宏和各种操作字符数组的函数。 库变量 下面是头文件 string.h 中定义的变量类型：序号 变量 &amp;amp; 描述1 size_t 这是无符号整数类型，它是 sizeof 关键字的结果。 库宏 下面是头文件 string.h 中定义的宏：序号 宏 &amp;amp; 描述1 NULL这个宏是一个空指针常量的值。 库函数 下面是头文件 string.h 中定义的函数：序号 函数 &amp;amp; 描述1 void *memchr(const void *str, int c, size_t n)在参数 str 所指向的字符串的前 n 个字节中搜索第一次出现字符 c（一个无符号字符）的位置。2 int memcmp(const void *str1, const void *str2, size_t n)把 str1 和 str2 的前 n 个字节进行比较。3 void *memcpy(void *dest, const void *src, size_t n)从 src 复制 n 个字符到 dest。4 void *memmove(void *dest, const void *src, size_t n)另一个用于从 str2 复制 n 个字符到 str1 的函数。5 void *memset(void *str, int c, size_t n)复制字符 c（一个无符号字符）到参数 str 所指向的字符串的前 n 个字符。6 char *strcat(char *dest, const char *src)把 src 所指向的字符串追加到 dest 所指向的字符串的结尾。7 char *strncat(char *dest, const char *src, size_t n)把 src 所指向的字符串追加到 dest 所指向的字符串的结尾，直到 n 字符长度为止。8 char *strchr(const char *str, int c)在参数 str 所指向的字符串中搜索第一次出现字符 c（一个无符号字符）的位置。9 int strcmp(const char *str1, const char *str2)把 str1 所指向的字符串和 str2 所指向的字符串进行比较。10 int strncmp(const char *str1, const char *str2, size_t n)把 str1 和 str2 进行比较，最多比较前 n 个字节。11 int strcoll(const char *str1, const char *str2)把 str1 和 str2 进行比较，结果取决于 LC_COLLATE 的位置设置。12 char *strcpy(char *dest, const char *src)把 src 所指向的字符串复制到 dest。13 char *strncpy(char *dest, const char *src, size_t n)把 src 所指向的字符串复制到 dest，最多复制 n 个字符。14 size_t strcspn(const char *str1, const char *str2)检索字符串 str1 开头连续有几个字符都不含字符串 str2 中的字符。15 char *strerror(int errnum)从内部数组中搜索错误号 errnum，并返回一个指向错误消息字符串的指针。16 size_t strlen(const char *str)计算字符串 str 的长度，直到空结束字符，但不包括空结束字符。17 char *strpbrk(const char *str1, const char *str2)检索字符串 str1 中第一个匹配字符串 str2 中字符的字符，不包含空结束字符。也就是说，依次检验字符串 str1 中的字符，当被检验字符在字符串 str2 中也包含时，则停止检验，并返回该字符位置。18 char *strrchr(const char *str, int c)在参数 str 所指向的字符串中搜索最后一次出现字符 c（一个无符号字符）的位置。19 size_t strspn(const char *str1, const char *str2)检索字符串 str1 中第一个不在字符串 str2 中出现的字符下标。20 char *strstr(const char *haystack, const char *needle)在字符串 haystack 中查找第一次出现字符串 needle（不包含空结束字符）的位置。21 char *strtok(char *str, const char *delim)分解字符串 str 为一组字符串，delim 为分隔符。22 size_t strxfrm(char *dest, const char *src, size_t n)根据程序当前的区域选项中的 LC_COLLATE 来转换字符串 src 的前 n 个字符，并把它们放置在字符串 dest 中。 strlen strlen 是 string length 的缩写，用来获得字符串的长度。所谓长度，就是包含多少个字符（不包括字符串结束标志 &#39;\0&#39;）。语法格式为：strlen(arrayName);strlen 将返回字符串的长度，它是一个整数。 strcat strcat 是 string catenate 的缩写，意思是把两个字符串拼接在一起，语法格式为：strcat(arrayName1, arrayName2);arrayName1、arrayName2 为需要拼接的字符串。 strcpy strcpy 是 string copy 的缩写，意思是字符串复制，语法格式为：strcpy(arrayName1, arrayName2);strcpy 会把 arrayName2 中的字符串拷贝到 arrayName1 中，串结束标志 &#39;\0&#39; 也一同拷贝。 strcmp strcmp 是 string compare 的缩写，意思是字符串比较，语法格式为：strcmp(arrayName1, arrayName2);arrayName1 和 arrayName2 是需要比较的两个字符串。字符本身没有大小之分，strcmp() 是以各个字符在ASCII 码表上对应的数值进行比较的。strcmp() 首先将 arrayName1 中第0个字符的 ASCII 码值减去 arrayName2 中第0个字符的 ASCII 码值，若差值为 0，则说明两个字符相同，再继续比较下个字符，若差值不为 0 则将差值返回。例如字符串&amp;quot;Ac&amp;quot;和&amp;quot;ba&amp;quot;比较则会返回字符&amp;quot;A&amp;quot;(65)和&#39;b&#39;(98)的差值(－33)。返回值：若 arrayName1 和 arrayName2 相同，则返回0；若 arrayName1 大于 arrayName2，则返回大于 0 的值；若 arrayName1 小于 arrayName2，则返回小于0 的值。 </description>
    </item>
    
    <item>
      <title>3.16 time</title>
      <link>https://yujian1018.github.io/book/cpp/3.-%E5%BA%93%E5%87%BD%E6%95%B0/3.16-time/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/cpp/3.-%E5%BA%93%E5%87%BD%E6%95%B0/3.16-time/</guid>
      <description>简介 time.h 头文件定义了四个变量类型、两个宏和各种操作日期和时间的函数。 库变量 下面是头文件 time.h 中定义的变量类型：序号 变量 &amp;amp; 描述1 size_t 是无符号整数类型，它是 sizeof 关键字的结果。2 clock_t 这是一个适合存储处理器时间的类型。3 time_t is 这是一个适合存储日历时间类型。4 struct tm 这是一个用来保存时间和日期的结构。tm 结构的定义如下：struct tm {int tm_sec; /* 秒，范围从 0 到 59 */int tm_min; /* 分，范围从 0 到 59 */int tm_hour; /* 小时，范围从 0 到 23 */int tm_mday; /* 一月中的第几天，范围从 1 到 31 */int tm_mon; /* 月，范围从 0 到 11 */int tm_year; /* 自 1900 年起的年数 */int tm_wday; /* 一周中的第几天，范围从 0 到 6 */int tm_yday; /* 一年中的第几天，范围从 0 到 365 */int tm_isdst; /* 夏令时 */}; 库宏 下面是头文件 time.</description>
    </item>
    
    <item>
      <title>3.17 printf</title>
      <link>https://yujian1018.github.io/book/cpp/3.-%E5%BA%93%E5%87%BD%E6%95%B0/3.17-printf/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/cpp/3.-%E5%BA%93%E5%87%BD%E6%95%B0/3.17-printf/</guid>
      <description>格式字符串 在Turbo C中格式字符串的一般形式为：%[标志][输出最小宽度][.精度][长度]类型。%[flags][width][.precision]type其中方括号[]中的项为可选项。1) 类型。 也就是以什么类型输出，比如 %d、%f、%c，type 就分别对应 d、f、c；%-9d中 type 对应 d。type 必须有。格式字符 意义 c 输出单个字符 s 输出字符串 f 以小数形式输出单、双精度实数 默认保留六位小数，不足六位以 0 补齐，超过六位按四舍五入截断d 以十进制形式输出带符号整数(正数不输出符号) o 以八进制形式输出无符号整数(不输出前缀0) x,X 以十六进制形式输出无符号整数(不输出前缀Ox) u 以十进制形式输出无符号整数 e,E 以指数形式输出单、双精度实数 g,G 以%f或%e中较短的输出宽度输出单、双精度实数 2) 标志。标志字符为 -、+、# 和空格四种，其意义下表所示：标志字符 含 义- 左对齐+ 输出符号（正号或负号）空格 输出值为正时冠以空格，为负时冠以负号# 对c、s、d、u类无影响；对o类，在输出时加前缀o；对x类，在输出时加前缀0x；对e、g、f 类当结果有小数时才给出小数点。3) 输出最小宽度。width 表示最小输出宽度，也就是占几个字符的位置；%-9d中 width 对应 9。用十进制整数来表示输出的最少位数。若实际位数多于定义的宽度，则按实际位数输出，若实际位数少于定义的宽度则补以空格或0。4) 精度精度格式符以“.”开头，后跟十进制整数。本项的意义是：如果输出数字，则表示小数的位数；如果输出的是字符，则表示输出字符的个数；若实际位数大于所定义的精度数，则截去超过的部分。不足的宽度以 0 补齐5) 长度长度格式符为h、l两种，h表示按短整型量输出，l表示按长整型量输出。例子：int a=15;long float b=123.</description>
    </item>
    
    <item>
      <title>2.8 函数模板</title>
      <link>https://yujian1018.github.io/book/cpp/2.-%E5%9F%BA%E7%A1%80/2.8-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/cpp/2.-%E5%9F%BA%E7%A1%80/2.8-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/</guid>
      <description>template&amp;lt;typename T&amp;gt;T max(T a, T b, T c) {if (a &amp;gt; b) a = b;if (a &amp;gt; c) a = c;return a;}int main() {cout &amp;lt;&amp;lt; max(10, 11, 12) &amp;lt;&amp;lt; endl;return 0;}模板类#include &amp;lt;iostream&amp;gt;using namespace std;template&amp;lt;typename M, typename N&amp;gt;class point {private:M x;N y;public:point() : x(0), y(0) {}point(M x, N y) : x(x), y(y) {}void set_xy(M x, N y);M get_x();N get_y();};template&amp;lt;typename M, typename N&amp;gt;void point&amp;lt;M, N&amp;gt;::set_xy(M x, N y) {this-&amp;gt;x = x;this-&amp;gt;y = y;}template&amp;lt;typename M, typename N&amp;gt;M point&amp;lt;M, N&amp;gt;::get_x() {return x;}int main() {point&amp;lt;int, float &amp;gt; p(10, 12.</description>
    </item>
    
    <item>
      <title>2.9 数据结构</title>
      <link>https://yujian1018.github.io/book/cpp/2.-%E5%9F%BA%E7%A1%80/2.9-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/cpp/2.-%E5%9F%BA%E7%A1%80/2.9-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid>
      <description>Array int a[10]={12, 19, 22 , 993, 344}; int a[10] = {0};char c[10] = {0};float f[10] = {0};float level[2], sum; 定义一个两个参数的数组，并且参数只能是float型 C语言规定，数组名就代表了该数组的地址。C语言还规定，数组名所代表的地址为第0个元素的地址，例如char c[10];，c就代表c[0]的地址。第0个元素的地址就是数组的起始地址，称为首地址。也就是说，数组名表示数组的首地址。数组的定义格式为：type arrayName[length]type 为数据类型，arrayName 为数组名，length 为数组长度。 需要注意的是：在不支持C99的编译器中，length 必须是一个数值常量，不能是变量，例如 VC6.0、VS2010 等；在支持C99的编译器中，length 还可以是变量，例如 C-Free 5.0、GCC等。数组在内存中占用一段连续的空间，数组名表示的是这段内存空间的首地址。2) 访问数组中某个元素的格式为：arrayName[index]index 为数组下标。注意 index 的值必须大于等于零，并且小于数组长度，否则会发生数组越界，出现意想不到的错误。 2.变元向量 argv[]  </description>
    </item>
    
    <item>
      <title>3.8 math</title>
      <link>https://yujian1018.github.io/book/cpp/3.-%E5%BA%93%E5%87%BD%E6%95%B0/3.8-math/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/cpp/3.-%E5%BA%93%E5%87%BD%E6%95%B0/3.8-math/</guid>
      <description>简介 math.h 头文件定义了各种数学函数和一个宏。在这个库中所有可用的功能都带有一个 double 类型的参数，且都返回 double 类型的结果。 </description>
    </item>
    
    <item>
      <title>3.9 setjmp</title>
      <link>https://yujian1018.github.io/book/cpp/3.-%E5%BA%93%E5%87%BD%E6%95%B0/3.9-setjmp/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/cpp/3.-%E5%BA%93%E5%87%BD%E6%95%B0/3.9-setjmp/</guid>
      <description>简介 setjmp.h 头文件定义了宏 setjmp()、函数 longjmp() 和变量类型 jmp_buf，该变量类型会绕过正常的函数调用和返回规则。 库变量 下面列出了头文件 setjmp.h 中定义的变量：序号 变量 &amp;amp; 描述1 jmp_buf 这是一个用于存储宏 setjmp() 和函数 longjmp() 相关信息的数组类型。 库宏 下面是这个库中定义的唯一的一个宏：序号 宏 &amp;amp; 描述1 int setjmp(jmp_buf environment)这个宏把当前环境保存在变量 environment 中，以便函数 longjmp() 后续使用。如果这个宏直接从宏调用中返回，则它会返回零，但是如果它从 longjmp() 函数调用中返回，则它会返回一个非零值。 库函数 下面是头文件 setjmp.h 中定义的唯一的一个函数：序号 函数 &amp;amp; 描述1 void longjmp(jmp_buf environment, int value)该函数恢复最近一次调用 setjmp() 宏时保存的环境，jmp_buf 参数的设置是由之前调用 setjmp() 生成的。 </description>
    </item>
    
    <item>
      <title>3.18 文件操作</title>
      <link>https://yujian1018.github.io/book/cpp/3.-%E5%BA%93%E5%87%BD%E6%95%B0/3.18-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/cpp/3.-%E5%BA%93%E5%87%BD%E6%95%B0/3.18-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</guid>
      <description>1. 文件和流的关系C将每个文件简单地作为顺序字节流。每个文件用文件结束符结束，或者在特定字节数的地方结束，这个特定的字节数可以存储在系统维护的管理数据结构中。当打开文件时，就建立了和文件的关系。在开始执行程序的时候，将自动打开3个文件和相关的流：标准输入流、标准输出流和标准错误。流提供了文件和程序的通信通道。打开一个文件将返回指向FILE结构(在stdio.h中定义)的指针，它包含用于处理文件的信息，也就是说，这个结构包含文件描述符。文件描述符是操作系统数组(打开文件列表的索引)。每个数组元素包含一个文件控制块(FCB, File Control Block)，操作系统用它来管理特定的文件。标准输入、标准输出和标准错误是用文件指针stdin、stdout和stderr来处理的。C语言把磁盘文件看成是字符（或字节）的序列，按照存储信息的形式来说，文件主要是有文本文件和二进制文件。文本文件由一个个字符组成，每个字节存放一个ASCII码制，代表一个字符。二进制文件把内存中的数据按其在内存中的存储形式原样放入磁盘空间。二进制文件以及文本文件都可以看做是“数据流”。2. C语言文件管理的实现C程序用不同的FILE结构管理每个文件。程序员可以使用文件，但不需要知道FILE结构的细节。实际上，FILE结构是间接地操作系统的文件控制块(FCB)来实现对文件的操作的。例如FILE结构体中的_file实际上就是一个文件描述符，作为进入打开文件表索引的整数。3. 操作系统文件管理简介文件是存放在物理磁盘上的，包括文件控制块(FCB)和数据块。文件控制块通常包括文件权限、日期（创建、读取、修改）、拥有者、文件大小、数据块信息。数据块用来存储实际的内容。对于打开的文件，操作系统是这样管理的：1系统维护了两张表，一张是系统级打开文件表，一张是进程级打开文件表（每个进程有一个）。系统级打开文件表复制了文件控制块的信息等；进程级打开文件表保存了指向系统级文件表的指针及其他信息。系统级文件表每一项都保存一个计数器，即该文件打开的次数。我们初次打开一个文件时，系统首先查看该文件是否已在系统级文件表中，如果不在，则创建该项信息，否则，计数器加1。当我们关闭一个文件时，相应的计数也会减1，当减到0时，系统将系统级文件表中的项删除。进程打开一个文件时，会在进程级文件表中添加一项。每项的信息包括当前文件偏移量（读写文件的位置）、存取权限、和一个指向系统级文件表中对应文件项的指针。系统级文件表中的每一项通过文件描述符（一个非负整数）来标识。FILE结构体中的_file成员应该是指向进程级打开文件表，然后，通过进程级打开文件表可以找到系统级打开文件表，进而可以通过FCB操作物理磁盘上面的文件。每打开一次文件，哪怕多次打开的都是同一个文件，进程级打开文件表中应该都会添加一个记录。如果是打开的是同一个文件，这多条记录对应着同一个物理磁盘文件。由于每一次打开文件所进行的操作都是通过进程级打开文件表中不同的记录来实现的，这样，相当于每次打开文件的操作是相对独立的。4. 缓冲区当我们从键盘输入数据的时候，数据并不是直接被我们得到，而是放在了缓冲区中，然后我们从缓冲区中得到我们想要的数据 。如果我们通过setbuf()或setvbuf()函数将缓冲区设置10个字节的大小，而我们从键盘输入了20个字节大小的数据，这样我们输入的前10个数据会放在缓冲区中，因为我们设置的缓冲区的大小只能够装下10个字节大小的数据，装不下20个字节大小的数据。那么剩下的那10个字节大小的数据怎么办呢？暂时放在了输入流中。请看下图：上面的箭头表示的区域就相当是一个输入流，红色的地方相当于一个开关，这个开关可以控制往深绿色区域（标注的是缓冲区）里放进去的数据，输入20个字节的数据只往缓冲区中放进去了10个字节，剩下的10个字节的数据就被停留在了输入流里！等待下去往缓冲区中放入！接下来系统是如何来控制这个缓冲区呢？再说一下 FILE 结构体中几个相关成员的含义：cnt // 剩余的字符，如果是输入缓冲区，那么就表示缓冲区中还有多少个字符未被读取ptr // 下一个要被读取的字符的地址base // 缓冲区基地址在上面我们向缓冲区中放入了10个字节大小的数据，FILE结构体中的 cnt 变为了10 ，说明此时缓冲区中有10个字节大小的数据可以读，同时我们假设缓冲区的基地址也就是 base 是0x00428e60 ，它是不变的 ，而此时 ptr 的值也为0x00428e60 ，表示从0x00428e60这个位置开始读取数据，当我们从缓冲区中读取5个数据的时候，cnt 变为了5 ，表示缓冲区还有5个数据可以读，ptr 则变为了0x0042e865表示下次应该从这个位置开始读取缓冲区中的数据 ，如果接下来我们再读取5个数据的时候，cnt 则变为了0 ，表示缓冲区中已经没有任何数据了，ptr 变为了0x0042869表示下次应该从这个位置开始从缓冲区中读取数据，但是此时缓冲区中已经没有任何数据了，所以要将输入流中的剩下的那10个数据放进来，这样缓冲区中又有了10个数据，此时 cnt 变为了10 ，注意了刚才我们讲到 ptr 的值是0x00428e69 ，而当缓冲区中重新放进来数据的时候这个 ptr 的值变为了0x00428e60 ，这是因为当缓冲区中没有任何数据的时候要将 ptr 这个值进行一下刷新，使其指向缓冲区的基地址也就是0x0042e860这个值！因为下次要从这个位置开始读取数据！在这里有点需要说明：当我们从键盘输入字符串的时候需要敲一下回车键才能够将这个字符串送入到缓冲区中，那么敲入的这个回车键(\r)会被转换为一个换行符\n，这个换行符\n也会被存储在缓冲区中并且被当成一个字符来计算！比如我们在键盘上敲下了123456这个字符串，然后敲一下回车键（\r）将这个字符串送入了缓冲区中，那么此时缓冲区中的字节个数是7 ，而不是6。缓冲区的刷新就是将指针 ptr 变为缓冲区的基地址 ，同时 cnt 的值变为0 ，因为缓冲区刷新后里面是没有数据的！5.</description>
    </item>
    
    <item>
      <title>3.18 文件读写函数</title>
      <link>https://yujian1018.github.io/book/cpp/3.-%E5%BA%93%E5%87%BD%E6%95%B0/3.18-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E5%87%BD%E6%95%B0/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/cpp/3.-%E5%BA%93%E5%87%BD%E6%95%B0/3.18-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E5%87%BD%E6%95%B0/</guid>
      <description>文件读写函数 fopen FILE *fopen(char *filename, char *mode); 函数用来打开一个文件fclose int fclose(FILE *fp); fgetc() int fgetc (FILE *fp); 函数每次只能读写一个字符fputc() int fputc ( int ch, FILE *fp ); 函数每次只能读写一个字符fgets char *fgets ( char *str, int n, FILE *fp ); 有局限性，每次最多只能从文件中读取一行内容，因为 fgets 遇到换行符就结束读取。fputs int fputs( char *str, FILE *fp ); fread size_t fread ( void *ptr, size_t size, size_t count, FILE *fp ); 读取多行内容fwrite size_t fwrite ( void * ptr, size_t size, size_t count, FILE *fp ); rewind(fp); void rewind ( FILE *fp ); //将文件中的位置指针重新定位到文件开头fseek() int fseek ( FILE *fp, long offset, int origin ); 来将位置指针移动到任意位置offset 为偏移量，也就是要移动的字节数。之所以为 long 类型，是希望移动的范围更大，能处理的文件更大origin 为起始位置文件开头 SEEK_SET 0当前位置 SEEK_CUR 1文件末尾 SEEK_END 2fscanf int fscanf ( FILE *fp, char * format, .</description>
    </item>
    
    <item>
      <title>README</title>
      <link>https://yujian1018.github.io/book/cpp/readme/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/cpp/readme/</guid>
      <description>好记性不如烂笔头 c-cpp笔记</description>
    </item>
    
  </channel>
</rss>