<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>1.游戏 on My New Hugo Site</title>
    <link>https://yujian1018.github.io/book/game/</link>
    <description>Recent content in 1.游戏 on My New Hugo Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 15 Aug 2020 14:52:01 +0800</lastBuildDate>
    
	<atom:link href="https://yujian1018.github.io/book/game/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>玩家利益转换系统</title>
      <link>https://yujian1018.github.io/book/game/1.%E8%AE%BE%E8%AE%A1/%E7%8E%A9%E5%AE%B6%E5%88%A9%E7%9B%8A%E8%BD%AC%E6%8D%A2%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Sat, 15 Aug 2020 14:53:54 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/game/1.%E8%AE%BE%E8%AE%A1/%E7%8E%A9%E5%AE%B6%E5%88%A9%E7%9B%8A%E8%BD%AC%E6%8D%A2%E7%B3%BB%E7%BB%9F/</guid>
      <description></description>
    </item>
    
    <item>
      <title>1.1玩家利益转换系统</title>
      <link>https://yujian1018.github.io/book/game/1.%E8%AE%BE%E8%AE%A1/1.1%E7%8E%A9%E5%AE%B6%E5%88%A9%E7%9B%8A%E8%BD%AC%E6%8D%A2%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Sat, 15 Aug 2020 14:53:05 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/game/1.%E8%AE%BE%E8%AE%A1/1.1%E7%8E%A9%E5%AE%B6%E5%88%A9%E7%9B%8A%E8%BD%AC%E6%8D%A2%E7%B3%BB%E7%BB%9F/</guid>
      <description>图片 </description>
    </item>
    
    <item>
      <title>2</title>
      <link>https://yujian1018.github.io/book/game/2.%E6%8A%80%E6%9C%AF/2.2%E7%BD%91%E7%BB%9C/2.2.1-%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/game/2.%E6%8A%80%E6%9C%AF/2.2%E7%BD%91%E7%BB%9C/2.2.1-%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86/</guid>
      <description></description>
    </item>
    
    <item>
      <title>AOI</title>
      <link>https://yujian1018.github.io/book/game/2.%E6%8A%80%E6%9C%AF/2.1%E6%9C%8D%E5%8A%A1%E7%AB%AF/aoi/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/game/2.%E6%8A%80%E6%9C%AF/2.1%E6%9C%8D%E5%8A%A1%E7%AB%AF/aoi/</guid>
      <description>1.九宫格。玩家每走一步同步到某个格子中，计算出该格子可以看到的玩家。 统一计时器下发视野内玩家数据，所以客户端需要做预测
2.aoi，场景玩家同步可以设定定时器，统一下发</description>
    </item>
    
    <item>
      <title>cs同步</title>
      <link>https://yujian1018.github.io/book/game/2.%E6%8A%80%E6%9C%AF/2.2%E7%BD%91%E7%BB%9C/cs%E5%90%8C%E6%AD%A5/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/game/2.%E6%8A%80%E6%9C%AF/2.2%E7%BD%91%E7%BB%9C/cs%E5%90%8C%E6%AD%A5/</guid>
      <description>帧同步：客户端p2p方式
cs同步：客户端采集input， 发送给服务器，广播给所有玩家</description>
    </item>
    
    <item>
      <title>storm1986网游策划设计空间原创文集2007-2010</title>
      <link>https://yujian1018.github.io/book/game/6.%E8%B5%84%E6%BA%90/storm1986%E7%BD%91%E6%B8%B8%E7%AD%96%E5%88%92%E8%AE%BE%E8%AE%A1%E7%A9%BA%E9%97%B4%E5%8E%9F%E5%88%9B%E6%96%87%E9%9B%862007-2010/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/game/6.%E8%B5%84%E6%BA%90/storm1986%E7%BD%91%E6%B8%B8%E7%AD%96%E5%88%92%E8%AE%BE%E8%AE%A1%E7%A9%BA%E9%97%B4%E5%8E%9F%E5%88%9B%E6%96%87%E9%9B%862007-2010/</guid>
      <description></description>
    </item>
    
    <item>
      <title>SUMMARY</title>
      <link>https://yujian1018.github.io/book/game/summary/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/game/summary/</guid>
      <description>Summary  1.设计规范  [1.1 热更新](1.1 re-geng-xin.md)   2.系统设计  [2.1 网络管理](2.1 网络管理.md)  2.1.1 帧同步 2.1.2 cs同步   2.2 活动管理器 2.3 时间管理器 2.4 地图AOI管理 2.101 玩家属性 2.102 装备系统 2.103 任务系统 2.104 NPC系统  2.104.1 怪物AI的配置原型   2.105 战斗系统  2.105.1 横板过关类游戏战斗类型 2.105.2 即时制战斗 2.105.3 麻将算法     3.算法  3.2 判断点是否在三角形内 3.3 重心坐标   4.引擎  4.1 虚幻引擎  4.1.1 下载编译     5.</description>
    </item>
    
    <item>
      <title>下载编译</title>
      <link>https://yujian1018.github.io/book/game/4.%E5%BC%95%E6%93%8E/4.1ue/%E4%B8%8B%E8%BD%BD%E7%BC%96%E8%AF%91/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/game/4.%E5%BC%95%E6%93%8E/4.1ue/%E4%B8%8B%E8%BD%BD%E7%BC%96%E8%AF%91/</guid>
      <description>git clone https://github.com/EpicGames cd ./Setup.sh ./GenerateProjectFiles.sh %生成data和index make make SlateViewer %编译了一个SlateViewer make UE4Editor UE4Game UnrealPak CrashReportClient ShaderCompileWorker UnrealLightmass %编译Editor cd Engine/Binaries/Linux &amp;amp;&amp;amp; ./UE4Editor </description>
    </item>
    
    <item>
      <title>任务</title>
      <link>https://yujian1018.github.io/book/game/2.%E6%8A%80%E6%9C%AF/2.1%E6%9C%8D%E5%8A%A1%E7%AB%AF/%E4%BB%BB%E5%8A%A1/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/game/2.%E6%8A%80%E6%9C%AF/2.1%E6%9C%8D%E5%8A%A1%E7%AB%AF/%E4%BB%BB%E5%8A%A1/</guid>
      <description>事件触发器 等级限制 前置限制 时间限制-到达某个时间开启任务
接受任务触发新任务 完成任务触发新任务 提交任务触发新任务 等级触发
任务框架设计 服务器与客户端协议设计直接使用任务索引</description>
    </item>
    
    <item>
      <title>优化</title>
      <link>https://yujian1018.github.io/book/game/2.%E6%8A%80%E6%9C%AF/2.1%E6%9C%8D%E5%8A%A1%E7%AB%AF/%E4%BC%98%E5%8C%96/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/game/2.%E6%8A%80%E6%9C%AF/2.1%E6%9C%8D%E5%8A%A1%E7%AB%AF/%E4%BC%98%E5%8C%96/</guid>
      <description></description>
    </item>
    
    <item>
      <title>即时制战斗</title>
      <link>https://yujian1018.github.io/book/game/2.%E6%8A%80%E6%9C%AF/2.1%E6%9C%8D%E5%8A%A1%E7%AB%AF/2.1.4%E5%8D%B3%E6%97%B6%E5%88%B6%E6%88%98%E6%96%97/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/game/2.%E6%8A%80%E6%9C%AF/2.1%E6%9C%8D%E5%8A%A1%E7%AB%AF/2.1.4%E5%8D%B3%E6%97%B6%E5%88%B6%E6%88%98%E6%96%97/</guid>
      <description></description>
    </item>
    
    <item>
      <title>国内网页游戏背景音乐</title>
      <link>https://yujian1018.github.io/book/game/6.%E8%B5%84%E6%BA%90/6.1-%E5%9B%BD%E5%86%85%E7%BD%91%E9%A1%B5%E6%B8%B8%E6%88%8F%E8%83%8C%E6%99%AF%E9%9F%B3%E4%B9%90/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/game/6.%E8%B5%84%E6%BA%90/6.1-%E5%9B%BD%E5%86%85%E7%BD%91%E9%A1%B5%E6%B8%B8%E6%88%8F%E8%83%8C%E6%99%AF%E9%9F%B3%E4%B9%90/</guid>
      <description>国内网页游戏使用的背景音乐,大量使用了经典的电影电视的OST,这里简单回顾一下:
 首先,一大批网页游戏用的是中国武侠背景,大量的电视武侠电影为此提供了丰富的素材:
 仙剑奇侠传（四） - 回梦游仙.wav
 何占豪&amp;amp;陈钢 - 少年十五二十时.wav 卢冠廷 - 一生所爱.wav 吕秀龄 - 逆伦.wav 商易 - 小刀会组曲 .wav 喜多郎 - 孙文与庆玲.wav 宗次郎 - 故乡的原风景.wav 徐嘉良 - 仙侣奇缘主题曲音乐.wav 横山菁儿 - 英雄的黎明.wav 胡伟立 - 偷功.wav 胡伟立 - 市集.wav 陈勋奇 - 天地孤影任我行.wav 陈淑桦 - 流光飞舞.wav 鲍比达 - 凡心大动.wav 黄沾&amp;amp; 胡伟立 - 傲气傲笑万重浪.wav 黄英华 - OPENING.wav 黄霑&amp;amp; 鲍比达 - 定情.wav 黄霑&amp;amp;徐克&amp;amp;罗大佑 - 沧海一生笑.wav
七剑战歌
2012-6-28 19:51:18 更新:
Folder PATH listing for volume Zen Volume serial number is 9ED7-E2AC E:.</description>
    </item>
    
    <item>
      <title>客户端服务端互联</title>
      <link>https://yujian1018.github.io/book/game/2.%E6%8A%80%E6%9C%AF/2.2%E7%BD%91%E7%BB%9C/2.2.2-%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BA%92%E8%81%94/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/game/2.%E6%8A%80%E6%9C%AF/2.2%E7%BD%91%E7%BB%9C/2.2.2-%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BA%92%E8%81%94/</guid>
      <description>1.使用长连接 阻塞式、非阻塞式 2.使用短连接</description>
    </item>
    
    <item>
      <title>工具</title>
      <link>https://yujian1018.github.io/book/game/5.%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/game/5.%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7/</guid>
      <description>js压缩 java -jar compiler.jar &amp;ndash;js hello.js &amp;ndash;js_output_file hello-compiled.js</description>
    </item>
    
    <item>
      <title>帧同步</title>
      <link>https://yujian1018.github.io/book/game/2.%E6%8A%80%E6%9C%AF/2.2%E7%BD%91%E7%BB%9C/%E5%B8%A7%E5%90%8C%E6%AD%A5/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/game/2.%E6%8A%80%E6%9C%AF/2.2%E7%BD%91%E7%BB%9C/%E5%B8%A7%E5%90%8C%E6%AD%A5/</guid>
      <description>http://www.gameres.com/thread_476063_1_1.html
1.帧同步
原理
设存在玩家A、B、C，服务器Server设为S，假设玩家A、B、C是一个状态机，一开始A、B、C都处于状态S1，这时候服务器S给A、B、C相同的输入I，此时A、B、C经过本地的运算，得到同一个状态S2。 在这短暂的时刻，可以理解成所有玩家从状态S1同步到状态S2，三个玩家便达到同步的目的。只要状态机函数模型Fun，初始S1，输入I是确定的，那么三个玩家得到的结果S2肯定也是确定的。
如图中所示，玩家A、B、C在T1、T2、T3时刻都会收到服务器发送过来的输入，从而变成相同的状态S1,S2,S3，达到同步的目的。可以想象成这就是个回合制的游戏，每个T1、T2、T3间隔是一个回合，玩家在回合结束的时候，状态是一致同步的。那对于我们游戏来说，服务器的输入可以是玩家在这回合的操作序列，可以是状态信息，都可以，取决于客户端游戏方案的设计。只要这输入到达任何一个客户端那里，能把这数据模拟成真实的游戏场景就可以了。此时您可能会有这样的疑问，如果帧同步比作成一个回合制游戏的话，那会不会出现一卡一卡的情况出现呢。其实是不会的，一般游戏的帧数为30-60帧玩家认为是流畅的，对于帧同步来说，我们把里面的每一次输入的时间间隔足够短，人眼的反应是可以被欺骗的，就好像电影放映一样，一张张连续的图片快速播放，人眼就会感觉是连续发生的，同理帧同步虽然就像是一个回合制游戏，但是只要回合的时间足够短，玩家看起来就像是连续的一样。通常情况下，我们把这个回合称为逻辑帧，逻辑帧的设定可以根据游戏类型，自己打磨决定，一般情况下，4-6渲染帧左右为一逻辑帧比较合理，大概1S的时间内，客户端会收到服务器8-10个逻辑帧输入。
后台实现
1、核心思想
对于后台开发来说，服务器主要起到控制作用，对客户端的帧信息进行输入输出管理，服务器就像是一个时间序列的驱动器，每隔一定间隔，会把在这段时间间隔收集到得客户端的输入，下发广播到所有客户端中去，从而驱动客户端执行帧同步处理，简而言之可以看作服务器在时间轴序列上，收集切片，每隔一定间隔，把这时间切片收集到的数据下发给客户端。
1.对于帧同步来说，数据同步的频率较高，当然是希望越小的网络延迟越佳，由于TCP的滑动窗口和重传机制，导致延时无法控制，因此帧同步一般采用udp进行网络传输。提到udp这里就会衍生出可靠性的问题，对于客户端来说，如果某些udp包没有收到该怎么办呢，这就是帧同步客户端会出现的丢帧的情况，这时候得靠客户端与服务器指定针对性的重传机制.
2.服务器单局中数据首先对每一帧下发客户端的数据进行编号，然后并保存下来，某某客户端网络不佳，中途丢了一些包，可以跟服务器发请求，我现在播放到哪一个序列号的帧了，服务器可以把这个客户端当前序号的帧和客户端缺省的帧一并下发，这样客户端拿到数据后，便可继续通过合帧快播的方式，加速播放，赶上当前时间。这样客户端的表现就是在快放一样。
3.一般来说，帧同步的方案的包量都是比较小的，对于客户端在这个时间间隔没有上传任何数据，服务器也得帮该客户端构造空帧出来，免得其他客户端出现没有输入的情况出现。
4.对于短时间的大量重传，服务器可以选择性的采取合并的策略，减少客户端的瞬间的收包数量。同时也可以利用好不超过mtu的包量大小，尽可能的携带一些之前若干个时间帧的信息，最大限度的把信息push到给客户端,减少客户端申请重传的概率.
2、断线重连
服务器单局可以把所有逻辑帧存储下来，当客户端断线，重新登陆的时候，服务器可以将所有的逻辑帧下发给客户端，客户端拿到所有的逻辑帧后，可以快速在后台跑完全部的逻辑帧，当跑完后，加载到画面，就重新回到游戏单局了。由于断线时，跑的是单局上所有客户端一样的逻辑帧，因此，等到恢复游戏的时候玩家的状态是一致的。
3、反外挂
服务器都是切逻辑帧，没有感知到客户端的逻辑，所以反外挂这块不方便校验，可以从以下两方面着手去校验 1.由于所有客户端的数据都是一致的，可以让客户端根据自身数据算出若干个特征值，严格来说， 所有的客户端算出来的特征值都应该是一样的，因为他们的数据是一样的，当有玩家不一致的时候，可以断定该玩家有作弊的嫌疑。 2.通过单局过程或者完成的时候，汇报统计信息给服务器，服务器通过若干个数据的关联关系，进行数据校验。（有点类似手游单机游戏的校验）
4、特殊关注的点
1.随机性：游戏中不可避免会有随机的逻辑，这时候伪随机就派上用场了，通过下发统一的随机种子，确保每个客户端都产生相同的随机序列。 war3中暴击就是使用的伪随机机制，同样是为了应付帧同步的问题而产生的解决方式。
2.浮点数：浮点数尽可能的避免，还有特殊注意的是，如果用了第三方的库，要确保客户端在不同平台的计算结果是一致的，比方说用了某些物理引擎，在安卓和IOS的平台上会有可能计算出不同的结果，那就要在开发过程中，注意避免使用平台不一致的API了。
3.调试难度
帧同步调试比较困难，需要良好的Log系统，针对不一致的情况能通过Log追溯原因。
尽早的搭建起录像功能通过录像回放可以反复观看逻辑上的不同步，方便问题定位。
在单局中增加debug模式下不一致的检查，当发生不一致时，及时发现，定位原因。如果能引入自动化测试那效果就更佳了。</description>
    </item>
    
    <item>
      <title>怪物AI的配置原型</title>
      <link>https://yujian1018.github.io/book/game/2.%E6%8A%80%E6%9C%AF/2.1%E6%9C%8D%E5%8A%A1%E7%AB%AF/2.1.1%E6%80%AA%E7%89%A9ai%E7%9A%84%E9%85%8D%E7%BD%AE%E5%8E%9F%E5%9E%8B/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/game/2.%E6%8A%80%E6%9C%AF/2.1%E6%9C%8D%E5%8A%A1%E7%AB%AF/2.1.1%E6%80%AA%E7%89%A9ai%E7%9A%84%E9%85%8D%E7%BD%AE%E5%8E%9F%E5%9E%8B/</guid>
      <description></description>
    </item>
    
    <item>
      <title>战斗系统</title>
      <link>https://yujian1018.github.io/book/game/2.%E6%8A%80%E6%9C%AF/2.1%E6%9C%8D%E5%8A%A1%E7%AB%AF/%E6%88%98%E6%96%97%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/game/2.%E6%8A%80%E6%9C%AF/2.1%E6%9C%8D%E5%8A%A1%E7%AB%AF/%E6%88%98%E6%96%97%E7%B3%BB%E7%BB%9F/</guid>
      <description></description>
    </item>
    
    <item>
      <title>时间管理器</title>
      <link>https://yujian1018.github.io/book/game/2.%E6%8A%80%E6%9C%AF/2.1%E6%9C%8D%E5%8A%A1%E7%AB%AF/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86%E5%99%A8/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/game/2.%E6%8A%80%E6%9C%AF/2.1%E6%9C%8D%E5%8A%A1%E7%AB%AF/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86%E5%99%A8/</guid>
      <description>时间管理。 服务器时间管理， 设定服务器时间、停止服务器时间&amp;hellip;.. 加速时间流逝</description>
    </item>
    
    <item>
      <title>横板过关类游戏战斗类型</title>
      <link>https://yujian1018.github.io/book/game/2.%E6%8A%80%E6%9C%AF/2.1%E6%9C%8D%E5%8A%A1%E7%AB%AF/2.1.2%E6%A8%AA%E6%9D%BF%E8%BF%87%E5%85%B3%E7%B1%BB%E6%B8%B8%E6%88%8F%E6%88%98%E6%96%97%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/game/2.%E6%8A%80%E6%9C%AF/2.1%E6%9C%8D%E5%8A%A1%E7%AB%AF/2.1.2%E6%A8%AA%E6%9D%BF%E8%BF%87%E5%85%B3%E7%B1%BB%E6%B8%B8%E6%88%8F%E6%88%98%E6%96%97%E7%B1%BB%E5%9E%8B/</guid>
      <description> 正常战斗，根据消耗可以无限制进入副本 次数限制，进入副本消耗次数 次数限制，通关副本失败才消耗次数，只要通关不消耗次数 限时开启  </description>
    </item>
    
    <item>
      <title>活动管理器</title>
      <link>https://yujian1018.github.io/book/game/2.%E6%8A%80%E6%9C%AF/2.1%E6%9C%8D%E5%8A%A1%E7%AB%AF/2.1.3%E6%B4%BB%E5%8A%A8%E7%AE%A1%E7%90%86%E5%99%A8/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/game/2.%E6%8A%80%E6%9C%AF/2.1%E6%9C%8D%E5%8A%A1%E7%AB%AF/2.1.3%E6%B4%BB%E5%8A%A8%E7%AE%A1%E7%90%86%E5%99%A8/</guid>
      <description>活动管理器（跑马灯，活动前-活动开始-活动中-触发活动结束-活动马上结束-活动结束） 可以考虑服务器关闭重启的情况
开服活动 运营活动 日常活动</description>
    </item>
    
    <item>
      <title>热更新</title>
      <link>https://yujian1018.github.io/book/game/2.%E6%8A%80%E6%9C%AF/2.1%E6%9C%8D%E5%8A%A1%E7%AB%AF/%E7%83%AD%E6%9B%B4%E6%96%B0/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/game/2.%E6%8A%80%E6%9C%AF/2.1%E6%9C%8D%E5%8A%A1%E7%AB%AF/%E7%83%AD%E6%9B%B4%E6%96%B0/</guid>
      <description>热更新有许多的必要条件，每个产品的需求可能都不太相同。 例如，每个产品的版本号设计都不太相同，有的有大版本、小版本；有的则有主版本、次版本、编译版本。我以前的习惯，是在主版本变化的时候需要整包更新，而次版本变化代表逻辑更新，编译版本代表资源更新等等。这些需要自己来定义升级规则。
再例如，有的产品希望逐个下载升级包，有的产品希望把所有资源打包成一个升级包；有的产品直接使用文件名作为资源名在游戏中调用，而有的产品会把资源名改为指纹码（例如MD5）形式来实现升级的多版本共存和实时回滚，还有的产品甚至要求能在用户玩游戏的过程中完成自动更新。
虑使用这样的版本号格式： XYZ （主版本号.次版本号.修订号）
进行不向下兼容的修改时，递增主版本号。 API 保持向下兼容的新增及修改时，递增次版本号； 修复问题但不影响API 时，递增修订号；</description>
    </item>
    
    <item>
      <title>玩家属性</title>
      <link>https://yujian1018.github.io/book/game/2.%E6%8A%80%E6%9C%AF/2.1%E6%9C%8D%E5%8A%A1%E7%AB%AF/%E7%8E%A9%E5%AE%B6%E5%B1%9E%E6%80%A7/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/game/2.%E6%8A%80%E6%9C%AF/2.1%E6%9C%8D%E5%8A%A1%E7%AB%AF/%E7%8E%A9%E5%AE%B6%E5%B1%9E%E6%80%A7/</guid>
      <description>可以完成功能的设计 1.只使用数值来计算所有的属性。这样属性计算放在各个模块，在各个模块增减
2.此时需要支持百分比的情况。 那么，属性统一维护可能是一个更清晰的设计。 设情况而定，需要多出一套甚至多套字段，用来存放百分比数值以及具体数值。 玩家升级具体数值、称号具体数值 活动百分比数值&amp;hellip;.</description>
    </item>
    
    <item>
      <title>虚幻引擎</title>
      <link>https://yujian1018.github.io/book/game/4.%E5%BC%95%E6%93%8E/4.1ue/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/game/4.%E5%BC%95%E6%93%8E/4.1ue/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/</guid>
      <description></description>
    </item>
    
    <item>
      <title>装备</title>
      <link>https://yujian1018.github.io/book/game/2.%E6%8A%80%E6%9C%AF/2.1%E6%9C%8D%E5%8A%A1%E7%AB%AF/%E8%A3%85%E5%A4%87/</link>
      <pubDate>Fri, 30 Aug 2019 15:13:01 +0800</pubDate>
      
      <guid>https://yujian1018.github.io/book/game/2.%E6%8A%80%E6%9C%AF/2.1%E6%9C%8D%E5%8A%A1%E7%AB%AF/%E8%A3%85%E5%A4%87/</guid>
      <description>可见对象 -》
 道具 装备
 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://yujian1018.github.io/book/game/2.%E6%8A%80%E6%9C%AF/2.3%E7%AE%97%E6%B3%95/2.3.1%E9%BA%BB%E5%B0%86%E7%AE%97%E6%B3%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yujian1018.github.io/book/game/2.%E6%8A%80%E6%9C%AF/2.3%E7%AE%97%E6%B3%95/2.3.1%E9%BA%BB%E5%B0%86%E7%AE%97%E6%B3%95/</guid>
      <description>麻将检查胡牌算法 1）解释麻将的胡牌规则，简单描述为：1个对子加4副牌 2）检查胡牌的计算复杂度如下： C(14,2) * C(12,3)*C(9,3)*C(6, 3)C(3,3) ~ 10的8次方，如果运气恰好非常差，需要进行大概是1亿次判断（两张牌相同、3张牌相同、3张牌连续） 实际检查过程中，大部分是不满足条件中间短返回的 我们再计算下实际运行时的计算复杂度： 以第一步检查对子为例，1手牌，对子最多出现7对，也就是C(14,2)最多有7种情况进入到下一步的检查，其他的都被裁剪掉了，计算复杂度更改为： C(14,2) + 7 * C(12,3)C(9,3)C(6,3) 第二检查3个是否是1副牌，12张牌，最多有XX(10&amp;gt;=XX&amp;gt;=8)副牌的可能性，也就是C(12,3)最多有XX种情况进入到下一步检查，其他的都被裁减掉了，计算复杂度更改为： C(14,2) + 7 * (C(12,3) + XX (C(9,3) + YY (C(6,3) + ZZ) 100 + 7 * (300 + 10(80 + 7 *(20 + 3))) ~ 10的4次方，最差情况大概需要1万次判断 优化思路 为什么要优化? 1W次的判断，对于CPU来说，可以在万分之一秒中解决，也就是1秒中最差可以完成1W次以上的胡牌检查，这个数据看起来已经很好了，还有优化的必要吗？ 先看第一个场景： 赖子听牌检查 手里如果有3个赖子，3个赖子可以有343434种组合，每种组合放入现有的手牌中后，需要再*14，50W左右的组合需要进行检查，嗯，看起来，5秒可以搞定，对于客户端来说可以通过分步处理来解决，但体验会打个折扣，对服务器来说，压力就有点大了 第二个场景： AI计算胡牌概率 AI在考虑打牌时，会模拟打牌，然后再计算手中新牌的胡牌概率，要算手中牌胡牌概率，首先要进行听牌检查，这是一个不断模拟和检查是否听牌的过程，以模拟打出3张牌为例，胡牌检查的数量，就是跟3个赖子的胡牌检查数量是一样的，AI要聪明，我们想模拟打出的牌越多，对胡牌的概率估算也就越精确，所以检查胡牌的算法需要越快越好 如何优化？ 1）并行 2）缓存 3）查表 第二个方法目前游戏中有使用，问题主要是第一次检查还是需要时间的，另外就是缓存的数量的问题，太多会占用较多内存 并行的方法可以考虑在后期加入，主要是把多核的优势发挥出来 查表这个方法很吸引我，因为可以在O(1)时间内返回胡牌的结果，所以决定尝试下 我们从屁胡的检查开始 先看下有多少屁胡的牌型？ 屁胡的牌是由1个对子和4副牌组成，简单计算如下： C(34,1) * (C(33, 4) + C(33, 3) * C(21, 1) + C(33, 2) * C(21, 2) + C(33, 1) * C(21, 3) + C(21, 4)) ~1000万 嗯，这个量级，可以看下能否努力下，通过查表的方式实现 继续优化：如何减少表的尺寸 1000万 这么多胡牌的牌型，如果简单的以牌组成的字符串进行hash，我们可以估算下hash表的大小： 以1个牌被hash成1个int来计算，14 bytes -&amp;gt; 4 bytes 4 * 10M = 40M，这仅仅是键的存储，hash表的存储效率50%左右，这样算&amp;gt;100M是肯定的，对于客户端程序来说，这个开销是有点大，还没有算上值的开销 我们发现不同的胡牌牌型，实际上可以归为一类 我们对手牌进行一下编码 1）连续的或相同的被视为一段 2）段之间通过00间隔 3）连续的以连续的1表示 4）相同的以01表示 示例： 1;1;14;15;16;17;18;19;21;22;23;27;28;29 -&amp;gt; 10100 111111 00 111 00 111 7;7;16;16;16;17;18;19;21;22;23;27;28;29 -&amp;gt; 10100 10101 111 00 111 00 111 经过编码后，1000多W的牌型减少为1W多 我们的hash表的尺寸减少为40K 最终性能对比 胡牌牌型对比： 对比判定胡牌算法共耗时17.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://yujian1018.github.io/book/game/2.%E6%8A%80%E6%9C%AF/2.3%E7%AE%97%E6%B3%95/2.3.2%E5%88%A4%E6%96%AD%E7%82%B9%E6%98%AF%E5%90%A6%E5%9C%A8%E4%B8%89%E8%A7%92%E5%BD%A2%E5%86%85/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yujian1018.github.io/book/game/2.%E6%8A%80%E6%9C%AF/2.3%E7%AE%97%E6%B3%95/2.3.2%E5%88%A4%E6%96%AD%E7%82%B9%E6%98%AF%E5%90%A6%E5%9C%A8%E4%B8%89%E8%A7%92%E5%BD%A2%E5%86%85/</guid>
      <description>本文只是翻译和整理，原文在此http://www.blackpawn.com/texts/pointinpoly/default.html 概述 给定三角形ABC和一点P(x,y,z)，判断点P是否在ABC内。这是游戏设计中一个常见的问题。需要注意的是，这里假定点和三角形位于同一个平面内。 本文介绍三种不同的方法，由浅入深 一 内角和法 连接点P和三角形的三个顶点得到三条线段PA，PB和PC，求出这三条线段与三角形各边的夹角，如果所有夹角之和为180度，那么点P在三角形内，否则不在，此法直观，但效率低下。
二 同向法 假设点P位于三角形内，会有这样一个规律，当我们沿着ABCA的方向在三条边上行走时，你会发现点P始终位于边AB，BC和CA的右侧。我们就利用这一点，但是如何判断一个点在线段的左侧还是右侧呢？我们可以从另一个角度来思考，当选定线段AB时，点C位于AB的右侧，同理选定BC时，点A位于BC的右侧，最后选定CA时，点B位于CA的右侧，所以当选择某一条边时，我们只需验证点P与该边所对的点在同一侧即可。问题又来了，如何判断两个点在某条线段的同一侧呢？可以通过叉积来实现，连接PA，将PA和AB做叉积，再将CA和AB做叉积，如果两个叉积的结果方向一致，那么两个点在同一测。判断两个向量的是否同向可以用点积实现，如果点积大于0，则两向量夹角是锐角，否则是钝角。 代码如下，为了实现程序功能，添加了一个Vector3类，该类表示三维空间中的一个向量。
// 3D vector class Vector3 { public: Vector3(float fx, float fy, float fz) :x(fx), y(fy), z(fz) { } // Subtract Vector3 operator - (const Vector3&amp;amp; v) const { return Vector3(x - v.x, y - v.y, z - v.z) ; } // Dot product float Dot(const Vector3&amp;amp; v) const { return x * v.x + y * v.y + z * v.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://yujian1018.github.io/book/game/2.%E6%8A%80%E6%9C%AF/2.3%E7%AE%97%E6%B3%95/2.3.3%E9%87%8D%E5%BF%83%E5%9D%90%E6%A0%87/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yujian1018.github.io/book/game/2.%E6%8A%80%E6%9C%AF/2.3%E7%AE%97%E6%B3%95/2.3.3%E9%87%8D%E5%BF%83%E5%9D%90%E6%A0%87/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://yujian1018.github.io/book/game/2.%E6%8A%80%E6%9C%AF/2.4%E8%A7%84%E8%8C%83/2.4.1-%E7%89%88%E6%9C%AC%E5%8F%B7/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://yujian1018.github.io/book/game/2.%E6%8A%80%E6%9C%AF/2.4%E8%A7%84%E8%8C%83/2.4.1-%E7%89%88%E6%9C%AC%E5%8F%B7/</guid>
      <description>版本号  热更新有许多的必要条件，每个产品的需求可能都不太相同。
例如，每个产品的版本号设计都不太相同，有的有大版本、小版本；有的则有主版本、次版本、编译版本。我以前的习惯，是在主版本变化的时候需要整包更新，而次版本变化代表逻辑更新，编译版本代表资源更新等等。这些需要自己来定义升级规则。
再例如，有的产品希望逐个下载升级包，有的产品希望把所有资源打包成一个升级包；有的产品直接使用文件名作为资源名在游戏中调用，而有的产品会把资源名改为指纹码（例如MD5）形式来实现升级的多版本共存和实时回滚，还有的产品甚至要求能在用户玩游戏的过程中完成自动更新。
虑使用这样的版本号格式：
XYZ （主版本号.次版本号.修订号）
进行不向下兼容的修改时，递增主版本号。
API 保持向下兼容的新增及修改时，递增次版本号；
修复问题但不影响API 时，递增修订号；</description>
    </item>
    
  </channel>
</rss>