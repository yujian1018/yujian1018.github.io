<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>My New Hugo Site</title>
    <link>http://example.org/2.%E6%8A%80%E6%9C%AF/2.3%E7%AE%97%E6%B3%95/</link>
    <description>Recent content on My New Hugo Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="http://example.org/2.%E6%8A%80%E6%9C%AF/2.3%E7%AE%97%E6%B3%95/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title></title>
      <link>http://example.org/2.%E6%8A%80%E6%9C%AF/2.3%E7%AE%97%E6%B3%95/2.3.1%E9%BA%BB%E5%B0%86%E7%AE%97%E6%B3%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/2.%E6%8A%80%E6%9C%AF/2.3%E7%AE%97%E6%B3%95/2.3.1%E9%BA%BB%E5%B0%86%E7%AE%97%E6%B3%95/</guid>
      <description>麻将检查胡牌算法 1）解释麻将的胡牌规则，简单描述为：1个对子加4副牌 2）检查胡牌的计算复杂度如下： C(14,2) * C(12,3)*C(9,3)*C(6, 3)C(3,3) ~ 10的8次方，如果运气恰好非常差，需要进行大概是1亿次判断（两张牌相同、3张牌相同、3张牌连续） 实际检查过程中，大部分是不满足条件中间短返回的 我们再计算下实际运行时的计算复杂度： 以第一步检查对子为例，1手牌，对子最多出现7对，也就是C(14,2)最多有7种情况进入到下一步的检查，其他的都被裁剪掉了，计算复杂度更改为： C(14,2) + 7 * C(12,3)C(9,3)C(6,3) 第二检查3个是否是1副牌，12张牌，最多有XX(10&amp;gt;=XX&amp;gt;=8)副牌的可能性，也就是C(12,3)最多有XX种情况进入到下一步检查，其他的都被裁减掉了，计算复杂度更改为： C(14,2) + 7 * (C(12,3) + XX (C(9,3) + YY (C(6,3) + ZZ) 100 + 7 * (300 + 10(80 + 7 *(20 + 3))) ~ 10的4次方，最差情况大概需要1万次判断 优化思路 为什么要优化? 1W次的判断，对于CPU来说，可以在万分之一秒中解决，也就是1秒中最差可以完成1W次以上的胡牌检查，这个数据看起来已经很好了，还有优化的必要吗？ 先看第一个场景： 赖子听牌检查 手里如果有3个赖子，3个赖子可以有343434种组合，每种组合放入现有的手牌中后，需要再*14，50W左右的组合需要进行检查，嗯，看起来，5秒可以搞定，对于客户端来说可以通过分步处理来解决，但体验会打个折扣，对服务器来说，压力就有点大了 第二个场景： AI计算胡牌概率 AI在考虑打牌时，会模拟打牌，然后再计算手中新牌的胡牌概率，要算手中牌胡牌概率，首先要进行听牌检查，这是一个不断模拟和检查是否听牌的过程，以模拟打出3张牌为例，胡牌检查的数量，就是跟3个赖子的胡牌检查数量是一样的，AI要聪明，我们想模拟打出的牌越多，对胡牌的概率估算也就越精确，所以检查胡牌的算法需要越快越好 如何优化？ 1）并行 2）缓存 3）查表 第二个方法目前游戏中有使用，问题主要是第一次检查还是需要时间的，另外就是缓存的数量的问题，太多会占用较多内存 并行的方法可以考虑在后期加入，主要是把多核的优势发挥出来 查表这个方法很吸引我，因为可以在O(1)时间内返回胡牌的结果，所以决定尝试下 我们从屁胡的检查开始 先看下有多少屁胡的牌型？ 屁胡的牌是由1个对子和4副牌组成，简单计算如下： C(34,1) * (C(33, 4) + C(33, 3) * C(21, 1) + C(33, 2) * C(21, 2) + C(33, 1) * C(21, 3) + C(21, 4)) ~1000万 嗯，这个量级，可以看下能否努力下，通过查表的方式实现 继续优化：如何减少表的尺寸 1000万 这么多胡牌的牌型，如果简单的以牌组成的字符串进行hash，我们可以估算下hash表的大小： 以1个牌被hash成1个int来计算，14 bytes -&amp;gt; 4 bytes 4 * 10M = 40M，这仅仅是键的存储，hash表的存储效率50%左右，这样算&amp;gt;100M是肯定的，对于客户端程序来说，这个开销是有点大，还没有算上值的开销 我们发现不同的胡牌牌型，实际上可以归为一类 我们对手牌进行一下编码 1）连续的或相同的被视为一段 2）段之间通过00间隔 3）连续的以连续的1表示 4）相同的以01表示 示例： 1;1;14;15;16;17;18;19;21;22;23;27;28;29 -&amp;gt; 10100 111111 00 111 00 111 7;7;16;16;16;17;18;19;21;22;23;27;28;29 -&amp;gt; 10100 10101 111 00 111 00 111 经过编码后，1000多W的牌型减少为1W多 我们的hash表的尺寸减少为40K 最终性能对比 胡牌牌型对比： 对比判定胡牌算法共耗时17.</description>
    </item>
    
    <item>
      <title></title>
      <link>http://example.org/2.%E6%8A%80%E6%9C%AF/2.3%E7%AE%97%E6%B3%95/2.3.2%E5%88%A4%E6%96%AD%E7%82%B9%E6%98%AF%E5%90%A6%E5%9C%A8%E4%B8%89%E8%A7%92%E5%BD%A2%E5%86%85/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/2.%E6%8A%80%E6%9C%AF/2.3%E7%AE%97%E6%B3%95/2.3.2%E5%88%A4%E6%96%AD%E7%82%B9%E6%98%AF%E5%90%A6%E5%9C%A8%E4%B8%89%E8%A7%92%E5%BD%A2%E5%86%85/</guid>
      <description>本文只是翻译和整理，原文在此http://www.blackpawn.com/texts/pointinpoly/default.html 概述 给定三角形ABC和一点P(x,y,z)，判断点P是否在ABC内。这是游戏设计中一个常见的问题。需要注意的是，这里假定点和三角形位于同一个平面内。 本文介绍三种不同的方法，由浅入深 一 内角和法 连接点P和三角形的三个顶点得到三条线段PA，PB和PC，求出这三条线段与三角形各边的夹角，如果所有夹角之和为180度，那么点P在三角形内，否则不在，此法直观，但效率低下。
二 同向法 假设点P位于三角形内，会有这样一个规律，当我们沿着ABCA的方向在三条边上行走时，你会发现点P始终位于边AB，BC和CA的右侧。我们就利用这一点，但是如何判断一个点在线段的左侧还是右侧呢？我们可以从另一个角度来思考，当选定线段AB时，点C位于AB的右侧，同理选定BC时，点A位于BC的右侧，最后选定CA时，点B位于CA的右侧，所以当选择某一条边时，我们只需验证点P与该边所对的点在同一侧即可。问题又来了，如何判断两个点在某条线段的同一侧呢？可以通过叉积来实现，连接PA，将PA和AB做叉积，再将CA和AB做叉积，如果两个叉积的结果方向一致，那么两个点在同一测。判断两个向量的是否同向可以用点积实现，如果点积大于0，则两向量夹角是锐角，否则是钝角。 代码如下，为了实现程序功能，添加了一个Vector3类，该类表示三维空间中的一个向量。
// 3D vector class Vector3 { public: Vector3(float fx, float fy, float fz) :x(fx), y(fy), z(fz) { } // Subtract Vector3 operator - (const Vector3&amp;amp; v) const { return Vector3(x - v.x, y - v.y, z - v.z) ; } // Dot product float Dot(const Vector3&amp;amp; v) const { return x * v.x + y * v.y + z * v.</description>
    </item>
    
    <item>
      <title></title>
      <link>http://example.org/2.%E6%8A%80%E6%9C%AF/2.3%E7%AE%97%E6%B3%95/2.3.3%E9%87%8D%E5%BF%83%E5%9D%90%E6%A0%87/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/2.%E6%8A%80%E6%9C%AF/2.3%E7%AE%97%E6%B3%95/2.3.3%E9%87%8D%E5%BF%83%E5%9D%90%E6%A0%87/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>