---
title: "dbg"
weight: 04070100
date: 2019-08-30T15:13:01+08:00
pre: "<b>4.7.1 </b>"
---


本地节点监听远程节点的函数被调用事件

1.远程节点,存在下面函数
player_handler:get_state(Uid).

2.本地节点。

```erlang
erl -name test@127.0.0.1 -setcookie 127001 -remsh 'game@127.0.0.1'。连接上远程节点。回退到本地节点
>dbg:tracer(). %启动
>dbg:n('game@127.0.0.1').
>dbg:p(all, c).
>dbg:tpl(player_handler, handle_info, dbg:fun2ms(fun(_) -> exception_trace() end)).
>
```

3.进入远程节点执行

```erlang
NaNundefinedplayer_handler:get_state(1).
NaNundefined{state, 1}
```

4.回到本地节点可以看到shell中会打印

```erlang
(<4641.47.0>) call player_handler:get_state(1)
(<4641.47.0>) returned from player_handler:get_state/1 -> {state, 1}
```

附上自家项目用的tracer

```erlang
t(Mod)->
    dbg:tpl(Mod,[{'_', [], [{return_trace}]}]).
t(Mod,Fun)->
    dbg:tpl(Mod,Fun,[{'_', [], [{return_trace}]}]).
t(Mod,Fun,Ari)->
    dbg:tpl(Mod,Fun,Ari,[{'_', [], [{return_trace}]}]).

p(Max)->
    FuncStopTracer =
        fun
            (_, N) when N =:= Max-> % 记录累计到上限值，追踪器自动关闭
                dbg:stop_clear(),
                io:format("#WARNING >>>>>> dbg tracer stopped <<<<<<~n~n",[]);
            (Msg, N) ->
                case Msg of
                    {trace, _Pid, call, Trace} ->
                        {M, F, A} = Trace,
        io:format("###################~n",[]),
                      io:format("call [~p:~p,(~p)]~n", [M, F, A]),
      io:format"###################~n",[]);
                    {trace, _Pid, return_from, Trace, ReturnVal} ->
                        {M, F, A} = Trace,
io:format("===================~n",[]),
                        io:format("return [~p:~p(~p)] =====>~p~n", [M, F, A, ReturnVal]),
io:format("===================~n",[]);
                    _ -> skip
                end,
                N + 1
        end,
    case dbg:tracer(process, {FuncStopTracer, 0}) of
        {ok, _Pid} ->
             dbg:p(all, [all]);
        {error, already_started} ->
             skip
    end.

stop()->
     dbg:stop_clear().
```

```erlang
开启

dbg:tracer()

dbg:p(Item, Flags)
dbg:p(Item) -> dbg:p(Item, [m]).

Item是设定要跟踪的对象,Flags是设置要监听的动作
Item =
  all           %会trace 整个系统所有的进程，同样可以监控整个集群
  |new       %就会trace 系统在此刻开始所创建的新进程，可以监控整个集群
  |existing %会trace 系统此刻之前所创建的进程，可以监控整个集群
  |pid() || register_name %则只会trace对应的进程，如果是在集群中，只要节点在traced nodes列表内，可以跨节点trace那个进程.
  | integer()                     %the process <0.Item.0> is traced  
  | {X, Y, Z}                     %the process <X.Y.Z> is traced
  |  "<X.Y.Z>"                  %as returned from pid_to_list/1, the process <X.Y.Z> is traced

Flags can be a single atom, or a list of flags
Flags =
 s(send) trace 进程发送的消息
 |r(receive) trace 进程受到的消息
 |m(messages) trace 进程收的或者发的消息
 |c(call） 通过tp/2设置的匹配规则后，可以trace 进程所有的call匹配的动作。
 |p（procs） trace 与目标进程相关联的进程
 |sos(set on spwan) 使监控的进程所产生的进程继承所以trace flags
 |sol （set on link） 如果有另外的进程p2 link被监控的进程，p2会继承所有的trace flags
 |sofs(set on first spawn) 监控第一个创建的进程
   |sofl (set on first link)
 |all 所有的flags
 |clear 清除所有flags

dbg:tp({Module, Function, Arity}, MatchSpec)

与 dbg:tpl({Module, Function, Arity}, MatchSpec) ->
 {ok, MatchDesc} | {error, term()}  tpl和tp类似，只是tpl会trace 未导出函数

dbg:tpl(Module, '_', []). 会trace 该module的所有的调用。
dbg:tpl(Module, Function, '_', []). 会trace module：function，不限定参数个数。
dbg:tpl(Module, Function, Arity, []). trace module：function/arity。
dbg:tpl(M, F, A, [{'_', [], [{return_trace}]}]). 会跟踪返回值

fun2ms

dbg:fun2ms(fun([M,N]) when N > 3 -> return_trace() end).
[{['$1','$2'],[{'>','$2',3}],[{return_trace}]}]

dbg:fun2ms(fun([M,N]) when N > X  -> return_trace() end).
[{['$1','$2'],[{'>','$2',{const,3}}],[{return_trace}]}]

dbg:fun2ms(fun(_) -> return_trace() end).

p, c
       - Set trace flags for processes

tp, tpl, ctp, ctpl, ctpg, ltp, dtp, wtp, rtp
       - Manipulate trace patterns for functions
n, cn, ln
       - Add/remove traced nodes.
tracer, trace_port, trace_client, get_tracer, stop, stop_clear
       - Manipulate tracer process/port
i
       - Info
```
