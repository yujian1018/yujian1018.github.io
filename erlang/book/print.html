<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Erlang笔记</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">介绍</a></li><li class="chapter-item expanded "><a href="1.开始/_index.html"><strong aria-hidden="true">1.</strong> 开始</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="1.开始/1.1安装与运行环境.html"><strong aria-hidden="true">1.1.</strong> 安装与运行环境</a></li><li class="chapter-item expanded "><a href="1.开始/1.2编辑器、集成开发环境与其它工具.html"><strong aria-hidden="true">1.2.</strong> 编辑器、集成开发环境与其它工具</a></li><li class="chapter-item expanded "><a href="1.开始/1.3代码编译运行.html"><strong aria-hidden="true">1.3.</strong> 代码编译运行</a></li></ol></li><li class="chapter-item expanded "><a href="2.基础/_index.html"><strong aria-hidden="true">2.</strong> 基础</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="2.基础/2.1 Erlang终端.html"><strong aria-hidden="true">2.1.</strong> Erlang终端</a></li><li class="chapter-item expanded "><a href="2.基础/2.2 基础语法.html"><strong aria-hidden="true">2.2.</strong> 基础语法</a></li><li class="chapter-item expanded "><a href="2.基础/2.2.1 异常处理.html"><strong aria-hidden="true">2.3.</strong> 异常处理</a></li><li class="chapter-item expanded "><a href="2.基础/2.3 数据类型.html"><strong aria-hidden="true">2.4.</strong> 数据类型</a></li><li class="chapter-item expanded "><a href="2.基础/2.4 运算符.html"><strong aria-hidden="true">2.5.</strong> 运算符</a></li><li class="chapter-item expanded "><a href="2.基础/2.5 模块属性.html"><strong aria-hidden="true">2.6.</strong> 模块属性</a></li><li class="chapter-item expanded "><a href="2.基础/2.6启动Erlang节点.html"><strong aria-hidden="true">2.7.</strong> 启动Erlang节点</a></li></ol></li><li class="chapter-item expanded "><a href="3.库函数/_index.html"><strong aria-hidden="true">3.</strong> 库函数</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3.库函数/asn1/_index.html"><strong aria-hidden="true">3.1.</strong> Asn 1</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3.库函数/asn1/asn1rt.html"><strong aria-hidden="true">3.1.1.</strong> Asn 1 Rt</a></li></ol></li><li class="chapter-item expanded "><a href="3.库函数/compiler/compiler.html"><strong aria-hidden="true">3.2.</strong> Compiler</a></li><li class="chapter-item expanded "><a href="3.库函数/crypto/crypto.html"><strong aria-hidden="true">3.3.</strong> Crypto</a></li><li class="chapter-item expanded "><a href="3.库函数/erts/_index.html"><strong aria-hidden="true">3.4.</strong> Erts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3.库函数/erts/erl_nif.html"><strong aria-hidden="true">3.4.1.</strong> Erl Nif</a></li><li class="chapter-item expanded "><a href="3.库函数/erts/erlang.html"><strong aria-hidden="true">3.4.2.</strong> Erlang</a></li><li class="chapter-item expanded "><a href="3.库函数/erts/init.html"><strong aria-hidden="true">3.4.3.</strong> Init</a></li></ol></li><li class="chapter-item expanded "><a href="3.库函数/kernel/_index.html"><strong aria-hidden="true">3.5.</strong> Kernel</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3.库函数/kernel/application.html"><strong aria-hidden="true">3.5.1.</strong> Application</a></li><li class="chapter-item expanded "><a href="3.库函数/kernel/code_server.html"><strong aria-hidden="true">3.5.2.</strong> Code Server</a></li><li class="chapter-item expanded "><a href="3.库函数/kernel/error_logger.html"><strong aria-hidden="true">3.5.3.</strong> Error Logger</a></li><li class="chapter-item expanded "><a href="3.库函数/kernel/inet.html"><strong aria-hidden="true">3.5.4.</strong> Inet</a></li><li class="chapter-item expanded "><a href="3.库函数/kernel/net_adm.html"><strong aria-hidden="true">3.5.5.</strong> Net Adm</a></li><li class="chapter-item expanded "><a href="3.库函数/kernel/net_kernel.html"><strong aria-hidden="true">3.5.6.</strong> Net Kernel</a></li></ol></li><li class="chapter-item expanded "><a href="3.库函数/os_mon/_index.html"><strong aria-hidden="true">3.6.</strong> Os Mon</a></li><li class="chapter-item expanded "><a href="3.库函数/otp/_index.html"><strong aria-hidden="true">3.7.</strong> otp模块</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3.库函数/otp/函数.html"><strong aria-hidden="true">3.7.1.</strong> 函数</a></li><li class="chapter-item expanded "><a href="3.库函数/otp/application_app.erl.html"><strong aria-hidden="true">3.7.2.</strong> application_app.erl</a></li><li class="chapter-item expanded "><a href="3.库函数/otp/application_sup.erl.html"><strong aria-hidden="true">3.7.3.</strong> application_sup.erl</a></li><li class="chapter-item expanded "><a href="3.库函数/otp/application.app.src.html"><strong aria-hidden="true">3.7.4.</strong> application.app.src</a></li><li class="chapter-item expanded "><a href="3.库函数/otp/gen_fsm.html"><strong aria-hidden="true">3.7.5.</strong> Gen Fsm</a></li><li class="chapter-item expanded "><a href="3.库函数/otp/gen_server.html"><strong aria-hidden="true">3.7.6.</strong> Gen Server</a></li><li class="chapter-item expanded "><a href="3.库函数/otp/receive.html"><strong aria-hidden="true">3.7.7.</strong> Receive</a></li></ol></li><li class="chapter-item expanded "><a href="3.库函数/sasl/_index.html"><strong aria-hidden="true">3.8.</strong> Sasl</a></li><li class="chapter-item expanded "><a href="3.库函数/stdlib/_index.html"><strong aria-hidden="true">3.9.</strong> Stdlib</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3.库函数/stdlib/array.html"><strong aria-hidden="true">3.9.1.</strong> Array</a></li><li class="chapter-item expanded "><a href="3.库函数/stdlib/base64.html"><strong aria-hidden="true">3.9.2.</strong> Base 64</a></li><li class="chapter-item expanded "><a href="3.库函数/stdlib/binary.html"><strong aria-hidden="true">3.9.3.</strong> Binary</a></li><li class="chapter-item expanded "><a href="3.库函数/stdlib/c.html"><strong aria-hidden="true">3.9.4.</strong> C</a></li><li class="chapter-item expanded "><a href="3.库函数/stdlib/calendar.html"><strong aria-hidden="true">3.9.5.</strong> Calendar</a></li><li class="chapter-item expanded "><a href="3.库函数/stdlib/code.html"><strong aria-hidden="true">3.9.6.</strong> Code</a></li><li class="chapter-item expanded "><a href="3.库函数/stdlib/dict.html"><strong aria-hidden="true">3.9.7.</strong> Dict</a></li><li class="chapter-item expanded "><a href="3.库函数/stdlib/erl_.html"><strong aria-hidden="true">3.9.8.</strong> Erl Scan</a></li><li class="chapter-item expanded "><a href="3.库函数/stdlib/file.html"><strong aria-hidden="true">3.9.9.</strong> File</a></li><li class="chapter-item expanded "><a href="3.库函数/stdlib/filelib.html"><strong aria-hidden="true">3.9.10.</strong> Filelib</a></li><li class="chapter-item expanded "><a href="3.库函数/stdlib/gb_trees.html"><strong aria-hidden="true">3.9.11.</strong> Gb Trees</a></li><li class="chapter-item expanded "><a href="3.库函数/stdlib/gen_tcp.html"><strong aria-hidden="true">3.9.12.</strong> Gen Tcp</a></li><li class="chapter-item expanded "><a href="3.库函数/stdlib/httpc.html"><strong aria-hidden="true">3.9.13.</strong> Httpc</a></li><li class="chapter-item expanded "><a href="3.库函数/stdlib/inet.html"><strong aria-hidden="true">3.9.14.</strong> Inet</a></li><li class="chapter-item expanded "><a href="3.库函数/stdlib/init_parse.html"><strong aria-hidden="true">3.9.15.</strong> Init Parse</a></li><li class="chapter-item expanded "><a href="3.库函数/stdlib/init.html"><strong aria-hidden="true">3.9.16.</strong> Init</a></li><li class="chapter-item expanded "><a href="3.库函数/stdlib/io.html"><strong aria-hidden="true">3.9.17.</strong> Io</a></li><li class="chapter-item expanded "><a href="3.库函数/stdlib/lists.html"><strong aria-hidden="true">3.9.18.</strong> List</a></li><li class="chapter-item expanded "><a href="3.库函数/stdlib/maps.html"><strong aria-hidden="true">3.9.19.</strong> Maps</a></li><li class="chapter-item expanded "><a href="3.库函数/stdlib/ordsets.html"><strong aria-hidden="true">3.9.20.</strong> Ordsets</a></li><li class="chapter-item expanded "><a href="3.库函数/stdlib/os.html"><strong aria-hidden="true">3.9.21.</strong> Os</a></li><li class="chapter-item expanded "><a href="3.库函数/stdlib/proplists.html"><strong aria-hidden="true">3.9.22.</strong> Proplists</a></li><li class="chapter-item expanded "><a href="3.库函数/stdlib/qlc.html"><strong aria-hidden="true">3.9.23.</strong> Qlc</a></li><li class="chapter-item expanded "><a href="3.库函数/stdlib/queue.html"><strong aria-hidden="true">3.9.24.</strong> Queue</a></li><li class="chapter-item expanded "><a href="3.库函数/stdlib/random.html"><strong aria-hidden="true">3.9.25.</strong> Random</a></li><li class="chapter-item expanded "><a href="3.库函数/stdlib/re.html"><strong aria-hidden="true">3.9.26.</strong> Re</a></li><li class="chapter-item expanded "><a href="3.库函数/stdlib/sets.html"><strong aria-hidden="true">3.9.27.</strong> Sets</a></li><li class="chapter-item expanded "><a href="3.库函数/stdlib/shell.html"><strong aria-hidden="true">3.9.28.</strong> Shell</a></li><li class="chapter-item expanded "><a href="3.库函数/stdlib/soft.html"><strong aria-hidden="true">3.9.29.</strong> Soft</a></li><li class="chapter-item expanded "><a href="3.库函数/stdlib/ssh.html"><strong aria-hidden="true">3.9.30.</strong> Ssh</a></li><li class="chapter-item expanded "><a href="3.库函数/stdlib/string.html"><strong aria-hidden="true">3.9.31.</strong> String</a></li><li class="chapter-item expanded "><a href="3.库函数/stdlib/supervisor.html"><strong aria-hidden="true">3.9.32.</strong> Supervisor</a></li><li class="chapter-item expanded "><a href="3.库函数/stdlib/timer.html"><strong aria-hidden="true">3.9.33.</strong> Timer</a></li><li class="chapter-item expanded "><a href="3.库函数/stdlib/tuple.html"><strong aria-hidden="true">3.9.34.</strong> Tuple</a></li><li class="chapter-item expanded "><a href="3.库函数/stdlib/unicode.html"><strong aria-hidden="true">3.9.35.</strong> Unicode</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="4.工具/_index.html"><strong aria-hidden="true">4.</strong> 工具</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="4.工具/4.10profiling/_index.html"><strong aria-hidden="true">4.1.</strong> Profiling</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="4.工具/4.10profiling/4.10.1fprof.html"><strong aria-hidden="true">4.1.1.</strong> Fprof</a></li><li class="chapter-item expanded "><a href="4.工具/4.10profiling/4.10.2eprof.html"><strong aria-hidden="true">4.1.2.</strong> Eprof</a></li><li class="chapter-item expanded "><a href="4.工具/4.10profiling/4.10.3cprof.html"><strong aria-hidden="true">4.1.3.</strong> Cprof</a></li></ol></li><li class="chapter-item expanded "><a href="4.工具/4.3Erlang多节点/4.3.1主从节点.html"><strong aria-hidden="true">4.2.</strong> 主从节点</a></li><li class="chapter-item expanded "><a href="4.工具/4.3Erlang多节点/4.3.2Erlang多节点.html"><strong aria-hidden="true">4.3.</strong> Erlang多节点</a></li><li class="chapter-item expanded "><a href="4.工具/4.7dbg-debug模块/_index.html"><strong aria-hidden="true">4.4.</strong> dbg-debug模块</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="4.工具/4.7dbg-debug模块/4.7.1dbg.html"><strong aria-hidden="true">4.4.1.</strong> Dbg</a></li></ol></li><li class="chapter-item expanded "><a href="4.工具/4.1Erlang预处理器.html"><strong aria-hidden="true">4.5.</strong> Erlang预处理器</a></li><li class="chapter-item expanded "><a href="4.工具/4.2Port.html"><strong aria-hidden="true">4.6.</strong> Port</a></li><li class="chapter-item expanded "><a href="4.工具/4.4Epmd.html"><strong aria-hidden="true">4.7.</strong> Epmd</a></li><li class="chapter-item expanded "><a href="4.工具/4.5断点工具.html"><strong aria-hidden="true">4.8.</strong> 断点工具</a></li><li class="chapter-item expanded "><a href="4.工具/4.6dialyzer.html"><strong aria-hidden="true">4.9.</strong> Dialyzer</a></li><li class="chapter-item expanded "><a href="4.工具/4.8Erlang跟踪工具.html"><strong aria-hidden="true">4.10.</strong> Erlang跟踪工具</a></li><li class="chapter-item expanded "><a href="4.工具/4.9etop.html"><strong aria-hidden="true">4.11.</strong> Etop</a></li></ol></li><li class="chapter-item expanded "><a href="5.进阶/_index.html"><strong aria-hidden="true">5.</strong> 进阶</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="5.进阶/5.1TCP粘包、大小端.html"><strong aria-hidden="true">5.1.</strong> TCP粘包、大小端</a></li><li class="chapter-item expanded "><a href="5.进阶/5.2rebar发布系统.html"><strong aria-hidden="true">5.2.</strong> rebar发布系统</a></li><li class="chapter-item expanded "><a href="5.进阶/5.3ErlangVM心跳.html"><strong aria-hidden="true">5.3.</strong> ErlangVM心跳</a></li><li class="chapter-item expanded "><a href="5.进阶/5.4ErlangGC.html"><strong aria-hidden="true">5.4.</strong> Erlang GC</a></li><li class="chapter-item expanded "><a href="5.进阶/5.5ErlangTime.html"><strong aria-hidden="true">5.5.</strong> Erlang Time</a></li><li class="chapter-item expanded "><a href="5.进阶/5.6Erlang启动/5.6.1Erlang启动.html"><strong aria-hidden="true">5.6.</strong> Erlang启动</a></li><li class="chapter-item expanded "><a href="5.进阶/5.6Erlang启动/5.6.2SASL配置.html"><strong aria-hidden="true">5.7.</strong> SASL配置</a></li><li class="chapter-item expanded "><a href="5.进阶/5.7Erlang系统限制.html"><strong aria-hidden="true">5.8.</strong> Erlang系统限制</a></li></ol></li><li class="chapter-item expanded "><a href="6.xx/_index.html"><strong aria-hidden="true">6.</strong> Xx</a></li><li class="chapter-item expanded "><a href="7.项目/_index.html"><strong aria-hidden="true">7.</strong> 项目</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="7.项目/7.1Mnesia/_index.html"><strong aria-hidden="true">7.1.</strong> Mnesia</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="7.项目/7.1Mnesia/7.1.10ets.html"><strong aria-hidden="true">7.1.1.</strong> Ets</a></li><li class="chapter-item expanded "><a href="7.项目/7.1Mnesia/7.1.1Mnesia模式.html"><strong aria-hidden="true">7.1.2.</strong> Mnesia模式</a></li><li class="chapter-item expanded "><a href="7.项目/7.1Mnesia/7.1.2Mnesia操作.html"><strong aria-hidden="true">7.1.3.</strong> Mnesia操作</a></li><li class="chapter-item expanded "><a href="7.项目/7.1Mnesia/7.1.3Mnesia增删改查.html"><strong aria-hidden="true">7.1.4.</strong> Mnesia增删改查</a></li><li class="chapter-item expanded "><a href="7.项目/7.1Mnesia/7.1.4Mnesia过载分析.html"><strong aria-hidden="true">7.1.5.</strong> Mnesia过载分析</a></li><li class="chapter-item expanded "><a href="7.项目/7.1Mnesia/7.1.5Mnesia高级特性.html"><strong aria-hidden="true">7.1.6.</strong> Mnesia高级特性</a></li><li class="chapter-item expanded "><a href="7.项目/7.1Mnesia/7.1.6分布式.html"><strong aria-hidden="true">7.1.7.</strong> 分布式</a></li><li class="chapter-item expanded "><a href="7.项目/7.1Mnesia/7.1.7Mnesia表分片.html"><strong aria-hidden="true">7.1.8.</strong> Mnesia表分片</a></li><li class="chapter-item expanded "><a href="7.项目/7.1Mnesia/7.1.8Mnesia锁.html"><strong aria-hidden="true">7.1.9.</strong> Mnesia锁</a></li><li class="chapter-item expanded "><a href="7.项目/7.1Mnesia/7.1.9dets.html"><strong aria-hidden="true">7.1.10.</strong> Dets</a></li></ol></li><li class="chapter-item expanded "><a href="7.项目/7.2Ejabberd/_index.html"><strong aria-hidden="true">7.2.</strong> Ejabberd</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="7.项目/7.2Ejabberd/7.2.1mod_echo.erl.html"><strong aria-hidden="true">7.2.1.</strong> mod_echo.erl</a></li><li class="chapter-item expanded "><a href="7.项目/7.2Ejabberd/7.2.2hooksformoduledevelopers.html"><strong aria-hidden="true">7.2.2.</strong> Hooksformoduledevelopers</a></li><li class="chapter-item expanded "><a href="7.项目/7.2Ejabberd/7.2.3Eventslist.html"><strong aria-hidden="true">7.2.3.</strong> Eventslist</a></li></ol></li><li class="chapter-item expanded "><a href="7.项目/7.3cowboy/_index.html"><strong aria-hidden="true">7.3.</strong> Cowboy</a></li><li class="chapter-item expanded "><a href="7.项目/7.4rebar/_index.html"><strong aria-hidden="true">7.4.</strong> Rebar</a></li><li class="chapter-item expanded "><a href="7.项目/7.4rebar/7.4.1Wiki.html"><strong aria-hidden="true">7.5.</strong> Wiki</a></li><li class="chapter-item expanded "><a href="7.项目/7.4rebar/7.4.2rebar.config.script.html"><strong aria-hidden="true">7.6.</strong> rebar.config.script</a></li><li class="chapter-item expanded "><a href="7.项目/7.5riak/_index.html"><strong aria-hidden="true">7.7.</strong> Riak</a></li><li class="chapter-item expanded "><a href="7.项目/7.6Leofs/_index.html"><strong aria-hidden="true">7.8.</strong> Leofs</a></li></ol></li><li class="chapter-item expanded "><a href="8.资料整理/_index.html"><strong aria-hidden="true">8.</strong> 资料整理</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="8.资料整理/8.1资料/_index.html"><strong aria-hidden="true">8.1.</strong> 资料</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="8.资料整理/8.1资料/8.1.3SMP.html"><strong aria-hidden="true">8.1.1.</strong> SMP</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="8.资料整理/8.1资料/8.1.1Erlang的调度原理.html"><strong aria-hidden="true">8.1.1.1.</strong> Erlang的调度原理</a></li><li class="chapter-item expanded "><a href="8.资料整理/8.1资料/8.1.2虚拟机代码执行原理.html"><strong aria-hidden="true">8.1.1.2.</strong> 虚拟机代码执行原理</a></li></ol></li><li class="chapter-item expanded "><a href="8.资料整理/8.2杂记/_index.html"><strong aria-hidden="true">8.1.2.</strong> 杂记</a></li><li class="chapter-item expanded "><a href="8.资料整理/8.2杂记/8.2.1设计.html"><strong aria-hidden="true">8.1.3.</strong> 设计</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Erlang笔记</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/yujian1018/yujian1018.github.io/tree/master/erlang" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="介绍"><a class="header" href="#介绍">介绍</a></h1>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h2 id="install"><a class="header" href="#install">Install</a></h2>
<pre><code class="language-bash">#ubuntu
sudo apt install -y make gcc openssl libssl-dev libncurses-dev libwxgtk3.0-gtk3-dev libwxgtk-webview3.0-gtk3-dev xsltproc

## CentOS
yum -y install make gcc gcc-c++ kernel-devel m4 ncurses-devel openssl-devel


wget https://github.com/erlang/otp/archive/OTP-21.0.tar.gz
tar -zxf otp-OTP-21.0.tar.gz
cd otp-OTP-21.0
./otp_build autoconf
./configure --enable-native-libs
make
sudo make install

</code></pre>
<h2 id="依赖库说明"><a class="header" href="#依赖库说明">依赖库说明</a></h2>
<div class="table-wrapper"><table><thead><tr><th>lib库</th><th>功能</th></tr></thead><tbody>
<tr><td>libncurses-dev</td><td>系统的必备库,基础库</td></tr>
<tr><td>build-essential</td><td>提供编译程序必须软件包的列表信息</td></tr>
<tr><td>libwxgtk3.0-dev</td><td>图形库</td></tr>
<tr><td>libssl-dev</td><td>加密库</td></tr>
<tr><td>m4</td><td>native 模式 hipe</td></tr>
<tr><td>hipe</td><td>erlang-base-hipe</td></tr>
<tr><td>fop</td><td>Apache FOP print formatter (requires Java).</td></tr>
<tr><td>xsltproc</td><td>A command line XSLT processor</td></tr>
<tr><td>Xmllint</td><td>libxml2-utils</td></tr>
<tr><td>libpam0g-dev</td><td>PAM开发文件</td></tr>
<tr><td>unixodbc-dev</td><td>odbc支持mysql</td></tr>
<tr><td>freeglut3-dev</td><td>允许用户在众多的平台的创建和管理窗口中OpenGL容器，以及相关的鼠标、键盘和游戏杆功能</td></tr>
<tr><td>openjdk-8-jdk</td><td>jdk</td></tr>
</tbody></table>
</div>
<h2 id="设置环境变量"><a class="header" href="#设置环境变量">设置环境变量</a></h2>
<p>在/etc/profile的最下面添加</p>
<pre><code class="language-bash">export ERL_HOME=/usr/local/erlang
export PATH=$ERL_HOME/bin:$PATH  #PS：注意是冒号隔开而不是分号
source /etc/profile
ln /usr/local/erlang/lib/erlang/bin/erl /usr/sbin/erl
</code></pre>
<h2 id="问题"><a class="header" href="#问题">问题</a></h2>
<div class="table-wrapper"><table><thead><tr><th>描述</th><th>解决方案</th></tr></thead><tbody>
<tr><td>configure: error: No curses library functions found</td><td>yum list|grep ncurses<br/>yum -y install ncurses-devel</td></tr>
<tr><td>jinterface     : No Java compiler found</td><td></td></tr>
<tr><td>odbc           : ODBC library - link check failed</td><td>yum install unixODBC-devel</td></tr>
<tr><td>crypto         : No usable OpenSSL found</td><td>yum install openssl-devel</td></tr>
<tr><td>ssh            : No usable OpenSSL found</td><td>yum install openssl-devel</td></tr>
<tr><td>ssl            : No usable OpenSSL found</td><td>yum install openssl-devel</td></tr>
<tr><td>No C++ compiler found</td><td>yum install gcc-c++</td></tr>
</tbody></table>
</div>
<h2 id="yaws"><a class="header" href="#yaws">Yaws</a></h2>
<pre><code class="language-bash">#ubuntu 
sudo apt install libpam0g-dev
#centOS
yum install autoconf libtool pam-devel

wget http://yaws.hyber.org/download/yaws-1.9.6.tar.gz
tar -zxf yaws-1.9.6.tar.gz
cd yaws
vim c_src/setuid_drv.c
#注释 line:135
vim src/yaws_log.erl
#注释 line:168

autoreconf -fi
./configure --prefix=/usr/local/lib/yaws/
sed -i 's/ -Werror//g' `grep -rl &quot; -Werror&quot; ./`
make install
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="编辑器"><a class="header" href="#编辑器">编辑器</a></h2>
<ul>
<li><a href="https://www.jetbrains.com/idea/">IDEA</a></li>
<li><a href="https://www.vim.org/">VIM</a></li>
<li><a href="https://code.visualstudio.com/">VSCode</a></li>
<li><a href="http://www.sublimetext.com/">Sublime Text 3</a></li>
</ul>
<p>side-effect-free无副作用,其中一种定义是说:一个程序执行前后保持程序的状态不变,不改变非局部变量的值,不改变传入参数值,也无I/O</p>
<p>1.单进程问题
Erlang虚拟机属于抢占式调度，抢占式调度有很多好处，但是同样也存在这弊端。虚拟机在默认情况下分配个每个进程的资源都是相同的，但是若一个进程（gen_server/event/fsm）要为其他许多进程提供服务，这个进程就极有可能成为整个Erlang系统的瓶颈所在。<a href="http://www.cnblogs.com/--00/p/4277640.html">http://www.cnblogs.com/--00/p/4277640.html</a></p>
<p>2.列表解析效率
在Erlang编程语言中，list/string 是非常常见的一种数据类型，list处理的方式几乎都是遍历或者是尾递归，在list规模小的情况下，这种方式几乎不会给大家造成麻烦，但是一旦list的规模很大之后，情况就会变得非常糟糕。如list的“++”操作存在陷阱，erlang:length(List) 存在陷阱，queue:len(Queue)存在陷阱，诸如这种陷阱看起来很细碎，但是如果不好好处理，指不定就容易出现各种让我们摸不着头脑的坑。
前不久，我们刚刚在一个系统中，优化了一个lists:keydelete/3 的操作，大幅度提升了整个接口处理的速度。
当然，这些问题和erts的设计思路有很大的关系，如：private heap，变量不变 ... 。</p>
<p>3.refc binary
binary的存在在一定程度上缓解了list处理带来的“低效率”的问题，但是，refc binary（erlang:byte_size(Binary) &gt; 64的binary）的gc又让人比较蛋疼。Erlang process structure -- refc binary</p>
<p>4.OOM
在一定程度上，这也是单进程问题的一个附属品。单进程获得虚拟机资源有限，处理性能不足，导致message mail box 的message不断挤压，继而引发large heap，导致整个Erlang 虚拟机crash。最最典型的就是lager了。</p>
<p>5.Erlang进程CPU消耗度量
一直以来，大家都在社区中试图寻找度量单个Erlang进程CPU的消耗，但是不管是Erlang现在的API函数，还是社区中的方案，都没有提供一种行之有效的方案。为什么？我简单摘抄一段Erlang_IN_Anger中的一段描述吧：</p>
<blockquote>
<p>It is generally difficult to properly analyze the CPU usage of an Erlang node to pin problems to a specific piece of code. With everything concurrent and in a virtual machine, there is no guarantee you will find out if a specific process, driver, your own Erlang code, NIFs you may have installed, or some third-party library is eating up all your processing power.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>安装Erlang后，运行代码，先编译后运行</p>
<h3 id="在eshell中编译运行"><a class="header" href="#在eshell中编译运行">在Eshell中编译运行</a></h3>
<pre><code class="language-erlang">$erl
Erlang (BEAM) emulator version 5.5.1 [source] [async一threads:0] [hipe]
Eshell V5.5.1  (abort with }G)
1&gt; c(hello).
{ok，hello}
2&gt; hello:start().
Hello world
ok
3&gt; c(&quot;test.erl&quot;, [to_core]).   
4&gt; c(test).   %编译
{ok,test}   
5&gt; erts_debug:df(test).   %生成opcode 
ok  
</code></pre>
<h3 id="自带的编译工具"><a class="header" href="#自带的编译工具">自带的编译工具</a></h3>
<pre><code class="language-bash">$ erlc hello.erl
$ erlc -h  
$ erlc -o ebin -I include/ src/*.erl  
$ erlc +&quot;'S'&quot; mod.erl %产生自解码 .S汇编代码 
$ erlc +&quot;'P'&quot; mod.erl  
$ erlc +&quot;'E'&quot; mod.erl  
$ erl -noshell -s hello start -s init stop
Hello world

$erl -eval 'io:format(&quot;Memory:~p~n&quot;, [erlang:memory(total)]).' -s init stop
</code></pre>
<h3 id="make模块-emakefile"><a class="header" href="#make模块-emakefile">make模块 Emakefile</a></h3>
<pre><code class="language-erlang">make:all().
make:all(Options). %根据当前目录下的Emakefile配置文件进行编译
$ erl -make %自动查找当前目录下的Emakefile
</code></pre>
<p>vim Emakefile</p>
<pre><code class="language-text">{'file1',[debug_info,{i,&quot;../foo&quot;}]}. {'*',[debug_info]}.
{&quot;src/erlyweb/*&quot;,  [debug_info, {outdir, &quot;ebin&quot;}, {i,&quot;/opt/local/lib/yaws/include&quot;}]}.  
{&quot;src/erlydb/*&quot;, [debug_info, {outdir, &quot;ebin&quot;}]}. 
{&quot;src/erlang-psql-driver/*&quot;, [debug_info, strict_record_tests, {outdir, &quot;ebin&quot;}]}. 
{&quot;src/lib/*&quot;, [debug_info, strict_record_tests, {outdir, &quot;ebin&quot;}]}. 

{ [ '*' ],  
[ debug_info,  
% native,  
% {d,product},  
% {i, [&quot;include&quot;]},  
% {i,&quot;include/mysql_statements&quot;},  
% {i,&quot;include/section&quot;},  
% {i, &quot;priv/src/mochiweb/include&quot;},  
{outdir, &quot;ebin&quot;} ] }. 
</code></pre>
<h3 id="compile模块"><a class="header" href="#compile模块">compile模块</a></h3>
<pre><code class="language-erlang">compile:file(File, Options)

%% hipe加速
hipe:c(test, [to_llvm]).
</code></pre>
<h3 id="脚本启动"><a class="header" href="#脚本启动">脚本启动</a></h3>
<pre><code class="language-bash"># linux hello.sh
vim hello.sh

#!/bin/sh
erl -noshell -pa /home/joe/code -s hello start -s init stop


# windows hello.bat

&quot;C:\Program Files\erl5.5.3\bin\erl.exe&quot; -pa joe/code -noshell -s hello start -s init stop
</code></pre>
<h3 id="escript运行"><a class="header" href="#escript运行">escript运行</a></h3>
<p>vim factorial.escript</p>
<pre><code class="language-erlang">#!/usr/bin/env escript
main([A]) -&gt;    
 I = list_to_integer(A),
    F = fac(I),
    io:format(&quot;factorial~w=~w~n&quot;, [I, F]).
fac(0) -&gt; 1;
fac(N) -&gt; N * fac(N - 1).
</code></pre>
<p>无须编译，直接运行:</p>
<pre><code class="language-bash">$./factorial 25
factorial 25=15511210043330985984000000
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h2 id="启动终端"><a class="header" href="#启动终端">启动终端</a></h2>
<p>在unix终端中输入erl来打开Erlang终端。Erlang终端简称（Eshell)
在windows中我们可以通过单击&quot;开始&quot;菜单中的Erlang运行图标来打开。</p>
<h2 id="eshell使用"><a class="header" href="#eshell使用">Eshell使用</a></h2>
<p>当进入Eshell中，请尝试输入一些整数，在表达式的最后需要使用英文句号(句点)来终止，然后按回车键执行：</p>
<pre><code class="language-erlang">1&gt; -234.
-234
2&gt; 2#1010.
10
3&gt; $A.
65
</code></pre>
<p>如果在输入结束时没有输入句点，那么Eshell就不会对你的输入值进行求值，并会继续接收你后续输入的信息，知道输入句点并且按下回车键执行</p>
<pre><code class="language-erlang">4&gt; 5-
4&gt;
4&gt; 4.
1
</code></pre>
<p>1&gt; 和 2&gt; 都是命令提示符，这表明Erlang已经准备好接受输入。当你按下回车键且结束行也使用了句点，那么Erlang就会对你所输人的内容进行求值，如果成功的话，就会显示出结果。请注意各种不同的整数表达式都转换和显示为十进制形式。如果你输人一个无效的表达式，你会得到一个错误，比如:</p>
<pre><code class="language-erlang">4&gt; 5-.
* 5: syntax error before: '.'
</code></pre>
<p>要从一个错误中故复，只需要多按几次回车键，在加上句点，最后再按下回车键。如果你想退出Erlang终端窗口，那么请输入</p>
<pre><code class="language-erlang">5&gt; q().
</code></pre>
<p>并加上句点。</p>
<ul>
<li>
<p>在Erlang Shell中可以方便的做进制转换:Base#Value Base的范围2~16 2#101011</p>
</li>
<li>
<p>Erlang Shell中查询ASCII码 $1 $a $A $\n $}</p>
</li>
<li>
<p>Erlang Shell中释放变量使用f() 定义record使用rd(),读取shell输入使用io:read/1可以接受输入Erlang term</p>
</li>
<li>
<p>Erlang Shell中接受消息使用flush() 自己的Pid是self() 查看进程信息使用processes() i() 但是不要在进程非常多的场景使用,会消耗大量内存</p>
</li>
<li>
<p>使用 CTRL ＋ \ 或 init:stop()， 可以退出Erlang，</p>
</li>
<li>
<p>使用CTRL ＋ G 及 CTRL + C 弹出菜单选项，可以选择是否退出Erlang。</p>
</li>
<li>
<p>其中CTRL ＋ G可以用来连接其他的shell，</p>
</li>
<li>
<p>CTRL ＋ C可以查看其他一些系统信息</p>
</li>
<li>
<p>Ctrl + C abort 是野蛮的退出方式</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="注释"><a class="header" href="#注释">注释</a></h2>
<p>注释不会被编译</p>
<p>单行注释，你可以在任何地方使用以 %% 开头的单行注释。
多行注释等同于单行注释</p>
<pre><code class="language-erlang">%%
</code></pre>
<hr />
<h2 id="if"><a class="header" href="#if">if</a></h2>
<pre><code class="language-erlang">test(A, B) -&gt;
    if 
        (A &gt; 1) andalso (B &gt; 1) -&gt; 1;
        true -&gt; 2
    end.
</code></pre>
<ul>
<li>if语句会对Guard子句做catch,所以 if 1/0 -&gt;a; true -&gt;b end.的返回值是b而不是抛出异常</li>
</ul>
<pre><code class="language-erlang">erl
Fun2 = fun() -&gt;
        if 
            1/0 -&gt; a;
            true -&gt; b
        end
    end.
#Fun&lt;erl_eval.45.65746770&gt;

Fun2().
b
</code></pre>
<ul>
<li>if的Guard子句放在变量里就可以让异常抛出来:</li>
</ul>
<pre><code class="language-erlang">Fun3 = fun() -&gt;
        G=1/0, 
        if 
            G-&gt;a; 
            true -&gt;b 
        end
    end.
#Fun&lt;erl_eval.45.65746770&gt;
Fun3().
** exception error: an error occurred when evaluating an arithmetic expression
     in operator  '/'/2
        called as 1 / 0

</code></pre>
<ul>
<li>Guard可以使用, ; 表达多个条件</li>
</ul>
<pre><code class="language-erlang">Fun4 = fun(X, Y) -&gt;
        if 
            X=:=1,Y&lt;2;X+Y&lt;4 -&gt;ok;
            true -&gt;error
        end
    end.
Fun4(1,3).
error
</code></pre>
<h2 id="case"><a class="header" href="#case">case</a></h2>
<pre><code class="language-erlang">a(Arg) -&gt;
 case Arg of
     undefined -&gt; 
         A = 1,
            B = 2;
  {ok, arg} -&gt;
         A = 3,
            B = 4
 end,
    A + B.
</code></pre>
<h2 id="宏的流程控制"><a class="header" href="#宏的流程控制">宏的流程控制</a></h2>
<pre><code class="language-erlang">-undef(Macro) . %取消改宏定义，在这个语句之后不能调用这个宏。
-ifdef(Macro). %只有Macro被定义后，才对该行以下的代码进行运算。
-ifndef(Macro). %只有在不定义Macro的情况下，才对该行以下的代码进行运算。
-else. %只能在-ifdef或-ifndef之后出现，如果条件为false, 那么改语句后的代码才被执行。
-endif. %标记-ifdef或-ifndef语句的结束。
</code></pre>
<p><img src="2.%E5%9F%BA%E7%A1%80//images/screenshot_1534332317889.png" alt="图片" /></p>
<h2 id="beginend"><a class="header" href="#beginend">begin...end</a></h2>
<p><img src="2.%E5%9F%BA%E7%A1%80//images/screenshot_1534332324550.png" alt="图片" /></p>
<h2 id="断言"><a class="header" href="#断言">断言</a></h2>
<p>1.Guard是一种强化模式匹配功能的结构，使用Guard可以在一个模式上做一些简单的变量测试和比较。</p>
<p>2.示例:
max(X, Y) -&gt; when X &gt; Y -&gt; X;
max(X, Y) -&gt; Y.</p>
<p>3.Guard组合关系
Guard1;Guard2...;Guardn 条件式中每个条件式是or关系。
Guard1,Guard2...,Guardn 条件式中每个条件式是and关系。</p>
<p>4.合法的Guard表达式：</p>
<ul>
<li>原子true。</li>
<li>其它常量(字典或者列表中的条目或者绑定变量), 这些在断言表达式中都会被求值为false。</li>
<li>断言谓词或者BIF。</li>
<li>比较表达式。</li>
<li>算数表达式。</li>
<li>布尔表达式。</li>
<li>短路布尔表达式</li>
</ul>
<p>断言谓词</p>
<ul>
<li>谓词                   含义</li>
<li>is_atom(X)             X是原子</li>
<li>is_binary(X)           X是二进制数据</li>
<li>is_constant(X)         X是常数</li>
<li>is_float(X)            X是浮点数</li>
<li>is_function(X)         X是函数</li>
<li>is_function(X, N)      X是有N个参数的函数</li>
<li>is_integer(X)          X是整数</li>
<li>is list (X)            X是列表</li>
<li>is_number(X)           X是整数或浮点数</li>
<li>is_pid(X)              X是进程标识符</li>
<li>is_port(X)             X是端口</li>
<li>is_reference(X)        X是引用</li>
<li>is_tuple(X)            X是元组</li>
<li>is_record(X,Tag)       X是标记为Tag的记录</li>
<li>is_record(X,Tag,N)    X是标记为Tag大小为N的记录</li>
</ul>
<p>断言BIF</p>
<ul>
<li>函数            含义</li>
<li>abs(X)              X的绝对值</li>
<li>element(N,X)        元组X的第N个元素</li>
<li>float(X)            将数字X转换为浮点数</li>
<li>hd(X)               列表X的头部</li>
<li>length(X)           列表X的长度</li>
<li>node()              当前节点</li>
<li>node(X)             创建X的节点，X可以是进程标识符、引用或端口</li>
<li>round(X)            将数字X转换为整数(四舍五入)</li>
<li>self()              当前进程的进程标识符</li>
<li>size(X)             X的大小，X为元组或二进制数据</li>
<li>trunc(X)            将数字X转换为整数(截取)</li>
<li>tl(X)               列表X的尾部</li>
</ul>
<h2 id="receiveend"><a class="header" href="#receiveend">receive...end</a></h2>
<pre><code class="language-erlang">receive
    {ClientPid, {table, Table}} -&gt;
        Res = filter( Table ),
        ClientPid ! {mnesiaDBA_pub_clear, Res},
        loop();
    {ClientPid, {stop, Stop}} -&gt;
        ClientPid ! {mnesiaDBA_pub_clear, &quot;pid stopping reason:&quot; ++ hd(io_lib:format( &quot;~p~n&quot;, [Stop] ))};
    {ClientPid, Other} -&gt;
        ClientPid ! {mnesiaDBA_pub_clear, &quot;arg is error:&quot; ++ hd(io_lib:format( &quot;~p~n&quot;, [Other] ))},
        loop()
after
    10000 -&gt; timeout
end.
</code></pre>
<h2 id="try-catch"><a class="header" href="#try-catch">try catch</a></h2>
<p>1.erlang:throw(Reason)
<img src="2.%E5%9F%BA%E7%A1%80//images/screenshot_1534332402269.png" alt="图片" /></p>
<p>2.exit(Reason)
<img src="2.%E5%9F%BA%E7%A1%80//images/screenshot_1534332423951.png" alt="图片" /></p>
<p>3.erlang:error
<img src="2.%E5%9F%BA%E7%A1%80//images/screenshot_1534332417471.png" alt="图片" /></p>
<pre><code class="language-erlang">try Fun of
 {ok, Val} -&gt; Val;
    _   -&gt; []
catch
     Catch:Why:Stk -&gt; []
end.

get_(L )-&gt;
         catch 
            lists:map(
                fun( E) -&gt; 
                    if 
                        E == 1 -&gt; throw([ 0]);
                        true -&gt;E  
                    end 
                end,
             L).
B = get_([ 1, 2, 3]).


Fun = 
 fun( X, {Data, Data1} ) -&gt; 
        case X==Data of 
            true -&gt; throw({0,0}); 
            false -&gt; {Data, Data1+X} 
        end 
    end. 
catch lists:foldl( Fun, {5, 0}, Lists).  %Catch的另类用法
{0,0}. 


try_catch(Expr, Handler) -&gt;
    try
        Expr()
    catch
        Catch:Why:Stk -&gt;
            Handler(Catch:Why:Stk)
    end.

try
  Exprs
catch
  something_was_thrown -&gt;
    %% The default class is 'throw'.
  throw:something_else_was_thrown -&gt;
  throw:thrown_with_interesting_stacktrace:Stk -&gt;
    %% The class 'throw' must be explicitly given when
    %% the stacktrace is to be retrieved.
  error:undef -&gt;
    %% Handle an undefined function specially.
  C:E:Stk -&gt;
    %% Log any other exception and rethrow it.
    log_exception(C, E, Stk),
    raise(C, E, Stk)
end.
</code></pre>
<ul>
<li>number&lt;atom&lt;reference&lt;fun&lt;port&lt;pid&lt;tuple&lt;list&lt;binary 之所以有这样一个比较关系,就是为了支持泛型比较=:= =/=精确比较运算不仅比较值,还比较类型,效率更高</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>即便是Erlang程序员也难免会写出有问题的程序。代码中的语法错误（和一些语义错误）可以借助编译器检测出来，但程序仍可能含有逻辑错误。对需求理解的偏差或对需求实现的不完备所造成的逻辑错误只能通过大量的一致性测试来检测。其他的错误则以运行时错误的形式出现。
函数是在Erlang进程中执行的。函数可能出于多种原因而失败，比如：</p>
<ul>
<li>一次匹配操作失败</li>
<li>使用错误的参数调用BIF</li>
<li>我们可能打算对一个算术表达式求值，然而其中的一个项式并不是数值</li>
</ul>
<p>Erlang本身当然无法修正这些情况，但它为程序员提供了一些检测和处理失败情况的机制。借助这些机制，程序员可以设计出健壮和容错的系统。Erlang具备如下机制：</p>
<ul>
<li>监视表达式的求值</li>
<li>监视其他进程的行为</li>
<li>捕获对未定义函数的求值
Catch和Throw
catch和throw提供了一种表达式求值的监视机制，可以用于</li>
</ul>
<blockquote>
<p>处理顺序代码中的错误（catch）</p>
<p>函数的非本地返回（catch结合throw）</p>
</blockquote>
<p>表达式求值失败（如一次匹配失败）的一般后果是导致求值进程的异常退出。通过以下方式可以借助catch来更改这个默认行为：</p>
<h2 id="catch-expression"><a class="header" href="#catch-expression">catch Expression</a></h2>
<p>若表达式的求值过程没有发生错误，则catch Expression返回Expression的值。</p>
<pre><code class="language-erlang">catch atom_to_list(abc).
&quot;abc&quot;
catch 22.
22
</code></pre>
<p>若求值过程失败，catch Expression将返回元组{'EXIT', Reason}，其中Reason是用于指明错误原因的原子式。</p>
<pre><code class="language-erlang">catch an_atom - 2.
{'EXIT',{badarith,[{erlang,'-',
                           [an_atom,2],
                           [{error_info,#{module =&gt; erl_erts_errors}}]},
                   {erl_eval,do_apply,6,[{file,&quot;erl_eval.erl&quot;},{line,689}]},
                   {erl_eval,expr,5,[{file,&quot;erl_eval.erl&quot;},{line,434}]},
                   {shell,exprs,7,[{file,&quot;shell.erl&quot;},{line,686}]},
                   {shell,eval_exprs,7,[{file,&quot;shell.erl&quot;},{line,642}]},
                   {shell,eval_loop,3,[{file,&quot;shell.erl&quot;},{line,627}]}]}}
catch atom_to_list(123).
{'EXIT',{badarg,[{erlang,atom_to_list,&quot;{&quot;,
                         [{error_info,#{module =&gt; erl_erts_errors}}]},
                 {erl_eval,do_apply,6,[{file,&quot;erl_eval.erl&quot;},{line,689}]},
                 {erl_eval,expr,5,[{file,&quot;erl_eval.erl&quot;},{line,434}]},
                 {shell,exprs,7,[{file,&quot;shell.erl&quot;},{line,686}]},
                 {shell,eval_exprs,7,[{file,&quot;shell.erl&quot;},{line,642}]},
                 {shell,eval_loop,3,[{file,&quot;shell.erl&quot;},{line,627}]}]}}
</code></pre>
<p>函数执行结束后，控制流程便返还者。throw/1可以令控制流程跳过调用者。如果我们像上述的那样计算catch Expression，并在Expression的求值过程中调用throw/1，则控制流程将直接返回至catch。注意catch可以嵌套；在嵌套的情况下，一次失败或throw将返回至最近的catch处。在catch之外调用throw/1将导致运行时错误。</p>
<pre><code class="language-erlang">%% 源代码 t1.erl
-module(t1).
-compile(export_all).


%% 下面的例子描述了catch和throw的行为。定义函数foo/1：
foo(1) -&gt; hello; 
foo(2) -&gt; throw({myerror, abc}); 
foo(3) -&gt; tuple_to_list(a); 
foo(4) -&gt; exit({myExit, 222}). 


demo(X) -&gt; 
    case catch foo(X) of 
        {myerror, Args} -&gt; {user_error, Args};
        {'EXIT', What} -&gt; {caught_error, What};
        Other -&gt; Other
    end.
</code></pre>
<pre><code class="language-bash"># 编译t1.erl
erlc t1.erl
ls
t1.beam
t1.erl

# 启动erl虚拟机
erl -pa .
</code></pre>
<pre><code class="language-erlang">%% 执行erl源代码编译后的模块

%% 假设在不使用catch的情况下，一个进程标识为Pid的进程执行了这个函数，则：
2&gt; t1:foo(1).
hello


%% 由于不在catch的作用域内，执行foo(2)的进程将出错退出。
3&gt; t1:foo(2).
** exception throw: {myerror,abc}
     in function  t1:foo/1 (t1.erl, line 6)


%% 这个BIF用于将元组转换为列表。在这个例子中，参数不是元组，因此该进程将出错退出。
4&gt; t1:foo(3).
** exception error: bad argument
     in function  tuple_to_list/1
        called as tuple_to_list(a)
        *** argument 1: not a tuple
     in call from t1:foo/1 (t1.erl, line 7)

%% 由于不在catch的范围内，执行foo(4)的函数将退出。很快我们就会看到参数{myExit,222}的用途。
5&gt; t1:foo(4).
** exception exit: {myExit,222}
     in function  t1:foo/1 (t1.erl, line 8)

%% 执行foo(5)的进程将出错退出，因为函数foo/1的首部无法匹配foo(5)。
6&gt; t1:foo(5).
** exception error: no function clause matching t1:foo(5) (t1.erl, line 5)


%% 现在让我们来看看在catch的作用域内对foo/1以相同的参数进行求值会发生什么：

%% 像原来一样执行hello。因为没有任何失败发生，而我们也没有执行throw，所以catch直接返回foo(1)的求值结果。
7&gt; t1:demo(1).
hello

%% 求值结果为{user_error,abc}。对throw({myerror,abc})的求值导致外围的catch返回{myerror, abc}同时case语句返回{user_error,abc}。
8&gt; t1:demo(2).
{user_error,abc}

%% 求值结果为{caught_error,badarg}。foo(3)执行失败导致catch返回{'EXIT',badarg}。
9&gt; t1:demo(3).
{caught_error,{badarg,[{erlang,tuple_to_list,
                               [a],
                               [{error_info,#{module =&gt; erl_erts_errors}}]},
                       {t1,foo,1,[{file,&quot;t1.erl&quot;},{line,7}]},
                       {t1,demo,1,[{file,&quot;t1.erl&quot;},{line,12}]},
                       {erl_eval,do_apply,6,[{file,&quot;erl_eval.erl&quot;},{line,689}]},
                       {shell,exprs,7,[{file,&quot;shell.erl&quot;},{line,686}]},
                       {shell,eval_exprs,7,[{file,&quot;shell.erl&quot;},{line,642}]},
                       {shell,eval_loop,3,[{file,&quot;shell.erl&quot;},{line,627}]}]}}

%% 求值结果为{caught_error,{myexit,222}}。
10&gt; t1:demo(4).
{caught_error,{myExit,222}}

%% 求值结果为{caught_error,function_clause}。
11&gt; t1:demo(5).
{caught_error,{function_clause,[{t1,foo,
                                    [5],
                                    [{file,&quot;t1.erl&quot;},{line,5}]},
                                {t1,demo,1,[{file,&quot;t1.erl&quot;},{line,12}]},
                                {erl_eval,do_apply,6,[{file,&quot;erl_eval.erl&quot;},{line,689}]},
                                {shell,exprs,7,[{file,&quot;shell.erl&quot;},{line,686}]},
                                {shell,eval_exprs,7,[{file,&quot;shell.erl&quot;},{line,642}]},
                                {shell,eval_loop,3,[{file,&quot;shell.erl&quot;},{line,627}]}]}}

%% 注意，在catch的作用域内，借助{'EXIT', Message}，你能够很容易地“伪造”一次失败——这是一个设计决策[1]。

</code></pre>
<h2 id="使用catch和throw抵御不良代码"><a class="header" href="#使用catch和throw抵御不良代码">使用catch和throw抵御不良代码</a></h2>
<p>下面来看一个简单的源代码：</p>
<pre><code class="language-erlang">-module(s_shell). 
-export([go/0]). 

go() -&gt; eval(io:parse_exprs('=&gt; ')).

eval({form,Exprs}) -&gt; 
        case catch eval:exprs(Exprs, []) of % Note the catch 
                {'EXIT', What} -&gt; io:format(&quot;Error: ~w!~n&quot;, [What]); 
                {value, What, _} -&gt; io:format(&quot;Result: ~w~n&quot;, [What]) 
        end;
eval(_) -&gt; io:format(&quot;Syntax Error!~n&quot;, []).

%% 标准库函数io:parse_exprs/1读取并解析一个Erlang表达式，若表达式合法，则返回{form,Exprs}。
%% 正确情况下，应该匹配到第一个子句eval({form,Expr})并调用库函数eval:exprs/2对表达式进行求值。由于无法得知表达式的求值过程是否为失败，我们在此使用catch进行保护。例如，对1 - a进行求值将导致错误，但在catch内对1 - a求值就可以捕捉这个错误[2]。借助catch，%% 在求值失败时，case子句与模式{'EXIT',what}匹配，在求值成功时则会与{value, What, _}匹配。
</code></pre>
<h2 id="使用catch和throw实现函数的非本地返回"><a class="header" href="#使用catch和throw实现函数的非本地返回">使用catch和throw实现函数的非本地返回</a></h2>
<p>假设我们要编写一个用于识别简单整数列表的解析器，可以编写如下的代码：</p>
<pre><code class="language-erlang">-module(t2). 
-export([parse_list/1,parse_list1/1]). 

parse_list(['[',']' | T]) -&gt; {nil, T}; 
parse_list(['[', X | T]) when integer(X) -&gt; 
        {Tail, T1} = parse_list_tail(T), 
        {{cons, X, Tail}, T1}. 

parse_list_tail([',', X | T]) when integer(X) -&gt; 
        {Tail, T1} = parse_list_tail(T), 
        {{cons, X, Tail}, T1}; 
parse_list_tail([']' | T]) -&gt; {nil, T}.


parse_list1(['[',']' | T]) -&gt; {nil, T}; 
parse_list1(['[', X | T]) when integer(X) -&gt; 
        {Tail, T1} = parse_list_tail1(T), 
        {{cons, X, Tail}, T1}; 
parse_list1(X) -&gt; throw({illegal_token, X}). 

parse_list_tail1([',', X | T]) when integer(X) -&gt; 
        {Tail, T1} = parse_list_tail1(T), 
        {{cons, X, Tail}, T1}; 
parse_list_tail1([']' | T]) -&gt; {nil, T}; 
parse_list_tail1(X) -&gt; throw({illegal_list_tail, X}).

</code></pre>
<p>编译源代码</p>
<pre><code class="language-bash">erlc t2.erl
ls 
t2.erl
t2.beam

# 启动erl虚拟机，并加载t2.beam编译后文件
erl -pa .
</code></pre>
<p>执行erl代码</p>
<pre><code class="language-erlang">1&gt; t2:parse_list(['[',12,',',20,']']).
{{cons,12,{cons,20,nil}},[]}

%% 要是我们试图解析一个非法的列表，就会导致如下的错误：
2&gt; t2:parse_list(['[',12,',',a]).
** exception error: no function clause matching t2:parse_list_tail([',',a]) (t2.erl, line 9)
     in function  t2:parse_list/1 (t2.erl, line 6)

%% 如果我们想在跳出递归调用的同时仍然掌握是哪里发生了错误，可以这样做：
%% 现在，如果我们在catch里对parse_list/1求值，将获得以下结果：
3&gt; catch parse_list1(['[',12,',',a]). {illegal_list_tail,[',',a]}

%% 通过这种方式，我们得以从递归中直接退出，而不必沿着通常的递归调用路径逐步折回。
</code></pre>
<h3 id="进程终止"><a class="header" href="#进程终止">进程终止</a></h3>
<p>当一个进程的进程执行函数（通过spawn/4创建进程时第3个参数所指定的函数）执行完毕，或是（在catch之外）执行exit(normal)，便会正常退出。</p>
<pre><code class="language-erlang">t3:start().
t3:process(). %% 创建一个注册名为my_name的进程来执行
</code></pre>
<p>erlang源代码</p>
<pre><code class="language-erlang">-module(t3). 
-export([process/0, start/0]). 
start() -&gt; register(my_name, spawn(t3, process, [])). 
process() -&gt; 
        receive 
                {stop, Method} -&gt; 
                        case Method of 
                                return -&gt; true; 
                                Other -&gt; exit(normal) 
                        end; 
                Other -&gt; process() 
        end.
</code></pre>
<p>编译并启动erl虚拟机</p>
<pre><code class="language-bash">erlc t3.erl
ls 
t3.erl
t3.beam

# 启动erl虚拟机，并加载t2.beam编译后文件
erl -pa .
</code></pre>
<p>执行erl代码</p>
<pre><code class="language-erlang">my_name ! {stop, return}
%% 令test:process()返回true，接着进程正常终止。

my_name ! {stop, hello}

%% 也会令进程正常终止，因为它执行了BIF exit(normal)。
%% 任何其它的消息，比如my_name ! any_other_message都将令进程递归执行test:process()（采用尾递归优化的方式，参见第??章）从而避免进程终止。
%% 若进程执行BIF exit(Reason)，则进程将异常终止。其中Reason是除了原子式normal以外的任意的Erlang项式。如我们所见，在catch上下文中执行exit(Reason)不会导致进程退出。
%% 进程在执行到会导致运行时失败的代码（如除零错误）时，也会异常终止。后续还会讨论各种类型的运行时失败。
</code></pre>
<h3 id="链接进程"><a class="header" href="#链接进程">链接进程</a></h3>
<p>进程可以互相监视。这里要引入两个概念，进程链接和EXIT信号。在执行期间，进程可以与其他进程（和端口，参见??章节）建立链接。当一个进程终止（无论正常或非正常终止）时，一个特殊的EXIT信号将被发送到所有与即将终止的进程相链接的进程（及端口）。该信号的格式如下：
{'EXIT', Exiting_Process_Id, Reason}</p>
<p>Exiting_Process_Id是即将终止的进程的进程标识，Reason可以是任意的Erlang项式。</p>
<p>收到Reason不是原子式normal的EXIT信号时，信号接收进程的默认动作是立即终止并，同时向当前与之链接的进程发送EXIT信号。默认情况下，Reason为原子式normal的EXIT信号将被忽略。</p>
<p>EXIT信号的默认处理方式行为可以被覆写，以允许进程在接收到EXIT信号时采取任意必要的动作。</p>
<h3 id="创建和删除链接"><a class="header" href="#创建和删除链接">创建和删除链接</a></h3>
<p>进程可以链接到其它进程和端口。进程间的链接都是双向的，也就是说，如果进程A链接到进程B，那么进程B也会自动链接到进程A。</p>
<p>通过执行BIF link(Pid)便可创建链接。调用link(Pid)时，若调用进程和Pid之间已经存在链接，则不会产生任何影响。</p>
<p>进程终止时，它所持有的链接都将被删除。也可以通过执行BIF unlink(Pid)显式删除链接。由于所有链接都是双向的，删除这一端到另一端的链接的同时，另一端的到这一端的链接也会被删除。若调用进程和Pid之间原本就没有链接，unlink(Pid)不会产生任何影响。</p>
<p>BIF spawn_link/3在创建新进程的同时还会在调用进程和新进程间建立链接。其行为可以定义为：</p>
<p>spawn_link(Module, Function, ArgumentList) -&gt; link(Id = spawn(Module, Function, ArgumentList)), Id.</p>
<p>只不过spawn和link是原子方式执行的。这是为了避免调用进程在执行link之前就被EXIT信号杀死。尝试向一个不存在的进程发起链接将导致信号{'EXIT', Pid, noproc}被发送至link(Pid)的调用进程。</p>
<p>函数start/1建立了若干以链式互联的进程，其中第一个进程的注册名为start。函数test/1向该注册进程发送消息。每个进程不断打印自己在链中的位置及收到的消息。消息stop令链中最后一个进程执行BIFexit(finished)，该BIF将导致该进程异常终止。</p>
<p>erlang源代码 normal.erl</p>
<pre><code class="language-erlang">-module(normal). 
-export([start/1, p1/1, test/1]). 
start(N) -&gt; register(start, spawn_link(normal, p1, [N - 1])). 

p1(0) -&gt; top1(); 
p1(N) -&gt; top(spawn_link(normal, p1, [N - 1]),N). 

top(Next, N) -&gt; 
        receive 
                X -&gt; 
                        Next ! X, 
                        io:format(&quot;Process ~w received ~w~n&quot;, [N,X]), 
                        top(Next,N) 
        end. 

top1() -&gt; 
        receive 
                stop -&gt; io:format(&quot;Last process now exiting ~n&quot;, []), exit(finished); 
                X -&gt; io:format(&quot;Last process received ~w~n&quot;, [X]), top1() 
        end. 

test(Mess) -&gt; start ! Mess.
</code></pre>
<p>编译并启动erl虚拟机</p>
<pre><code class="language-bash">erlc normal.erl
ls 
normal.erl
normal.beam

# 启动erl虚拟机，并加载t2.beam编译后文件
erl -pa .
</code></pre>
<p>执行erl代码</p>
<pre><code class="language-erlang">%% 我们启动三个进程
4&gt; normal:start(3). 
true

%% 然后向第一个进程发送消息123：
5&gt; normal:test(123). 
Process 2 received 123 
Process 1 received 123 
Last process received 123 
123

%% 再向第一个进程发送消息stop：
6&gt; normal:test(stop). 
Process 2 received stop 
Process 1 received stop 
Last process now exiting 
stop

%% 这条消息顺着进程链传递下去，我们将看到它最终导致链中最后一个进程的终止。这会引发一个发送给倒数第二个进程的EXIT信号，致其异常终止，接着又向第一个进程发送EXIT信号，于是注册进程start也异常终止。
%% 若这时再向注册进程start发送一条新消息，将由于目标进程不存在而失败：

7&gt; normal:test(456). 
!!! Error in process &lt;0.42.1&gt; in function !!! normal:test(456) !!! reason badarg **exited: badarg**

</code></pre>
<p>运行时失败</p>
<p>如前所述，catch作用域以外的运行时失败将导致进程的异常终止。进程终止时，将向与其链接的所有进程发送EXIT信号。这些信号包括一个指明失败原因的原子式。常见的失败原因如下：</p>
<ul>
<li>badmatch
匹配失败。例如，尝试匹配1 = 3的进程将终止并向链接进程发送EXIT信号{'EXIT', From, badmatch}。</li>
<li>badarg
BIF调用参数错误。例如，执行atom_to_list(123)将导致调用进程终止，并向链接进程发送EXIT信号{'EXIT', From, badarg}。因为123不是原子式。</li>
<li>case_clause
缺少匹配的case语句分支。例如，若进程执行：
M = 3, case M of 1 -&gt; yes; 2 -&gt; no end.
则进程将终止，并向所有链接进程发送EXIT信号{'EXIT', From, case_clause}。</li>
<li>if_clause
缺少匹配的if语句分支。例如，若进程执行：
M = 3, if M == 1 -&gt; yes; M == 2 -&gt; no end.
则进程将终止，并向所有链接进程发送EXIT信号{'EXIT', From, if_clause}。</li>
<li>function_clause
缺少能够匹配函数调用参数列表的函数首部。例如，对如下的foo/1定义调用foo(3)：
foo(1) -&gt; yes; foo(2) -&gt; no.
则调用进程终止，并向所有链接进程发送EXIT信号{'EXIT', From, function_clause}。</li>
<li>undef
尝试执行未定义函数的进程将终止并向所有链接进程发送{'EXIT', From, undef}（参见第??节）。</li>
<li>badarith
执行非法算术表达式（如，1 + foo）将导致进程终止，并向所有链接进程发送{'EXIT', Pid, badarith}。</li>
<li>timeout_value
receive表达式中出现非法超时值；如超时值既不是整数也不是原子式infinity。</li>
<li>nocatch
执行了throw语句却没有对应的catch。</li>
</ul>
<p>自定义默认的信号接收动作</p>
<p>BIF process_flag/2可用于自定义进程接收到EXIT信号时所采取的默认行为。如下所述，执行process_flag(trap_exit,true)将改变默认行为，而process_flag(trap_exit,false)重新恢复默认行为。</p>
<p>如前所述，EXIT信号的格式如下：</p>
<p>{'EXIT', Exiting_Process_Id, Reason}</p>
<p>调用了process_flag(trap_exit,true)的进程接收到其他进程发送的EXIT信号后不再会自动终止。所有EXIT信号，包括Reason为原子式normal的信号，都将被转换为消息，进程可以以接收其他消息同样的方式来接收这些消息。程序7.3说明了进程如何互相链接以及执行了process_flag(trap_exit,true)的进程如何接收EXIT信号。</p>
<p>erlang源代码 link_demo.erl</p>
<pre><code class="language-erlang">-module(link_demo).
-export([start/0, demo/0, demonstrate_normal/0, demonstrate_exit/1, demonstrate_error/0, demonstrate_message/1]).
start() -&gt; register(demo, spawn(link_demo, demo, [])).
demo() -&gt; process_flag(trap_exit, true),demo1().
demo1() -&gt; 
        receive 
                {'EXIT', From, normal} -&gt; io:format( &quot;Demo process received normal exit from ~w~n&quot;, [From]), demo1(); 
                {'EXIT', From, Reason} -&gt; io:format( &quot;Demo process received exit signal ~w from ~w~n&quot;, [Reason, From]), demo1(); 
                finished_demo -&gt; io:format(&quot;Demo finished ~n&quot;, []); 
                Other -&gt; io:format(&quot;Demo process message ~w~n&quot;, [Other]), demo1() 
        end.
demonstrate_normal() -&gt; link(whereis(demo)).
demonstrate_exit(What) -&gt; link(whereis(demo)), exit(What). 
demonstrate_message(What) -&gt; demo ! What. 
demonstrate_error() -&gt; link(whereis(demo)), 1 = 2.
</code></pre>
<p>编译并启动erl虚拟机</p>
<pre><code class="language-bash">erlc link_demo.erl
ls 
link_demo.erl
link_demo.beam

# 启动erl虚拟机，并加载t2.beam编译后文件
erl -pa .
</code></pre>
<p>执行erl代码</p>
<pre><code class="language-erlang">%% link_demo:start()以函数demo/0启动一个进程并用名字demo进行注册。demo/0关闭EXIT信号的默认处理机制并调用demo1/0等待新消息的到来。
8&gt; link_demo:start(). 
true

%% 我们来考察一次正常退出过程：
9&gt; link_demo:demonstrate_normal(). 
true
Demo process received normal exit from &lt;0.13.1&gt;

%% 执行demonstrate_normal/0的进程（在这个例子中该进程由Erlang shell创建）寻找注册进程demo的进程标识并与之建立链接。函数demostrate_normal/0没有别的子句，它的执行进程无事可做因而正常终止，从而引发信号：{'EXIT', Process_Id, normal}
%% 该信号被发送到注册进程demo。注册进程demo正在等待EXIT信号，因此它将之转换为一条消息，该消息在函数demo1/0内被接收，并输出文本：Demo process received normal exit from &lt;0.13.1&gt;
%% 接着demo1/0继续递归调用自身。
%% 正常退出信号

%% 下面再来考察一次异常退出过程：
10&gt; link_demo:demonstrate_exit(hello). 
Demo process received exit signal hello from &lt;0.14.1&gt; **exited: hello**
%% 和demonstrate_normal/0相同，demonstrate_exit/1创建一个到注册进程demo的链接。该例中，demonstrate_exit/1通过exit(hello)调用BIF exit/1。这导致demostrate_exit/1的执行进程异常终止，并将信号：{'EXIT', Process_Id, hello}
%% 发送给注册进程demo。注册进程demo将该信号转换为消息，并在函数demo1/0内被接收，从而输出文本：Demo process received exit signal hello from &lt;0.14.1&gt;
%% 接着demo1/0继续递归调用自身。

%% 执行exit(hello)
%%下一个案例中我们将看到link_demo:demonstrate_normal()和link_demo:demonstrate_exit(normal)是等同的：
11&gt; link_demo:demonstrate_exit(normal). 
Demo process received normal exit from &lt;0.13.1&gt; **exited: normal**

%% 执行exit(normal)
%% 下一个案例将展示出现运行时错误时，会发生什么事：
12&gt; link_demo:demonstrate_error(). 
!!! Error in process &lt;0.17.1&gt; in function !!! link_demo:demonstrate_error() !!! reason badmatch **exited: badmatch** Demo process received exit signal badmatch from &lt;0.17.1&gt;
%% 向前面一样，link_demo:demonstrate_error/0创建一个到注册进程demo的链接。link_demo:demonstrate_error/0错误的试图匹配1 = 2。 该错误导致link_demo:demonstrate_error/0的执行进程异常终止，并发送信号{'EXIT', Process_Id, badmatch}至注册进程demo。

%% 匹配错误导致的进程失败

%% 下一个案例中我们简单地向正在等待消息的注册进程demo发送消息hello：
13&gt; link_demo:demonstrate_message(hello).
Demo process message hello hello
%% 没有链接被创建，也就没有EXIT信号被发送或被接收。
%% 通过以下调用来结束这个示例：
14&gt; link_demo:demonstrate_message(finished_demo).
Demo finished finished_demo
</code></pre>
<p>未定义函数和未注册名称</p>
<p>最后一类错误关注的是当进程试图执行一个未定义的函数或者给一个未注册的名称发送消息时会发生什么。</p>
<p>调用未定义函数</p>
<p>如果进程尝试调用Mod:Func(Arg0,...,ArgN)，而该函数未被定义，则该调用被转换为：error_handler:undefined_function(Mod, Func, [Arg0,...,ArgN])</p>
<p>假设模块error_handler已经被加载（标准发行版中预定义了error_handler模块）。</p>
<p>erlang源代码 error_handler.erl</p>
<pre><code class="language-erlang">-module(error_handler). 
-export([undefined_function/3]). 
undefined_function(Module, Func, Args) -&gt; 
        case code:is_loaded(Module) of 
                {file,File} -&gt; 
                        % the module is loaded but not the function 
                        io:format(&quot;error undefined function:~w ~w ~w&quot;, [Module, Func, Args]), exit({undefined_function,{Module,Func,Args}}); 
                        false -&gt; 
                                case code:load_file(Module) of 
                                        {module, _} -&gt; apply(Module, Func, Args); 
                                        {error,_} -&gt; io:format(&quot;error undefined module:~w&quot;, [Module]), exit({undefined_module, Module}) 
                                end 
        end.
</code></pre>
<p>编译并启动erl虚拟机</p>
<pre><code class="language-bash">erlc error_handler.erl
ls 
error_handler.erl
error_handler.beam

# 启动erl虚拟机，并加载t2.beam编译后文件
erl -pa .
</code></pre>
<p>如果模块Mod已经被加载，那么将导致一个运行时错误。如果模块尚未加载，那么首先尝试加载该模块，若加载成功，再尝试执行先前调用的函数。</p>
<p>模块code了解哪些模块已被加载，同时也负责代码加载。</p>
<p>自动加载</p>
<p>编译过的函数无需再显式地编译或“加载”相关模块即可直接用于后续的会话。模块中的导出函数被第一次调用时，该模块将（通过上述的机制）被自动加载。</p>
<p>要实现自动加载，必须满足两个条件：首先，包含Erlang模块的源码文件必须与模块同名（扩展名必须为.erl）；其次，系统使用的默认搜索路径必须能定位到该未知模块。</p>
<p>向未注册名称发送消息</p>
<p>尝试向一个不存在的注册进程发送消息时会触发error_handler:unregistered_name(Name,Pid,Message)调用。其中Name是不存在的注册进程的名称，Pid是发送消息的进程标识，Message是发送给注册进程的消息。</p>
<p>自定义缺省行为</p>
<p>执行BIF process_flag(error_handler, MyMod)可以用模块MyMod替换默认的error_handler。这使得用户得以定义他们（私有）的错误处理器，用以处理针对未定义函数的调用以及以为注册进程名称为目标的消息发送。该功能仅对执行调用的进程自身有效。定义非标准的错误处理器时必须注意：如果你在替换标准错误处理器时犯了什么错误，系统可能会失控！</p>
<p>也可以通过加载一个新版本的error_handler模块来更改默认行为。这么做会影响到所有的进程（定义了私有错误处理器的进程出外），因此非常危险。</p>
<p>Catch和退出信号捕获</p>
<p>在catch作用域内求值和捕获进程退出信号是两种完全不同的错误处理机制。退出信号的捕获影响的是一个进程从其他进程处收到EXIT信号时的动作。catch只影响当前进程中由catch保护的表达式的求值。</p>
<p>erlang源文件 tt.erl</p>
<pre><code class="language-erlang">%%执行程序的tt:test()会创建一个进程，这个进程匹配N（它的值是1）和2。这会失败的，引发信号{'EXIT',Pid,badmatch}被发送到执行tt:test()并且正在等待一个信号的进程。如果这个进程没有正在捕获exits，它也会非正常终止。
-module(tt). 
-export([test/0, p/1]). 
test() -&gt; spawn_link(tt, p,[1]), receive X -&gt; X end. 
p(N) -&gt; N = 2.
</code></pre>
<p>编译并启动erl虚拟机</p>
<pre><code class="language-bash">erlc tt.erl
ls 
tt.erl
tt.beam

# 启动erl虚拟机，并加载t2.beam编译后文件
erl -pa .
</code></pre>
<p>执行erl代码</p>
<pre><code class="language-erlang">&gt;1 tt:test().

%% 调用tt:test()将创建一个以2对N（值为1）作匹配的链接进程。这会失败，并导致信号{'EXIT',Pid,badmatch}被发送至调用tt:test()的进程，该进程正在等待消息。要是这个进程不捕获退出信号，它就会异常退出。


%%如果我们执行的不是tt:test()而是catch tt:test()，结果一样：catch作用域外的另一个进程会发生匹配失败。在spawn_link(tt,p,[1])之前加上process_flag(trap_exit, true)，tt:test()就会将收到的{'EXIT',Pid,badmatch}信号转换为一条消息。

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="1-变量"><a class="header" href="#1-变量">1. 变量</a></h2>
<h3 id="1变量不变"><a class="header" href="#1变量不变">1.变量不变</a></h3>
<p>在erlang中的变量只能被赋值一次，变量第一个字母要是大写的。
在erlang中变量是不可变的，也没有共享内存的概念，也没有锁。</p>
<h3 id="2模式匹配"><a class="header" href="#2模式匹配">2.模式匹配</a></h3>
<p>符号”=”是值类型匹配操作(带有赋值的意思)。（pattern matching）</p>
<hr />
<h2 id="2整数"><a class="header" href="#2整数">2.整数</a></h2>
<p>一个整数</p>
<pre><code class="language-erlang">-234 0 10 10000000
2#1010
-16#EA
$a $A $\n

1&gt; Color = 16#F09A29. 
15768105
2&gt; Pixel = &lt;&lt;Color:24&gt;&gt;.
&lt;&lt;240,154,41&gt;&gt;
</code></pre>
<p>Erlang中整型数据的计算是精确的，整型变量可代表的数据长度仅受限于可用的内存。
Erlang中可表达和使用任意大的整数。当一个整数大到一个word不能容纳的时候，Erlang内部会自动把它转换成用多个word表示的bignums类型。
可以用下面3种不同的语法来表达一个整型数值。</p>
<ol>
<li>传统语法:这种写法是我们最为熟悉的，比如1112. 12375、-23427都是整数。</li>
<li>K进制整数:不以10为进制的整数可以用语法K#Digits来表示。因此我们可以写一个二
进制数2#00101010或者一个16进制数16#af6bfa23。对于大于10进制的整数，用字符abc...(或
ABC二。)来表示数值10. 11, 12等。这种语法所能表示的最高进制为36进制。</li>
<li>$语法:语法$C表示ASCII字符C的整数值，因此$a是97的简写，$1是49的简写，等等。紧随$之后，我们还可以使用表5-1中描述的任何转义符。因此$\n就是10, $^c是3，等等。</li>
</ol>
<p>下面是一些整数的例子:
0 -65 2#010001110 ~8#377 16#fe34 16#FE34 36#wow
(它们的值分别是0 -65 142 -255 65076 65076和423680)</p>
<p>Base#Value符号表示基数不是10的整数 Base是一个介于2～16的整数</p>
<hr />
<h2 id="3-浮点数"><a class="header" href="#3-浮点数">3. 浮点数  </a></h2>
<ol>
<li>整数除法示例: 4 div 2。</li>
<li>求余示例:     5 rem 2。</li>
<li>&quot;/&quot;永远返回浮点数。</li>
<li>368 -56. 654 1.234E-10.</li>
</ol>
<p>E-10是一种常规的浮点表示符号，用来表示十进制小数点必须向左移动10个位置。1. 234E-10和1.234×10~10是一样的，即0.00000001234。</p>
<p>Erlang中的浮点数的精确度是由IEEE 754-1985标准中的64位表示法来保证的。</p>
<p>一个浮点数有5个部分:一个可选符号位、一个数值部分、一个小数点、一个小数部分以及一个可选的指数部分。</p>
<p>下面就是一些浮点数的例子:</p>
<p>1.0 3.14159 -2.3e+6 23.56E-27</p>
<p>经过解析，浮点数在内部会以IEEE 754的64 bit格式表示。Erlang可表示的浮点数的范围是</p>
<p>-10 323 -10 308</p>
<hr />
<ul>
<li>二进制串/位串</li>
<li>唯一标识符（pid、端口、引用）</li>
<li>Fun函数</li>
<li>=模式匹配</li>
</ul>
<h2 id="atoms原子"><a class="header" href="#atoms原子">Atoms(原子)</a></h2>
<ul>
<li>Atoms表示不同的非数字常量值。</li>
<li>示例: Xss = 'Asss'。  </li>
<li>atom是否已经注册的:registered() unregister(Pid) whereis(Atom) regs().</li>
<li>atom能够进行的唯一运算就是比较</li>
<li>atom是可以使用.和@的,但是别给自己添乱</li>
<li>atom会被记录在ERT系统表中,只需要几个字节,atom之间比较起来也很快</li>
<li>atom不参与Erlang GC,所以atom不能无节制的创建,list_to_existing_atom可以一定程度上缓解创建重复atom的内存消耗</li>
</ul>
<h2 id="元组"><a class="header" href="#元组">元组</a></h2>
<ul>
<li>将若干个以逗号分隔的值用一对大括号括起来就形成了一个元组。</li>
<li>元组示例: Person = {person, {name, joe}, {height, 1.83}, {footsize, 42}}.</li>
<li>从元组中提取数据：</li>
</ul>
<pre><code class="language-erlang">Point = {point, 10, 45}.
{point, X, Y} = Point.( pattern match)
此后X=10, Y=45.

 %%1. record类型作为参数的小技巧
 
-record(x,{name,zz}).
-record(y,{yy,name}).
-export([test1/0,test2/0]).
-define(create(Type,Name),#Type{name = Name}).
test1() -&gt; ?create(x,&quot;Noel&quot;). % -&gt; {x,&quot;Noel&quot;,undefined}
test2() -&gt; ?create(y,&quot;Noel&quot;). % -&gt; {y,undefined,&quot;Noel&quot;}
</code></pre>
<ul>
<li>Tuple是Erlang表达复杂数据结构的手段,第一个元素经常被称作Tag,Tag Massage是Erlang编程的最佳实践</li>
<li>Tuple索引是从1开始的,执行一下 element(1,{a,b,c}).看看 再试一下element(0,{a,b,c})看看报什么错</li>
<li>Tuple大小使用tuple_size({1,2,3,4,5}).</li>
</ul>
<h2 id="列表"><a class="header" href="#列表">列表</a></h2>
<ul>
<li>将若干个以逗号分隔的值用一对方括号括起来，就形成了一个列表。</li>
<li>示例: ThingsToBuy = [{apple, 10}, {pear, 6}, {milk, 3}].</li>
<li>列表中的第一个元素叫做列表头，剩下的部分叫做列表尾。一般来说列表头可以是任何东西，列表尾经常是一个列表。</li>
<li>访问列表头元素是一个非常高效的操作。</li>
<li>从列表中解析元素:</li>
</ul>
<pre><code class="language-erlang">ThingsToBuy1 = [{oranges, 4}, {newspaper, 1}|ThingsToBuy].
[Buy1|ThingsToBuy2] = ThingsToBuy1.
%% 此后:ThingsToBuy1 = [{oranges,4},{newspaper,1},{apple,10},{pear,6},{milk,3}].
Buy1 = {oranges,4}.
ThingsToBuy2 = [{newspaper,1},{apple,10},{pear,6},{milk,3}].
</code></pre>
<ul>
<li>M++N会遍历列表M所以如果必须要使用++也要让数据量小的List在前面</li>
<li>proplist对于处理key_value的list真的是非常方面</li>
<li>List=[Element|List]所以你可以在shell中可以输入[1,2|3],尝试匹配一下它 [A,B,C]=[1,2|3]再试一下[P,Q]=[1,2,3]</li>
<li>List最后一个元素是空列表[],被称作well-formed list正则列表,[1,2|3]这种结构要避免</li>
<li>--操作符是针对元素进行的 [1,2]--[3]结果是[1,2] [2,2]--[2]结果是[2],运算顺序是从右到左, [1,2,3]--[1,2]--[1].结果是[1,3]</li>
<li>在Server中，总是尽力书写尾递归(tail-recursive)的函数</li>
<li>使用'++'时，left list会被拷贝，然后添加到right list的头部，因此最好把length较短的list放在左侧</li>
</ul>
<h2 id="字符串"><a class="header" href="#字符串">字符串</a></h2>
<p>在erlang中没有字符串，字符串仅仅是整数列表。用双引号将一串字符括起来就是一个字符串。</p>
<pre><code class="language-erlang">Name = &quot;Hello&quot;.
5&gt;I = $s.
115
8&gt; [I-32, $u, $r, $p, $r, $i, $s, $e].
&quot;Surprise&quot;
</code></pre>
<ul>
<li>Erlang中String采用list实现，32位系统中，其1个字符用8个字节的空间（4个保存value, 4个保存指针)。因此string速度较慢，空间占用较大</li>
</ul>
<h2 id="map"><a class="header" href="#map">map</a></h2>
<pre><code class="language-erlang">#{a =&gt; 1}.
#{a := A} = #{a =&gt; 1}. 
 
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="转义符"><a class="header" href="#转义符">转义符</a></h2>
<pre><code class="language-bash">\b 退格
\d 删除
\e 转义
\f 换页
\n 新行
\r 换行
\s 空格
\t 制表符
\v 纵向制表符
\' 单引号
\&quot; 双引号
\\ 反斜杠
\C C的ASCII码（C是一个字符）
</code></pre>
<h2 id="操作符"><a class="header" href="#操作符">操作符</a></h2>
<pre><code class="language-bash">X&gt;Y   X大于Y
X&lt;Y   X小于Y
X=&lt;Y  X小于等于Y
X&gt;=Y  X大于等于Y
X==Y  X等于Y
X/=Y  X不等于Y
X=:=Y X全等于Y 值和类型都必须相同 2 =:= 2.0 -&gt; false
X=/=Y X不全等于Y
number&lt;atom&lt;reference&lt;fun&lt;port&lt;pid&lt;tuple&lt;list&lt;binary
</code></pre>
<h2 id="布尔表达式"><a class="header" href="#布尔表达式">布尔表达式</a></h2>
<pre><code class="language-bash">and      两个参数都是真，返回真
andalso  如果第一个参数是假，返回假
or
orelse   如果第一个参数是真，返回真。
xor      “异或”：如果两个参数的任何一个参数是真，并且另一个是假，那么返回真
not      一元否定运算符：如果参数是假，那么就返回真
</code></pre>
<h2 id="算术表达式"><a class="header" href="#算术表达式">算术表达式</a></h2>
<div class="table-wrapper"><table><thead><tr><th>操作</th><th>描述</th><th>优先级</th></tr></thead><tbody>
<tr><td>+X</td><td>一元操作符 +</td><td>1</td></tr>
<tr><td>-X</td><td>一元操作符 1</td><td>2</td></tr>
<tr><td>X*Y</td><td>X*Y</td><td>2</td></tr>
<tr><td>X/Y</td><td>X/Y(浮点数相除)</td><td>2</td></tr>
<tr><td>X div Y</td><td>X整除Y</td><td>2</td></tr>
<tr><td>X rem Y</td><td>X除Y取余数</td><td>2</td></tr>
<tr><td>bnot X</td><td>对X按位取反</td><td>2</td></tr>
<tr><td>X band Y</td><td>对X和Y安位取与</td><td>2</td></tr>
<tr><td>X+Y</td><td></td><td>3</td></tr>
<tr><td>X-Y</td><td></td><td>3</td></tr>
<tr><td>X bor Y</td><td>对X和Y按位取或</td><td>3</td></tr>
<tr><td>X bxor Y</td><td>对X和Y按位进行异或</td><td>3</td></tr>
<tr><td>X bsl N</td><td>对X按位左移N位</td><td>3</td></tr>
<tr><td>XbsrN</td><td>对X按位右移N位</td><td>3</td></tr>
</tbody></table>
</div>
<p>2 bsl 5 将整数2左移5位。2转化为二进制10向左移5位变为1000000 转化为10进制64</p>
<p>2 bsr 5 将整数2右移5位。原理相同</p>
<p>band,bor,bxor,bnot 位逻辑运算符。 X band (bnot Y)会在X中将Y所占用的位清零</p>
<p>一元操作符＋和-拥有最高的优先级:其次是乘、除和取余数操作，而加法和减法的优先级别最低。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="模块属性"><a class="header" href="#模块属性">模块属性</a></h2>
<p>vim modname.erl</p>
<pre><code class="language-erlang">-module(modname).
-import(...).
-export(...).
-compile(Options).
-compile(export_all)%属性经常被使用在调试程序中。
-compile( {parse_transform, Module} ).
-vsn(Version).
    %最后一个选项为增加编译选项，Options可以是单个选项或者选项列表。
-vsn(Version).%中的Version可以是任意字符条目。
</code></pre>
<p>vim attrs.erl</p>
<pre><code class="language-erlang">-module(attrs).
-vsn(1234).
-author({joe，armstrong}).
-purpose(&quot;example of attributes&quot;).

-export( [fac/1]).

-type player_id() :: neg_integer().
-callback fun( PlayerId::player_id() ) -&gt; boolean().

fac(1) -&gt; 1;
fac(N) -&gt; N*fac(N一1).
</code></pre>
<pre><code class="language-erlang">$ erlc attrs.erl
$ erl -pa ./
1&gt; attrs:module_info().
[{exports，[{fac，1}，{rnodul a_ info，0}，{rnodul e_i nfo，1}]}，
{imports，[]}，
{attributes，[{vsn，[1234]}，
                {author，[{joe，armstrong}]}，
                {purpose，&quot;example of attributes&quot;}]}，
{compile，[{options，[{cwd，&quot;/home/joe/2006/book/JAERLANG/Book/code&quot;}，
                        {outdir，&quot;/home/joe/2006/book/JAERLANG/Book/code&quot;}]}，
          {version，&quot;4.4.3&quot;}，
          {time，{2007，2，21，19，23，48}}，
          {source，&quot;/home/joe/2006/book/JAERLANG/Book/code/attrs.erl&quot;}]}]
2&gt; attrs:module_info(attributes).
[{vsn，[1234]}，{author，[{joe，armstrong}]}，{purpose，&quot;example of attributes&quot;}]
3&gt; beam_ lib:chunks(&quot;attrs.beam&quot;，[attributes])，
{ok，{attrs，[{attributes，[{author，[{joe，armstrong}]}，
                              {purpose，&quot;example of attributes&quot;}，
                          {vsn，[1234]}]}]}}
</code></pre>
<hr />
<h2 id="类型标注"><a class="header" href="#类型标注">类型标注</a></h2>
<pre><code class="language-erlang">-type tuplelist() -&gt; [tuple()].
-spec fun( integer() ) -&gt; [] | {integer(), TupleList} when TupleList :: [Tuple], Tuple::term().
</code></pre>
<p>类型标注后可以只用工具<a href="http://www.erlang.org/doc/reference_manual/typespec.html">dialyzer</a>来进行分析</p>
<hr />
<h2 id="行为回调函数"><a class="header" href="#行为回调函数">行为回调函数</a></h2>
<p>例如：
a.erl</p>
<pre><code class="language-erlang">-type player_id() :: neg_integer().
-callback fun( PlayerId::player_id() ) -&gt; boolean().%必须要在具体函数上面
</code></pre>
<p>b.erl</p>
<pre><code class="language-erlang">-behaviour(a).
-export( fun/1 ).
fun(PlayerId) -&gt;
   io:format( &quot;PlayerId:~p~n&quot;, [ PlayerId ] ).
</code></pre>
<hr />
<h2 id="erlang继承"><a class="header" href="#erlang继承">Erlang继承</a></h2>
<pre><code class="language-erlang">-extends(alpha). 

alpha.erl
-module(alpha).
-export([c/2, b/1, a/0]).
a() -&gt;{this_is_module,?MODULE}.
b(S) -&gt;{this_is_module,?MODULE,S}.
c(S,T)-&gt;{this_is_module,?MODULE,S,T}.

beta.erl
-module(beta).
-compile(export_all).
-extends(alpha).
show() -&gt; {hello_world,?MODULE,?BASE_MODULE}.
a() -&gt;{hello,?MODULE}.
</code></pre>
<hr />
<p><img src="2.%E5%9F%BA%E7%A1%80//images/screenshot_1534329746629.png" alt="图片" /></p>
<div style="break-before: page; page-break-before: always;"></div><p>进入已经启动的节点方法:</p>
<h2 id="作业jcl-模式"><a class="header" href="#作业jcl-模式">作业（JCL ）模式</a></h2>
<p>使用该功能需要保证cookie一致,并且node的名字的IP保持一致</p>
<pre><code class="language-erlang">$ erl -setcookie abc -name node_1@192.168.1.110
Eshell V5.9 (abort with ^G) 


$ erl -setcookie abc -name node_2@192.168.1.110
Eshell V5.9 (abort with ^G) 
(node_2@192.168.1.110)1&gt; node(). %当前这是在node_2 
'node_2@192.168.1.110' 
(node_2@192.168.1.110)2&gt; %Ctrl + G 进入JCL模式 
 User switch command 
--&gt; h 
  c [nn] - connect to job 
  i [nn] - interrupt job 
  k [nn] - kill job 
  j - list all jobs 
  s [shell] - start local shell 
  r [node [shell]] - start remote shell 
  q - quit erlang 
  ? | h - this message 
--&gt; r'node_1@192.168.1.110' %尝试连接到node_1@192.168.1.110 
--&gt; j 
   1 {shell,start,[init]} %列出所有的Job 
   2* {'node_1@192.168.1.110',shell,start,[]} 
--&gt; c 2 %这里2是job的编号,切换到job 2 
</code></pre>
<h2 id="erl启动参数remsh"><a class="header" href="#erl启动参数remsh">erl启动参数remsh</a></h2>
<pre><code class="language-erlang">erl -setcookie abc -name node_3@192.168.1.110 -remsh node_1@192.168.1.110 %%这样就直接进入了node_1节点
</code></pre>
<h2 id="erl内置ssh-模式"><a class="header" href="#erl内置ssh-模式">erl内置SSH 模式</a></h2>
<pre><code class="language-erlang">Eshell V5.10.3  (abort with ^G)
(1@127.0.0.1)1&gt; ssh:start().
ok
(1@127.0.0.1)2&gt; ssh:daemon(8888, [{password, &quot;12345&quot;}]).
{ok,&lt;0.57.0&gt;}

%%本地不需要启动erlang节点，直接使用ssh连接即可，输入以上设置的密码，就可以接入节点1的shell控制台。
$ ssh -p 8888 1@127.0.0.1
1@127.0.0.1's password:
Eshell V5.10.3  (abort with ^G)
(1@127.0.0.1)1&gt; 

%%这种方式，erlang shell所有操作都是在远程节点完成的。 
</code></pre>
<h2 id="管道pipe模式"><a class="header" href="#管道pipe模式">管道（pipe）模式</a></h2>
<p>在使用管道（pipe）连接到一个Erlang节点时，和SSH一样不需要启动本地erlang节点。这种方法很少用，每次输出时都调用fsync，如果输出过多时，会有很大的性能损失。</p>
<p><img src="2.%E5%9F%BA%E7%A1%80//images/screenshot_1534328344298.png" alt="图片" /></p>
<p>具体做法为：用 run_erl 启动 erlang，相当于把 erlang 进程包在一个管道中：</p>
<pre><code class="language-bash">$ mkdir /tmp/erl_log
$ cd /home/erl/bin
$ ./run_erl -daemon /tmp/erl_pipe /tmp/erl_log &quot;erl -name 1@127.0.0.1 -setcookie abc&quot;

#其中，daemon 表示以后台进程运行，/tmp/erl_pipe是管道文件的名称，/tmp/erl_log指定了日志保存文件夹

然后使用 to_erl 程序来连接节点： 
$ ./to_erl /tmp/erl_pipe
Attaching to /tmp/erl_pipe (^D to exit) 
(1@127.0.0.1)1&gt; node(). 
'1@127.0.0.1'
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>ctrl+G 按c</p>
<p>Erlang shell没有反应，可能是正在输入一个字符串&quot;aabbcc......
解决cmd卡死的问题。（win下面ctrl+G 回车）</p>
<pre><code class="language-erlang">&lt;&lt;A:32,B:32,C:32&gt;&gt; = crypto:strong_rand_bytes(12) .  
&lt;&lt;42,136,117,238,28,89,154,241,88,189,70,139&gt;&gt;  

%找出消耗内存最多的进程
lists:reverse(lists:keysort(2,[{P, erlang:process_info(P, heap_size)} || P &lt;- erlang:processes()])).

%%找到最消耗内存的ETS表
lists:reverse(lists:keysort(2,[{T, ets:info(T, memory)} || T &lt;- ets:all()])).

</code></pre>
<p>Basic</p>
<ul>
<li>compiler 8.1.1 A byte code compiler for Erlang which produces highly compact code</li>
<li>erts 12.3.2 Functionality necessary to run the Erlang System itself</li>
<li>kernel 8.3.2 Functionality necessary to run the Erlang System itself</li>
<li>sasl 4.1.2 The System Architecture Support Libraries is a set of tools for release upgrades and alarm handling etc.</li>
<li>stdlib 3.17.2 The Erlang standard libraries</li>
</ul>
<p>Database</p>
<ul>
<li>mnesia 4.20.4 A heavy-duty real-time distributed database</li>
<li>odbc 2.13.5 An interface to relational SQL-databases built on ODBC (Open Database Connectivity).</li>
</ul>
<p>Operation &amp; Maintenance</p>
<ul>
<li>os_mon 2.7.1 A monitor which allows inspection of the underlying operating system</li>
<li>snmp 5.12 Simple Network Management Protocol (SNMP) support including a MIB compiler and tools for creating SNMP agents</li>
</ul>
<p>Interface and Communication</p>
<ul>
<li>asn1 5.0.18 Provides support for Abstract Syntax Notation One</li>
<li>crypto 5.0.6 Cryptographical support</li>
<li>diameter 2.2.5 Diameter</li>
<li>eldap 1.2.10 eldap - Erlang LDAP library</li>
<li>erl_interface 5.2.2 Low level interface to C</li>
<li>ftp 1.1.1 FTP client</li>
<li>inets 7.5.3 A set of services such as a Web server etc.</li>
<li>jinterface 1.12.2 Low level interface to Java</li>
<li>megaco 4.3 Megaco/H.248 is a protocol for control of elements in a physically decomposed multimedia gateway, enabling separation of call control from media conversion.</li>
<li>public_key 1.12 API to public key infrastructure.</li>
<li>ssh 4.13.2 Secure Shell application with sftp and ssh support</li>
<li>ssl 10.7.3 ssl- Secure Socket Layer.</li>
<li>tftp 1.0.3 TFTP application</li>
<li>wx 2.1.4 A Graphics System used to write platform independent user interfaces</li>
<li>xmerl 1.3.28 Provides support for XML 1.0</li>
</ul>
<p>Tools</p>
<ul>
<li>debugger 5.2.1 A debugger for debugging and testing of Erlang programs</li>
<li>dialyzer 4.4.4 The DIALYZER, a DIscrepancy AnaLYZer for ERlang programs.</li>
<li>et 1.6.5 Event Tracer (ET), uses the built-in trace mechanism in Erlang and provides tools for collection and graphical viewing of trace data.</li>
<li>observer 2.11.1 Observer, tools for tracing and investigation of distributed systems</li>
<li>parsetools 2.3.2 A set of parsing and lexical analysis tools</li>
<li>reltool 0.9 Reltool is a release management tool. It analyses a given Erlang/OTP installation and determines various dependencies between applications. The graphical frontend depicts the dependencies and enables interactive customization of a target system. The backend provides a batch interface for generation of customized target systems.</li>
<li>runtime_tools 1.18 Runtime tools, tools to include in a production system</li>
<li>syntax_tools 2.6 A utility used to handle abstract Erlang syntax trees, reading source files differently, pretty-printing syntax trees.</li>
<li>tools 3.5.2 A set of programming tools including a coverage analyzer etc</li>
</ul>
<p>Test</p>
<ul>
<li>common_test 1.22.1 A portable framework for automatic testing</li>
<li>eunit 2.7 Support for unit testing.</li>
</ul>
<p>Documentation</p>
<ul>
<li>edoc 1.1 A utility used to generate documentation out of tags in source files.</li>
<li>erl_docgen 1.2.1 A utility used to produce the OTP documentation.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><p>ASN.1（抽象语法标记：Abstract Syntax Notation One) 是一套标准，是描述数据的表示、编码、传输、解码的灵活的记法。它提供了一套正式、无歧义和精确的规则以描述独立于特定计算机硬件的对象结构。</p>
<p>asn1rt:info/1</p>
<p>返回模块的编译信息</p>
<p>asn1rt:load_driver/0</p>
<p>加载链接驱动</p>
<p>asn1rt:unload_driver/0</p>
<p>卸载链接驱动</p>
<p>asn1rt:utf8_binary_to_list/1</p>
<p>把一个 utf8 编码的二进制数据转为一个 unicode 列表</p>
<p>asn1rt:utf8_list_to_binary/1</p>
<p>把一个 unicode 列表转为一个 utf8 二进制数据</p>
<div style="break-before: page; page-break-before: always;"></div><p>写测试模块的时候不必频繁导出函数 –compile(export_all) 就可以导出所有函数</p>
<pre><code class="language-erlang">编译模块 

1.-compile( export_all ) 

   

2.-compile( {parse_transform,Module} ).  

  Module:parse_transform/2 

auses the parse transformation function Module:parse_transform/2 to be applied to the parsed code before the code is checked for errors. 

在编译器检查错误之前会把所有代码送入 Module:parse_transform/2，所以 Module:parse_transform/2的返回值需要是代码串 

例子： 

a.erl 

-compile( {parse_transform,b} ). 

b.erl 

-export( [parse_transform/2] ). 

parse_transform( Code, Option ) -&gt; Fun(), Code. 


file(File, Options) -&gt; CompRet 

{outdir,Dir} 

export_all 

{i,Dir} 

{d,Macro} 

{d,Macro,Value} 

from_core 

 
(t_lib, [to_core]).
c(t_lib, [from_core]).

 

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-erlang">crypto:hash(md5, Bin||Str).
  md5_to_str(Str) -&gt;
    &lt;&lt;Mac:128/integer&gt;&gt; = erlang:md5(Str),
    lists:flatten(io_lib:format(&quot;~32.16.0b&quot;, [Mac])).
  
  
  md5(S) -&gt;
    Md5_bin = erlang:md5(S),
    Md5_list = binary_to_list(Md5_bin),
    lists:flatten(list_to_hex(Md5_list)).
  list_to_hex(L) -&gt;
    lists:map(fun(X) -&gt; int_to_hex(X) end, L).
  int_to_hex(N) when N &lt; 256 -&gt;
    [hex(N div 16), hex(N rem 16)].
  hex(N) when N &lt; 10 -&gt;
    $0 + N;
  hex(N) when N &gt;= 10, N &lt; 16 -&gt;
    $a + (N - 10).
  
  
  
  md5_to_str(Str) -&gt;
    &lt;&lt;M:128/integer&gt;&gt; = erlang:md5(Str),
    Integer_to_hex( M, 32 ).
  
  integer_to_hex(I, Len) -&gt;
      Hex = string:to_lower(erlang:integer_to_list(I, 16)),
      LenDiff = Len - length(Hex),
      case LenDiff &gt; 0 of
          true  -&gt; string:chars($0, LenDiff) ++ Hex;
          false -&gt; Hex
      end.
  
  hex_to_integer(Hex) -&gt;
      lists:foldl (fun (E, Acc) -&gt; Acc * 16 + dehex (E) end, 0, Hex).
  
  
  %加密模块，常见的加密算法
  &lt;&lt;Mac:160/integer&gt;&gt; = crypto:sha(&quot;aabbcc&quot;).
  lists:flatten(io_lib:format(&quot;~40.16.0b&quot;, [Mac])).
  
  5&gt; &lt;&lt;Mac:160/integer&gt;&gt; = crypto:sha_mac(&quot;aabbcc&quot;, &quot;ddeeff&quot;).
  &lt;&lt;156,97,184,203,233,133,139,40,205,53,140,142,128,72,34,
    38,248,183,32,69&gt;&gt;
  6&gt; lists:flatten(io_lib:format(&quot;~40.16.0b&quot;, [Mac])).
  &quot;9c61b8cbe9858b28cd358c8e80482226f8b72045&quot;
  
  crypto:rand_uniform(A,B)
  
  1&gt; &lt;&lt;Mac:128/integer&gt;&gt; = erlang:md5( &quot;123456&quot; ).
     %md5加密返回128位的密文，使用变量Mac去匹配该128位的密文
  2&gt; lists:flatten(io_lib:format(&quot;~32.16.0b&quot;, [Mac])).
     %格式化&quot;~32.16.0b&quot;的含义,输出的用长度length为32，转化为16进制，转化时如果遇到空的位，使&quot;0&quot;填充，b输出的英文小写字母，B输出大写字母
     %完整的格式化&quot;~Length.P.PadC&quot;
         Length输出宽度
         P输出精度
         Pad填充字符
         C是控制字符
  &quot;e10adc3949ba59abbe56e057f20f883e&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p><img src="3.%E5%BA%93%E5%87%BD%E6%95%B0/erts//images/screenshot_1534592557765.png" alt="图片" /></p>
<pre><code class="language-erlang">库
作用
模块
erts
Erlang Run-Time System Application
erlang系统运行时启动的应用
函数
erlang内置函数（BIF）
init系统启动  reboot,restart,stop
zlib压缩与解压  zip,unzip,gzip,gunzip
erl_driver驱动
abs,
date,
time,
element,
exit,
float,
get,
halt,
hash,
is_*,
length,
link,
md5,
memory,
min,
now
put,
register,
round,
self,
size,
spawn,
spawn_link,
time,
trunc,
unlink,
unregister,
whereis...
stdlib
标准库
STDLIB,
array,
base64,
beam_lib,
c,
calendar,
dets,
dict,
digraph,
digraph_utils,
epp,
erl_eval,
erl_expand_records
erl_id_trans,
erl_internal,
erl_lint,
erl_parse,
erl_pp,
erl_scan,erl_tar,ets,file_sorter,filelib,filename
gb_sets,gb_trees,gen_event,gen_fsm,gen_server,io,io_lib,lib,lists,log_mf_h,math,ms_transform,orddict
ordsets,pg,pool,proc_lib,proplists,qlc,queue,random,re,regexp,sets,shell,shell_default,slave,sofs,string
supervisor,supervisor_bridge,sys,timer,unicode,win32reg,zip
kernel
核心库
kernel,application,auth,code,disk_log,erl_boot_server,erl_ddll,erl_prim_loader,erlang,
error_handler,error_logger,file,gen_tcp,gen_udp,gen_sctp,global,global_group,heart,inet,
init,net_adm,net_kernel,os,pg2,rpc,seq_trace,user,wrap_log_reader,zlib,app,config,packages
odbc


mnesia
数据库

snmp
SNMP

cos
CORBA

compile
Erlang Compiler

SASL
System Application Support Libraries (SASL)

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-erlang">
niftest.erl 

-module(niftest). 

-export([init/0, hello/0]). 

init() -&gt; 
      erlang:load_nif(&quot;./niftest&quot;, 0). 
 

hello() -&gt; %函数名称 
      &quot;NIF library not loaded&quot;. 

 

 

/* niftest.c */ 
#include &quot;erl_nif.h&quot; 

static ERL_NIF_TERM hello(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[]) 
{ 
    return enif_make_string(env, &quot;Hello world!&quot;, ERL_NIF_LATIN1); 
} 
 

//定义函数 

static ErlNifFunc nif_funcs[] = 
{ 
    {&quot;hello&quot;, 0, hello} 
}; 
 

ERL_NIF_INIT(niftest,nif_funcs,NULL,NULL,NULL,NULL) 

 

%编译成公共库，需要使用到erl_nif.h 

 gcc -fPIC -shared -o niftest.so niftest.c -I $ERL_ROOT/usr/include/ 

%测试 

$&gt; erl 
 

1&gt; c(niftest). 
{ok,niftest} 
2&gt; niftest:hello(). 
&quot;NIF library not loaded&quot; 
3&gt; niftest:init(). 
ok 
4&gt; niftest:hello(). 
&quot;Hello world!&quot;  
</code></pre>
<p><img src="3.%E5%BA%93%E5%87%BD%E6%95%B0/erts//images/screenshot_1534592602444.png" alt="图片" /></p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>apply(M,F,A)要比直接调用调用对应的方法M:F(A1,A2...)要慢6~10倍，尽量避免使用</li>
<li>BIFs是built-in functions的缩写代表这些方法是Erlang运行时系统的一部分</li>
</ul>
<pre><code class="language-erlang">%% binary_to_list VS bitstring_to_list
1&gt; A = &lt;&lt;1:2, 23:6&gt;&gt;.
&lt;&lt;&quot;W&quot;&gt;&gt;
2&gt; B = &lt;&lt;1:2, 23:5&gt;&gt;.
&lt;&lt;55:7&gt;&gt;
3&gt; binary_to_list(A).
&quot;W&quot;
4&gt; binary_to_list(B).
** exception error: bad argument
in function binary_to_list/1
called as binary_to_list(&lt;&lt;55:7&gt;&gt;)
5&gt; bitstring_to_list(A).
&quot;W&quot;
6&gt; bitstring_to_list(B).
[&lt;&lt;55:7&gt;&gt;]
</code></pre>
<p><img src="3.%E5%BA%93%E5%87%BD%E6%95%B0/erts//images/screenshot_1534592495217.png" alt="图片" /></p>
<pre><code class="language-erlang">statistics(wall_clock).  
{11405766,266}
返回指定类型的系统参数，当Type为wall_clock时，返回Erlang虚拟机运行至今所度过的时间和上次执行statistics(wall_clock)到这次执行之间的时间(精确到毫秒级)。
performs CPU time measurements 

context_switches||exact_reductions||garbage_collection||io||reductions||run_queue||runtime||scheduler_wall_time||wall_clock
make_tuple( 2,“1” )
{“1”, “1”}
localtime().
now().
localtime_to_universaltime({{1996,11,6},{14,45,17}}).
{{年月日}，{时分秒}}

获取8小时时差的时间
list_to_existing_atom()

tuple_size/1
byte_size/1
bit_size/1

round(10.5) -&gt; 11, 
trunc( 10.5 ) -&gt; 10
abs( -10 ) -&gt; 10 
12.8 rem 3 = 2. 
8 div 3 = 2.

get_stacktrace().
查看最近的栈跟踪信息，栈跟踪信息包含当前调用函数的返回信息
system_info( process_limit ).
系统允许创建的进程上限
scheduler_id -&gt; cpu 核心
schedulers
process_count
process_limit
processes_used
info 

memory(processes||total)

node().
nodes().
nodes(hide).

apply(Module, Fun, Arg).

user_default.erl
user_default.erl
hello() -&gt; &quot;hello word!&quot;. 
放入加载路径后，user_default模块中的任何函数可以直接调用而不需要给出模块名
put( key, value ) -&gt; value||undefined   
get( key ) -&gt; value||undefined

float_to_list(7.12, [{decimals, 4}]). 
binary_to_integer(&lt;&lt;&quot;10204&quot;&gt;&gt;). 10204
integer_to_binary(10204). &lt;&lt;&quot;10204&quot;&gt;&gt; 

&quot;7.1200&quot; 
&gt; float_to_list(7.12, [{decimals, 4}, compact]).  &quot;7.12&quot; 
&gt; float_to_binary(7.12, [{decimals, 4}]).  &lt;&lt;&quot;7.1200&quot;&gt;&gt; 
&gt; float_to_binary(7.12, [{decimals, 4}, compact]). &lt;&lt;&quot;7.12&quot;&gt;&gt; 
raise(Class, Reason, Stacktrace) -&gt; no_return()
Types: 
     Class = error | exit | throw 
     Reason = term() 
     Stacktrace = raise_stacktrace() 
     raise_stacktrace() = [{module(), atom(), arity() | [term()]} |{function(), [term()]}] 
                   | [{module(), atom(), arity() 
               | [term()],[{atom(), term()}]} 
               | {function(), [term()], [{atom(), term()}]}] 
disconnect_node( Node() ). 
强制断开一个节点的链接
garbage_collect(pid(0,12571,0)).
强制GC
make_ref()
通过引用来保证请求和响应包是同一个会话 make_ref() ，它在一个节点的生命周期内几乎是唯一的，2的28次方调用后才会重复
erlang:process_info(pid(0,12571,0)). 
查看进程的详细信息
binary_part(Subject, PosLen) -&gt; binary(). binary_part(Subject, Start, Length) -&gt; binary().
binary_part( &lt;&lt;1,2,3,4,5&gt;&gt;, {0,2} ). -&gt; &lt;&lt;1,2&gt;&gt;. 
exit(whereis(Regname), kill).
杀进程
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-erlang">get_argument( home ). %{ok,[[&quot;C:\\Documents and Settings\\Administrator&quot;]]}

init:get_arguments(). %获取启动的配置参数

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><p>通用OTP应用程序的方函数。</p>
<pre><code class="language-erlang">1.Module:config_change(Changed, New, Removed)一&gt;ok
配置参数发生变化的回调函数。

Module:prep_stop(State)一&gt;NewState
应用程序准备停止的回调函数。

Module:start(StartType, StartArgs)一&gt;{ok, Pid}}{ok, Pid，State}}{error, Reason}
应用程序被启动的同调函数。

Module:start_phase(Phase, StartType，PhaseArgs)一&gt;ok{{error，Reason}
应用程序在扩展方式一日台动的同调函数。

Module:stop(State)
应用程序被停止，执行清除「作的回调函数。

get_all_env(Application)一&gt;Env
获取Application应用程序的所有配置。

get_all_key(Application)一&gt;{ok, Keys}}undefined
获取Application应用程序所有配置的键值。

get_application(Pid } Module)一&gt;{ok, Application}}undefined
获取Pid进程(或Module模块)所属应用程序的名称。

get_env(Application, Par)一&gt;{ok, Val}}undefined
获取Application应用程序Par配置参数的值。

get_key(Application，Key)一&gt;{ok, Val}}undefined
获取Application应用程序Key参数的值。

load(AppDescr, Distributed)一&gt;ok}{error, Reason}
以Distrubuted方式加载AppDescr应用程序。
loaded_applications()一&gt;[{Application, Description, Vsn}]
获取当前已经加载应用程序的列表。
permit(Application，Bool)一&gt;ok}{error, Reason}
将当前结点上Application应用程序的运行权限改为Boolo
set_env(Application，Par, Val，Ti rneout)一&gt;ok
将Appliction应用程序的Par配置参数设置为Valo
start(Application，Type)一&gt;ok}{error, Reason}
加载并以Type方式启动Application应用程序。
start_type()一&gt;startType}local}undefined
获取当前进程所属应用程序的启动类型。
stop(Application)一&gt;ok}{error, Reason}
停止Application应用程序。
takeover(Application，Type)一&gt;ok!{error, Reason}
以丁ype方式接管Appliction应用程序。
unload(Application)一&gt;ok}{error, Reason}
卸载Appliction应用程序。
upset env(Application, Par, Timeout)一&gt;ok
清除Application应用程序的Par配置参数。
which_applications(Timeout)一&gt;[{Application，Description, Vsn}]
获取当前正在运行的应用程序的列表。
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="模块code_server"><a class="header" href="#模块code_server">模块code_server</a></h2>
<pre><code class="language-erlang">%% 第一种热更新方式：  
{Module, Binary, Filename} = code:get_object_code(Module), %获取Module.beam的信息
code:load_binary(Module, Filename, Binary).  %load 二进制

 %% 第二种热更新方式：  
 code:purge(Module),  %杀掉应用old_version的进程
code:load_file(Module).  %load_file

 %% 第三种热更新方式：  
 code:soft_purge(Module), %清理old_version的代码，如果old_version的代码还在被引用，则返回false
code:load_file(Module).

add_pathz(&quot;D:/project/yapp/ebin&quot;) 把yapp的ebin文件夹中的文件加载到erlang的环境中
get_path(). 获取加载的erlang模块
which(file).  file模块的文件存放位置
clash() 通过code:clash/0 检测代码中是否有module冲突现象
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-erlang">1.error_logger:error_msg( &quot;an error has occurred\n&quot; ). 

2.error_logger:error_msg( &quot;~s, an error has occurred\n&quot;, [ &quot;joe&quot; ] ). 

3.error_logger:error_report( [{tag1,data1}, a_term, {tar2, data}] ). 

4.error_logger:info_msg(FormatStr, Args); 

5.error_logger:warning_msg(FormatStr, Args); 

6.error_logger:info_report(progress,[{application,test},{started_at, nonode@noh ost}]). 

  error_logger:info_report(crash,[{application,test},{started_at, nonode@noh ost}]). 
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="模块inet"><a class="header" href="#模块inet">模块inet</a></h2>
<p>Access to TCP/IP Protocols</p>
<p>peername(State#state.socket) %socket获取登录的ip和端口</p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-erlang">net_adm:ping(Node). 
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>net_kernel:monitor_nodes(Flag).%调用这个方法来订阅节点状态变动的消息.一个节点加入的时候会向所有的订阅进程发送一个nodeup消息,一个节点断开的时候会发送nodedown消息.  </p>
<pre><code class="language-erlang">
 [net_kernel:disconnect(X) || X &lt;- nodes() -- [List_of_wanted_nodes]]. 
net_kernel:allow(Nodes). 
net_kernel:monitor_nodes(true). 


init([]) -&gt;  
    ok = net_kernel:monitor_nodes(true),  
    {ok, no_state}.  

handle_call(_Request, _From, State) -&gt; {noreply, State}.  

handle_cast(_Msg, State) -&gt; {noreply, State}.  

handle_info({nodeup, Node}, State) -&gt;  
    rabbit_log:info(&quot;node ~p up&quot;, [Node]),  
    {noreply, State};  

handle_info({nodedown, Node}, State) -&gt;  
    rabbit_log:info(&quot;node ~p down&quot;, [Node]), 
%% TODO: This may turn out to be a performance hog when there are  
%% lots of nodes. We really only need to execute this code on %%*one* node, rather than all of them. 
    ok = rabbit_networking:on_node_down(Node), 
    ok = rabbit_amqqueue:on_node_down(Node), 
    {noreply, State}; 

 

 
net_kernel:start( [节点] )  
net_kernel:stop().    
net_kernel:disconnect(X)  
net_kernel:monitor_nodes(true). 
net_kernel:allow(Nodes).  
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="操作系统健康应用"><a class="header" href="#操作系统健康应用">操作系统健康应用</a></h2>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><p><img src="3.%E5%BA%93%E5%87%BD%E6%95%B0/otp//images/screenshot_1534592012634.png" alt="图片" /></p>
<ul>
<li>Erlang的设计哲学是为每一个独立的事件创建一个新进程.</li>
<li>负责进程创建职责的是Erlang VM中的Scheduler</li>
<li>spawn第三个参数是List,这个调用的时候注意!!</li>
<li>Spawning a process will never fail!!!</li>
<li>receive子句的处理逻辑抽取为一个独立的方法是推荐的做法</li>
<li>receive如果接受到没有匹配任何子句的消息,那么这条消息就会保存在mailbox,长此以往就会耗尽内存系统崩溃之险;</li>
<li>消息发送的速度快于进程处理的速度就会增加CPU上的消耗,因为会反复扫描mailbox</li>
<li>Not handling unknown messages should therefore be treated as a bug. 匹配未知消息会导致难以发现错误,所以这些位置要记录日志</li>
<li>选择性接受和mailbox这两个东西就解决了消息接受缓冲区的问题</li>
<li>A race condition occurs when the behavior of a system depends on the order in which certain events occur: these events “race” to influence the behavior.</li>
<li>上面两个不失败的设计原则是为了解除进程依赖:另外一个进程的创建和接受消息是否成功不影响当前进程的正常执行</li>
<li>{'EXIT', Pid, Reason}退出消息的格式包含的信息:谁因为什么退出了</li>
<li>process_flag(trap_exit, true).退出截获的决策当然是在生命周期的早期进行配置。所以一般出现在init阶段。</li>
<li>截获到底做了一件什么事情呢？把退出消息放在进程收件箱中当成一个普通的消息来处理。这就相当于我们把异常信息放在返回结果中的情况</li>
<li>receive接收并处理退出信号,退出消息被截获就不再传播</li>
<li>link是双向的,monitor是单向的,被监控的进程死掉后,监控进程会收到 {'DOWN',Reference,process,Pid,Reason} 消息</li>
<li>如果接收到{'EXIT', Pid, Reason}的进程没有trap_exit,而且Reason不是normal,这个进程就会终止掉并继续传播这个退出消息</li>
<li>所有的BIFs的执行都是原子性的,所以spawn_link不等同于spawn 和 link的组合调用</li>
<li>{'EXIT', Pid, Reason}Reason如果是kill,关联进程无论是否trap_exit都会死掉</li>
<li>{'EXIT', Pid, Reason}Reason如果是normal,关联进程trap_exit会收到一条{'EXIT', Pid, normal}消息,如果没有trap_exit什么都不会发生</li>
</ul>
<p>spawn
spawn( fun() -&gt; loop/1 end )
spawn( fun loop/1 ).
spawn( Node, Fun ).<br />
spawn( Node, Module, Fun, ArgList ).
register
register( name, pid() ).
regs().</p>
<p>whereis( Atom ).</p>
<p>erlang:processes().
erlang:process_info(pid(0,12571,0)).
i().
系統正在執行的進程
erlang:flush().
顯示所有發送到該進程的消息，同時刪除（或刷新）信箱中的消息
link(Pid).
unlink( Pid ).
在調用進程和Pid之間設置一個雙向連接，连接后的两个进程其中一个kill另一个会收到消息：{'EXIT', Exiting_Process_Id, Reason}
spawn_link
spawn_link( Mod, Fun, Args ). 原子性地生成進程並設置一個調用進程和新進程之間連接
spawn_link( Node, Mod, Fun, ArgList ).</p>
<p>spawn_monitor
spawn_monitor( Mod, Fun, Args ).原子性地生成進程並設置一個調用進程和新進程之間的監控
erlang:monitor( process, Pid ).
erlang:monitor( process, Pid ).
生成一個針對Pid的單項監控。它返回給調用進程一個可以用來識別模式匹配的終止進程的引用.
如果进程A监视进程B，A死亡B不会收到消息，B死亡A会收到消息
erlang:monitor( Node, Flag(true|false) ).
在监视被打开时，若有新的节点加入或者离开集群，执行这个BIF的进程就会收到信息{nodeup, Node}|{nodedown, Node}
erlang:demonitor( Reference )
erlang:demonitor( Reference ). 清除監控從而使監控不再進行。不要忘記刷新信息，它可能已經在調用內置函數demonitor之間到達了
erlang:demonitor( Reference, [flush] ). 和demonitor/1一樣，但如果它是作為一個競爭條件的結果發送的時候會刪除{<em>,Reference,</em>,<em>,</em>}消息</p>
<p>process_flag( trap_exit, Flag ).
把當前進程的退出信號轉換為退出信號。Flag可以是基元true(開啟捕捉退出信號)或者基元false（關閉捕捉退出信號）
 process_flag(priority, Pri)
Pri是进程的新的优先级，可以是normal或者low，这将改变调用该BIF的进程的运行优先级。
优先级为normal的进程会比优先级为low的进程运行得更加频繁一些。所有进程默认的优先级都是normal。
exit(Reason)
exit(Reason). 導致調用進程以原因Reason終止
exit( Pid, Reason ). 發送一個退出信號到Pid
Reason = normal||kill||shutdown
如果Reason是kill、shutdown，那么是不能被捕获的，会无条件退出；<br />
如果Reason是normal，则进程是不会退出的，如果该进程设置了捕获退出消息，则会收到{'EXIT', From, normal}消息；
如果Reason是原子值，则如果进程设置为不捕获退出消息，则该进程会退出；但如果设置了捕获退出消息，则不会退出，而是收到{'EXIT', From, Reason}消息。
is_alive().
is_alive().本地节点状态正常并且是一个分布式系统的一部分，那么会返回true
application:loaded_applications().
application:load( framenet ).
application:start( framenet ).
application:stop( framenet ).
application:unload( framenet ).</p>
<p>appmon:start().
启动进程管理器
supervisor:start_child
supervisor:start_child(the_room, []) -&gt; 在监控进程the_room下已经有子进程chat_room,使用此函数复制一个子进程，这个进程的表现和chat_room表现一致
gen_server:start_link/4
gen_server:start_link/4 。这个函数产生了一个新进程一个gen_server并联接到其上。
gen_server:start_link({local, RegName}, CallFunction, Arg, Option) =&gt; {ok, Pid}</p>
<p>第一个参数 {local, ch3} 指定了名称。在这种情况下，gen_srever将在本地被注册为 ch3 。
如果忽略名称，那么这个gen_server就不会被注册了，这时就必须使用其pid。
名称也可以以 {global, Name} 的形式给出，这种情况下gen_server则会使用 global:register_name/2 来进行注册。</p>
<p>第二个参数, ch3, 则是回调模块的名字，也就是回调函数所放的那个模块。
在这里，接口函数（ start_link, alloc 和 free ）和回调函数（init, handle_call 和 handle_cast)。
一般来说这是好的编程实践，将代表同一个进程的代码包含在同一个模块中。</p>
<p>第三个参数，[], 这个值将被原封不动传递给回调函数 init。在这里，init无须任何输入数据将忽略这个参数。
第四个参数，[]，是参数的列表。具体的参数请查看 gen_server(3) 。
Module:init/1
Module:init/1的那些返回值都什么意思？<br />
{ok, State}，就不用说了，一切正常，State将为gen_server的State；<br />
{ok, State, Timeout}，也很正常，只是如果process在Timeout（&gt;=0，ms)时间内没有收到任何消息，那么将产生一个timeout消 息，这个消息要在handle_info中处理。<br />
一个进程中只存在一个超时时间（用来做倒计时）
{ok, State, hibernate}, 还是正常，只是我们在process启动后，就让它先”睡眠“，因为我们知道最近一段时间内，我们还不用这个process，此process睡眠的好处 就是可以最大限度的减少其内存占用，当有消息到达时，process就会”惊醒“，重新工作。
{stop, Reason}，oops，出错了，process将会调用
exit(Reason)退出。如果init没有预期，我们就退出吧。<br />
ingore,既然要求忽略了，什么都不做，退出吧</p>
<p>call(ServerRef, Request)
call(ServerRef, Request) -&gt; Reply
call(ServerRef, Request, Timeout) -&gt; Reply<br />
Types:
ServerRef = Name | {Name,Node} | {global,GlobalName} | {via,Module,ViaName} | pid()
Node = atom()
GlobalName = ViaName = term()</p>
<p>Request = term()
Timeout = int()&gt;0 | infinity</p>
<p>process_flag(trap_exit, true)
gen_server进程设置了trap_exit为true（process_flag(trap_exit, true)），则在该进程结束时会自动调用terminate。
利用这个功能，我们可以在进程退出时进行一些善后工作，例如持久化数据、清理等等。
但实际上terminate不一定有时间完成所有的任务，在此之前可能已经被系统强制结束了(如果使用init:stop形式结束beam)。
gen_fsm
gen_fsm:start
gen_fsm:start_link                -----&gt; Module:init/1
gen_fsm:stop                      -----&gt; Module:terminate/3
gen_fsm:send_event                -----&gt; Module:StateName/2
gen_fsm:send_all_state_event      -----&gt; Module:handle_event/3
gen_fsm:sync_send_event           -----&gt; Module:StateName/3
gen_fsm:sync_send_all_state_event -----&gt; Module:handle_sync_event/4</p>
<ul>
<li>-----&gt; Module:handle_info/3</li>
<li>-----&gt; Module:terminate/3</li>
<li>-----&gt; Module:code_change/4</li>
</ul>
<pre><code class="language-erlang">register(num_generator, spawn_opt(?MODULE, init, [],[{priority,high},{scheduler,0},{min_heap_size, 65536 * 2},{min_bin_vheap_size,65536 * 2}])).

%%参数讲解:
1.priority 
 erlang是公平调度策略，因此默认情况下每个进程得到的运行时间片是相同的：2000reductions,但是对于我们的应用场景来说，这个进程应该是优先级较高的，需要得到更多的调度，因此设置为high,还可以设置为max,但是max是系统进程的预留优先级，用high即可

2. scheduler 
 将该进程绑定到指定的scheduler上，防止进程的任务被scheduler分配来分配去，可以减少CPU调用,注意这个和+sbt db是不同的，+sbt db是防治调度器的任务队列在CPU线程间跃迁，scheduler是为了防止进程在时间片切换过程中被分配给其它的调度器

3.min_heap_size
 进程初始堆大小，用内存换CPU的典型做法，增大初始大小，可以显著降低GC次数和内存再分配次数

4.min_bin_vheap_size
 进程初始二进制堆大小，当该进程对于binary数据的处理交换很多时，可以获得和增大min_heap_size一样的效果
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-erlang">-module( admin_app ).

-behaviour(application).

-export( [start/2, stop/1] ).

start(_Type, _State) -&gt;
    %%初始化的数据
    io:format( &quot;admin_app111~p~n222~p~n&quot;, [ _Type, _State ] ),
    admin_sup:start().

stop(_State) -&gt;
    ok.

1&gt;application:start(log4erl).
    我们就从这一行命令开始说起吧,回车之后可以把log4erl应用程序启动起来.Erlang/OTP中的能完成特定功能集合的组件被称为application. ,application是Erlang代码和功能组织的形式之一([Erlang 0015]Erlang OTP设计原则).application的设计目的是通过运行一个或者多个进程来完成一定功能.为了能够管理这些进程的生命周期,需要通过supervisor进行管理.
    
application:start(log4erl).
Start_Type = permanent||transient||temporary
application:start(log4erl,temporary).

Start_Type==permanent 应用程序终止之后所有其它的应用程序和运行时系统都会死掉; 
Start_Type==transient 应用程序终止的原因是normal,这个消息会报出来但是其它应用程序不会重启,如果应用程序终止的原因不是normal,其他应用程序和运行时也会跟着死掉; 
Start_Type==temporary 应用程序死掉会报错误出来但是其它应用程序不受影响.
注意实践过程中很少使用transient参数,因为进程树崩掉的时候,进程正常退出原因是shutdown不是normal, 
    
这个我之前的文章提到过:[Erlang 0017]Erlang/OTP基础模块 proc_lib 无论使用哪种类型启动,直接调用stop方法关闭application是不会影响到其它应用程序的.
    之前遇到过一个比较严重的问题导致应用崩掉,当时就有同事问为什么erlang的进程还在,或者说运行时还活着?其实就是因为我们启动应用程序的时候默认使用了temporary;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p><img src="3.%E5%BA%93%E5%87%BD%E6%95%B0/otp//images/screenshot_1534592134230.png" alt="图片" /></p>
<pre><code class="language-erlang">%% @author : 余健 &lt;yujian1018@gmail.com&gt;
%% @创建时间 : 2014-04-14
%% @doc : 如果该系统是一个application，该模块设置该application的监督树，监督树的功能就只是提供监控树，不要添加其他的功能
-module(admin_sup).

-behaviour(supervisor).
-export([start/0, init/1]).

start() -&gt; 
    Args = [], 
    io:format( &quot;111~p~nArgs:~p~n&quot;, [self(), Args] ),     
    supervisor:start_link({local,?MODULE}, ?MODULE, Args).


% Supervisor 
init(Args) -&gt;  
    io:format( &quot;222~p~nArgs:~p~n&quot;, [self(), Args] ), 
    Server1 = {admin, {admin, start_link, [Args]}, temporary, 2000, worker, [admin]}, 
    Server2 = {mnesiaDBA_pub_sup, {mnesiaDBA_pub_sup, start,[]}, permanent, infinity, supervisor, [mnesiaDBA_pub_sup, supervisor]}, 
    {ok, {{one_for_one, 0, 1}, [Server1, Server2, Server3]}}.


mnesiaDBA_pub_sup.erl
init([]) -&gt; % Supervisor 
    Server1 = {mnesiaDBA_public, {mnesiaDBA_public, start_link,[]}, permanent, 30000, worker, [mnesiaDBA_public, gen_server]} 
    {ok, {{simple_one_for_one, 3, 10}, [Server1 ] } }. 


init/0函数特别强调
{one_for_one, 1, 3600} -&gt; 在3600秒之内执行了超过1次重启，则终止所有的工作进程

one_for_one 如果子进程终止，只有这个进程会被重启
one_for_all 如果子进程终止，所有子进程都会被重启
rest_for_one 如果子进程终止，在这个进程重启后，其他所有子进程会被重启
simple_one_for_one 简化one_for_one，所有子进程都动态添加同一种进程的实例

 使用supervisor:start_child(regName, []),来启动多个进程
 server:start_link() -&gt; init()的返回值{ok, State, TimeOut||0||infinity}在Timeout毫秒内没有收到请求消息就发生超时，0立即超时
 进程kill不会调用terminate，需要设置（process_flag(trap_exit, true)）

{Tag,             {Mod, FunC, ArgList},    Restart,         ShutDown, Type, [Mod1, Action]}
{framenet, {framenet,start_link,[]}, permanent, KA, worker, [framenet, gen_event]}
Tag,一个原子，用来标记之后要如何来表示这个工作进程

{Mod, FunC, ArgList}，定义监控程序是如何启动工作进程的。它会继续传递给apply( Mod, FunC, ArgList )

Restart=permanent|transient|temporary
permanent 遇到任何错误导致进程终止就重启
temporary 进程永远都不重启
transient 只有进程异常终止的时候会被重启

Shutdown 终止时间。工作进程从它启动到它终止之间允许运行的时间，如果超过这个时间仍在运行，就会将其终止
brutal_kill 立刻强制关闭进程
int() &gt;= 0 等待多少毫秒后强制关闭进程
infinity 当子进程也是监督者时使用，意思是给足够时间让子进程重启

Type = worker|supervisor 被监控进程的类型。可以将一个监控进程设置于另外一个监控进程的控制之下，并由此构建一个更复杂的监控树

Modules  = [Module] | dynamic
表示进程运行依赖哪些模块，仅在代码热更新时使用。使用dynamic的情况是当使用了 Erlang/OTP 发布（Release）等功能，使得Erlang/OTP 可以判断在热更新时需要哪些模块

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-config">{application,%进程名称%
  [{description,&quot;Yaws applications 中文语义切词系统&quot;},
  {vsn,&quot;1.0.0&quot;},
   {modules,[  %所有需要加载的模块]},
   {registered, [%注册进程%]}, %填写的注册进程trap_exit才会被设置为true（待验证）
   {mod,{framenet_sup,[]}}, %定义应用程序启动时的入口函数
   {applications,[kernel, stdlib]}]}. %该应用程序依赖哪些应用程序


启动Erlang 是如果代码都已经自动加载，可以简写.app文件
{application,admin,
 [{description,&quot;Yaws applications 公共模块系统&quot;},
  {vsn,&quot;1.0.0&quot;},
  {modules,[]},
  {registered, [admin,mnesiaDBA_pub_sup]},
  {mod,{admin,[]}},
  {applications,[kernel, stdlib]}]}.
</code></pre>
<ul>
<li>如果仅仅是将一系列的模块打包在一起,并不需要启动application,那么只需要在app文件中移除掉{mod,{Module,Args}}配置节即可.这种Libiary Application典型范例就是stdlib.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-erlang">%%%------------------------------------------------------------------- 
%%% @author yujian 
%%% @doc 
%%%------------------------------------------------------------------- 
-module(test_fsm). 
 

-behaviour(gen_fsm). 

 
-export([start_link/0, init/1, handle_event/3, handle_sync_event/4, handle_info/3, terminate/3, code_change/4]). 

 
-export([send_event/1, 
    role_login/2, 
    role_logined/2, 
    role_ping_role/2 
]). 

 
-define(SERVER, ?MODULE). 

  
-record(state, {}). 

  
start_link() -&gt; 
    gen_fsm:start_link({local, ?SERVER}, ?MODULE, [], []). 
 
 
init([]) -&gt; 
    io:format( &quot;111:~n&quot; ), 
    {ok, role_login, #state{}}. 
 
 
handle_event(_Event, StateName, State) -&gt; 
    io:format( &quot;222:~w~n&quot;, [[_Event, StateName, State]] ), 
    {next_state, StateName, State}. 
 
 
handle_sync_event(_Event, _From, StateName, State) -&gt; 
    io:format( &quot;333:~w~n&quot;, [[_Event, _From, StateName, State]] ), 
    Reply = ok, 
    {reply, Reply, StateName, State}. 
 
 
handle_info(_Info, StateName, State) -&gt; 
    io:format( &quot;444:~w~n&quot;, [[_Info, StateName, State]] ), 
    {next_state, StateName, State}. 
 
 
terminate(_Reason, _StateName, _State) -&gt; 
    io:format( &quot;555:~w~n&quot;, [[_Reason, _StateName, _State]] ), 
    ok. 
 
 
code_change(_OldVsn, StateName, State, _Extra) -&gt; 
    {ok, StateName, State}. 
 
 
role_login(_Event, State) -&gt; 
    io:format( &quot;666:~w~n&quot;, [[_Event, State]] ), 
    {next_state, role_logined, State}. 
 
 
role_logined(_Event, State) -&gt; 
    io:format( &quot;777:~w~n&quot;, [ [_Event, State] ] ), 
    {next_state, role_ping_role, State}. 
 
 
role_ping_role(_Event, State) -&gt; 
    io:format( &quot;888:~w~n&quot;, [ [_Event, State] ] ), 
    {next_state, role_ping_role, State}. 
 
 
send_event(Event) -&gt; 
    io:format( &quot;999:~w~n&quot;, [Event] ), 
    gen_fsm:send_event(?MODULE, Event). 
 ![pic](/images/screenshot_1534592200164.png)

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-erlang">%%%-------------------------------------------------------------------
%%% @author yujian1018@gmail.com
%%% @doc
%%%
%%% Created : 20. 八月 2018 下午3:31
%%%-------------------------------------------------------------------

-module(srv_trie4).

-behaviour(gen_server).


-export([start_link/0, init/1, handle_call/3, handle_cast/2, handle_info/2, terminate/2, code_change/3]).


-export([
    start/0, stop/0,
    select/3
]).

start() -&gt; mnesia:start().


stop() -&gt; gen_server:call(?MODULE, stop).


%% @doc Args参数可以列表表示项，Tuple表示参数只有一个。
select(Module, FunC, Args) -&gt;
    gen_server:call(?MODULE, {Module, {FunC, Args}}).


start_link() -&gt; gen_server:start_link({local, ?MODULE}, ?MODULE, [], []).


init([]) -&gt;
    erlang:process_flag(min_bin_vheap_size, 1024 * 1024),%消息和binary内存,减少大量消息到达或处理过程中产生大量binary时的gc次数
    erlang:process_flag(min_heap_size, 1024 * 1024),%堆内存：，减少处理过程中产生大量term，尤其是list时的gc次数
    erlang:process_flag(priority, high),%进程优先级：，防止特殊进程被其它常见进程强制执行reductions
    erlang:process_flag(scheduler, 1),%进程调度器绑定：，当进程使用了port时，还需要port绑定支持，防止进程在不同调度器间迁移引起性能损失，如cache、跨numa node拷贝等，当进程使用了port时，主要是套接字，若进程与port不在一个scheduler上，可能会引发严重的epoll fd锁竞争及跨numa node拷贝，导致性能严重下降
    {ok, #{}}.


handle_call(stop, _From, State) -&gt; {stop, normal, stopped, State};

handle_call(_Request, _From, State) -&gt; {reply, ok, State}.


handle_cast(_Msg, State) -&gt; {noreply, State}.

%% 进程中实现倒计时的方法
handle_info(timeout1, State = #{num := Num}) -&gt;
    io:format(&quot;gen_server timeout1:~p~n &quot;, [State]),
    {noreply, State#{num = Num + 1}, 1000};

handle_info(_Info, State) -&gt; {noreply, State}.

terminate(_Reason, _State) -&gt; ok.

code_change(_OldVsn, State, _Extra) -&gt; {ok, State}.


</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-erlang">start() -&gt; register( mnesiaDBA_pub_clear, spawn( fun()-&gt; loop() end ) ).

stop() -&gt; rpc( {stop, &quot;stop&quot;} ).

rpc(Request) -&gt;
    mnesiaDBA_pub_clear ! {self(), Request},
    receive
        {mnesiaDBA_pub_clear, Res} -&gt;
            Res;
        Other -&gt;
            io:format(&quot;server is different:~p~n&quot;, [Other])
    end.

loop() -&gt;
    receive
        {ClientPid, {table, Table}} -&gt;
            Res = filter(Table),
            ClientPid ! {mnesiaDBA_pub_clear, Res},
            loop();
        {ClientPid, {stop, Stop}} -&gt;
            ClientPid ! {mnesiaDBA_pub_clear, &quot;pid stopping reason:&quot; ++ hd(io_lib:format(&quot;~p~n&quot;, [Stop]))};
        {ClientPid, Other} -&gt;
            ClientPid ! {mnesiaDBA_pub_clear, &quot;arg is error:&quot; ++ hd(io_lib:format(&quot;~p~n&quot;, [Other]))},
            loop()
    end.


1.upmap(F, L) -&gt;
  Parent = self(),
  Ref = make_ref(),
  [receive {Ref, Result} -&gt; Result end || _ &lt;- [spawn(fun() -&gt; Parent ! {Ref, F(X)} end) || X &lt;- L]].

2.loop() -&gt;
receive
  a -&gt;           
    Fun,loop();
  stop -&gt; stop;
  Other -&gt;     
    Fun,loop();
  after
    3000 -&gt; 0
 end.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="sasl-application"><a class="header" href="#sasl-application">SASL application</a></h2>
<p>系统架构支持库是一套用于发布升级和警报处理等的工具。</p>
<div style="break-before: page; page-break-before: always;"></div><p><a href="http://erlang.org/doc/man_index.html">http://erlang.org/doc/man_index.html</a></p>
<div style="break-before: page; page-break-before: always;"></div><p>函数式且可扩展的数组模块</p>
<pre><code class="language-erlang">内部实现：tuple

array:new(10, {default, {[], 0}}). -&gt; {array,10,0,{[],0},10}
array:set( 0, [1,2,3], Array2 ). -&gt; Array
array:get( 0, Array3 ). -&gt; [1,2,3].
array:reset(Index, Array). 清空该列
array:from_list(Sub)
</code></pre>
<p><img src="3.%E5%BA%93%E5%87%BD%E6%95%B0/stdlib//images/screenshot_1534642192915.png" alt="图片" /></p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-erlang">%% 实现base 64的编码解码算法，具体细节参考RFC 20450
base64:decode(&quot;dGhpcyBpcyBhIHRlc3Qh&quot;). -&gt; &lt;&lt;&quot;this is a test!&quot;&gt;&gt;
base64:decode_to_string(&quot;dGhpcyBpcyBhIHRlc3Qh&quot;). -&gt; this is a test!
base64:encode(&quot;this is a test!&quot;). -&gt; &lt;&lt;&quot;dGhpcyBpcyBhIHRlc3Qh&quot;&gt;&gt;
base64:encode_to_string(&quot;this is a test!&quot;). -&gt; dGhpcyBpcyBhIHRlc3Qh
base64:mime_decode(&quot;dGhpcyBpcyBhIHRlc3Qh&quot;). -&gt; &lt;&lt;&quot;this is a test!&quot;&gt;&gt;
%% 对Data数据进行base 64编码。

base64:mime_decode_to_string(&quot;dGhpcyBpcyBhIHRlc3Qh&quot;). -&gt; this is a test!
%% 对以base 64编码过的Base64数据进行解码。
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-erlang">at(Subject, Pos) -&gt; byte() 
返回一个二进制数据里指定位置（从 0 开始）的数据（整数的形式），如果 Pos &gt;= byte_size(Subject)，则会发生一个 badarg 的异常错误。

bin_to_list/1,bin_to_list/2,bin_to_list/3
binary:bin_to_list(&lt;&lt;&quot;erlang&quot;&gt;&gt;, {1 ,3}). -&gt; erl
binary:bin_to_list(&lt;&lt;&quot;erlang&quot;&gt;&gt;, {1 ,33}). -&gt; badarg
binary:bin_to_list(&lt;&lt;&quot;erlang&quot;&gt;&gt;, 1, 3).
binary:list_to_bin( List ) -&gt; Bin

copy(Bin).
创建二进制数据 Subject 的一个副本。

first(Bin).
binary:first(&lt;&lt;&quot;12345&quot;&gt;&gt;). -&gt; 49.

last(Bin).
binary:last(&lt;&lt;&quot;12345&quot;&gt;&gt;). -&gt; 53

longest_common_suffix(Binaries) -&gt; integer() &gt;= 0
返回在二进制数据列表里最长的公共后缀长度。如果参数不是一个扁平的二进制数据列表，那么将会出现一个 badarg 的异常。
binary:longest_common_suffix([&lt;&lt;&quot;erlang&quot;&gt;&gt;, &lt;&lt;&quot;fang&quot;&gt;&gt;]). -&gt; 3
binary:longest_common_suffix([&lt;&lt;&quot;erlang&quot;&gt;&gt;, &lt;&lt;&quot;perl&quot;&gt;&gt;]). -&gt; 0

binary:match(&lt;&lt;&quot;abcde&quot;&gt;&gt;, [&lt;&lt;&quot;bcde&quot;&gt;&gt;, &lt;&lt;&quot;cd&quot;&gt;&gt;]). -〉{1，4}
在一个二进制数据 Subject 里查找符合一个模式 Pattern 的第一个匹配，用法跟 match(Subject, Pattern, []) 一样。

Binary = &lt;&lt;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&gt;&gt;, 
&lt;&lt;_:4/binary, Bin:4/binary, _/binary&gt;&gt; = Binary,
binary:referenced_byte_size(Bin). -&gt; 10
如果 Binary 是一个很大二进制数据的一个二进制引用，那么该函数可以获取所引用的二进制数据的实际大小。

binary:split(&lt;&lt;1,255,4,0,0,0,2,3&gt;&gt;, [&lt;&lt;0,0,0&gt;&gt;,&lt;&lt;2&gt;&gt;]). -&gt; [&lt;&lt;1,255,4&gt;&gt;,&lt;&lt;2,3&gt;&gt;]
 binary:split(&lt;&lt;&quot;a,b,c,d&quot;&gt;&gt;,&lt;&lt;$,&gt;&gt;,[global,trim]). -&gt; [&lt;&lt;&quot;a&quot;&gt;&gt;,&lt;&lt;&quot;b&quot;&gt;&gt;,&lt;&lt;&quot;c&quot;&gt;&gt;,&lt;&lt;&quot;d&quot;&gt;&gt;]
根据模式把一个二进制数据 Subject 分割成一个二进制列表，在 Subject 里实际匹配到的那部分是不会包括在结果里。用法跟 binary:split/3 的 binary:split(Subject, Pattern, []) 一样。

&lt;&lt;&quot;{[&quot;, (iolist_to_binary([&lt;&lt;&quot;{&quot;, X/binary, &quot;, &quot;, Y/binary, &quot;},\n    &quot;&gt;&gt; || {X, Y} &lt;- Encodes]))/binary, &quot;}]}.&quot;&gt;&gt;
&lt;&lt; &lt;&lt;(X*2)&gt;&gt; || &lt;&lt;X&gt;&gt; &lt;= &lt;&lt;1,2,3&gt;&gt; &gt;&gt;.

&lt;&lt;C1:8, _/binary&gt;&gt; = &lt;&lt;&quot;aa&quot;&gt;&gt; -&gt; C1 = 97.
&lt;&lt;C1:1/binary, _/binary&gt;&gt; = &lt;&lt;&quot;aa&quot;&gt;&gt; -&gt; C1 = &lt;&lt;&quot;a&quot;&gt;&gt;
&lt;&lt;A:1/binary,B:8, O:B &gt;&gt; = &lt;&lt;&quot;a&quot;,8:8,&quot;b&quot;&gt;&gt;
&lt;&lt;A:1/unsigned-big-integer&gt;&gt; = &lt;&lt;1:8&gt;&gt;
&lt;&lt;A:16/unsigned-big-integer&gt;&gt; = &lt;&lt;1:8, 1:8&gt;&gt;.


%%%二进制列表解析
%%The only change in syntax from regular list comprehensions is the &lt;- which became &lt;= and using binaries (&lt;&lt;&gt;&gt;) instead of lists ([]).

1&gt; Pixels = &lt;&lt;213,45,132,64,76,32,76,0,0,234,32,15&gt;&gt;.
&lt;&lt;213,45,132,64,76,32,76,0,0,234,32,15&gt;&gt;
2&gt; RGB = [ {R,G,B} || &lt;&lt;R:8,G:8,B:8&gt;&gt; &lt;= Pixels ].
[{213,45,132},{64,76,32},{76,0,0},{234,32,15}]
3&gt; &lt;&lt; &lt;&lt;R:8, G:8, B:8&gt;&gt; ||  {R,G,B} &lt;- RGB &gt;&gt;.
&lt;&lt;213,45,132,64,76,32,76,0,0,234,32,15&gt;&gt;
4&gt; &lt;&lt; &lt;&lt;R:8, G:8, B:8&gt;&gt; ||  {R,G,B} &lt;- RGB &gt;&gt;.
&lt;&lt;213,45,132,64,76,32,76,0,0,234,32,15&gt;&gt;
5&gt; &lt;&lt; &lt;&lt;Bin&gt;&gt; || Bin &lt;- [&lt;&lt;3,7,5,4,7&gt;&gt;] &gt;&gt;.
** exception error: bad argument
6&gt; &lt;&lt; &lt;&lt;Bin/binary&gt;&gt; || Bin &lt;- [&lt;&lt;3,7,5,4,7&gt;&gt;] &gt;&gt;.
&lt;&lt;3,7,5,4,7&gt;&gt;
7&gt; &lt;&lt; &lt;&lt;(X+1)/integer&gt;&gt; || &lt;&lt;X&gt;&gt; &lt;= &lt;&lt;3,7,5,4,7&gt;&gt; &gt;&gt;.
&lt;&lt;4,8,6,5,8&gt;&gt;

</code></pre>
<p>erlang 对于二进制的数据处理提供了非常强大的语法，而一般语言对于二进制数据的处
理多用移位操作来完成。</p>
<p>1 byte = 8 bit (1字节 === 8位)
1 int =4 byte = 32 bit(其他语言中 一般情况下int 类型为4字节，32位)
2^8 =256 (2 的八次方是256,)
似乎erlang 不区分int float ,
hex 0 1 2 3 4 5 6 7 8 9 a b c d e f
binnary 0000  0001  0010  0011  0100  0101  0110  0111  1000  1001  1010  1011  1100  1101  1110  1111
所以一个十六进制字符需要4位(4bit)来表示,故一字节(byte)可以容纳2个十六进制字符,
故 16#ffffff 占3字节，24位，就不难理解了.</p>
<p>二进制，八进制，十六进制数的表示方法举例
二进制 八进制 十六进制
2#00001111  8#12345670  16#ff
2#0010  8#123 16#ff0011</p>
<p>erlang 几个取size 的BIF(build in functions)
• size/1 返回字节数(byte为单位)
• bit_size/1 (返回位数,bit为单位)
bit syntax 重头戏
整数，
对于字母，数字转化成binary,可以进行这样的操作</p>
<pre><code class="language-erlang">(emacs@jf.org)77&gt; A = &lt;&lt;12&gt;&gt;.
&lt;&lt;&quot;\f&quot;&gt;&gt;
(emacs@jf.org)78&gt; B = &lt;&lt;23&gt;&gt;.
&lt;&lt;23&gt;&gt;
(emacs@jf.org)79&gt; C = &lt;&lt;257&gt;&gt;. % 大于256
&lt;&lt;1&gt;&gt;
(emacs@jf.org)80&gt; bit_size(A).
8
(emacs@jf.org)81&gt; bit_size(C).
8
(emacs@jf.org)82&gt;
decimal binary
12  00001100
23  00010111
257(只取前8bit 00000001) 0000000100000001
以上可见: 对于数字的情况：数字只能接受8bit 的数字，即小于256的数字(不包括256)

(emacs@jf.org)63&gt; B= &lt;&lt;1,2,3,4&gt;&gt;. %B是二进制数据，32bit
&lt;&lt;1,2,3,4&gt;&gt;
(emacs@jf.org)64&gt; &lt;&lt;C:32&gt;&gt; = B.  %给整数C赋值
&lt;&lt;1,2,3,4&gt;&gt;
(emacs@jf.org)65&gt; C.
16909060
(emacs@jf.org)66&gt;F = &lt;&lt;C:32&gt;&gt;.    % int --&gt;binary ,F是二进制
&lt;&lt;1,2,3,4&gt;&gt;
decimal binary
1 00000001
2 00000010
3 00000011
4 00000100
16909060  00000001 00000010 00000011 00000100
对以上代码进行分析,可以得知如何从一个二进制数中截取出一个int 来，
及如何将一个int 值写到二进制数据中
字符,每个字符以其ascii 值来处理

(emacs@jf.org)110&gt; A = &lt;&lt;&quot;a&quot;&gt;&gt;. % 等效于 A = &lt;&lt;97&gt;&gt;.
&lt;&lt;&quot;a&quot;&gt;&gt;
(emacs@jf.org)111&gt; A. % A是二进制数据
&lt;&lt;&quot;a&quot;&gt;&gt;
(emacs@jf.org)112&gt; &lt;&lt;B:8&gt;&gt; = A.
&lt;&lt;&quot;a&quot;&gt;&gt;
(emacs@jf.org)113&gt; B. % B是整数，8bit
97
(emacs@jf.org)114&gt; bit_size(A).
8
(emacs@jf.org)115&gt; size(A).
1
(emacs@jf.org)116&gt; E = &lt;&lt;&quot;ab&quot;&gt;&gt;. %等效于 E = &lt;&lt;97,98&gt;&gt;.
&lt;&lt;&quot;ab&quot;&gt;&gt;
  % 另外字符还可以这样表示   $a,$b,$c
 (emacs@jf.org)132&gt;  C = &lt;&lt;$a&gt;&gt;.
   &lt;&lt;&quot;a&quot;&gt;&gt;
其他示例

(emacs@jf.org)127&gt; A = &lt;&lt;1,2,3&gt;&gt;.
&lt;&lt;1,2,3&gt;&gt;
(emacs@jf.org)128&gt; bit_size(A).
24
(emacs@jf.org)129&gt; B = &lt;&lt;1,2,3:16&gt;&gt;.
&lt;&lt;1,2,0,3&gt;&gt;
(emacs@jf.org)130&gt; bit_size(B).
32
(emacs@jf.org)131&gt;
关于位数的控制
</code></pre>
<p>3:16  ,16位的数字3  00000000 00000011
3 8位的数字3  00000011
二进制的表示方法，完全语法
• Value
• Value:Size
• Value/TypeSpecifierList
• Value:Size/TypeSpecifierList
• 其中TypeSpecifierList可以是以下几种类型及其组合，组合以 - 相连  unsigned-big-integer
○ Type(类型)
integer | float | binary | bytes | bitstring | bits | utf8 | utf16 | utf32
bytes = binary bits = bitstring
○ Signedness (是否为有符号整数 + /-)
signed | unsigned
只有当Type 为integer 时有效，默认为unsigned
○ Endianness(字节序) (default big)
big | little | native
哪个字节存储在低地址(内存地址)
网络传输一般采用大端序big，也被称之为网络字节序，或网络序
比如对于一个32位的整数 72 ,这32位是如何安排的
• 72  • little-endian • big-endian
• 72
• binary  • 01001000 00000000 00000000 00000000 • 00000000 01001000 00000000 00000000
○ Unit
语法 unit:Integer ,如unit:1
取值范围1..257
• integer,float,bitstring • 1
• binary  • 8
• utf8 ,utf16,utf32,  • 不需要此属性
移位 and or 等传统操作
• bsl (Bit Shift Left),
• bsr (Bit Shift Right),
• band,
• bor,
• bxor,
• bnot.
示例 int32–&gt;binary binary–&gt;int32
将int32转换成binary ,从binary 头部读取32位，转成int32</p>
<pre><code class="language-erlang">-module(aaa).
-export([int32_2_binary/1,read_int32_from_binary/1]).
%%int按网络字节流 转成binary%%网络传输一般采用大端序big，也被称之为网络字节序，或网络序%%而erlang 默认就是bigint32_2_binary(Int) when is_integer(Int)-&gt;
    &lt;&lt;Int:32&gt;&gt; ;
int32_2_binary(Bin) when is_binary(Bin) -&gt;                          %若本就Bin ,直接返回
    Bin.
%%默认binary 长度大于32read_int32_from_binary(Bin) when is_binary(Bin)-&gt;
    &lt;&lt;Int:32,_/bits&gt;&gt; = Bin,
    Int
        ;
read_int32_from_binary(Int) when is_integer(Int) -&gt;
    Int.
%% aaa:read_int32_from_binary(&lt;&lt;&quot;abcdefghijk&quot;&gt;&gt;).%% 1633837924%% 1100001 01100010 01100011 01100100%% 97      98       99          100%% a       b         c          d
</code></pre>
<p>参考链接
• learnyousomeerlang.com/bit syntax
• <a href="http://www.erlang.org/euc/00/bit_syntax.html">http://www.erlang.org/euc/00/bit_syntax.html</a>
• 字节序wiki</p>
<p>来自 <a href="http://jixiuf.github.io/erlang/binary_bit.html#sec-4">http://jixiuf.github.io/erlang/binary_bit.html#sec-4</a></p>
<ul>
<li>使用binary match来进行binary的分割，而不使用split_binary/2</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>Command Interface Module</p>
<p><img src="3.%E5%BA%93%E5%87%BD%E6%95%B0/stdlib//images/screenshot_1534642567117.png" alt="pic" /></p>
<p>hepl().
显示帮助信息
pwd().
返回当前路径。
cd(Path).<br />
设置路径
bt(Pid)一&gt;voidU
显示Pid进程的栈回溯信息。
c(File，Options)一&gt;{ok, Module}!error<br />
使用Options选项编译并加载File文件。
c(test,['S']). %assembler code文件 汇编代码
c(FileName, [to_core]). %会生成中间代码，可以看到一些初步优化后的结果
c(test,['E']). %after all source code transformations have been performed
c(test,['P']). %parsed code 语法分析代码 after preprocessing and parse transforms</p>
<p>flush()一&gt;void()
强制刷新所有发给shell的消息。
i(X, Y, Z)一&gt;void()
显示Pid为&lt;&lt;X.Y.Z&gt;的进程信息。
i()</p>
<p>ni().
显示当前系统的信息
l(Module)一&gt;void()
加载或者重新加载Module模块。
lc(Files)一&gt;ok
编译Files列表中的文件。
ls()一&gt;void()
列出当前日录中的文件
ls(Dir)一&gt;void()
列出dir日录中的文件
m()一&gt;void()<br />
显示当前系统中己加载的模块。
m(Module)一&gt;void()
显示Module模块的信息
memory()
显示当前系统的内存分配情况
memory([Type])
显示[[Type〕列表中各种内存的分配情况
nc(File)
nc(File, Options〕一&gt;{ok, Module}|error
在当前系统的所有的节点上编译并加载File文件
nl (Module)一&gt;void()
在所有的节点上加载Module模块
pid(X, Y, Z)一&gt;pid()
将X, Y,  Z转换为PID(进程标识符)
q()一&gt;void()
退出，等同于init:stop().
regs()一&gt;void()
显示当前系统中己经注册的进程
nregs()
for all nodes in the network
xm(ModSpec)一&gt;void()
对ModSpec指定的模块进行交叉引用检查，等同于几xref:m/l
y(File〕一&gt;YeccRet
y(File，Options)一&gt;YeccRet
根据File语法文件生成相应的LALR-1分析器
根据File语法文件带Options参数生成相应的LALR-1分析器</p>
<div style="break-before: page; page-break-before: always;"></div><p><img src="3.%E5%BA%93%E5%87%BD%E6%95%B0/stdlib//images/screenshot_1534642666206.png" alt="pic" /></p>
<pre><code class="language-erlang">date_to_gregorian_days(Date) -&gt; Days  获取到现在为止的天数
date_to_gregorian_days(Year, Month, Day) -&gt; Days  
datetime_to_gregorian_seconds(DateTime) -&gt; Seconds  获取到现在为止的秒数
day_of_the_week(Date) -&gt; daynum() 获取到现在为止的周数
day_of_the_week(Year, Month, Day) -&gt; daynum()
gregorian_days_to_date(Days) -&gt; date()  calendar:gregorian_days_to_date( 20000 ) -&gt; {54,10,4}
 20000天是多少年多少月多少日
gregorian_seconds_to_datetime(Seconds) -&gt; datetime()  calendar:gregorian_seconds_to_datetime( 200000 ) -》{{0,1,3},{7,33,20}}  

20万秒是多少年月日，时分秒
is_leap_year(Year) -&gt; boolean() Year年数是否为闰年
iso_week_number() -&gt; yearweeknum()  This function returns the tuple {Year, WeekNum} representing the iso week number for the actual date. For determining the actual date, the function local_time/0 is used.
iso_week_number(Date) -&gt; yearweeknum()  该年的第几周
last_day_of_the_month(Year, Month) -&gt; LastDay calendar:last_day_of_the_month( 2014,3 ) -&gt; 31  

根据年月获取该月份的最后一天
local_time()  calendar:local_time() -&gt; {{2013,7,11},{16,25,46}}
local_time_to_universal_time(DateTime1)  calendar:local_time_to_universal_time( {{2013,7,11},{16,25,46}} ) -&gt; {{2013,7,11},{8,25,46}}
local_time_to_universal_time_dst(DateTime1) -&gt; [DateTime] calendar:local_time_to_universal_time_dst( {{2013,7,11},{16,25,46}} ) -&gt; [{{2013,7,11},{8,25,46}}]
now_to_local_time(Now) -&gt; datetime1970()  calendar:now_to_local_time( now() ) -&gt; {{2014,5,23},{10,57,10}}
 now()转化为datetime1970()
now_to_universal_time(Now) -&gt; datetime1970()  calendar:now_to_local_time( now() ) -&gt; {{2014,5,23},{2,57,10}}  

八小时时差
now_to_datetime(Now) -&gt; datetime1970()  calendar:now_to_local_time( now() ) -&gt; {{2014,5,23},{2,57,10}}  

默认UTC时间
seconds_to_daystime(Seconds) -&gt; {Days, Time}  calendar:seconds_to_daystime(1400774400) -&gt; {16212,{16,0,0}}  

Seconds秒转换为多少天时分秒
seconds_to_time(Seconds) -&gt; time()  秒数转换为时分秒，不能超过一天
time_difference(T1, T2) -&gt; {Days, Time} calendar:time_difference( {{2013,7,11},{16,25,46}}, {{2013,7,11},{8,25,46}} ) -&gt; {-1,{16,0,0}}
time_to_seconds(Time) -&gt; secs_per_day() 时分秒转换成秒
universal_time()  
valid_date(Date) -&gt; boolean()  

valid_date(Year, Month, Day) -&gt; boolean().  验证是否存在日期
 8&gt;calendar:valid_date(2015, 2, 29). 
 false
9&gt; calendar:valid_date(2015, 2, 28).
true
 



DateTime1 = DateTime = datetime1970() 

This function converts from local time to Universal Coordinated Time (UTC). DateTime1 must refer to a local date after Jan 1, 1970. 

The return value is a list of 0, 1 or 2 possible UTC times: 

[] 

For a local {Date1, Time1} during the period that is skipped when switching to daylight saving time, there is no corresponding UTC since the local time is illegal - it has never happened. 

[DstDateTimeUTC, DateTimeUTC] 

For a local {Date1, Time1} during the period that is repeated when switching from daylight saving time, there are two corresponding UTCs. One for the first instance of the period when daylight saving time is still active, and one for the second instance. 

[DateTimeUTC] 

For all other local times there is only one corresponding UTC. 

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-erlang">load_binary
purge    Erlang的代码服务器
add_patha(Dir)   将Dit目录添加到代码目录列表的前端
add_pathsa(Dirs)  将Dirs列表中的目录添加到代码目录列表的前端
add_pathsz(Dirs) 将Dirs列表中的目录添加到代码目录列表的末端
add_pathz(Dir)  将Dir目录添加到代码目录列表的末端
all loaded()  获取所有已加载模块的列表
clash()   显示命名冲突检查报告
compiler_dir()  获取编译器的库文件目录
del_path(Name | Dir) 从代码目录列表中删除dir目录
delete (Module)  删除Module模块目前的代码
ensure_loaded(Module) 确保Module模块己经被加载
get_object_code (Module)获取Module模块的BEAM代码
get_path()  获取代码服务器当前的搜索路径
is loaded (Module) 检查Module模块是否已经加载
lib_dir()  获取Erlang/OTP的库文件目录
lib_dir(Name)  获取Name应用程序的库文件目录
load_abs(F们ename) 从filename绝对路径加载BEAM文件
load_binary(Module, Filenarne, Binary)将Binary的BEAM数据载入，Filename为其文件名，Module为模块名
load_file(Module) 从代码目录中加载Module模块
objfile_extension(). 获取目标文件的扩展名
priv_dir(Name)  获取Name应用程序的Priv目录
purge(Module)  清除Module模块老版本的代码
rehash()  创建或者重新建立代码目录的缓存
replace_path(Name, Dir) 将代码目录列表中名为Name的目录替换为
root_dir()  获取Erlang/OTP的根目录
set_path(Path)  设置代码服务器的搜索路径
soft_purge(Module) 在没有进程使用的情况下清除Module模块老版本的代码
stick_dir(Dir)
unstick_dir(Dir)
where_is_file(Filename) 搜索代码目录，获取filename文件名的完整路径
which (Module)  获取Module模块目标代码文件的位置
code:clash/0   %检测代码中是否有module冲突现象
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>    dict是动态哈希表实现的字典.在接口上和orddict保持一致,在实现上和array动态扩展的思路类似, 与proplists,orddict相比它能够支持更大的数据量,你可以在数据量膨胀的时候从orddict转为dict.dict使用的是动态哈希技术实现,
理论依据是论文: &quot;The Design and Implementation of Dynamic Hashing for Sets and Tables in Icon&quot; ,论文地址: <a href="http://www.2007.cccg.ca/%7Emorin/teaching/5408/refs/a99.pdf">http://www.2007.cccg.ca/~morin/teaching/5408/refs/a99.pdf</a></p>
<p>    数组寻址容易,插入和删除困难;链表寻址困难,插入和删除容易;哈希表插入和删除的时间均取决于查找时间.哈希表在数据和数据存储位置之间建立了确定的函数关系,所以获得了高效的查询效率,而线性表和树,数据项在结构中的位置是随机的,和数据项取值没有确定的关系,这种结构上进行查找数据项是基于&quot;比较&quot;,查找效率依赖比较次数.
    参考资料：<a href="http://www.cnblogs.com/me-sa/archive/2012/06/24/erlang-dict.html">http://www.cnblogs.com/me-sa/archive/2012/06/24/erlang-dict.html</a></p>
<pre><code class="language-erlang">1.Dict = dict:new().
2.dict:store( key, Value, Dict ).
3.dict:is_key( Key, Dict ). -&gt; true | false
4.dict:find(Key, Dict). == dict:fetch( Key, Dict ).

5.dict:fold(Fun, [], Dict).  Fun = fun( I, List ) -&gt; Return = fun(I), [Return | List] end.
6.dict:erase(k1, Dict). 清除Dict中key=k1的数据
7.dict:append( k2,v3, Dict2 ) 向k2追加v3

1.dict可以存储更大的数据
在dict的实现中,Segment,Slot,bucket是三个逐渐逐渐变小的概念
-record(dict, {
  size=0 %元素的数量 
  n=?seg_size % 已经激活的slot数量 
  maxn=?seg_size % 最大slots数 
  bso=?seg_size div 2 %最大bucket数散列表中当前允许的最大 bucket 数量，扩张操作需要据此判断是否要增加新的 bucket 区段，初始为 16； 
  exp_size=?exp_size %扩张阈值 初始值为16*5=80 
  con_size=?con_size %收缩阈值 初始值为16*3=48 
  empty :: tuple(), % Empty segment 
  segs :: tuple() % Segments 所有的数据存放的地方 }).

</code></pre>
<p><img src="3.%E5%BA%93%E5%87%BD%E6%95%B0/stdlib//images/screenshot_1534642825354.png" alt="pic" /></p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-erlang">1.{ok,Scanned,_} = erl_scan:string( &quot;1+2*2+(2+4)/2.&quot; ).
    {ok,[{integer,1,1},
     {'+',1},
     {integer,1,2},
     {'*',1},
     {integer,1,2},
     {'+',1},
     {'(',1},
     {integer,1,2},
     {'+',1},
     {integer,1,4},
     {')',1},
     {'/',1},
     {integer,1,2}],
    1}
2.{ok,Parsed} = erl_parse:parse_exprs(Scanned),
  {ok,[{op,1,'+',
         {op,1,'+',
             {integer,1,1},
             {op,1,'*',{integer,1,2},{integer,1,2}}},
         {op,1,'/',
             {op,1,'+',{integer,1,2},{integer,1,4}},
             {integer,1,2}}}]}
3.erl_eval:exprs(Parsed,[]).
    {value,8.0,[]}

4.erl_syntax:abstract(T::term()) -&gt; syntaxTree()

  {ok, T1, _} = erl_scan:string( &quot;aaa,bbb.&quot; ).
5. erl_parse:parse_term(T1).
  T1的末尾必须是 {dot, 1}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="写文件"><a class="header" href="#写文件">写文件</a></h3>
<pre><code class="language-erlang">   file:open( FileName, [append]|[write]|[read] )  

    file:open(?FilePath, [write, {encoding, utf8}]) 

    tool_log( Res, State )-&gt; 

        {ok, S} = file:open(get_path(&quot;../doc/tool_log.txt&quot;), [append]), 

        io:format( S, &quot;~p:~n{~p, ~p}~n&quot;, [ erlang:localtime(), Res, State ]), 

        file:close( S ). 

    file:open(File, [raw, binary]). 

  2.file:write( IoDevice, Bytes ). 

  file:write_file( FileName, Bytes ). 可以保存图片 
</code></pre>
<h3 id="读文件"><a class="header" href="#读文件">读文件</a></h3>
<pre><code class="language-erlang">file:open( FileName, read ). 

{ok,&lt;0.547.0&gt;} 

io:read( &lt;0.547.0&gt;, '' ). 

{ok,{1,&quot;买星马AK-8880&quot;}}
  ile:read_file(FileName )  

      file:read_file( &quot;E:\a.xml&quot; ). {ok,&lt;&lt;&quot;&lt;xml&gt;\r\n&lt;name&gt;yujian&lt;/name&gt;\r\n&lt;/xml&gt;&quot;&gt;&gt;} 

  file:consult( FileName  )   

        case file:consult( Doc ) of 

        {ok, [FileConent]} -&gt; FileConent; 

        Other -&gt; Other 

        end. 

     file:consult可以直接把文件中的Erlang项读取出来 
file:list_dir(Docs) 列出当先文件夹下所有的子目录及文件
file:make_dir(Docs) 创建一个新的目录

 
{ok, S} = file:open( &quot;D:/project/minertwo/doc/countrys.txt&quot;, [read] ). 

   io:get_line( S, '' ). 

   &quot;中国  蒙古  朝鲜  韩国  日本\n&quot; 

   &quot;菲律宾\t越南\t老挝\t柬埔寨\t缅甸\t泰国\t马来西亚\t文莱\t新加坡\t印度尼西亚\t东帝汶\t\t\t\t\t\t\t\t\n&quot; 

file:delete( Path ). 

file:del_dir(Dir) 

filelib:is_file( Path )  判断是否是一个文件 
</code></pre>
<p>Erlang用于操纵文件I/O的模块有：</p>
<p>file模块：打开、读、写、关闭文件已经操作目录的方法基本都在这里</p>
<p>filename模块：提供平台独立方式用于操纵文件名</p>
<p>filelib模块：file模块的扩展，提供了更多的实用工具，在file模块基础上构建</p>
<p>io模块：一系列用于操作打开的文件的方法，解析格式、格式化输出等等。</p>
<p>1.打开文件：</p>
<pre><code class="language-erlang">{ok,F}=file:open(&quot;data1.dat&quot;,read). %读模式打开 

{ok,F}=file:open(&quot;data1.dat&quot;,write). %写模式 

{ok,F}=file:open(&quot;data1.dat&quot;,[read,write]). %读、写、二进制模式 
</code></pre>
<p>支持的所有模式参见文档。</p>
<p>2.读取：</p>
<pre><code class="language-erlang">(1)如果以一个Erlang term的方式读取，采用: 
io:read(F,''). 
其中第二个参数是提示符，用于在标准输入时作为提示。 
这个方法有一个变形read/3 
read(IoDevice, Prompt, StartLine) 
第三个参数用于指定开始行数。 

(2)如果是按字节读取，文件必须按raw模式打开采用： 
    {ok, Data}=file:read(F,100). 

(3)按行读取： 
    io:get_line(F, ''). 

(4)读取整个文件的内容： 
{ok,Binary}=file:read_file(&quot;data1.dat&quot;). 
%%注意返回的是一个binary类型 

(5)随机读取： 
{ok,Binary}=file:pread(F, 22, 46). 
%%其中第二个参数是开始位置，第三个参数是读取的长度，返回的也是binary类型。 
</code></pre>
<p>3.写入文件：</p>
<pre><code class="language-erlang">(1)采用io:format/3方法： 
    {ok, S} = file:open(&quot;test2.dat&quot;, write). 
    io:format(S, &quot;~s~n&quot;, [&quot;Hello readers&quot;]). 
    io:format(S, &quot;~w~n&quot;, [123]). 
    %%其中的~开头的字符是一个个格式化命令，比如常见的： 

    ~c anscii码 
    ~f 浮点数 
    ~s 字符串 
    ~w Erlang term 
    ~p 与~w类似，不过当多行时将自动换行 
    ~n 显然，换行符 

（2）写入整个文件： 
    file:write_file(File, IO) 
    其中IO可以为list、integer或者binary类型 

（3）随机写入： 
    file:pwrite(F, 10, &lt;&lt;&quot;new&quot;&gt;&gt;) 
</code></pre>
<p>4.关闭文件:</p>
<pre><code class="language-erlang">file:close(F). 
</code></pre>
<p>5.目录操作：</p>
<pre><code class="language-erlang">都是linux命令风格的操作， 
cd(&quot;/home/dennis/&quot;). %进入目录 
file:list_dir(&quot;.&quot;). %列出当前目录文件 
file:make_dir(&quot;test&quot;). %创建test目录 
file:del_dir(&quot;test&quot;). %删除test目录 
</code></pre>
<p>6.获取文件信息，比如文件大小，最后修改时间等等。</p>
<pre><code class="language-erlang">%%调用file:read_file_info/1方法，该方法返回一个file_info记录类型，里面拥有文件的具体信息，比如type、size等。 
{ok, Facts} =file:read_file_info(File). 
io:format(&quot;~s~n&quot;,{Facts#file_info.type, Facts#file_info.size}). 
</code></pre>
<p>复制和删除文件：</p>
<pre><code class="language-erlang">file:copy(Source, Destination). 
file:delete(File).
</code></pre>
<p><img src="3.%E5%BA%93%E5%87%BD%E6%95%B0/stdlib//images/screenshot_1534643061547.png" alt="pic" />
<img src="3.%E5%BA%93%E5%87%BD%E6%95%B0/stdlib//images/screenshot_1534643068655.png" alt="pic" /></p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-erlang">file utilities, such as wildcard matching of filenames

filelib:ensure_dir( &quot;test/c/a.txt&quot; ). %在pwd()目录下查看是否存在存在该目录，如果不存在新建目录，不新建文件

filelib:file_size( &quot;text.txt&quot; ). 127

filelib:is_dir( &quot;test/c&quot; ). true
filelib:is_dir( &quot;text.txt&quot; ). false

filelib:is_file(&quot;test/c/&quot;). true
filelib:is_file(&quot;text.txt&quot;).true

filelib:is_regular(&quot;log/ssl.log&quot;).    true
filelib:is_regular(&quot;log/&quot;).       false

filelib:last_modified(&quot;log/ssl.log&quot;). {{2015,10,29},{17,51,38}}

filelib:wildcard(&quot;log/*&quot;). [&quot;log/ssl.log&quot;]
    filelib:wildcard(&quot;lib/*/ebin/*.beam&quot;).        
    filelib:wildcard(&quot;lib/*/src/*.?rl&quot;)        
    filelib:wildcard(&quot;lib/*/src/*.{erl,hrl}&quot;)        
    filelib:wildcard(&quot;lib/*/{src,include}/*.hrl&quot;).        
    filelib:wildcard(&quot;lib/*/{src,include}/*.{erl,hrl}&quot;)        
    filelib:wildcard(&quot;lib/**/*.{erl,hrl}&quot;)        

?     %Matches one character.
*     %Matches any number of characters up to the end of the filename, the next dot, or the next slash.
**    %Two adjacent *'s used as a single pattern will match all files and zero or more directories and subdirectories.
[Character1,Character2,...]    %Matches any of the characters listed. Two characters separated by a hyphen will match a range of characters. Example: [A-Z] will match any uppercase letter.
{Item,...}    %Alternation. Matches one of the alternatives.

filelib:wildcard(&quot;log/*&quot;, Cmd::dirname()). 

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p> 平衡二叉树</p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-erlang">server() -&gt;
    LSock = listen(),
    {ok, Sock} = gen_tcp:accept(LSock),
    {ok, Bin} = do_recv(Sock, []),
    ok = gen_tcp:close(Sock),
    Bin.

listen() -&gt;
    {ok, LSock} = gen_tcp:listen(5678, [binary, {packet, 4},
                                        {active, false}]),
    LSock.
client() -&gt;
    SomeHostInNet = &quot;localhost&quot;,
    {ok, Sock} = gen_tcp:connect(SomeHostInNet, 5678,
                                [binary, {packet, 0}]),
    ok = gen_tcp:send(Sock, &quot;Some Data&quot;),
    ok = gen_tcp:close(Sock).

do_recv(Sock, Bs) -&gt;
    case gen_tcp:recv(Sock, 0) of
        {ok, B} -&gt;
            do_recv(Sock, [Bs, B]);
        {error, closed} -&gt;
            {ok, list_to_binary(Bs)}
    end.
gen_tcp:listen中使用的options
[binary, {packet, 4}, {active, true}, {reuseaddr,true}, {delay_send,true}]
%% {active,true} 创建一个主动套字节(非阻塞)
%% {active,false} 创建一个被动套字节(阻塞)
%% {active,once} 创建一个主动套字节仅接收一条消息,如想接收下一条必须再次激活(半阻塞)
%%{packet, 4} 表示每一个消息都是从一个4字节长的头部开始 意味着每个包有4个字节的包头，代表长度
</code></pre>
<p><img src="3.%E5%BA%93%E5%87%BD%E6%95%B0/stdlib//images/screenshot_1534760515753.png" alt="pic" />
<img src="3.%E5%BA%93%E5%87%BD%E6%95%B0/stdlib//images/screenshot_1534760522141.png" alt="pic" /></p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-erlang">1、启动
方式一：启动inets应用，一个缺省profile的管理进程将被启动。
inets:start().
方式二：运行时，动态启动profile停止profile。
动态启动profile：{ok, Pid} = inets:start(httpc, [{profile, foo}]).
动态停止profile：inets:stop(httpc, foo) 或 inets:stop(httpc, Pid).
2、设置
httpc:set_options() -&lt; ok | {error, Reason}参考：http://www.erlang.org/doc/man/httpc.html#set_options-1

3、请求参考：http://www.erlang.org/doc/man/httpc.html#request-1
同步请求：{ok, {{Version, 200, ReasonPhrase}, Headers, Body}} = httpc:request(&quot;http://www.baidu.com&quot;).
等同于    {ok, {{Version, 200, ReasonPhrase}, Headers, Body}} = httpc:request(get, {&quot;http://www.baidu.com&quot;, []}, [], []).
异步请求： {ok, RequestId} = httpc:request(get, {&quot;http://www.baidu.com&quot;, []}, [], [{sync, false}]),
           receive {http, {RequestId, Result}} -&lt; ok after 500 -&lt; error end.
4.httpc:request(get, {Url, Header}, [{timeout, ?TimeOut}], [{sync, false}]).
  {ok, {{_Protocol, 200, _State}, _Head, Html}}
  {ok, {{_Protocol, 302, _State}, _Head, Html}}
  {error, Reason}
5.httpc:request(post, {Url, Header,Content_type, Post }, [{timeout, ?TimeOut}], []).
  {ok, {{_Protocol, 200, _State}, _Head, Html}
  {ok, {{_Protocol, 302, _State}, _Head, Html}
  {error, Reason}
Post = &quot;a=b&amp;c=d&quot;

inets:start(),
httpc:set_options([{max_keep_alive_length,500},{max_sessions,100},{nodelay,true},{reuseaddr,true}]),  
参数详解:
    max_keep_alive_length:  在同一条http连接上允许发送的最大包数，默认为5，超过5个包，就会重连
    max_sessions:跟目标服务器之间最大的并行http连接数目,大大的增加了数据上行吞吐量
    nodelay_true:开启linux中的TCP_NODELAY参数，请搜索:TCP_NODELAY 40毫秒延迟
    reuseaddr:允许系统复用port,对于高吞吐的系统，这个参数很重要,请搜索:linux port 复用
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-erlang">inet:getifaddrs() 本机所有网卡
inet:getif() 本机网卡ip地址
inet:peername(State#state.socket)

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-erlang">init_parse:ntoa( IP:tuple() ) -&gt; IP:string()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-erlang">init:get_argument( home ). -&gt; {ok,[[&quot;C:\\Users\\Administrator&quot;]]}
init:stop().关闭所有的Erlang Application，包括终端
init:i(). 列出网络的连接情况
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p><img src="3.%E5%BA%93%E5%87%BD%E6%95%B0/stdlib//images/screenshot_1534761017270.png" alt="pic" /></p>
<pre><code class="language-erlang">io:get_line
io:get_line( &quot;gissa line&gt;&quot; ). 
gissa line&gt; fdfdsfdfdsfds. 
 &quot;fdfdsfdfdsfds.\n&quot; 
io:get_chars
io:get_chars( &quot;me&gt;&quot;,4 ).
 me&gt;fdfdfdfd.
 &quot;fdfd&quot;
 fdfd
io:read( &quot;ok,aa&gt;&gt;&quot; )
io:read( &quot;ok,aa&gt;&gt;&quot; ). 
ok,aa&gt;&gt;atom. 
{ok,atom}.
io:fwrite(&quot;843 Error&quot;).
io:fwrite(&quot;843 Error&quot;).
843 Errorok
io_lib:format(&quot;~32.16.0b&quot;, [Mac])).
格式化&quot;~32.16.0b&quot;的含义,输出的用长度length为32，转化为16进制，转化时如果遇到空的位，使&quot;0&quot;填充，
b输出的英文小写字母，B输出大写字母

%完整的格式化&quot;~Length.P.PadC&quot;
    Length输出宽度
    P输出精度
    Pad填充字符
    C是控制字符
io:format( &quot;~c~p~n~f~e~w~p~w~p~B&quot; )

~ The character ~ is written.
c  参数必须是ASCII码，控制输出的精度 io:format( &quot;|~-10.1c|&quot;, [$c] ). io:format( &quot;|~10.1c|&quot;, [$c] ).
f 参数必须是float, 输出一个有6个小数位的浮点数
e [-]d.ddde+-ddd, 输出一个以科学记数法表示的总共6位的浮点数

g 
s 字符串
w Writes data with the standard syntax. 
p 相比w更加格式化的输出
W 
P 
B 2..36进制输出一个integer,默认10进制
X 
#
b
x
+
n换行符
i
io:format( &quot;~ts~n&quot;, [&quot;余健&quot;] ) -&gt; &quot;余健&quot;


%%1. 打印浮点型
lists:flatten(io_lib:format(&quot;~.*..f&quot;, [2, S]));
3&gt; lists:flatten(io_lib:format(&quot;~.*..f&quot;, [2, 192.2225])).
&quot;192.22&quot;
4&gt; lists:flatten(io_lib:format(&quot;~.*..f&quot;, [3, 192.2225])).
&quot;192.223&quot;
5&gt; lists:flatten([io_lib:format(&quot;~8.2.0B,&quot;, [L]) || L &lt;- [1,2,3]]).
&quot;00000001,00000010,00000011,&quot;
6&gt; lists:flatten([io_lib:format(&quot;~2.16.0B &quot;, [L]) || L &lt;- [1,2,3]]).
&quot;01 02 03 &quot;.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>lists模块的reverse/1经过高度优化，可以在重排lists元素顺序时考虑使用</li>
<li>如果两个list都拥有很多数据，那么请不要使用'--'，而是将数据转化到ordsets，然后调用ordsets:substract/2</li>
<li>调用lists:flatten/1可以将list扁平化，这个操作代价很大，比'++'还要昂贵。下面这些时候我们可以避免：</li>
</ul>
<p>将数据发送给port时
调用list_bo_binary/1和iolist_to_binary前</p>
<pre><code class="language-erlang">1.all(F, List) -&gt; boolean()
    &gt; lists:all( fun(X) -&gt; X == 1 end, [1,1,1,1,1] ) -&gt; true
    &gt; lists:all( fun(X) -&gt; X == 1 end, [1,1,1,1,2] ) -&gt; false.
2.any(Pred, List) -&gt; boolean()
    &gt; lists:any( fun(X) -&gt; X == 1 end, [2,2,2,2,2] ) -&gt; false
    &gt; lists:any( fun(X) -&gt; X == 1 end, [1,2,2,2,2] ) -&gt; true.
3.append(ListOfLists) -&gt; List1
    &gt; lists:append([[1, 2, 3], [a, b], [4, 5, 6]]) -&gt; [1,2,3,a,b,4,5,6]
  append(List1, List2) -&gt; List3
    &gt; lists:append(&quot;abc&quot;, &quot;def&quot;) -&gt; &quot;abcdef&quot;
4.concat(Things) -&gt; string()
    &gt; lists:concat([doc, '/', file, '.', 3]) -&gt; &quot;doc/file.3&quot;
5.delete(Elem, List1) -&gt; List2
    &gt; lists:delete( 1, [1,2,3,4,5,1] ) -&gt; [2,3,4,5,1].
6.dropwhile(Pred, List1) -&gt; List2
    &gt; lists:dropwhile( fun(X) -&gt; X==1 end, [1,2,3,4] ) -&gt; [2,3,4].
7.duplicate(N, Elem) -&gt; List
    &gt; lists:duplicate(5, xx).[xx,xx,xx,xx,xx]
8.filter(Pred, List1) -&gt; List2
    &gt; lists:filter（fun(X) -&gt; X &lt; 3 end, [1,2,3,4,5,6,] ) -&gt; [1,2].
9.flatlength(DeepList) -&gt; integer() &gt;= 0
    &gt; lists:flatlength( [[1], [2,3]] ) -&gt; 3.
    &gt; lists:flatlength([[1], [2,3], [4], 5]) -&gt; 5.
    去除中括号后所有的项数
10.flatmap(Fun, List1) -&gt; List2
    &gt; lists:flatmap(fun(X)-&gt;[X,X] end, [a,b,c]).[a,a,b,b,c,c]
11.flatten(DeepList) -&gt; List
    &gt; lists:flatten( [1,[2], [3, [4, [5,6]]]] ) -&gt; [1,2,3,4,5,6]
    &gt; lists:flatten( [&quot;a&quot;,[&quot;b&quot;], [&quot;c&quot;, [&quot;d&quot;, [&quot;e&quot;,&quot;f&quot;]]]] ) -&gt; &quot;abcdef&quot;
12.flatten(DeepList, Tail) -&gt; List
    &gt; lists:flatten( [&quot;a&quot;,[&quot;b&quot;], [&quot;c&quot;, [&quot;d&quot;, [&quot;e&quot;,&quot;f&quot;]]]], &quot;qqq&quot; ) -&gt; &quot;abcdefqqq&quot;
13. foldl(Fun, Acc0, List) -&gt; Acc1
    &gt; lists:foldl(fun(X, Sum) -&gt; X + Sum end, 0, [1,2,3,4,5]).15
    &gt; lists:foldl(fun(X, Prod) -&gt; X * Prod end, 1, [1,2,3,4,5]).120
    &gt; lists:foldl(  fun( X, A ) -&gt;X++&quot;a&quot;++A end, [], [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;] ) -&gt; &quot;5a4a3a2a1a&quot;
    &gt; lists:foldl(  fun( X, A ) -&gt;{X++&quot;a&quot;, A}end, [], [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;] ) -&gt; {&quot;5a&quot;,{&quot;4a&quot;,{&quot;3a&quot;,{&quot;2a&quot;,{&quot;1a&quot;,[]}}}}}
    &gt; lists:foldl(  fun( X, A ) -&gt;[X++&quot;a&quot;| A] end, [], [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;] ) -&gt; [&quot;5a&quot;,&quot;4a&quot;,&quot;3a&quot;,&quot;2a&quot;,&quot;1a&quot;]
14.foldr(Fun, Acc0, List) -&gt; Acc1
    &gt; lists:foldr(  fun( X, A ) -&gt;[X++&quot;a&quot;| A] end, [], [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;] ) -&gt; [&quot;1a&quot;,&quot;2a&quot;,&quot;3a&quot;,&quot;4a&quot;,&quot;5a&quot;]
    &gt; P = fun(A, AccIn) -&gt; io:format(&quot;~p &quot;, [A]), AccIn end.#Fun
    &gt; lists:foldl(P, void, [1,2,3]). 1 2 3 void
    &gt; lists:foldr(P, void, [1,2,3]).3 2 1 void
15.foreach(Fun, List) -&gt; ok
    对列表List的每一个元素执行fun函数，并且成功返回ok
16.keydelete(Key, N, TupleList1) -&gt; TupleList2
    lists:keydelete(Key, 1, [{Key,V},{...}]).
17.keyfind(Key, N, TupleList) -&gt; Tuple | false
    lists:keyfind(Key, 1, [{Key,V},{...}]).
18.keymap(Fun, N, TupleList1) -&gt; TupleList2
    &gt; Fun = fun(Atom) -&gt; atom_to_list(Atom) end.#Fun2
    &gt; lists:keymap(Fun, 2, [{name,jane,22},{name,lizzie,20},{name,lydia,15}]).[{name,&quot;jane&quot;,22},{name,&quot;lizzie&quot;,20},{name,&quot;lydia&quot;,15}]
19.keymember(Key, N, TupleList) -&gt; boolean()
    &gt; lists:keymember( 1, 2, [{2,3},{4,5},{1,2}] ) -&gt; false.
20.keymerge(N, TupleList1, TupleList2) -&gt; TupleList3
    &gt; lists:keymerge( 3, [{a,b,c},{c,d,e},{e,f,g}], [{a,b,1},{c,d,2},{e,f,3}] ) -&gt; [{a,b,1},{c,d,2},{e,f,3},{a,b,c},{c,d,e},{e,f,g}]
    每一项元组的第3项来排序
21.keyreplace(Key, N, TupleList1, NewTuple) -&gt; TupleList2
    &gt; lists:keyreplace( 1, 1, [{1,2},{3,4}], {1,5} ) -&gt; [{1,5},{3,4}]
22.keysearch(Key, N, TupleList) -&gt; {value, Tuple} | false
    &gt; lists:keysearch( 1, 2, [{1,2},{3,4},{5,1}] ) -&gt; {value,{5,1}}
    The function lists:keyfind/3 (introduced in R13A) is in most cases more convenient.
23.keysort(N, TupleList1) -&gt; TupleList2
    &gt; lists:keysort( 2, [{5,6},{3,4},{1,2},{7,8}] ) -&gt; [{1,2},{3,4},{5,6},{7,8}]
24.keystore(Key, N, TupleList1, NewTuple) -&gt; TupleList2
    &gt; lists:keystore( 1, 1, [{1,2},{3,4},{5,6}], {1,7} ) -&gt; [{1,7},{3,4},{5,6}]
    &gt; lists:keystore( 6, 1, [{1,2},{3,4},{5,6}], {1,7} ) -&gt; [{1,2},{3,4},{5,6},{1,7}]
25.keytake(Key, N, TupleList1) -&gt; {value, Tuple, TupleList2} | false
    &gt; lists:keytake( 1, 1, [{1,2},{3,4}] ) -&gt; {value,{1,2},[{3,4}]}
    &gt; lists:keytake( 2, 1, [{1,2},{3,4}] ) -&gt; false
26.last(List) -&gt; Last
    &gt; lists:last( [1,2,3,4,5] ) -&gt; 5
27.map(Fun, List1) -&gt; List2
    将函数F应用到 List1 的每一个元素上（性能问题）
28.mapfoldl(Fun, Acc0, List1) -&gt; {List2, Acc1}
    &gt; lists:mapfoldl(fun(X, Sum) -&gt; {2*X, X+Sum} end,0, [1,2,3,4,5]) -&gt; {[2,4,6,8,10],15}
29.mapfoldr(Fun, Acc0, List1) -&gt; {List2, Acc1}
    &gt; lists:mapfoldr(fun(X, Sum) -&gt; {2*X, X+Sum} end,0, [1,2,3,4,5]) -&gt; {[2,4,6,8,10],15}
30.max(List) -&gt; Max
    &gt; lists:max( [a,b,c,d,e] ) -&gt; e
31.member(Elem, List) -&gt; boolean()
    &gt; lists:member( &quot;a&quot;, [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;] ) -&gt; true
32.merge(ListOfLists) -&gt; List1
    &gt; lists:merge( [[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;], [[1,2,3]]] ) -&gt; [[1,2,3],&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]
    效果类似append函数
33.merge(List1, List2) -&gt; List3
    &gt; lists:merge( [1,2,3], [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;] ) -&gt; [1,2,3,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]
34.merge(Fun, List1, List2) -&gt; List3
    &gt; lists:merge( fun(X,Y) -&gt; X&lt;Y end, [1,12,13,55,44,33,22,11], [&quot;a&quot;, &quot;ab&quot;, &quot;ac&quot;] ) -&gt; [1,12,13,55,44,33,22,11,&quot;a&quot;,&quot;ab&quot;,&quot;ac&quot;]
Returns the sorted list formed by merging List1 and List2. Both List1 and List2 must be sorted according to the ordering functionFun prior to evaluating this function. Fun(A, B) should return true if A compares less than or equal to B in the ordering, false otherwise. When two elements compare equal, the element from List1 is picked before the element from List2.
35.merge3(List1, List2, List3) -&gt; List4
    &gt; lists:merge3( [1,2,3],[1,2,3],[4,5,6] ) -&gt; [1,1,2,2,3,3,4,5,6]
36.min(List) -&gt; Min
    &gt; lists:min( [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;] ) -&gt; &quot;a&quot;
37.nth(N, List) -&gt; Elem
    &gt; lists:nth(3, [a, b, c, d, e]).c
38.nthtail(N, List) -&gt; Tail
    &gt; lists:nthtail(3, [a, b, c, d, e]) -&gt; [d,e]
    &gt; tl(tl(tl([a, b, c, d, e]))) -&gt; [d,e]
    &gt; lists:nthtail(0, [a, b, c, d, e]) -&gt; [a,b,c,d,e]
    &gt; lists:nthtail(5, [a, b, c, d, e]) -&gt; []
39.partition(Pred, List) -&gt; {Satisfying, NotSatisfying}
    &gt; lists:partition(fun(A) -&gt; A rem 2 == 1 end, [1,2,3,4,5,6,7]).{[1,3,5,7],[2,4,6]}
    &gt; lists:partition(fun(A) -&gt; is_atom(A) end, [a,b,1,c,d,2,3,4,e]).{[a,b,c,d,e],[1,2,3,4]}
40.prefix(List1, List2) -&gt; boolean()
    &gt; lists:prefix( [1,2,3], [1,2,3,4,5] ) -&gt; true
    &gt; lists:prefix( &quot;我们&quot;, &quot;我们都有一个家&quot; ) -&gt; true
41.reverse(List1) -&gt; List2
    reverse(List1, Tail) -&gt; List2
    &gt; lists:reverse([1, 2, 3, 4], [a, b, c]).[4,3,2,1,a,b,c]
42.seq(From, To) -&gt; Seq
    seq(From, To, Incr) -&gt; Seq
    &gt; lists:seq(From, To, Incr)) == (To-From+Incr) div Incr
    &gt; lists:seq(1, 10).[1,2,3,4,5,6,7,8,9,10]
    &gt; lists:seq(1, 20, 3) -&gt; [1,4,7,10,13,16,19]
    &gt; lists:seq(1, 0, 1) -&gt; []
    &gt; lists:seq(10, 6, 4) -&gt; []
    &gt; lists:seq(1, 1, 0) -&gt; [1]
43.sort(List1) -&gt; List2
   sort(Fun, List1) -&gt; List2
44.split(N, List1) -&gt; {List2, List3}
    &gt; lists:split( 4, [1,2,3,3,3,34,5,65] ) -&gt; {[1,2,3,3],[3,34,5,65]}
45.splitwith(Pred, List) -&gt; {List1, List2}
   splitwith(Pred, List) -&gt; {takewhile(Pred, List), dropwhile(Pred, List)}.
    &gt; lists:splitwith(fun(A) -&gt; A rem 2 == 1 end, [1,2,3,4,5,6,7]) -&gt; {[1],[2,3,4,5,6,7]}
    &gt; lists:splitwith(fun(A) -&gt; is_atom(A) end, [a,b,1,c,d,2,3,4,e]) -&gt; {[a,b],[1,c,d,2,3,4,e]}
    &gt; lists:splitwith(fun(A) -&gt; is_atom(A) end, [a,b,c,d,1,2,3,4,e]) -&gt; {[a,b,c,d],[1,2,3,4,e]}
46.sublist(List1, Len) -&gt; List2
   sublist(List1, Start, Len) -&gt; List2
    &gt; lists:sublist([1,2,3,4], 2, 2).[2,3]
    &gt; lists:sublist([1,2,3,4], 2, 5).[2,3,4]
    &gt; lists:sublist([1,2,3,4], 5, 2).[]
47.subtract(List1, List2) -&gt; List3
    &gt; lists:subtract(&quot;123212&quot;, &quot;212&quot;).&quot;312&quot;.
   lists:subtract(A, B) is equivalent to A -- B.
WarUsing ordered lists and ordsets:subtract/2 is a much better choice if both lists are long.
48.suffix(List1, List2) -&gt; boolean()
    &gt; lists:suffix( &quot;aa&quot;, &quot;bbccaa&quot; ) -&gt; true
49.sum(List) -&gt; number()
    &gt; lists:sum( [1,2,3,4] ) -&gt; 10
50.takewhile(Pred, List1) -&gt; List2
    lists:takewhile( fun(X) -&gt; X==1 end, [1,2,3,4,5] ) -&gt; [1]
51.ukeymerge(N, TupleList1, TupleList2) -&gt; TupleList3
    &gt; lists:ukeymerge( 3, [{a,b,c},{c,d,e},{e,f,g}], [{a,b,1},{c,d,2},{e,f,3}] ) -&gt; [{a,b,1},{c,d,2},{e,f,3},{a,b,c},{c,d,e},{e,f,g}]
    &gt; lists:ukeymerge( 2, [{a,b},{c,d},{e,f}], [{a,b},{c,d},{e,f}] ) -&gt; [{a,b},{c,d},{e,f}]
    排序去重复
52.ukeysort(N, TupleList1) -&gt; TupleList2
    u表示去重复？？？
53.umerge(ListOfLists) -&gt; List1
   umerge(List1, List2) -&gt; List3
   umerge(Fun, List1, List2) -&gt; List3
   umerge3(List1, List2, List3) -&gt; List4
54.unzip(List1) -&gt; {List2, List3}
    un表示功能相反？？
    &gt; lists:unzip( [{1,2},{3,4},{5,6}]) -&gt; {[1,3,5],[2,4,6]}
  unzip3(List1) -&gt; {List2, List3, List4}
    &gt; lists:unzip3( [{1,2,3},{3,4,4},{5,6,6}] ) -&gt; {[1,3,5],[2,4,6],[3,4,6]}
55.usort(List1) -&gt; List2
    排序去重复
   usort(Fun, List1) -&gt; List2
56.zip(List1, List2) -&gt; List3
    &gt; lists:zip( [1,2,3],[4,5,6] ) -&gt; [{1,4}, {2,5}, {3,6}]
   zip3(List1, List2, List3) -&gt; List4
    &gt; lists:zip3( [1,2,3], [4,5,6], [7,8,9] ) -&gt; [{1,4,7},{2,5,8},{3,6,9}]
57.zipwith(Combine, List1, List2) -&gt; List3
   zipwith(fun(X, Y) -&gt; {X,Y} end, List1, List2) is equivalent to zip(List1, List2).
    &gt; lists:zipwith(fun(X, Y) -&gt; X+Y end, [1,2,3], [4,5,6]).[5,7,9]
   zipwith3(Combine, List1, List2, List3) -&gt; List4
   zipwith3(fun(X, Y, Z) -&gt; {X,Y,Z} end, List1, List2, List3) is equivalent to zip3(List1, List2, List3).
    &gt; lists:zipwith3(fun(X, Y, Z) -&gt; X+Y+Z end, [1,2,3], [4,5,6], [7,8,9]).[12,15,18]
    &gt; lists:zipwith3(fun(X, Y, Z) -&gt; [X,Y,Z] end, [a,b,c], [x,y,z], [1,2,3]).[[a,x,1],[b,y,2],[c,z,3]]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-erlang">1.find(Key, Map) -&gt; {ok, Value} | error
    Map = #{&quot;hi&quot; =&gt; 42},
    Key = &quot;hi&quot;,
    maps:find(Key,Map).
    {ok,42}
2.fold(Fun, Init, Map) -&gt; Acc
    Fun = fun(K,V,AccIn) when is_list(K) -&gt; AccIn + V end,
    Map = #{&quot;k1&quot; =&gt; 1, &quot;k2&quot; =&gt; 2, &quot;k3&quot; =&gt; 3},
    maps:fold(Fun,0,Map).
3.from_list(List) -&gt; Map
    List = [{&quot;a&quot;,ignored},{1337,&quot;value two&quot;},{42,value_three},{&quot;a&quot;,1}],
    maps:from_list(List).
    #{42 =&gt; value_three,1337 =&gt; &quot;value two&quot;,&quot;a&quot; =&gt; 1}
4.get(Key, Map) -&gt; Value
    Key = 1337,
    Map = #{42 =&gt; value_two,1337 =&gt; &quot;value one&quot;,&quot;a&quot; =&gt; 1},
    maps:get(Key,Map).
    &quot;value one&quot;
5.is_key(Key, Map) -&gt; boolean()
    &gt; Map = #{&quot;42&quot; =&gt; value}.
        #{&quot;42&quot;&gt; =&gt; value}
    &gt; maps:is_key(&quot;42&quot;,Map).
        true
    &gt; maps:is_key(value,Map).
        false
6.keys(Map) -&gt; Keys
    &gt; Map = #{42 =&gt; value_three,1337 =&gt; &quot;value two&quot;,&quot;a&quot; =&gt; 1},
    maps:keys(Map).
    [42,1337,&quot;a&quot;]
7.map(Fun, Map1) -&gt; Map2
    &gt; Fun = fun(K,V1) when is_list(K) -&gt; V1*2 end,
    Map = #{&quot;k1&quot; =&gt; 1, &quot;k2&quot; =&gt; 2, &quot;k3&quot; =&gt; 3},
    maps:map(Fun,Map).
    #{&quot;k1&quot; =&gt; 2,&quot;k2&quot; =&gt; 4,&quot;k3&quot; =&gt; 6}
8.merge(Map1, Map2) -&gt; Map3
    &gt; Map1 = #{a =&gt; &quot;value_one&quot;, b =&gt; &quot;value_two&quot;},
    Map2 = #{a =&gt; 1, c =&gt; 2},
    maps:merge(Map1,Map2).
    #{a =&gt; 1,b =&gt; &quot;value_two&quot;,c =&gt; 2}
9.new() -&gt; Map
    &gt; maps:new().
      #{}
10.put(Key, Value, Map1) -&gt; Map2
    &gt; Map = #{&quot;a&quot; =&gt; 1}.
    #{&quot;a&quot; =&gt; 1}
    &gt; maps:put(&quot;a&quot;, 42, Map).
    #{&quot;a&quot; =&gt; 42}
    &gt; maps:put(&quot;b&quot;, 1337, Map).
    #{&quot;a&quot; =&gt; 1,&quot;b&quot; =&gt; 1337}
11.remove(Key, Map1) -&gt; Map2
    &gt; Map = #{&quot;a&quot; =&gt; 1}.
    #{&quot;a&quot; =&gt; 1}
    &gt; maps:remove(&quot;a&quot;,Map).
    #{}
    &gt; maps:remove(&quot;b&quot;,Map).
    #{&quot;a&quot; =&gt; 1}
12.size(Map) -&gt; integer() &gt;= 0
    &gt; Map = #{42 =&gt; value_two,1337 =&gt; &quot;value one&quot;,&quot;a&quot; =&gt; 1},
    maps:size(Map).
    3
13.to_list(Map) -&gt; [{Key, Value}]
    &gt; Map = #{42 =&gt; value_three,1337 =&gt; &quot;value two&quot;,&quot;a&quot; =&gt; 1},
    maps:to_list(Map).
    [{42,value_three},{1337,&quot;value two&quot;},{&quot;a&quot;,1}]
14.update(Key, Value, Map1) -&gt; Map2
    &gt; Map = #{&quot;a&quot; =&gt; 1}.
    #{&quot;a&quot; =&gt; 1}
    &gt; maps:update(&quot;a&quot;, 42, Map).
    #{&quot;a&quot; =&gt; 42}
15.values(Map) -&gt; Keys
    &gt; Map = #{42 =&gt; value_three,1337 =&gt; &quot;value two&quot;,&quot;a&quot; =&gt; 1},
    maps:values(Map).
    [value_three,&quot;value two&quot;,1]
16.without(Ks, Map1) -&gt; Map2
    &gt; Map = #{42 =&gt; value_three,1337 =&gt; &quot;value two&quot;,&quot;a&quot; =&gt; 1},
    Ks = [&quot;a&quot;,42,&quot;other key&quot;],
    maps:without(Ks,Map).
    #{1337 =&gt; &quot;value two&quot;}

#{key := Key} = Map

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>MODULE SUMMARY</p>
<p>Functions for Manipulating Sets as Ordered Lists</p>
<p>DESCRIPTION</p>
<pre><code>Sets are collections of elements with no duplicate elements. An ordset is a representation of a set, where an ordered list is used to store the elements of the set. An ordered list is more efficient than an unordered list.

This module provides exactly the same interface as the module sets but with a defined representation. One difference is that while sets considers two elements as different if they do not match (=:=), this module considers two elements as different if and only if they do not compare equal (==).
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-erlang">os:type().
os:cmd(Cmd).
os:cmd(&quot;file --mime-encoding -b &quot; ++ FullFile)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-erlang">proplists:get_value(1,[{1,2},{3,4}], none) -&gt; 2
proplists:get_value(1,[{5,6},{3,4}], none) -&gt; none
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="模块-qlc"><a class="header" href="#模块-qlc">模块 QLC</a></h2>
<p>模块描述
Mnesia、ets、dets、etc查询接口</p>
<p>DESCRIPTION
为Mnesia、ets、dets或者其他的数据类型提供一个迭代器遍历的查询接口</p>
<p>qlc模块为【QLC Tables】 实现一个快速查询接口，典型的【QLC Tables】包括ets、dets和mnesia表。它也支持用户定义的表，查看Implementing a QLC table部分。
一个查询开始与【QLCs】,【Qlc Tables】中一个查询的答案取决于QLCs约束</p>
<pre><code class="language-erlang">1.Erlang有一个类似SQL的数据检索机制，叫做QLC（Query Interface to Mnesia, ETS, Dets, etc），可用于对Mnesia、ETS/DETS的数据表进行数据检索，包括常见的按指定域排序（ORDER BY）、按条件筛选（WHERE...）以及限制返回的结果长度（COUNT）。看个简单的例子：
-module(test).
-export([start/0]).
-include_lib(&quot;stdlib/include/qlc.hrl&quot;).
start()-&gt;
    QH1 = qlc:q([{X, Y}|| X &lt;-[8,3,6,2], Y &lt;-[b,a,c]]),
     %以第一个值作为key进行排序
    QH2 = qlc:keysort(1, QH1,[{order, ascending}]),
    QC = qlc:cursor(QH2),
     %获取前两条记录
    qlc:next_answers(QC, 2),
     %获取剩余的其他记录
    qlc:next_answers(QC, all_remainning).
2。再看一个国外网站上的案例：
Use QLC's {unique, true} option (See QLC documentation for more info).
I created a mnesia table, called test, with bag semantics. Each row consists of the table name, a Key and a Value, so my rows looked like:
1. test, 1, 1
2. test, 2, 1
3. test, 2, 2
4. test, 3, 1
5. test, 3, 2
6. test, 3, 3
... etc.
Then this simple module illustrates my approach. Notice that you have to include the qlc library and that, in my example, I am selecting distinct Keys.
-module(test).
-export([select_distinct/0]).
-include_lib(&quot;stdlib/include/qlc.hrl&quot;).
select_distinct()-&gt;
    QH = qlc:q([K ||{_TName, K, _V}&lt;- mnesia:table(test)],{unique, true}),
    F = fun()-&gt; qlc:eval(QH)end,
    {atomic,Result}= mnesia:transaction(F),
    Result.
Compiling and running
&gt; c(&quot;/home/jim/test&quot;, [{outdir, &quot;/home/jim/&quot;}]).
&gt; test:select_distinct().
&gt; [4,1,2,3,5]
If you wanted sorted output then use the following version of the QH = ... line above
QH = qlc:sort(qlc:q([K ||{_TName, K, _V}&lt;- mnesia:table(test)],{unique, true})),
If you wanted to select distinct values, the following would work:
QH = qlc:sort(qlc:q([V ||{_TName, _K, V}&lt;- mnesia:table(test)],{unique, true})),
Again, the code is just to illustrate an approach
来自：
http://stackoverflow.com/questions/8706867/erlang-mnesia-equivalent-to-select-distinct-id-from-table
3.另外一个案例：
It is not always easy to do complicated queries over ETS tables or mnesia.
The official syntax to make queries with select/2 is really cryptic.
Here is an example from the official Erlang docs. The query returns the name of each male person aged more then 30.
 1. MatchHead = #person{name='$1', ***=male, age='$2', _='_'},
 2. Guard={'&gt;','$2', 30},
 3. Result='$1',
 4. mnesia:select(Tab,[{MatchHead,[Guard],[Result]}]),
Les critères sont exprimé avec des $. L'ensemble devient assez indigeste pour des cas plus compliqué.
De plus il est impossible de réaliser des opérations basiques dans d'autres moteurs de base de données, comme trier le résultat.
Un module existe pourtant pour améliorer la lisibilité des requêtes. QLC pour Query List Comprehension. Il supporte de base mnesia, ets et dets.
Voici une réécriture de l'exemple précédent
 1. Query= qlc:q([Person#person.name|| Person &lt;- mnesia:table(Tab), Person#person.*** == male, Person#person.age &gt; 30]),
Dans ce cas, la requête est exprimé sous la forme d'une list comprehension. Les critères sont exprimé d'une manière intelligible dans la deuxième partie de la list comprehension.
Si vous voulez exécuter cette requête dans mnesia, vous devez le faire dans une transaction.
 1. -include_lib(&quot;stdlib/include/qlc.hrl&quot;)
 2. Transaction= fun()-&gt;
 3. Query= qlc:q([Person#person.name|| Person &lt;- mnesia:table(Tab), Person#person.*** == male, Person#person.age &gt; 30]),
 4.     qlc:eval(Query)
 5. end,
 6. mnesia:transaction(Transaction),
Pour trier d'une manière efficace, qlc fournit qlc:sort.
 1. -include_lib(&quot;stdlib/include/qlc.hrl&quot;)
 2. Transaction= fun()-&gt;
 3. Query= qlc:q([Person#person.name|| Person &lt;- mnesia:table(Tab), Person#person.*** == male, Person#person.age &gt; 30]),
 4. Order= fun(A, B)-&gt;
 5.         B#person.age &gt; A#person.age
 6. end,
 7.     qlc:eval(qlc:sort(Query,[order,Order]))
 8. end,
 9. mnesia:transaction(Transaction),
Je n'ait pas encore exploré toutes les fonctionnalités de QLC, mais la syntaxe que ce module offre m'a convaincu de l'utiliser le plus possible. La maintenance des requêtes devient beaucoup plus facile.
Une dernière chose, il est possible de créer ses propres modules utilisable avec QLC. Vous pouvez ainsi proposer une syntaxe de recherche sympathique avec un backend totalement différent de ets ou mnesia.

来自 &lt;http://blog.chinaunix.net/uid-429659-id-3357001.html&gt; 

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-erlang">Queue:列队

1.queue:new(). -&gt; {[],[]}
2.queue:in( {1,2}, {[],[]} ) -&gt; {[{1,2}],[]}
  queue:in( {a,b}, {[{1,2}],[]} ) -&gt; {[{a,b}],[{1,2}]}
  queue:in( {3,4}, {[{a,b}],[{1,2}]} ) -&gt; {[{3,4},{a,b}],[{1,2}]}
3.queue:in_r( {c,d}, {[{3,4},{a,b}],[{1,2}]} ) -&gt; {[{3,4},{a,b}],[{c,d},{1,2}]}.
4.queue:out( {[{3,4},{a,b}],[{c,d},{1,2}]} ) -&gt; {{value,{c,d}},{[{3,4},{a,b}],[{1,2}]}}
5.queue:out_r( {[{3,4},{a,b}],[{c,d},{1,2}]} ) -&gt; {{value,{3,4}},{[{a,b}],[{c,d},{1,2}]}}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-erlang">1.random:uniform(  ) -&gt; float(). 随机浮点数
2.random:uniform( N::integer() ) -&gt; integer() -&gt;小于N的随机整数
3.random:seed() -&gt; ran().  用默认值产生随机数种子。
4.用法
            Time = erlang:now(),
            random:seed( Time ),
            Ran1 = random:seed( Time ),
            {New_Num, _} = random:uniform_s( Num, Ran1 ),

看它的代码实现：
[plain]view plaincopy
 uniform() -&lt;  
     {A1, A2, A3} = case get(random_seed) of  
                undefined -&lt; seed0();  
                Tuple -&lt; Tuple  
            end,  
     B1 = (A1*171) rem 30269,  
     B2 = (A2*172) rem 30307,  
     B3 = (A3*170) rem 30323,  
     put(random_seed, {B1,B2,B3}),  
     R = A1/30269 + A2/30307 + A3/30323,  
     R - trunc(R).  
每次调用会更新进程字典里的random_seed变量，这样在同一个进程内每次调用random:uniform()时，随机数种子都不同，所以生成的随机数都不一样（调用完random:uniform()后，可以用get(random_seed)查看更新后的种子值）。
但是如果是不同的进程分别调用random:uniform()，因为随机种子更新的算法是一样的，所以每次各进程的随机数种子也是相同的，从而生成的随机数也是一样的，要想让不同进程生成的随机数不同，要手动为每个进程设置不同的种子，常用的是用erlang:now，比如：
[plain]view plaincopy
 random:seed(erlang:now()),  
 random:uniform().  
不过如果每个进程调用random:seed(erlang:now())太接近，种子值会比较接近，生成的随机数也会比较接近，更好的方法是用一个单独的进程来生成种子，保证每次的种子值相差比较大：
[plain]view plaincopy
 Seed = {random:uniform(99999), random:uniform(999999), random:uniform(999999)}  
然后每次调用random:uniform()前从该种子生成进程获取最新的种子值，seed()之。
1case get(random_seed) of
2  undefined -&gt;
3   random:seed(now());
4  _Tuple -&gt;
5   ok
6 end,
7 random:uniform(Max).

1.&lt;&lt;A:32,B:32,C:32&gt;&gt; = crypto:strong_rand_bytes(12) .
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-erlang">9&gt; re:run(&quot;The sick quick brown fox.&quot;, &quot;ick&quot;, [global]).
    {match,[[{5,3}],[{11,3}]]}
10&gt; re:replace(&quot;The quick brown fox.&quot;, &quot;brown&quot;, &quot;red&quot;).
    [&lt;&lt;&quot;The quick &quot;&gt;&gt;,&lt;&lt;&quot;red&quot;&gt;&gt;|&lt;&lt;&quot; fox.&quot;&gt;&gt;]
11&gt; re:replace(&quot;The quick brown fox.&quot;, &quot;brown&quot;, &quot;red&quot;, [{return, list}]).
    &quot;The quick red fox.&quot;
27&gt; re:run(&quot;E-mail: xyz@pdq.com&quot;, &quot;[a-zA-Z0-9]+@[a-zA-Z0-9]+\.[a-z]{2,3}&quot;).
    {match,[{8,11}]}
28&gt; re:split(&quot;this/is/my/path&quot;,&quot;/&quot;).
    [&lt;&lt;&quot;this&quot;&gt;&gt;,&lt;&lt;&quot;is&quot;&gt;&gt;,&lt;&lt;&quot;my&quot;&gt;&gt;,&lt;&lt;&quot;path&quot;&gt;&gt;]
29&gt;  {_, P} = re:compile(&quot;[a-zA-Z0-9]+@[a-zA-Z0-9]+\.[a-z]{2,3}&quot;).
    {ok,{re_pattern,0,0,&lt;&lt;69,82,67,80,164,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,64,...&gt;&gt;}}
30&gt; re:run(&quot;E-mail: xyz@pdq.com&quot;, P).
    {match,[{8,11}]}
get_url(String) -&gt;
    HTTP_regex = &quot;^(H|h)(T|t)(T|t)(P|p)(S|s)*://&quot;,    
    case re:run(String, HTTP_regex) of        
        nomatch    -&gt; not_url;        
        {match, _} -&gt; get_url1(String, [])    
   end.
31.re:run( &quot;fdsfdsfw1990.10.18fdsfsd&quot;, &quot;\\d{4}.\\d{2}.\\d{2}&quot; ).
   {match,[{8,10}]}
32.re:replace(&quot;The quick brown fox.&quot;, &quot;brown&quot;, &quot;red&quot;, [{return, list}]).
    &quot;The quick red fox.&quot;
33.re:split( Html, &quot;&lt;script[^&gt;]*?&gt;.*?&lt;/script&gt;&quot;,[{return,list},trim] ).
34. HtmlString2 =  string:join(re:split( HtmlString1, &quot;&lt;script[^&gt;]*?&gt;.*?&lt;/script&gt;&quot;,[{return,list},trim] ), &quot;&quot;),

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-erlang">1.sets:add_element( Element, Set1 ). 向集合中添加一個元素
   
2.sets:del_element( Element, Set1 ). 向集合中減少一個元素
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>Eshell V5.10.2  (abort with ^G)<br />
1&gt; help().<br />
<strong>shell 内置命令</strong><br />
b()        -- 显示所有绑定的变量<br />
e(N)       -- 重复某次查询 <N><br />
f()        -- 释放所有绑定的变量<br />
f(X)       -- 释放某个绑定的变量<br />
h()        -- 显示之前的操作<br />
history(N) -- 设置保存之前操作命令的条数<br />
results(N) -- 设置保存之前操作结果的条数<br />
catch_exception(Bool) -- 设置的执行过程中的异常处理<br />
v(N)       -- 使用某次查询的值 <N><br />
rd(R,D)    -- 定义一个 record<br />
rf()       -- 移除所有 record<br />
rf(R)      -- 移除某个 record<br />
rl()       -- 显示所有 record<br />
rl(R)      -- 显示某个 record 信息<br />
rp(Term)   -- 显示某个元组的所有内容<br />
rr(File)   -- 从一个文件或模块读取 record 定义<br />
<strong>c 模块命令</strong><br />
bt(Pid)    -- 显示一个进程的栈回溯<br />
c(File)    -- 编译及重新加载模块<br />
cd(Dir)    -- 改变工作目录<br />
flush()    -- 刷新信箱（以便shell接收信息）<br />
help()     -- 帮助信息<br />
i()        -- 显示系统信息<br />
ni()       -- 和 i() 一样显示系统信息，还包括网络节点的系统信息<br />
i(X,Y,Z)   -- 通过 pid &lt;X,Y,Z&gt; 获取某个进程的信息<br />
l(Module)  -- 加载或重新加载模块<br />
lc([File]) -- 编译一个列表的 Erlang 模块<br />
ls()       -- 显示当前工作目录下的文件列表<br />
ls(Dir)    -- 显示某个目录下的文件列表<br />
m()        -- 显示已加载进系统的模块<br />
m(Mod)     -- 显示某个模块信息<br />
memory()   -- 显示内存分配信息<br />
memory(T)  -- 显示某项内存分配信息 <T><br />
nc(File)   -- 在所有节点编译及加载模块<br />
nl(Module) -- 在所有节点重新加载模块<br />
pid(X,Y,Z) -- 通过 pid &lt;X,Y,Z&gt; 获取某个进程 pid<br />
pwd()      -- 显示当前工作目录<br />
q()        -- 关闭 erlang shell<br />
regs()     -- 显示注册过的进程信息<br />
nregs()    -- 和 regs() 一样显示注册过的进程信息，还包括网络节点的进程信息<br />
xm(M)      -- 查找某个模块未定义的函数，未使用的函数，已弃用的函数<br />
y(File)    -- 编译 Yecc 文件(.yrl)<br />
<strong>i 模块命令</strong><br />
ih()       -- 显示 i 模块的帮助信息<br />
true</p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-erlang">1.sofs:range(). inout-&gt;sofs:relation([{1,2},{1,3},{2,4},{2,5}])
outout -&gt;{'Set',[2,3],atom}
2.sofs:relation().  input -&gt;[{1,2},{1,3},{2,4},{2,5}]
   output -&gt;{'Set', [{1,2},{1,3},{2,4},{2,5}],{atom,atiom}}

3.sofs:to_external().  input -&gt;{'Set', [2,3],atom} 
output -&gt; [2,3]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-erlang">crypto:start().
ssh:start().
{ok, Conn} = ssh:connect(&quot;ip or host name&quot;, 22, [
        {user, &quot;the user name&quot;},
        {password, &quot;the password&quot;},
        {silently_accept_hosts, true},
        {user_interaction, false}
]).
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-erlang">1.string:len().
2.string:concat().  --连接
3.string:substr(Str,Start,Length).  --Str中从Start开始Length长度
4.string:tokens(Str,List). --从Str中含有List的部分切割
5.string:rstr( String, SubString ). --获取SubString在String中出现的最后一个位置
6.string:join( String, Char ).   --input:( [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;], &quot;&lt;br/&gt;&quot; ) -&gt; &quot;a&lt;br/&gt;b&lt;br/&gt;c&quot;
7.string:strip( String ). --去两边的空格
  string:strip( String, right|left|both ) --去除右边|左边|两边的空格
  string:strip( String, right|left|both, Char() ). --在String中去除Char()符号
string:strip( &quot;.....hello.....&quot;, right, $. ).  -&gt;&quot;.....hello&quot;
        string:left(&quot;Hello&quot;,10,$.). -&gt; &quot;Hello.....&quot;    

8.string:str( Str, Ches )  -&gt;Ches 在Str中的位置
9.string:to_lower()
  string:to_upper()
  string:to_integer()
  string:to_float()
10.string:to_integer( &quot;123.456aabb&quot; ). -&gt; {123,&quot;.456aabb&quot;}
   string:to_float( &quot;123.456aabb&quot; ). -&gt; {123.456,&quot;aabb&quot;}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-erlang">1. supervisor:start_child(admin_sup, 
                                  [{admin, {admin, start_link, [self()]},perm anent , 2000 ,worker, [admin]}]). -&gt; {ok, Child :: child()} |{ok, Child :: child(), Info :: term()}|{error, startchild_err()}

   start_child(SupRef, ChildSpec) -&gt; startchild_ret().
       SupRef = sup_ref()
 ChildSpec = child_spec() | (List :: [term()])
 child_spec() =
     {Id :: child_id(),
      StartFunc :: mfargs(),
      Restart :: restart(),
      Shutdown :: shutdown(),
      Type :: worker(),
      Modules :: modules()}
 startchild_ret() = {ok, Child :: child()}
                  | {ok, Child :: child(), Info :: term()}
                  | {error, startchild_err()}
 startchild_err() = already_present
                  | {already_started, Child :: child()}
                  | term().
 
2.terminate_child(SupRef, Id) -&gt; Result
3.delete_child(SupRef, Id) -&gt; Result
4.restart_child(SupRef, Id) -&gt; Result
5.which_children(SupRef) -&gt; [{Id, Child, Type, Modules}]
6.count_children(SupRef) -&gt; PropListOfCounts
7.check_childspecs(ChildSpecs) -&gt; Result
该模块只能针对注册过的进程进行修改，比如使用start_child函数无法批量增加进程
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-erlang">1．Timer：tc（Module，Function，Arguments）-&gt;{Time,Value}  参数使用中括号括起来
测量某函数运行的确切时间。
Example：timer:tc(lists, seq, [1，100000]).
2．timer:apply_after(Time, Module, Fun, Arg). -&gt; {ok,Tref} | {error, Reason}
在Time毫秒后执行特定函数
Time 为毫秒数
3.timer:apply_interval(Time, Module, Fun, Arg). -&gt; {ok,Tref} | {error, Reason}
每隔Time时间执行的特定函数
4.{_, {H1, M1, S1}} = erlang:localtime(),
timer:hms( H1, M1, S1 ).
5.T1 = erlang:now(),
timer:now_diff( erlang:now(), T1 ).  （精确到微秒级）
6.timer:sleep( 3000 )
7.send_after(Time, Message) == send_after(Time, self(), Message)
  send_after(Time, Pid, Message)
  發送Message到對應的Pid
8.kill_after(Time) -&gt; {ok, TRef} | {error, Reason2}
  kill_after(Time, Pid) -&gt; {ok, TRef} | {error, Reason2}
  exit_after(Time, Reason1) -&gt; {ok, TRef} | {error, Reason2}
  exit_after(Time, Pid, Reason1) -&gt; {ok, TRef} | {error, Reason2}
9.send_interval(Time, Message) -&gt; {ok, TRef} | {error, Reason}
  send_interval(Time, Pid, Message) -&gt; {ok, TRef} | {error, Reason}
  發送Message到對應的Pid，並且獲得返回的結果
10.seconds(Seconds), minutes(Minutes), hours(Hours), hms(Hours, Minutes, Seconds)
   獲得對應的毫秒數
11.erlang:cancel_timer(TimeRef)
</code></pre>
<p>涉及模块</p>
<p>timer.erl</p>
<p>实现
1.启动一个进程来维护所有调用该模块的倒计时
2.内部实现使用gen_server的timeout来实现</p>
<p>缺陷
当该进程被太多调用时，进程卡顿，导致倒计时时间不准确</p>
<p>解决方案
倒计时分散到各自的进程，不要过多依赖timer倒计时</p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-erlang">1.tuple_size  返回元组元素的数目
2.element     返回元组的第N个元素
3.setelement/3 替换元组中的一个元素，返回新的元组
    setelement(1, {1,2,3,4,5,6},2 ). -》{2,2,3,4,5,6}
4.erlang:append_element/2
    erlang:append_element( {1,2,3,4},4 ) -&gt; {1,2,3,4,4}

5.erlang:delete_element( 1, {a,b,c,d} ). -&gt; {b,c,d}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-erlang">unicode:characters_to_list(DatB)

erlang csv

Result_str = &quot;r1c1,r1c2,r1c3\nr2c1,r2c2,r2c3&quot;,
Bom = unicode:characters_to_list(unicode:encoding_to_bom(utf8)),
unicode:characters_to_binary(Bom++Result_str, unicode, utf8),
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="1"><a class="header" href="#1">1</a></h2>
<p>ERTS Erlang Runtime System Application 运行
 -----------------------------------------------------
 epmd(Erlang Port Mapper Daemon )
 erl运行命令
 erlc编译命令
 werl运行窗口
 escript不编译直接运行
 erlsrv运行Erlang为Windows服务
 start_erl启动嵌入式
 run_erl在Solaris上重定向IO
 start在Unix上启动
 -----------------------------------------------------
SASL System Architecture Support Libraries 报警和发布处理</p>
<h2 id="2接口"><a class="header" href="#2接口">2.接口</a></h2>
<p>asn1  文法
crypto  加密
gs  图形
inets  网络服务：inets,ftp,tftp,http,httpd,httpd_conf,httpd_socket,httpd_util,mod_alias,mod_auth,mod_esi,mod_security
jinterface Java接口
megaco
public_key 公钥
ssh  SSH：ssh,ssh_channel,ssh_connection,ssh_sftp,ssh_sftpd
ssl  SSL
wx  窗口编程
xmerl  支持XML：xmerl_scan,xmerl,xmerl_xs,xmerl_eventp,xmerl_xpath,xmerl_xsd
erl_interface C接口
 SSH主要用于远程管理网络设备（相对应协议是TELNET）
 SSL主要用于浏览器与WEB服务器之间交互（相对应协议是HTTP）</p>
<h2 id="3"><a class="header" href="#3">3</a></h2>
<p><img src="4.%E5%B7%A5%E5%85%B7//images/screenshot_1534332992548.png" alt="3" /></p>
<h2 id="4"><a class="header" href="#4">4</a></h2>
<p><img src="4.%E5%B7%A5%E5%85%B7//images/screenshot_1534590777445.png" alt="4" /></p>
<div style="break-before: page; page-break-before: always;"></div><p><a href="http://www.erlang.org/doc/efficiency_guide/profiling.html">http://www.erlang.org/doc/efficiency_guide/profiling.html</a></p>
<div style="break-before: page; page-break-before: always;"></div><p>fprof类似eprof，但是会把详细信息存储到文件中，方便数据统计分析。</p>
<p>只看某一函数的简单调用方法：
1&gt; fprof:apply(Module, fun, Args).
2&gt; fprof:profile().
3&gt; fprof:analyse().
实际上在执行的时候，fprof:apply/3前后会自动添加trace([start, ...]) 和 trace(stop).</p>
<blockquote>
<p>fprof:trace([start, {file, &quot;./fprof.trace&quot;}, {procs, PidSpec}]).  %% 或者可以trace多个Pid，[PidSpec]<br />
fprof:trace(stop).<br />
fprof:profile({file, &quot;./fprof.trace&quot;}).<br />
fprof:analyse([{dest, &quot;fprof.analysis&quot;},{sort,own}]).  %% 详细参数见： <a href="http://www.erlang.org/doc/man/fprof.html#analyse-2">http://www.erlang.org/doc/man/fprof.html#analyse-2</a></p>
</blockquote>
<p>%是一种标记，每一个“段落”中，%表示被调用的函数主体，%以上为调用它的函数，%以下为它调用的函数。“段落”中的CNT列表示被调用次数，Acc表示包括%之上的函数在内所花费的时间，own表示不包括%之上的函数所用的时间。</p>
<p>suspend表示进程挂起。
也可以将fprof这类工具卸载想监控的代码前后。</p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-erlang">&gt; eprof:start().  
&gt; eprof:profile([pid(x,x,x)]).  
&gt; eprof:stop_profiling().  
&gt; eprof:analyze().  
&gt; eprof:stop().  

&gt; eprof:start_profiling([regNames], {gen, call, 4}).  
&gt; eprof:stop_profiling().  
&gt; eprof:analyze().  
&gt; eprof:stop().
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>用于统计一个函数中的每个函数的调用次数。相较于eprof和fprof，cprof对性能影响很小，官方说大约10%
使用举例（引自官网）</p>
<pre><code class="language-erlang">1&gt; cprof:start(),R=calendar:day_of_the_week(1896,4,27),cprof:pause(),R.
1
2&gt; cprof:analyse(calendar).
{calendar,9,
          [{{calendar,df,2},1},
           {{calendar,dm,1},1},
           {{calendar,dy,1},1},
           {{calendar,last_day_of_the_month1,2},1},
           {{calendar,last_day_of_the_month,2},1},
           {{calendar,is_leap_year1,1},1},
           {{calendar,is_leap_year,1},1},
           {{calendar,day_of_the_week,3},1},
           {{calendar,date_to_gregorian_days,3},1}]}
3&gt; cprof:stop().
3271
该示例表明day_of_the_week这个函数需要调用9个函数完成计算。

同样cprof可以嵌入代码中。
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="流程"><a class="header" href="#流程">流程</a></h3>
<ol>
<li>确保所有的服务器开通ssh服务。</li>
<li>确保主节点服务器可以不使用密码直接链接到从节点</li>
<li>确保主节点服务器使用xw.config配置启动Erl节点，确保xw.config中配置了所有节点的Ip，以及使用erl_boot_server启动节点</li>
<li>注意事项：
保证启动Erlang的linux的用户名所有服务器都一样
    保证Erlang安装路径所有服务器都一样</li>
</ol>
<h3 id="技术文档"><a class="header" href="#技术文档">技术文档</a></h3>
<ol>
<li>Server:
引导服务器 erl_boot_server
%server操作模块，配置加入到主节点的从节点，只有定义该节点后，才能被调用 <a href="http://erlang.org/doc/man/erl_boot_server.html">http://erlang.org/doc/man/erl_boot_server.html</a></li>
</ol>
<p>start_boot_server， boot_server_slaves
%erlang start启动时的options <a href="http://erlang.org/doc/man/kernel_app.htm">http://erlang.org/doc/man/kernel_app.htm</a>
2. Client:
从节点：<a href="http://erlang.org/doc/man/slave.html">http://erlang.org/doc/man/slave.html</a>
%启动从节点的模块。</p>
<p>参考资料
<a href="http://cryolite.iteye.com/blog/381758">http://cryolite.iteye.com/blog/381758</a>
<a href="http://avindev.iteye.com/blog/100113">http://avindev.iteye.com/blog/100113</a>
<a href="http://cryolite.iteye.com/blog/376893">http://cryolite.iteye.com/blog/376893</a></p>
<p>详细流程，以ubuntu12.04-client为例：
1.确保server服务器开通ssh服务。
 ~$ps -e |grep ssh
<img src="4.%E5%B7%A5%E5%85%B7/4.3Erlang%E5%A4%9A%E8%8A%82%E7%82%B9//images/screenshot_1534333386239.png" alt="" /></p>
<p> 说明只有ssh客户端，能够登陆其他带有ssh服务端的服务器.
 安装ssh-server
 ~$sudo apt-get install openssh-server
 ~$ps -e |grep ssh
<img src="4.%E5%B7%A5%E5%85%B7/4.3Erlang%E5%A4%9A%E8%8A%82%E7%82%B9//images/screenshot_1534333395700.png" alt="" /></p>
<p> 安装成功</p>
<p>2.确保所有服务器之间可以不使用密码直接互联ssh。ubuntu下安装ssh后会提示输入用户密码
   1.生成密匙对。
        密匙 从A -&gt; 拷贝到B,A可以不用密码链接到B</p>
<h1 id="ssh-keygen--t-rsa-一路回车在当前用户的根目录下的ssh目录生成id_rsapub公钥"><a class="header" href="#ssh-keygen--t-rsa-一路回车在当前用户的根目录下的ssh目录生成id_rsapub公钥">ssh-keygen -t rsa //一路回车在当前用户的根目录下的.ssh目录生成id_rsa.pub公钥</a></h1>
<p><img src="4.%E5%B7%A5%E5%85%B7/4.3Erlang%E5%A4%9A%E8%8A%82%E7%82%B9//images/screenshot_1534333403187.png" alt="" /></p>
<p>2.将公钥放到服务器上（注意存放目录位置）</p>
<h1 id="scp-sshid_rsapub-用户名你的服务器的ipsshauthorized_keys"><a class="header" href="#scp-sshid_rsapub-用户名你的服务器的ipsshauthorized_keys">scp ~/.ssh/id_rsa.pub 用户名@你的服务器的ip:~/.ssh/authorized_keys</a></h1>
<p>//将本地生成的公钥拷贝到远程服务器的下并改名为authorized_keys，authorized_keys的权限设置为600，目前的权限是416没有影响
<img src="4.%E5%B7%A5%E5%85%B7/4.3Erlang%E5%A4%9A%E8%8A%82%E7%82%B9//images/screenshot_1534333415220.png" alt="" /></p>
<p>3.ssh Ip -l user
        使用user用户登录到ip主机上
4.exit.退出ssh</p>
<p>如果无法直接输入密码登录到ssh
复制密钥
主机生成密钥
复制到从机上。具体待验证，重点：known_hosts文件</p>
<p>3.测试</p>
<p>Serve：</p>
<pre><code class="language-bash">vim xw.config
[
    {kernel, [{start_boot_server, true}, %设置为true，开启该功能
              {boot_server_slaves, ['192.168.0.234', '192.168.0.219']}]} %配置从节点，只有配置后才可能链接
].
%参数 -kernel start_boot_server true boot_server_slaves '[{10,0,0,253},{10,0,0,252}]' 是让主节点成为引导服务器，从节点的beam程序都将从主节点传送。

erl -name server@192.168.0.219  %设置节点名称
    -setcookie 'xw'             %设置cookie
    -config &quot;D:/xw.config&quot;      %使用该配置文档打开
    -rsh ssh                    %参数-rsh ssh是为了让主节点远程启动从节点（slave）必须的
slave:start_link( Host, Name, Args ).
slave:start('10.0.0.252', slave1, &quot;-setcookie abc -loader inet -hosts '10.0.0.253' -id master@10.0.0.253&quot;). 开启从节点10.0.0.252
</code></pre>
<p>出现错误
a.</p>
<p>这个一般就是指系统中找不到erl命令，也就是在/usr/bin/或/usr/sbin/或/bin/等path下找不到erl命令
将/usr/local/erlang/lib/erlang/bin/erl 链接到/usr/sbin/erl
ln /usr/local/erlang/lib/erlang/bin/erl /usr/sbin/erl
删除链接 rm -r /usr/sbin/erl</p>
<p>Client保证可以启动Erlang
    ln /usr/local/erlang/lib/erlang/bin/erl /usr/bin/erl</p>
<p>函数：
1.c:nl(hello). 第一次调用hello模块被自动发送到从节点，不过在hello模块修改重新编译后，从节点上还是旧的模块，可以调用该命令广播新模块。
    目前ubuntu测试机中：
    a.在主节点启动从节点成功
    b.在主节点使用code:add_pathz( &quot;/home/yujian-slave/zt_server/ebin&quot; )添加模块，此时可以在主节点上运行加载的模块，从节点上不能运行.
    c.如果需要在从节点上运行，需要使用c:nl( module ),进行广播。
2.rpc:call( Node, M, F, Args ).</p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-erlang">
rpc:call(Node, Module, Function, Args) -&gt; Res | {badrpc, Reason} 
Types: 
Node = node() 
Module = module() 
Function = atom() 
Args = [term()] 

Res = Reason = term() 
Evaluates apply(Module, Function, Args) on the node Node and returns the corresponding value Res, or {badrpc, Reason} if the call fails. 

rpc:cast().  
erlang:set_cookie(node(), cookie).  
erl -sname test -name test@test -setcookie 'pwd' 
c:nl( Mod ).  

%slave 模块 
slave:start('10.0.0.252', slave1, &quot;-setcookie abc -loader inet -hosts '10.0.0.253' -id master@10.0.0.253&quot;). %开启从节点10.0.0.252出现错误
slave:start_link( Host, Name, Args ).
slave:stop( Node ). Stops (kills) a node.

%erl_boot_server模块 
erl_boot_server:which_slaves().  
erl_boot_server:add_slave( '42.96.128.67' ). 
erl_boot_server:delete_slave( '42.96.128.67' ).

net_adm:ping(node@Hostname). %这个结果可能是pong，也可能是pang。其中pong表示可以ping通，pang表示ping不通。
erlang:send(Dest, Msg) -&gt; Msg. %Dest may be a 
%remote pid, %远程pid
%local pid,     %本地Pid
%a (local) port, %本地或者远程port
%a locally registered name %本地的注册进程名
%a tuple {RegName, Node}  %{注册进程名称,节点}
%for a registered name at another node. 
   
spawn(Node, Mod, Func, Args).  %在远程节点产生一个新的进程。
spawn_link(Node, Mod, Func, Args).  %在远程节点产生一个新的进程并创建一个指向这个进程的链接。

monitor_node(Node, Flag). 
%若Flag为true，该BIF令当前进程监视节点Node。如果Node出错或消失，一个{nodedown, Node}消息将被发送给当前进程，若Flag为false，则关闭监视。


nodes().  
node(Item).%返回Item所处节点的名称。Item可以是Pid、引用或端口。 
disconnect_node(Nodename).%断开与节点Nodename的连接。 
</code></pre>
<p>控制节点对集群的访问
1.防火墙
2.Erlang集群未公开特性：IP网段限制 <a href="http://blog.yufeng.info/archives/1575">http://blog.yufeng.info/archives/1575</a>
3.net_kernel:allow
net_kernel:allow(['x@127.0.0.1', 'y@127.0.0.1']).
可以知道如果Allowed空的话，代表不做任何限制，否则net_kernel:allow限制主动和被动连接的节点</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><p>本地节点监听远程节点的函数被调用事件</p>
<p>1.远程节点,存在下面函数
player_handler:get_state(Uid).</p>
<p>2.本地节点。</p>
<pre><code class="language-erlang">erl -name test@127.0.0.1 -setcookie 127001 -remsh 'game@127.0.0.1'。连接上远程节点。回退到本地节点
&gt;dbg:tracer(). %启动
&gt;dbg:n('game@127.0.0.1').
&gt;dbg:p(all, c).
&gt;dbg:tpl(player_handler, handle_info, dbg:fun2ms(fun(_) -&gt; exception_trace() end)).
&gt;
</code></pre>
<p>3.进入远程节点执行</p>
<pre><code class="language-erlang">NaNundefinedplayer_handler:get_state(1).
NaNundefined{state, 1}
</code></pre>
<p>4.回到本地节点可以看到shell中会打印</p>
<pre><code class="language-erlang">(&lt;4641.47.0&gt;) call player_handler:get_state(1)
(&lt;4641.47.0&gt;) returned from player_handler:get_state/1 -&gt; {state, 1}
</code></pre>
<p>附上自家项目用的tracer</p>
<pre><code class="language-erlang">t(Mod)-&gt;
    dbg:tpl(Mod,[{'_', [], [{return_trace}]}]).
t(Mod,Fun)-&gt;
    dbg:tpl(Mod,Fun,[{'_', [], [{return_trace}]}]).
t(Mod,Fun,Ari)-&gt;
    dbg:tpl(Mod,Fun,Ari,[{'_', [], [{return_trace}]}]).

p(Max)-&gt;
    FuncStopTracer =
        fun
            (_, N) when N =:= Max-&gt; % 记录累计到上限值，追踪器自动关闭
                dbg:stop_clear(),
                io:format(&quot;#WARNING &gt;&gt;&gt;&gt;&gt;&gt; dbg tracer stopped &lt;&lt;&lt;&lt;&lt;&lt;~n~n&quot;,[]);
            (Msg, N) -&gt;
                case Msg of
                    {trace, _Pid, call, Trace} -&gt;
                        {M, F, A} = Trace,
        io:format(&quot;###################~n&quot;,[]),
                      io:format(&quot;call [~p:~p,(~p)]~n&quot;, [M, F, A]),
      io:format&quot;###################~n&quot;,[]);
                    {trace, _Pid, return_from, Trace, ReturnVal} -&gt;
                        {M, F, A} = Trace,
io:format(&quot;===================~n&quot;,[]),
                        io:format(&quot;return [~p:~p(~p)] =====&gt;~p~n&quot;, [M, F, A, ReturnVal]),
io:format(&quot;===================~n&quot;,[]);
                    _ -&gt; skip
                end,
                N + 1
        end,
    case dbg:tracer(process, {FuncStopTracer, 0}) of
        {ok, _Pid} -&gt;
             dbg:p(all, [all]);
        {error, already_started} -&gt;
             skip
    end.

stop()-&gt;
     dbg:stop_clear().
</code></pre>
<pre><code class="language-erlang">开启

dbg:tracer()

dbg:p(Item, Flags)
dbg:p(Item) -&gt; dbg:p(Item, [m]).

Item是设定要跟踪的对象,Flags是设置要监听的动作
Item =
  all           %会trace 整个系统所有的进程，同样可以监控整个集群
  |new       %就会trace 系统在此刻开始所创建的新进程，可以监控整个集群
  |existing %会trace 系统此刻之前所创建的进程，可以监控整个集群
  |pid() || register_name %则只会trace对应的进程，如果是在集群中，只要节点在traced nodes列表内，可以跨节点trace那个进程.
  | integer()                     %the process &lt;0.Item.0&gt; is traced  
  | {X, Y, Z}                     %the process &lt;X.Y.Z&gt; is traced
  |  &quot;&lt;X.Y.Z&gt;&quot;                  %as returned from pid_to_list/1, the process &lt;X.Y.Z&gt; is traced

Flags can be a single atom, or a list of flags
Flags =
 s(send) trace 进程发送的消息
 |r(receive) trace 进程受到的消息
 |m(messages) trace 进程收的或者发的消息
 |c(call） 通过tp/2设置的匹配规则后，可以trace 进程所有的call匹配的动作。
 |p（procs） trace 与目标进程相关联的进程
 |sos(set on spwan) 使监控的进程所产生的进程继承所以trace flags
 |sol （set on link） 如果有另外的进程p2 link被监控的进程，p2会继承所有的trace flags
 |sofs(set on first spawn) 监控第一个创建的进程
   |sofl (set on first link)
 |all 所有的flags
 |clear 清除所有flags

dbg:tp({Module, Function, Arity}, MatchSpec)

与 dbg:tpl({Module, Function, Arity}, MatchSpec) -&gt;
 {ok, MatchDesc} | {error, term()}  tpl和tp类似，只是tpl会trace 未导出函数

dbg:tpl(Module, '_', []). 会trace 该module的所有的调用。
dbg:tpl(Module, Function, '_', []). 会trace module：function，不限定参数个数。
dbg:tpl(Module, Function, Arity, []). trace module：function/arity。
dbg:tpl(M, F, A, [{'_', [], [{return_trace}]}]). 会跟踪返回值

fun2ms

dbg:fun2ms(fun([M,N]) when N &gt; 3 -&gt; return_trace() end).
[{['$1','$2'],[{'&gt;','$2',3}],[{return_trace}]}]

dbg:fun2ms(fun([M,N]) when N &gt; X  -&gt; return_trace() end).
[{['$1','$2'],[{'&gt;','$2',{const,3}}],[{return_trace}]}]

dbg:fun2ms(fun(_) -&gt; return_trace() end).

p, c
       - Set trace flags for processes

tp, tpl, ctp, ctpl, ctpg, ltp, dtp, wtp, rtp
       - Manipulate trace patterns for functions
n, cn, ln
       - Add/remove traced nodes.
tracer, trace_port, trace_client, get_tracer, stop, stop_clear
       - Manipulate tracer process/port
i
       - Info
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>在Erlang模块被编译之前，首先会被名为epp的Erlang预处理器进行自动处理。这个预处理器会扩展任何存在于源文件中的宏，并且插入任何必需的包含文件。</p>
<p>通常，你无须关心预处理器的输出，但在一些特殊情况下(例如，你要调试一个有错误的宏)，你可能希望能够保存预处理器的输出。通过命令compile:file(M,['p'])可以将预处理器的输出保存在一个文件中。这个命令编译M.erl文件中的所有代码，然后在M.P文件中产生一个列表，存放所有经过扩展的宏和所有已经插入的包含文件。</p>
<p>erlang的VM作为register based的VM, 大概有400条指令.指令分为hot, normal, cold 3大类别。beam_emu.c是vm的实现，hot和cold指令在编译的时候 由脚本生成的，include到beam_emu去的。 hot是热门的操作如list, tuple操作, cold的就是比较偏的指令。</p>
<p>erlc +&quot;'S'&quot; gram.erl
中间汇编码, 供transform进行处理和编译器进一步生成opcode.
<a href="http://blog.yufeng.info/archives/34">http://blog.yufeng.info/archives/34</a></p>
<p>erts_debug:df(eg).
VM opcode形式, VM就是来解释运行这些code的
<a href="http://blog.yufeng.info/archives/498">http://blog.yufeng.info/archives/498</a></p>
<p>1.erts_debug:df(Mod). %生成自解码，vm码</p>
<p>2.erts_debug:size(MyList).</p>
<p>3.erts_debug:flat_size(MyList).</p>
<div style="break-before: page; page-break-before: always;"></div><p>port(socket)调优</p>
<p>示例：服务器监听端口，接受客户端请求。典型应用场景web服务器，需要实现高吞吐，低延迟的目标</p>
<pre><code class="language-erlang">Res = gen_tcp:listen(Port, [binary,
{reuseaddr, true},
{nodelay, true},
{delay_send,true},
{high_watermark,64 * 1024},
{send_timeout, 30000},
{send_timeout_close, true},
{keepalive, true}])


参数详解:
binary:接收到客户端的消息后，作为binary来处理，binary在erlang中是很高效的数据结构，超过64字节，就是全局保存的，因此在很多操作下是不需要复制的，仅仅复制binary的指针即可，详细请搜索refc binary，注意：binary大量使用需要有丰富的经验，不然可能会内存泄漏

reuseaddr:允许系统复用port,对于高吞吐的系统，这个参数很重要,请搜索:linux port 复用
nodelay:开启linux中的TCP_NODELAY参数，请搜索:TCP_NODELAY 40毫秒延迟
delay_send:默认的erlang port消息发送，是直接发送，若失败则排队处理，然后由调度器进行队列poll操作，如果设置为true,那么就不尝试直接发送，而且扔进队列，等待poll，开启选项会增加一点点消息延迟，换来吞吐量的大量提升

high_watermark:port的发送缓存，缓存满了后，下次发送会直接阻塞，直到缓存低于某个阈值low_watermark。如果是密集网络IO系统，请增大该buffer,避免发送阻塞
send_timeout:在high_watermark中提到了发送阻塞，如果阻塞超过这个时间，那么就会超时，发送直接返回,停止发送
send_timeout_close:如果发生了send_timeout同时设置了send_timeout_close选项，那么超时后，会直接关闭socket.如果发送进程不是很重要，例如web用户进程，强烈建议开启这个选项，当发送30秒超时的时候，就说明该用户出现了很大的麻烦，断开连接是最理想的做法，否则可能出现很多奇怪的bug.

keepalive:遵循HTTP/1.1协议的keepalive规定,这个根据业务需求选择是否开启,如果同一个客户端会连续发起http请求，那么建议设置为true,避免多次TCP握手
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>erlang集群是依靠epmd维护的，epmd是erlang集群节点间端口映射的守护进程，负责维护集群内的节点连接，提供节点名称到IP地址及端口的解析服务。</p>
<p>epmd 自定义端口号</p>
<p>epmd端口配置</p>
<p>默认情况下，epmd绑定在4369端口。但是，端口固定的话，容易遭受攻击，可能导致新节点的认证失败而无法启动，或无法加入集群。或者要在一台机器上部署不同的erlang集群，希望不会互相干扰。</p>
<pre><code class="language-bash">epmd -daemon -port 5000
epmd -d -port 5000 #如果想用调试模式启动 epmd
</code></pre>
<p>另外，epmd通常伴随着erlang节点启动时自动启动，无须手动处理，所以，这里也可以通过修改erl启动参数以达到自动调整epmd端口。</p>
<pre><code class="language-bash">erl -name hello@127.0.0.1 -epmd &quot;epmd -port 5000 -daemon&quot; 
</code></pre>
<p>节点启动配置
当epmd端口改变时，erlang节点需要显式指定epmd端口信息。
windwos下启动方式：
1、设置环境变量ERL_EPMD_PORT</p>
<pre><code class="language-bat">C:\&gt;set ERL_EPMD_PORT=5000
C:\&gt;erl -name hello@127.0.0.1 
</code></pre>
<p>注意了， 以上命令端口号（这里是5000）前后不能留有空格。
2、设置erlang启动参数</p>
<pre><code class="language-bash">erl -name hello@127.0.0.1 -epmd_port 5000
</code></pre>
<p>linux下启动方式：</p>
<pre><code class="language-bash">1、设置环境变量ERL_EPMD_PORT
ERL_EPMD_PORT=5000 erl -name hello@127.0.0.1

2、设置erlang启动参数
erl -name hello@127.0.0.1 -epmd_port 5000
</code></pre>
<p>这两种方式是等价的，erlang启动时会做以下处理：</p>
<pre><code class="language-c"> // erlexec.c  
 static void add_epmd_port(void)  
 {  
     char* port = get_env(&quot;ERL_EPMD_PORT&quot;);  
     if (port != NULL) {  
     add_args(&quot;-epmd_port&quot;, port, NULL);   
     }  
 }  
//其中，epmd_port在erl_epmd模块被用到，完成epmd连接。
 %% erl_epmd.erl  
 get_epmd_port() -&gt;  
     case init:get_argument(epmd_port) of  
     {ok, [[PortStr|_]|_]} when is_list(PortStr) -&gt;  
         list_to_integer(PortStr);  
     error -&gt;  
         ?erlang_daemon_port  
     end.  

 %%  
 %% Epmd socket  
 %%  
 open() -&gt; open({127,0,0,1}).  % The localhost IP address.  

 open({A,B,C,D}=EpmdAddr) when ?ip(A,B,C,D) -&gt;  
     gen_tcp:connect(EpmdAddr, get_epmd_port(), [inet]);  

%% 注册节点名称和端口  
 do_register_node(NodeName, TcpPort) -&gt;  
     case open() of  
     {ok, Socket} -&gt;  
         Name = to_string(NodeName),  
         Extra = &quot;&quot;,  
         Elen = length(Extra),  
         Len = 1+2+1+1+2+2+2+length(Name)+2+Elen,  
         gen_tcp:send(Socket, [?int16(Len), ?EPMD_ALIVE2_REQ,  
                    ?int16(TcpPort),  
                    $M,  
                    0,  
                    ?int16(epmd_dist_high()),  
                    ?int16(epmd_dist_low()),  
                    ?int16(length(Name)),  
                    Name,  
                    ?int16(Elen),  
                    Extra]),  
         wait_for_reg_reply(Socket, []);  
     Error -&gt;  
         Error  
     end.  
</code></pre>
<p>限制指定IP的节点加入集群</p>
<pre><code class="language-bash">epmd -port 5000 -address 127.0.0.1 -daemon #这样，如果节点名字不是 xxx@127.0.0.1，将无法启动，或加入集群。
</code></pre>
<p>如何杀掉epmd进程
epmd独立于erlang节点，在所有节点关闭后还会继续存在，有时候可能需要杀掉epmd进程。</p>
<pre><code class="language-bash">epmd  -kill
</code></pre>
<p>设定节点连接监听端口
节点启动时，会启动一个tcp socket，用于监听并处理其他节点的连接请求，但是，这个端口号是随机的，有时候我们需要定义防火墙规则，就要对端口范围做一些限定。
通过修改erlang启动参数即可设定，方法如下：
erl -name hello@127.0.0.1 -kernel inet_dist_listen_min 9100 -kernel inet_dist_listen_max 9200
看下这两个参数是怎么被使用的？</p>
<pre><code class="language-erlang">%% inet_tcp_dist.erl   

listen(Name) -&gt;  
    %% 启动本地节点监听socket  
    case do_listen([{active, false}, {packet,2}, {reuseaddr, true}]) of  
    {ok, Socket} -&gt;  
        TcpAddress = get_tcp_address(Socket),  
        {_,Port} = TcpAddress#net_address.address,  
        %% 注册节点名称和端口  
         case erl_epmd:register_node(Name, Port) of  
         {ok, Creation} -&gt;  
             {ok, {Socket, TcpAddress, Creation}};  
         Error -&gt;  
             Error  
         end;  
     Error -&gt;  
         Error  
     end.  

 do_listen(Options0) -&gt;  
     %% 获取端口范围  
     {First,Last} = case application:get_env(kernel,inet_dist_listen_min) of  
                {ok,N} when is_integer(N) -&gt;  
                case application:get_env(kernel,  
                             inet_dist_listen_max) of  
                    {ok,M} when is_integer(M) -&gt;  
                    {N,M};  
                    _ -&gt;  
                    {N,N}  
                end;  
                _ -&gt;  
                {0,0}  
            end,  
     %% 获取绑定IP地址  
     Options = case application:get_env(kernel, inet_dist_use_interface) of  
            {ok, Ip} -&gt;  
                [{ip, Ip} | Options0];  
            _ -&gt;  
                Options0  
            end,  
     do_listen(First, Last, [{backlog,128}|Options]).  

 do_listen(First,Last,_) when First &gt; Last -&gt;  
     {error,eaddrinuse};  
 do_listen(First,Last,Options) -&gt;  
     %% 尝试监听socket  
     case inet_tcp:listen(First, Options) of  
     {error, eaddrinuse} -&gt;  
         do_listen(First+1,Last,Options);  
     Other -&gt;  
         Other  
     end. 
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>erlang源代码</p>
<p>i.erl</p>
<p>编译方式: make:all([debug_info]). | c(test.erl,debug_info).</p>
<pre><code class="language-erlang"> 基本调试方法：
im/0:打开调试器
i/1 :把文件添加到调试器中
ni  :针对多个Node的用法
n/1 :与i/1相反
nn/1:与ni/1相反
interrepted/0:列出所有要调试的Module
file/1:显示源文件
break/2:添加断点
delete_break/2删除断点
break_in/3:在具体函数中添加断点
del_break_in/3:在具体函数中删除断点
no_break/0:删除所有断点
no_break/1:删除某个Module的所有断点
disable_break/2:使某个模块的断点失效
enable_break/2:恢复某个模块的断点
action_at_break/1:设置断点的状态，实验中发现enable不起作用
all_breaks/0:显示所有的断点状态
all_breaks/1:显示指定所有的断点状态
snapshot／0：回放调试进程信息
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>1.使用dialyzer需要定义函数的-spec</p>
<p>2.使用dialyzer</p>
<p>a.由于我们编写的代码需要使用到Erlang的函数库，在分析时，可以把这些库生成dialyzer能够快速访问的格式，用来加快分析速度，命令</p>
<p>% 生成plt
dialyzer --build_plt -r /usr/local/lib/erlang/lib/erts-5.7.1/ebin <br />
           /usr/local/lib/erlang/lib/kernel-2.13.1/ebin <br />
           /usr/local/lib/erlang/lib/stdlib-1.16.1/ebin <br />
           /usr/local/lib/erlang/lib/mnesia-4.4.9/ebin <br />
           /usr/local/lib/erlang/lib/crypto-1.6/ebin <br />
           /usr/local/lib/erlang/lib/sasl-2.1.6/ebin</p>
<p>% 从plt中去处crypto应用
dialyzer --remove_from_plt --plt ~/.dialyzer_plt -c /usr/local/lib/erlang/lib/crypto-1.6/ebin<br />
% 向plt中添加crypto应用
dialyzer --add_to_plt --plt ~/.dialyzer_plt -c /usr/local/lib/erlang/lib/crypto-1.6/ebin</p>
<p>假设我们书写一个简单的module（spec/spec.erl):</p>
<pre><code class="language-erlang">-module(spec).
-compile([export_all]).
-vsn('0.1').
 
-spec index(any(), pos_integer(), [any()]) -&gt; non_neg_integer().
index(Key, N, TupleList) -&gt;
   index4(Key, N, TupleList, 0).
 
index4(_Key, _N, [], _Index) -&gt; 0;
index4(Key, N, [H | _R], Index) when element(N, H) =:= Key -&gt; Index;
index4(Key, N, [_H | R], Index) -&gt; index4(Key, N, R, Index + 1).
 
% correct:
%-spec fa( non_neg_integer() ) -&gt; pos_integer().
% invalid:
-spec fa( N :: atom() ) -&gt; pos_integer().
fa(0) -&gt; 1;
fa(1) -&gt; 1;
fa(N) -&gt; fa(N-1) + fa(N-2).
 
-spec some_fun() -&gt; any().
some_fun() -&gt;
   L = [{bar, 23}, {foo, 33}],
   lists:keydelete(1, foo, L).
</code></pre>
<p>编译spec.erl:</p>
<pre><code class="language-bash">erlc +debug_info spec.erl
</code></pre>
<p>使用dialyzer进行分析:</p>
<pre><code class="language-bash">dialyzer -r ./spec/
</code></pre>
<p>显示结果:</p>
<pre><code class="language-bash">Checking whether the PLT /home/litao/.dialyzer_plt is up-to-date... yes
Proceeding with analysis...
spec.erl:15: Invalid type specification for function 'spec':fa/1. The success typing is (non_neg_integer()) -&gt; pos_integer()
spec.erl:22: Function some_fun/0 has no local return
spec.erl:24: The call lists:keydelete(1,'foo',L::[{'bar',23} | {'foo',33},...]) will never return since it differs in argument position 2 from the success typing arguments: (any(),pos_integer(),maybe_improper_list())
done in 0m0.29s
done (warnings were emitted)
</code></pre>
<p>我们可以看到,我们的fa/1函数的spec信息错误，我们进行修正:</p>
<pre><code class="language-erlang">由
-spec fa( non_neg_integer() ) -&gt; pos_integer().
改为:
-spec fa( N :: atom() ) -&gt; pos_integer().
some_fun中，lists:keydelete/3参数顺序进行修改:
lists:keydelete(1, foo, L).
改为:
lists:keydelete(foo,1, L).
</code></pre>
<p>重新编译，进行dialyzer分析，提示成功:</p>
<pre><code class="language-bash">litao@litao:~/erltest$ dialyzer -r ./spec
Checking whether the PLT /home/litao/.dialyzer_plt is up-to-date... yes
Proceeding with analysis... done in 0m0.28s
done (passed successfully)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>1.Trace Tool Builder（erlang跟踪工具） 主要特性：
•       用一个函数调用来跟踪多个节点上的文件端口
•       可以往在formatting过程中读取的记录跟踪信息的文件中写入在额外的信息
•       通过维护历史缓存和处理配置文件来复原以前版本的配置
•       对于连续的跟踪提供了一些简单的支持
•        格式化输出二进制格式跟踪日志和合并多个节点上的日志</p>
<p>2.ttb 模块
        ttb模块是Trace Tool 的使用接口，首先你要启动跟踪：ttb:tracer/0/1/2，对需要跟踪的进程设置跟踪标志：ttb:p/2，然后当跟踪结束时你必须要停止跟踪器：ttb:stop/0/1，
然后格式化跟踪日志(当然必须有东西让你格式化):ttb:format/1/2。</p>
<p>        ttb:trace/0/1/2在你需要跟踪的每个节点上启动一个跟踪端口，默认的情况下，跟踪信息被写入到远程节点上的二进制文件里面（the binary trace log）。</p>
<p>        ttb:p/2 指定了要跟踪哪个进程，这个方法给与的跟踪标志（Trace flag）指定了在各个进程上要跟踪的内容。你可以调用这个函数多次来跟踪多个不同的进程。
       如果你想要跟踪函数调用（换句话说在进程上设置了call跟踪标志），你必须设置跟踪模式（Pattern）在需要被跟踪的函数上，使用ttb:tp 或者ttb:tpl，只有在跟踪模式设置后函数才会被跟踪。跟踪模式指定了如何用
特殊的匹配格式进行跟踪，匹配格式在User's Guide for the erlang runtime system erts.</p>
<p>       ttb:stop/0/1 停止在所有节点上的跟踪，删除所有的跟踪格式和刷新跟踪端口缓存。</p>
<p>       ttb:format/1/2 将二进制格式的日志翻译成可读性较强的格式。默认的情况下显示的跟踪信息是一行文本，但是你也可以写自己的处理方法使得跟踪信息显示的更复杂详细。
跟踪日志甚至可以通过Event Tracer application以图形化的方式呈现出来。注意如果在ttb:stop/1中给与了format选项，那格式化会在ttb停止的时候自动处理。</p>
<div style="break-before: page; page-break-before: always;"></div><p><a href="http://erlang.org/doc/apps/observer/etop_ug.html">http://erlang.org/doc/apps/observer/etop_ug.html</a></p>
<p>平时用的最多的可能就是etop,两种用法:
[1] 在/usr/local/lib/erlang/lib/observer-1.0/priv/bin目录下面(视安装情况而异)执行:</p>
<p>找出cpu占用最高的进程，图形界面输出，每10秒更新一次</p>
<blockquote>
<p>spawn(fun() -&gt; etop:start([{interval,10}, {sort, runtime}]) end).
etop:stop()</p>
</blockquote>
<p>找出内存占用较高进程, 输出进程的数量为20，文本形式输出</p>
<blockquote>
<p>spawn(fun() -&gt; etop:start([{output, text}, {lines, 20},  {sort, memory}]) end).<br />
etop:stop().<br />
spawn(fun() -&gt; etop:start([{output, text}, {interval, 20}, {lines, 20}, {sort, memory}]) end).</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><p>1.粘包问题
数据连包问题，这个在client/server的通讯中很常见。就是，当client在极短的时间内发送多个包给server，这时server在接收数据的时候可能发生连包问题，就一次性接收这几个包的数据，导致数据都粘连在一起。</p>
<p>这里先讨论{packet, raw}或者{packet,0}的情况，分别看下{active, Boolean}的两种方式：</p>
<p>gen_tcp对socket数据封包的获取有以下2种方式，</p>
<p>1、{active, false} 方式通过 gen_tcp:recv(Socket, Length)  -&gt; {ok, Data} | {error, Reason} 来接收。
gen_tcp:recv/2,3，如果封包的类型是{packet, raw}或者{packet,0}，就需要显式的指定长度，否则封包的长度是对端决定的，长度只能设置为0。如果长度Length设置为0，gen_tcp:recv/2,3会取出Socket接收缓冲区所有的数据</p>
<p>2、{active, true} 方式以消息形式{tcp, Socket, Data} | {tcp_closed, Socket} 主动投递给线程。
缓存区有多少数据，都会全部以消息{tcp, Socket, Data} 投递给线程。</p>
<p>以上就会导致数据连包问题，那么如何解决呢？</p>
<p>{packet, PacketType}</p>
<p>现在再来看下 {packet, PacketType}，erlang的解释如下：
raw | 0
没有封包，即不管数据包头，而是根据Length参数接收数据。</p>
<p>1 | 2 | 4
表示包头的长度，分别是1,2,4个字节（2,4以大端字节序，无符号表示），当设置了此参数时，接收到数据后将自动剥离对应长度的头部，只保留Body。</p>
<p>asn1 | cdr | sunrm | fcgi |tpkt|line
设置以上参数时，应用程序将保证数据包头部的正确性，但是在gen_tcp:recv/2,3接收到的数据包中并不剥离头部。</p>
<p>http | http_bin
设置以上参数，收到的数据将被erlang:decode_packet/3格式化，在被动模式下将收到{ok, HttpPacket},主动模式下将收到{http, Socket, HttpPacket}.</p>
<p>{packet,  N}
也就是说，如果packet属性为1,2,4，可以保证server端一次接收的数据包大小。</p>
<p>下面我们以 {packet, 2} 做讨论。
gen_tcp 通信传输的数据将包含两部分：包头+数据。gen_tcp:send/2发送数据时，erlang会计算要发送数据的大小，把大小信息存放到包头中，然后封包发送出去。
所以在接收数据时，要根据包头信息，判断接收数据大小。使用gen_tcp:recv/2,3接收数据时，erlang会自动处理包头，获取封包数据。</p>
<p>{ok, ListenSocket} = gen_tcp:listen(?PORT, [binary,{active,false}]),<br />
{ok, ListenSocket2} = gen_tcp:listen(?PORT2, [binary,{active,false},{packet,2}]),</p>
<p>{ok,Socket} = gen_tcp:connect({127,0,0,1},?PORT,[binary,{active,false}]),<br />
gen_tcp:send(Socket, &quot;1&quot;),<br />
gen_tcp:send(Socket, &quot;2&quot;),<br />
gen_tcp:send(Socket, &quot;3&quot;),<br />
gen_tcp:send(Socket, &quot;4&quot;),<br />
gen_tcp:send(Socket, &quot;5&quot;),
received message &lt;&lt;&quot;12345&quot;&gt;&gt;</p>
<p>{ok,Socket} = gen_tcp:connect({127,0,0,1},?PORT2,[binary,{active,false},{packet,2}]),<br />
gen_tcp:send(Socket, &quot;1&quot;),<br />
gen_tcp:send(Socket, &quot;2&quot;),<br />
gen_tcp:send(Socket, &quot;3&quot;),<br />
gen_tcp:send(Socket, &quot;4&quot;),<br />
gen_tcp:send(Socket, &quot;5&quot;),<br />
received message &lt;&lt;&quot;1&quot;&gt;&gt;<br />
received message &lt;&lt;&quot;2&quot;&gt;&gt;<br />
received message &lt;&lt;&quot;3&quot;&gt;&gt;<br />
received message &lt;&lt;&quot;4&quot;&gt;&gt;<br />
received message &lt;&lt;&quot;5&quot;&gt;&gt;</p>
<p>2.大小端问题</p>
<p>字节序分为两类：Big-Endian和Little-Endian，定义如下：
a) Little-Endian就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。
b) Big-Endian就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。
其实还有一种网络字节序，为TCP/IP各层协议定义的字节序，为Big-Endian。</p>
<p>packet包头是以大端字节序（big-endian）表示。如果erlang与其他语言，比如C++，就要注意字节序问题了。如果机器的字节序是小端字节序（little-endian），就要做转换。</p>
<p>{packet, 2} ：[L1,L0 | Data]</p>
<p>{packet, 4} ：[L3,L2,L1,L0 | Data]</p>
<div style="break-before: page; page-break-before: always;"></div><p>以发布ping为例
1.获取源码+deps，并且完成编译</p>
<p>2生成配置文件
cd ~
mkdir rel
cd rel
../rebar create-node nodeid=ping</p>
<p>3.修改原始配置文件,
reltool.config
lib_dirs %配置deps库路径，必须配置打包应用的路径
{lib_dirs, [&quot;../&quot;, &quot;../deps/&quot;, &quot;../apps/&quot;]}</p>
<p>{incl_cond, exclude}, %该选项需要列出需要的erlang lib库
{incl_cond, derived}, %该选项默认erlang lib库，不需要自己写</p>
<p>{rel, &quot;game&quot;, &quot;1&quot;, %版本号</p>
<p>{app, ranck, [{mod_cond, app}, {incl_cond, include}]} %第三方库或者app配置</p>
<p>{app, game, [{incl_cond, include}, {lib_dir, &quot;..&quot;}]}, %或者配置该应用的路径</p>
<p>rebar.config
{sub_dirs, [&quot;rel&quot;]}.</p>
<p>4.生成系统
cd rel
../rebar generate</p>
<p>release_handler:which_releases(). %%查看当前版本</p>
<p>5.热更</p>
<p>&lt;4&gt;生成版本1.0.0
修改了代码，此时需要热更
源打包文件夹重命名成rel_1.0.0</p>
<p>a.修改配置文件
ping.app.src %修改版本号
reltool.config %修改版本号
b.重新release
cd rel
../rebar generate
../rebar generate-appups previous_release=myapp_1.0.0 指定之前的版本是1
../rebar generate-upgrade previous_release=myapp_1.0.0</p>
<p>c.热更
mv rel/ping_1.0.1.tar.gz rel/ping_1.0.0/releases/
在erl shell控制台
release_handler:unpack_release(&quot;ping_1.0.1&quot;).
release_handler:install_release(&quot;1.0.1&quot;).
release_handler:make_permanent(&quot;1.0.1&quot;).</p>
<p>ok，热更新完成</p>
<div style="break-before: page; page-break-before: always;"></div><p>erlang心跳机制</p>
<p>什么是erlang心跳机制？这是erlang运行时系统定期监控系统是否正常运行的程序。
erlang为什么要心跳机制？我们都知道，erlang有很多进程监督树，启动了很多supervisor来保证process的高可靠性， 但如果连emulator也死掉了，那erlang也就回天乏术了， 所以这时只能靠heart 来重新启动erlang。</p>
<pre><code>1. C:\&gt;erl -heart -env HEART_COMMAND &quot;erl -heart&quot;  
2. Eshell V5.10.2  (abort with ^G)  
3. 1&gt;  
</code></pre>
<p>这时候你可以按 CTRL + C 挂起erlang，或者直接关闭 erlang shell 窗口，系统都会重新打开erlang shell</p>
<p>erlang心跳原理
erlang心跳机制的实现原理是启动一个 heart 进程，通过定时发送特定消息来检查erlang是否正常回应，收不到回应则判断erlang没有正常工作。
erlang心跳参数
<img src="5.%E8%BF%9B%E9%98%B6//images/screenshot_1534591408101.png" alt="pic" />
参数项 说明  注意
HEART_COMMAND   心跳监控程序发现erlang没正常运行时执行的命令   在Windows下还可以调用其他进程或命令
HEART_BEAT_TIMEOUT  心跳超时，如果监控程序发出的检查消息在这个时间没有得到回应，就会执行 HEART_COMMAND 命令，默认60秒，有效范围 10 ~ 65535   如果调整系统时间，而且超过了这个限定，erlang进程也会被重启
ERL_CRASH_DUMP_SECONDS  用以控制erlangg崩溃时写日志的行为。0表示不写日志；-1表示写完日志再重启erlang；其他表示写入的等待完成时间，如果还没写完也将强制重启。默认0   如果这个参数没有设置，erlang就不会写crash日志</p>
<ol>
<li>% 获取 HEART_COMMAND 命令</li>
<li>1&gt; heart:get_cmd().</li>
<li>{ok,&quot;erl -heart&quot;}</li>
<li></li>
<li>% 设置临时 HEART_COMMAND 命令</li>
<li>2&gt; heart:set_cmd(&quot;heart -shutdown&quot;).</li>
<li>ok</li>
<li></li>
<li>% 获取 HEART_COMMAND 命令，当临时 HEART_COMMAND 命令设置时取了 临时命令的值</li>
<li>3&gt; heart:get_cmd().</li>
<li>{ok,&quot;heart -shutdown&quot;}</li>
<li></li>
<li>% 清除临时 HEART_COMMAND 命令</li>
<li>4&gt; heart:clear_cmd().</li>
<li>ok</li>
<li></li>
<li>% 获取 HEART_COMMAND 命令</li>
<li>5&gt; heart:get_cmd().</li>
<li>{ok,&quot;erl -heart&quot;}</li>
</ol>
<p>也就是说erlang HEART_COMMAND 命令有两种形式：全局环境变量的和临时变量。如果临时命令存在则取执行临时命令。
关闭erlang心跳
有可能我们要临时关闭erlang，对erlang程序进行维护。这时就要就要关闭erlang心跳，否则将无法关闭erlang。关闭erlang心跳方法很简单，如下：
q().</p>
<div style="break-before: page; page-break-before: always;"></div><p>二进制存储</p>
<p>erlang二进制数据在内存中有两种存在形式，当数据大小不到 64 bytes，就直接存在进程堆内，如果超过了64 bytes，就被保存到进程外的共享堆里，可以给节点内所有进程共享。</p>
<p>erlang有两种二进制容器：heap binaries和refc binaries。</p>
<p>heap binaries
这个就是进程堆二进制，是一些比较小的二进制数据，每个数据大小不超过64bytes，这些数据保存在进程堆内。对于这里的二进制数据，垃圾回收走的是进程堆数据的回收机制，参考这里。如果发给其他进程的消息含有这些数据，erlang将直接复制一份到别的进程堆内。</p>
<p>refc binaries
官方的叫法是引用计数二进制，就是对于那些超过64bytes的二进制数据，他们如果直接保存在进程堆内，将导致进程频繁的gc，比较大的数据复制来复制去开销也很大。所以，erlang将这些数据保存在进程外的共享堆，再把这个二进制数据的地址给拥有这个数据的进程。所以，进程堆内保存的是这个二进制数据的引用，叫ProcBin。如果进程把这个二进制数据发给其他进程，erlang也不再复制整个二进制数据，而是直接再生成一份ProcBin到别的进程堆内。那么，这个二进制数据就可以多个进程的ProcBin引用，当没有一个ProcBin引用到这个二进制数据，这个二进制就被erlang回收。</p>
<p>所以，这种二进制数据的gc的是引用计数的回收机制。注意了，ProcBin是进程堆内数据，走的是进程堆数据的回收方式。</p>
<p>进程间存储 使用分代</p>
<div style="break-before: page; page-break-before: always;"></div><p>os:timestamp() 获取到的时间为操作系统的时间，不做任何修正；</p>
<p>而erlang:now()，每次获取都会确保生成了唯一的时间，就是说，erlang:now()在实现上对时间做了一个校正，每次都生成一个单调向前的唯一值。</p>
<p>主要是这3个特点：</p>
<p>特点</p>
<p>说明</p>
<p>单调向前</p>
<p>erlang:now() 获取的时间是单调向前，就算系统时间倒退了，也不会影响这个函数的使用。（时间依旧是向前的，较之前几乎没有偏差）</p>
<p>唯一性</p>
<p>erlang:now() 获取的值都是唯一的，不会重复出现2个相同的值。</p>
<p>间隔修正</p>
<p>两次 erlang:now() 调用的间隔都可以被利用来修正erlang时间。</p>
<p>erlang 时间校正
时间校正的作用：
在开始这段内容前，讲讲时间校正的作用</p>
<ol>
<li>
<p>时间单调向前：
举个例子，说明时间倒退问题：
比如，游戏中会统计今天和昨天杀怪的总数量，跨零点时要把今天杀怪字段的数量写到昨天的字段，然后将今天的置0。跨零点后，如果时间倒退了几秒钟，然后就会重复跨零点。那么，今天的数量会覆盖昨天的数量，导致昨天的数量被清零。</p>
</li>
<li>
<p>时间平稳：
同样举个例子，说明时间不平稳问题：
比如，erlang开发中，经常都会出现一个进程call另一个进程的场景，一般是5秒超时，假如时间突然加快了5秒，就相当于没有等待操作完成，就直接超时了。当然这是很不合理的</p>
</li>
</ol>
<p>假如操作系统时间出现了改变，erlang不会立刻改变内部时间为系统时间，而是将时间轻微加快或减慢，最终和系统时间保持一致。就算系统时间突然倒退到以前的某个时间，但时间总是向前这点是不会改变的，所以，erlang只是预期在将来某个时间和系统时间达成一致，而不会倒退时间。</p>
<p>erlang是怎么校正时间的？
erlang内部时间会和系统挂钟时间保持同步，当系统挂钟时间突然改变时，erlang会比较两个时间的差异，让内部的时间的同步值轻微变大或变小，幅度最大是1%，就是说，VM经历 1s 实际上可能就是 0.99s 或者1.01s。当系统时间改变了1分钟，erlang会花100分钟来慢慢校正，并最终和系统时间保持同步。</p>
<p>哪些函数受到时间校正影响？
erlang:now/0
The infamous erlang:now/0 function uses time correction so that differences between two &quot;now-timestamps&quot; will correspond to other timeouts in the system. erlang:now/0 also holds other properties, discussed later.
receive ... after
Timeouts on receive uses time correction to determine a stable timeout interval.
The timer module
As the timer module uses other built in functions which deliver corrected time, the timer module itself works with corrected time.
erlang:start_timer/3 and erlang:send_after/3
The timer BIF's work with corrected time, so that they will not fire prematurely or too late due to changes in the wall clock time.
不只是 erlang:now() ，以上几个功能都有赖于时间校正的实现。比如 erlang:send_after/3 , 就算系统时间改变了，这个函数发出的消息也会按预定时间期限送达。</p>
<div style="break-before: page; page-break-before: always;"></div><p>官方文档：<a href="http://www.erlang.org/doc/man/erl.html">http://www.erlang.org/doc/man/erl.html</a></p>
<p>erlang启动参数有3种：emulator flags, flags 和plain arguments。</p>
<p>emulator flags 是以“+”开头的，用来控制虚拟机的行为，附送一个非常实用的例子：</p>
<pre><code class="language-bash">erl +p  100000 # 最大进程数
erl -pa ebin 
+K true  #开启epoll调度，在linux中开启epoll，会大大增加调度的效率
+A 10  #异步线程池大小默认10
+sbt db  #绑定调度器，绑定后调度器的任务队列不会在各个CPU线程之间跃迁，结合sub使用，可以让CPU负载均衡的同时也避免了大量的跃迁发生。 注意：一个linux系统中，最好只有一个evm开启此选项，若同时有多个erlang虚拟机在系统中运行，还是关闭为好
+sub true #开启CPU负载均衡，false的时候是采用的CPU密集调度策略，优先在某个CPU线程上运行任务，直到该CPU负载较高为止。
+sbwt very_long  #此选项设置为eager后，CPU将更频繁的被唤醒，可以增加CPU利用率
+swt very_low 
+Mulmbcs 32767 
+Mumbcgs 1 
+Musmbcs 2047
+spp true #开启并行port并行调度队列，当开启后会大大增加系统吞吐量，如果关闭，则会牺牲吞吐量换取更低的延迟。
+zdbbl 65536 分布式erlang的端口buffer大小，当buffer满的时候，向分布式的远程端口发送消息会阻塞
+e Number Ets表的最大数量
+ec 强制Ets表启动压缩
+fnl 如果文件使用了ISO-latin-1编码
+fnu(w|i|e) 文件使用utf8编码
+fna(w|i|e) 和当前系统一致
+hms Size 指定erlang进程的默认最小堆内存大小
+hmbs Size 指定进程默认二进制虚拟内存堆大小
+hpds Size initial process dictionary size
</code></pre>
<p>flags 是以“-”开头的， 是erlang运行时系统的参数，可以用init:get_argument/1获得。
plain arguments 普通参数，在第一个flag参数前，或在-- flag之后，-extra后的参数都是普通参数。</p>
<pre><code class="language-bash">erl +W w -sname arnie +R 9 -s my_init -extra +bertie
(arnie@host)1&gt; init:get_argument(sname).
 {ok,[[&quot;arnie&quot;]]}
(arnie@host)2&gt; init:get_plain_arguments().
        [&quot;+bertie&quot;]
</code></pre>
<p><img src="5.%E8%BF%9B%E9%98%B6/5.6Erlang%E5%90%AF%E5%8A%A8//images/screenshot_1534591608930.png" alt="pic" /></p>
<p>Environment variables</p>
<p>ERL_CRASH_DUMP  设置crash.dump文件的路径
If the emulator needs to write a crash dump, the value of this variable will be the file name of the crash dump file. If the variable is not set, the name of the crash dump file will be erl_crash.dump in the current directory.</p>
<p>ERL_CRASH_DUMP_NICE
Unix systems: If the emulator needs to write a crash dump, it will use the value of this variable to set the nice value for the process, thus lowering its priority. The allowable range is 1 through 39 (higher values will be replaced with 39). The highest value, 39, will give the process the lowest priority.</p>
<p>ERL_CRASH_DUMP_SECONDS</p>
<p>ERL_AFLAGS</p>
<p>ERL_ZFLAGS 和 ERL_FLAGS</p>
<p>ERL_LIBS</p>
<p>ERL_EPMD_PORT</p>
<p>让Erlang服务器后台运行
erlang默认运行时是带有终端的，在开发过程中可以很方便的检查程序的bug，但在开发完成后，应该以后台的方式运行服务。
-noshell (该参数关闭终端，但依然不会后台运行，有输出时会直接打印到当前屏幕
-noinput 禁止终端下的输入
-hidden 隐藏运行
-detached 后台方式运行
其实最好用的就是-detached，如果将此参数加入启动脚本，程序会立即进入后台运行，你可以通过进程号将其调入到前台，在加入此参数运行服务器后，查看当前正在运行的程序，你会发现这个参数自动被分解成了 -noshell 和 -noinput, 所以，在加入-detached后，就不需要再加这两个参数了。</p>
<div style="break-before: page; page-break-before: always;"></div><p>错误日志记录器会产生几种类型的报告：
Supervisor报告
在Supervisor启动或者停止被监管的进程时</p>
<p>Progress报告
每次OTP监管进程启动或者停止的时候会产生这个报告。</p>
<p>Crash报告
当被监管的进程退出时，如果它的退出原因不是normal或者shutdown，就会产生这个报告。
这三种报告是自动产生的，程序员无需关心。除此之外，当程序显式调用error_handler的方法时，也会产生三种日志报告。通过这三种报告，程序可以记录错误，警报以及提示信息。在这里，这三个术语并没有什么特别的语意，仅仅是程序员可以使用的三种标签，用来标明错误日志条目的自然属性（也就是说，想怎么用，随你）。</p>
<p>$erl -boot start_sasl -config elog1
注意 -config filename 不能使用全名称  elog1.config</p>
<pre><code class="language-config">elog1.conf 
{sasl, [
        {sasl_error_logger, {file, &quot;log/sasl-error.log&quot;}},
        {errlog_type, error},
        {error_logger_mf_dir, &quot;log/sasl&quot;},      % Log directory
        {error_logger_mf_maxbytes, 10485760},   % 10 MB max file size
        {error_logger_mf_maxfiles, 5}           % 5 files max
       ]},
</code></pre>
<p>sasl_error_logger<br />
错误信息的显示点
false：不显示,只有错误报告会被记录，进程报告之类的全部被忽略掉，而且所有的错误报告都在shell当中
tty：控制台
{file,File}：写到文件</p>
<p>errlog_type
error：错误信息
progress：进程信息
all：所有信息</p>
<p>产品化环境：</p>
<pre><code class="language-conf"> elog1.conf
     [{sasl, [
              % minimise shell error logging
              {sasl_error_logger, false},
              %only report errors
              {error_type, error},
              %define the parameters of the rotating log
              %the log file directory
              {error_logger_mf_dir, &quot;/home/joe/error_logs&quot;},
              % bytes per logfile
              {error_logger_mf_maxbytes, 10485760}, %10MB
              %maximum number of
              {error_logger_mf_maxfiles, 10}
             ]}].
</code></pre>
<pre><code class="language-erlang">rb:help().
rb:start([{max, 20}]).
rb:list().
rb:show(1).
rb:grep(RegExp).
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p><img src="5.%E8%BF%9B%E9%98%B6//images/screenshot_1534591818837.png" alt="pic" /></p>
<pre><code class="language-erlang">ets表 1400 erl -env ERL_MAX_ETS_TABLES 1000000
  erl +e 1000000
并发数  erl +P 1000000
erlang:system_info(process_limit). 2^18=262144 最大值为2^27-1=134217727 erlang实际使用的进程数量限制可能比你设置的要大得多，这是因为erlang运行系统选择的进程数量限制通常是2的幂
 有效范围是1024-134217727
打开文件数  linux并发读取文件最大数量
erlang:system_info(min_heap_size).  {min_heap_size,233}  min_heap_size是进程最小堆大小这个参数两个地方会用到，
  第一处是erlang初始化进程堆大小，
  第二处是gc后堆收缩后维持的最小值，
  
erlang:system_info(min_bin_vheap_size). {min_bin_vheap_size,46368} min_bin_vheap_size是进程最小虚拟二进制堆大小，这两个参数都是以word为单位。
  初始化足够大的初始内存，可以减少轻度gc的次数，减少反复申请和回收内存的开销
erlang:system_info(fullsweep_after).   {fullsweep_after,65535} fullsweep_after控制深扫描的频率
  这个参数确定多少次gc后执行一次深度gc，默认值为65536，有点大了
erlang:system_info(check_io).  
erlang:statistics(garbage_collection). {433,750604,0} 
erlang:statistics(io). {{input,3020851},{output,31981}} 
节点名称限制  一个节点的远程节点的最大数目是由可用于节点名称atom的最大数目的限制，换句话说，节点名称限制数量取决于atom的最大数量。另外，节点名称长度也和atom有关，不能超过255个字符。
节点连接限制  能够同时连接的最大节点数是由节点名称限制，可用端口限制，或者可用socket限制共同决定
atom的最大数量  设置erlang系统最大能够处理的原子（atom）数量，默认是1048576 通过配置erlang启动参数（标志+t）可以改变进程数量限制
  一个atom最多能有255个字符
tuple中最大元素数量  2^26=67108863个
二进制数据(binary)的大小限制   32位机器上最大不超过 2^29-1 = 536870911 个字节 64位机器上最大不超过 2^61-1 = 2305843009213693951 个字节
  果超出限制，erlang位语法（bit syntax）将无法工作，直接抛出 system_limit 异常
一个Erlang节点最大分配的数据空间大小  Erlang运行时系统可以使用到32（或64）位地址空间，事实上，操作系统对单个进程的使用空间做了限制
同时打开的端口数量限制  erlang对同时打开的端口数量做出了限制。默认是65536，Windows下是8096。有效值范围是1024-134217727
erlang:system_info(port_limit)  可以通过环境变量ERL_MAX_PORTS修改，或者配置erlang启动参数（标志+Q）修改
  erlang实际使用的端口数量限制可能比你设置的要大得多，这是因为erlang运行系统选择的端口数量限制通常是2的幂
同时打开的文件和socket数量限制  能同时打开的最大文件和socket数量取决于最大能打开的端口数量，以及操作系统的设定和限制
dets表存储限制  单个dets文件大小不能超过2G，在64位的系统也有此限制，mnesia也受到这个限制
  


The unit of measurement is memory words. There exists both a 32-bit and a 64-bit implementation. A word is therefore 4 bytes or 8 bytes, respectively.
Data Type Memory Size
Small integer 1 word.On 32-bit architectures: -134217729 &lt; i &lt; 134217728 (28 bits).On 64-bit architectures: -576460752303423489 &lt; i &lt; 576460752303423488 (60 bits).
Large integer 3..N words.
Atom 1 word.An atom refers into an atom table, which also consumes memory. The atom text is stored once for each unique atom in this table. The atom table is not garbage-collected.
Float On 32-bit architectures: 4 words.On 64-bit architectures: 3 words.
Binary 3..6 words + data (can be shared).
List 1 word + 1 word per element + the size of each element.
String (is the same as a list of integers) 1 word + 2 words per character.
Tuple 2 words + the size of each element.
Pid 1 word for a process identifier from the current local node + 5 words for a process identifier from another node.A process identifier refers into a process table and a node table, which also consumes memory.
Port 1 word for a port identifier from the current local node + 5 words for a port identifier from another node.A port identifier refers into a port table and a node table, which also consumes memory.
Reference On 32-bit architectures: 5 words for a reference from the current local node + 7 words for a reference from another node.On 64-bit architectures: 4 words for a reference from the current local node + 6 words for a reference from another node.A reference refers into a node table, which also consumes memory.
Fun 9..13 words + the size of environment.A fun refers into a fun table, which also consumes memory.
Ets table Initially 768 words + the size of each element (6 words + the size of Erlang data). The table grows when necessary.
Erlang process 327 words when spawned, including a heap of 233 words.


Processes The maximum number of simultaneously alive Erlang processes is by default 32,768. This limit can be configured at startup. For more information, see the +P command-line flag in the erl(1) manual page in erts.
Known nodes A remote node Y must be known to node X if there exists any pids, ports, references, or funs (Erlang data types) from Y on X, or if X and Y are connected. The maximum number of remote nodes simultaneously/ever known to a node is limited by the maximum number of atoms available for node names. All data concerning remote nodes, except for the node name atom, are garbage-collected.
Connected nodes The maximum number of simultaneously connected nodes is limited by either the maximum number of simultaneously known remote nodes, the maximum number of (Erlang) ports available, orthe maximum number of sockets available.
Characters in an atom 255.
Atoms By default, the maximum number of atoms is 1,048,576. This limit can be raised or lowered using the +t option.
Ets tables Default is 1400. It can be changed with the environment variable ERL_MAX_ETS_TABLES.
Elements in a tuple The maximum number of elements in a tuple is 67,108,863 (26-bit unsigned integer). Clearly, other factors such as the available memory can make it difficult to create a tuple of that size.
Size of binary In the 32-bit implementation of Erlang, 536,870,911 bytes is the largest binary that can be constructed or matched using the bit syntax. In the 64-bit implementation, the maximum size is 2,305,843,009,213,693,951 bytes. If the limit is exceeded, bit syntax construction fails with a system_limit exception, while any attempt to match a binary that is too large fails. This limit is enforced starting in R11B-4.In earlier Erlang/OTP releases, operations on too large binaries in general either fail or give incorrect results. In future releases, other operations that create binaries (such as list_to_binary/1) will probably also enforce the same limit.
Total amount of data allocated by an Erlang node The Erlang runtime system can use the complete 32-bit (or 64-bit) address space, but the operating system often limits a single process to use less than that.
Length of a node name An Erlang node name has the form host@shortname or host@longname. The node name is used as an atom within the system, so the maximum size of 255 holds also for the node name.
Open ports The maximum number of simultaneously open Erlang ports is often by default 16,384. This limit can be configured at startup. For more information, see the +Q command-line flag in the erl(1) manual page in erts.
Open files and sockets The maximum number of simultaneously open files and sockets depends on the maximum number of Erlang ports available, as well as on operating system-specific settings and limits.
Number of arguments to a function or fun 255
Unique References on a Runtime System Instance Each scheduler thread has its own set of references, and all other threads have a shared set of references. Each set of references consist of 2⁶⁴ - 1 unique references. That is the total amount of unique references that can be produced on a runtime system instance is (NoSchedulers + 1) * (2⁶⁴ - 1). If a scheduler thread create a new reference each nano second, references will at earliest be reused after more than 584 years. That is, for the foreseeable future they are unique enough.
Unique Integers on a Runtime System Instance There are two types of unique integers both created using the erlang:unique_integer() BIF. Unique integers created:
 with the monotonic modifier
         consist of a set of 2⁶⁴ - 1 unique integers.
 without the monotonic modifier
         consist of a set of 2⁶⁴ - 1 unique integers per scheduler thread and a set of 2⁶⁴ - 1 unique integers shared by other threads. That is the total amount of unique integers without the monotonicmodifier is (NoSchedulers + 1) * (2⁶⁴ - 1)
 If a unique integer is created each nano second, unique integers will at earliest be reused after more than 584 years. That is, for the foreseeable future they are unique enough.

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h2 id="me"><a class="header" href="#me">me</a></h2>
<p><a href="https://git.01cs.cc/yujian/the_seed">https://git.01cs.cc/yujian/the_seed</a></p>
<p><a href="https://git.01cs.cc/yujian/network">https://git.01cs.cc/yujian/network</a></p>
<p><a href="https://git.01cs.cc/yujian/parse_tool">https://git.01cs.cc/yujian/parse_tool</a></p>
<p><a href="https://git.01cs.cc/yujian/cache">https://git.01cs.cc/yujian/cache</a></p>
<h2 id="mochiweb源码"><a class="header" href="#mochiweb源码">mochiweb源码</a></h2>
<p>MochiWeb是一个用来构建Web应用的轻便，高效的HTTP应用框架的Erlang库
开发语言： ErLang
项目主页： <a href="https://github.com/basho/mochiweb">https://github.com/basho/mochiweb</a>
文档地址：
下载地址： <a href="https://github.com/mochi/mochiweb">https://github.com/mochi/mochiweb</a></p>
<h2 id="cowboy"><a class="header" href="#cowboy">cowboy</a></h2>
<p><a href="https://github.com/extend/cowboy">https://github.com/extend/cowboy</a>
网络服务器</p>
<h2 id="emysqleredid"><a class="header" href="#emysqleredid">emysql,eredid</a></h2>
<p>持久化</p>
<h2 id="protobuff"><a class="header" href="#protobuff">protobuff</a></h2>
<p>协议层</p>
<h2 id="ets"><a class="header" href="#ets">ets</a></h2>
<p>用自己这个简单的cache
联系写aoi一类的算法
逻辑程</p>
<h2 id="rebar源码"><a class="header" href="#rebar源码">rebar源码</a></h2>
<p>lager
<a href="https://github.com/basho/lager">https://github.com/basho/lager</a>
protobuffs
<a href="https://github.com/roowe/erlang_protobuffs">https://github.com/roowe/erlang_protobuffs</a>
ibrowse
<a href="https://github.com/cmullaparthi/ibrowse">https://github.com/cmullaparthi/ibrowse</a>
getopt
<a href="https://github.com/roowe/getopt">https://github.com/roowe/getopt</a>
recon
<a href="https://github.com/ferd/recon">https://github.com/ferd/recon</a>
gen_smtp
<a href="https://github.com/Vagabond/gen_smtp">https://github.com/Vagabond/gen_smtp</a>
dynarec
<a href="https://github.com/dieswaytoofast/dynarec">https://github.com/dieswaytoofast/dynarec</a>
folsom
<a href="https://github.com/boundary/folsom">https://github.com/boundary/folsom</a>
ets_cache
<a href="https://github.com/roowe/ets_cache">https://github.com/roowe/ets_cache</a>
gproc
<a href="https://github.com/uwiger/gproc">https://github.com/uwiger/gproc</a>
gs_cron
<a href="https://github.com/roowe/gs_cron">https://github.com/roowe/gs_cron</a>
gs_tcp
<a href="https://github.com/roowe/gs_tcp">https://github.com/roowe/gs_tcp</a>
reloader
<a href="https://github.com/roowe/reloader">https://github.com/roowe/reloader</a>
emysql
<a href="https://github.com/Eonblast/Emysql">https://github.com/Eonblast/Emysql</a>
cover_tool
<a href="https://github.com/roowe/cover_tool">https://github.com/roowe/cover_tool</a>
uuid
<a href="https://github.com/avtobiff/erlang-uuid">https://github.com/avtobiff/erlang-uuid</a>
jiffy
<a href="https://github.com/davisp/jiffy">https://github.com/davisp/jiffy</a>
NIF json解析库</p>
<p>CouchDB 项目
CouchDB是一个&quot;面向文档&quot;的数据库，采用 ErLang 语言开发，文档的格式是一个JSON字符串（也可包含二进制附件）。 底层结构是由一个&quot;存储&quot;(storeage) ，以及多个&quot;视图索引&quot;(view indexs)。 &quot;储存&quot;用来储存文件, &quot;视图索引&quot;用于查询处理。
CouchDB落实到最底层的数据结构就是两类B+Tree 。
CouchDB 能够适应非常广泛的应用场景，在某些偶尔连接网络的应用中，我们可以用CouchDB暂存数据，随后进行同步。也可以在Cloud环境中，作为大型的分布 式的数据存储。CouchDB提供了基于 HTTP的API的访问方式，这样，保证了所有的常见的语言都可以使用CouchDB。
开发语言： ErLang
项目主页： <a href="http://incubator.apache.org/couchdb/">http://incubator.apache.org/couchdb/</a>
文档地址： <a href="http://incubator.apache.org/co">http://incubator.apache.org/co</a> ... .html
下载地址： <a href="http://incubator.apache.org/couchdb/downloads.html">http://incubator.apache.org/couchdb/downloads.html</a></p>
<p>ejabberd 项目
ejabberd是的Jabber / XMPP协议的即时通讯服务器，持牌GPLv2许可下（自由和开放源码） ，写的爱尔朗/检察官办公室。在其它特性中， ejabberd是跨平台，容错， clusterable和模块化。
开发语言： ErLang
项目主页： <a href="http://www.ejabberd.im/">http://www.ejabberd.im/</a>
文档地址： <a href="http://www.process-one.net/doc">http://www.process-one.net/doc</a> ... .html
下载地址： <a href="http://www.process-one.net/en/ejabberd/downloads/">http://www.process-one.net/en/ejabberd/downloads/</a></p>
<p>rabbitmq 项目
rabbitmq 是一个实现了AMQP协议的消息服务器
开发语言： ErLang
项目主页： <a href="http://www.rabbitmq.com/">http://www.rabbitmq.com/</a>
文档地址： <a href="http://www.rabbitmq.com/documentation.html">http://www.rabbitmq.com/documentation.html</a>
下载地址： <a href="http://www.rabbitmq.com/download.html">http://www.rabbitmq.com/download.html</a></p>
<p>Disco 项目
Disco 是一个实现了Map-Reduce 的框架，采用 Erlang + Python 开发
开发语言： ErLang Python
项目主页： <a href="http://discoproject.org/">http://discoproject.org/</a>
文档地址： <a href="http://discoproject.org/doc/">http://discoproject.org/doc/</a>
下载地址： <a href="http://discoproject.org/download.html">http://discoproject.org/download.html</a></p>
<p>tsung 项目
压力测试工具，可以测试包括HTTP, WebDAV, PostgreSQL, MySQL, LDAP, and XMPP/Jabber等服务器
开发语言： ErLang
项目主页： <a href="http://tsung.erlang-projects.org/">http://tsung.erlang-projects.org/</a>
文档地址：
下载地址： <a href="http://tsung.erlang-projects.o">http://tsung.erlang-projects.o</a> ... ar.gz</p>
<p>wxErlang 项目
wxErlang不仅是一个跨平台ErLang的GUI框架。它不像其他许多现有的GUI库，采用了本地的外观和感觉的基本平台。也就是 说，如 果一个 应用程序的执行在Mac OS X的应用程序会看起来像一个真正** Mac OS X的应用程序。 Linux下和GNOME ，它的外观就像一个普通的GNOME应用程序。和Windows环境下，它会看起来像一个Windows应用程序。
wxErlang 是一个 Erlang 语言对 C++ 的 GUI 库 wxWidgets 的封装。</p>
<p>Dynomite 项目
Dynomite 是采用 ErLang 语言开发的分布式的Key-Value存储系统。
开发语言： ErLang
项目主页： <a href="http://wiki.github.com/cliffmoon/dynomite">http://wiki.github.com/cliffmoon/dynomite</a></p>
<p>Ringo 项目
Ringo 是一个分布式的Key-Value存储系统，采用 ErLang 语言开发。支持磁盘数据存储。
开发语言： ErLang
项目主页： <a href="http://github.com/tuulos/ringo/tree/master">http://github.com/tuulos/ringo/tree/master</a></p>
<p>riak_sysmon
github : basho/riak_sysmon · GitHub
对erlang:system_monitor/0,1,2 的封装，尽快的发现系统中存在的long_gc，large_heap等性能隐患。针对上述痛点中的“refc binary”和“OOM”。</p>
<p>2、recon
github : ferd/recon · GitHub
封装了erlang:process_info/1,2 函数，并提供了TOPN的feature，recon_alloc封装了度量虚拟机内部内存的使用量的查询。
不仅如此，recon提供了一种近似度量Erlang进程CPU消耗的方案，Erlang tool -- recon ，memory leak的检查。针对上述痛点中的“Erlang进程CPU消耗度量”、“refc binary”，并且提供了种种便利。好用到爆的感觉。</p>
<p>3、eper/redbug
github : massemanet/eper · GitHub
刚开始接触Erlang时，社区提供的一种代码调试方案是日志。然，这种方式太不优雅，使用起来非常麻烦。
redbug是对Erlang系统中dbg模块的封装，提供了非常安全有效的代码调试方式。“安全”对生产环境来说，确实太过重要了。</p>
<p>4、pooler/poolboy
github : seth/pooler · GitHub
github : devinus/poolboy · GitHub
池。Erlang单进程效率的问题，非常常见的三种方式，第一种是池，第二种是noblock call，第三种是修改某个进程的资源配置。
在社区中，常见的是第一种方案，而第二种和第三种方案常见于Erlang编程语言编源码中（rpc模块，net_kernel模块）。针对上述痛点中的“单进程问题”。</p>
<p>5、jiffy
github : davisp/jiffy · GitHub
json处理库，而且是nif的，能够尽可能保证效果，并且可以支持return_maps已经encode force_utf8，decode 的return_maps能直接返回map 数据类型，非常之方便。（虽然17的map效率不怎么样，但是18版本做了很大的优化）</p>
<p>6、entop
github : mazenharake/entop · GitHub
有没有觉得Erlang自带的etop有些难用？entop提供了非常不错的可替代方案。</p>
<p>7、erlang-lz4
github : szktty/erlang-lz4 · GitHub
不管是Erlang系统，还是其他系统，所倡导的都是“小消息，大计算”，加之Erlang消息传递是值传递的方式，对于大的message，稍微做一下压缩，获取能取得意想不到的效果。不放试一试，lz4 的算法，请Google 之。</p>
<p>8、sync
github : rustyio/sync · GitHub
on-the-fly recompiling and reloading in Erlang. 大幅度提高工作效率，避免接二连三的重新compile、generate。不过，要注意的是，最好只用在开发环境下。</p>
<blockquote>
<p>关于热更，多叨叨两句：
1，在supervisor下增删 gen_server child 热更会失败，目前无解，除非修改supervisor源代码
2，gen_server record 增删字段，这个可用 “使用proplists字段值”或者是“map字段值”
3，gen_server init 函数逻辑无法热更，解决办法，重写code_change 代码
至于常规的逻辑代码，热更基本上没什么问题</p>
</blockquote>
<p>9、erlang_term
github : okeuday/erlang_term · GitHub
存了一个Term到ETS表中，难道不应该知道这个Term到底占用了多大的内存空间吗？要send一个大的message给另一个进程，不度量一点内存占用大小就随心所欲？恐怕不太好。erlang_term可以作为贴心小工具。Erlang ets -- something about cache continue</p>
<p>10、folsom
github : boundary/folsom · GitHub
提供了多种Metrics 模型，根据自己的应用场景，选择不同的模型就行。内部主要使用ets:update_counter/3,4，性能效果很有保证。</p>
<p>11、ej
github : seth/ej · GitHub
Helper module for working with Erlang terms representing JSON
试试就知道有没有意思，好不好玩了。</p>
<p>12、task
github : redink-toys/task · GitHub
遇到过这样一个有意思的场景：主进程是一个普通进程，有10W量级的列表，我想将其过滤之后，将1/2或者是1/4的列表写入到ETS表中，然后进行后续的操作。如果我在主进程中做这一些列操作，这个主进程就会被挂住，因为GC（Erlang的GC不会STW，但很有可能会STP）。考虑到ETS表可以在不同的进程之间共享数据，我就可以在主进程中spawn一个进程，这个这个进程去执行过滤、写入操作，然后这个进程生命周期结束之后，GC是很简单快速的。
task就是一个spawn、receive的简单封装。</p>
<p>13、xref_runner
github : inaka/xref_runner · GitHub
做xref检查：善待Erlang 代码 -- Xref 实践</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h2 id="ets基础"><a class="header" href="#ets基础">ETS基础</a></h2>
<p>ETS查询时间是常量,例外是如果使用ordered_set查询时间与logN成正比(N为存储的数据量)</p>
<p>ETS Table由进程创建,进程销毁ETS Table也随着销毁,在使用Shell做ETS实验的时候要注意一下,Table的拥有关系可以give_away 转交给其它进程</p>
<p>一个Erlang节点的ETS表的数量是有限制的,默认是1400个表,在启动erlang节点之前修改 ERL_MAX_ETS_TABLES参数可以修改这个限制ejabberd社区站点上总结的性能调优中提到了这一点,点击这里查看:
<a href="http://www.ejabberd.im/tuning">http://www.ejabberd.im/tuning</a></p>
<p>ETS表不在GC的管理范围内，除非拥有它的进程死掉它才会终止；可以通过delete删除数据</p>
<p>目前版本,insert和lookup操作都会导致对象副本的创建,insert和lookup时间对于set bag duplicate_bag都是常量值与表大小无关.</p>
<p>并发控制：所有针对一个对象的更新都被保证是原子的、隔离的：修改要么全部成功要么失败。也没有其它的中间结果被其它的进程使用。有些方法可以在处理多个对象的时候保证这种原子性和隔离性。</p>
<p>在数据库术语中隔离级别被称作序列化，就好像所有隔离的操作一个接一个严格按照顺序执行。</p>
<p>在遍历过程中,可以使用safe_fixtable来保证遍历过程中不出现错误,所有数据项只被访问一遍.用到逐一遍历的场景就很少，使用safe_fixtable的情景就更少。不过这个机制是非常有用的，还记得在.net中版本中很麻烦的一件事情就是遍历在线玩家用户列表.由于玩家登录退出的变化,这里的异常几乎是不可避免的.select match内部实现的时候都会使用safe_fixtable</p>
<p><img src="7.%E9%A1%B9%E7%9B%AE/7.1Mnesia//images/screenshot_1534763574440.png" alt="pic" /></p>
<pre><code class="language-erlang">set,ordered_set,bag,duplicate_bag 指定创建的table类型

public,private,protected 指定table的访问权限，若是public表示所有process都可以对该table进行读写(只要你知道TableId或者TableName)，private表示只有创建表的process才能对table进行读写，而protected则表示所有的process都可以对表进行读取，但是只有创建表的process能够对表进行写操作（ps: ets table仅可以被同一个erlang node中的processes共享）

named_table 若指定了named_table这个属性，就可以使用表名(也就是new函数的第一个参数Name)对表进行操作，而无需使用TableId

{keypos,Pos} 上面说到，我们默认使用tuple中第一个元素作为Key，那么是否可以修改这个规则呢？自然可以，使用{keypos,Pos}即可，其中Pos就是表示使用tuple中第几个元素作为Key

{heir, Pid, HeirData},{heir,none} 这个heir属性指明当创建table的process终止时，是否有其他process来继承这个table，默认值是{heir,none},表示没有继承者，所以当创建表的process终止时，表也随之被delete；若我们指定了{heir,Pid,HeirData}，那么当创建表的process终止时，process identifer为Pid的process将会收到一个消息：{'ETS-TRANSFER',tid(),FromPid,HeirData},这样表的拥有权就转交了，我们可以看下面这段测试代码
</code></pre>
<p><img src="7.%E9%A1%B9%E7%9B%AE/7.1Mnesia//images/screenshot_1534763622130.png" alt="pic" /></p>
<pre><code class="language-erlang">match(Tab, Pattern, Limit) -&gt; {[Match],Continuation} | '$end_of_table'
match(Continuation) -&gt; {[Match],Continuation} | '$end_of_table' 

match_object(Tab, Pattern, Limit) -&gt; {[Match],Continuation} | '$end_of_table'
match_object(Continuation) -&gt; {[Match],Continuation} | '$end_of_table'  

select(Tab, MatchSpec, Limit) -&gt; {[Match],Continuation} | '$end_of_table' 
select(Continuation) -&gt; {[Match],Continuation} | '$end_of_table' 

ets:all()
列出所有的ETS Table  
ets:i()
给出一个ETS Table的清单 包含表的类型,数据量,使用内存,所有者信息 
ets:i(zen_ets)
输出zen_ets表的数据
ets:info(zen_ets)
单独查看一个ETS Table的详细信息
表被锁了可以使用ets:info(zen_ets,fixed)查看, 

看表里面是否存在键值为Key的数据项. 
ets:fun2ms
ets:fun2ms( fun( {Name, Country, Job} ) when Job /= cook -&gt; [Country, Name] end ). 
  [{{'$1','$2','$3'}, [{'/=','$3',cook}], [['$2','$1']]}] 
   
ets:fun2ms( fun( #table{ name=N, id= Id } ) when N &gt; 1000 -&gt; ['$$'] end ) 

include_lib(&quot;stdlib/include/ms_transform.hrl&quot;).
Match specifications的详细说明参见这里: http://www.erlang.org/doc/apps/erts/match_spec.html  
MS = ets:fun2ms(fun({ Name,Country , Position }  ) when Position /=cook -&gt; [Country,Name ] end   )  
new(Name, Options)
Option = 
       Type = set | ordered_set | bag | duplicate_bag
       | Access = public | protected | private
       | named_table
       | {keypos, Pos}
       | {heir, Pid :: pid(), HeirData::term()}
       | {heir, none}
       | Tweaks = {write_concurrency, boolean()} | {read_concurrency, boolean()} | compressed
ets:insert(Table, Value)
ets:lookup(Table, Key)
ets:delete(Table, Key)
ets:member(Tab, Key) 



select_count()
MS2=ets:fun2ms(fun(T={A,B,C}) when B=:=&quot;hi&quot; -&gt; true end). 
Count2 = ets:select_count(task_table,MS2). 
['$$']||['$_']

</code></pre>
<p><img src="7.%E9%A1%B9%E7%9B%AE/7.1Mnesia//images/screenshot_1534763659878.png" alt="pic" /></p>
<p><a href="https://snapbrowse.com/browse.php/Oi8vd3d3/LmVybGFu/Zy5zZS93/b3Jrc2hv/cC8yMDAz/L3BhcGVy/L3A0My1m/cml0Y2hp/ZS5wZGY_/3D/b0/">A Study of Erlang ETS Table Implementation and Performance</a></p>
<div style="break-before: page; page-break-before: always;"></div><p>schema -&gt; 分布式信息</p>
<p><img src="7.%E9%A1%B9%E7%9B%AE/7.1Mnesia//images/screenshot_1534762821737.png" alt="pic1" /></p>
<pre><code class="language-erlang">mnesia:create_schema(NodeList). 该函数用来初始化一个新的空模式,在 Mnesia
 启动之前这是一个强制性的必要步骤。
 Mnesia 是一个真正分布式的数据库管理系统,而模式是一个系统表,它被复制到 Mnesia 系统的所有节点上。
 如果 NodeList 中某一个节点已经有模式,则该函数会失败。该函数需要 NodeList 中所有节点上的 Mnesia 都停止之后才执行。应用程序只需调用该函数一次,因为通常只需要初始化数据库模式一次
mnesia:delete_schema(DiscNodeList) 该函数在 DiscNodeList 节点上删除旧的模式,
 它也删除所有旧的表和数据。
 该函数需要在所有数据库节点(db_nodes)上的Mnesia 都停止后才能执行
mnesia:delete_table(Tab). 该函数永久删除表 Tab 的所有副本 。
mnesia:clear_table(Tab). 该函数永久删除表 Tab 的全部记录
mnesia:move_table_copy(Tab, From, To). 该函数将表 Tab 的拷贝从 From 节点移动到 To 节点。表的存储类型{type}被保留,这样当移动一个 RAM 表到另一个节点时,在新节点上也维持一个 RAM 表。在表移动的过程中仍然可以有事务执行读和写操作 。
mnesia:add_table_copy(Tab, Node, Type). 该函数在 Node 节点上创建 Tab 表的
 备份。Type 参数必须是 ram_copies 、 disc_copies 或者是 disc_only_copies。如果我们加一个系统表 schema 的拷贝到某个节点上,这意味着我们要 Mnesia 模式也驻留在那里。这个
 动作扩展了组成特定 Mnesia 系统节点的集合 。
mnesia:del_table_copy(Tab, Node). 该函数在 Node 节点上删除 Tab 表的备份,当
 最后一个备份被删除后,表本身也被删除。
mnesia:transform_table(Tab, Fun,NewAttributeList, NewRecordName). 该函数改变表 Tab 中所有记录的格式。它对表里所有记录调用参数 Fun 指明的函数进行处理,从表中取得旧的记录类型处理后返回新的纪录类型,表的键(key)可以不被改变。
 
 T= fun({test, A1,A2::test所有记录}) -&gt;  
     { test， A1,A2,&quot;add_clumn&quot;::对每一个记录进行修改|添加|删除 } end. 
 mnesia:transform_table(test,T,[id,name,age]--新的字段).  
  
  
 Fun = fun({person, Name, Age})  -&gt; {person, Name, Age, 0} end, 
 NewAttr = [name, age, money], 
 mnesia:transform_table(person, Fun, NewAttr, person).
 
change_table_copy_type(Tab, Node, ToType). 该函数改变表的存储类型。例如,将在 Node 节点上指定的内存类型的表 Tab 改为磁盘类型的表
 disc_only_copies -&gt;建立磁盘表  
 disc_copies -&gt; 磁盘加内存表  
 ram_copies -&gt; 内存表
mnesia:change_config (extra_db_nodes, NodeList) 
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p><img src="7.%E9%A1%B9%E7%9B%AE/7.1Mnesia//images/screenshot_1534762874133.png" alt="pic1" /></p>
<pre><code class="language-erlang">mnesia:create_table(Name, Opts).
[
  {type, bag||set||ordered_set|| duplicate bag},  %默认值 set
*{disc_only_copies||disc_copies||ram_copies, NodeList},  %默认值是 [node()],可以同时新建三种类型的表
  {index,AttributeNameList},  %AttributeNameList 是一个原子类型的属性名列表
  {snmp, SnmpStruct} %SnmpStruct 在 SNMP 用户指南中描述，表示该表可以立即通过简单网络管理协议(SNMP)来访问
  {local_content, true} %表名对所有 Mnesia 点可见,但是内容对每个节点都是唯一的。这种类型的表只能在本地进行存取
*{attributes, record_info( fields, itemGene )},  
  {record_name, Name},  %指定表中所有记录的通用名
  [{frag_properties,
                     [{n_fragments, 20}, {n_disc_copies, 1},
                     {node_pool, [node()]}]},
  ]

set -&gt; 每一个元组的键值都不能相同 
ordered_set -&gt; 元组会进行排序 
bag -&gt; 多个元组可以有相同的键值,一条记录确定唯一性 
 duplicate_bag -&gt; 多个元组可以有相同的键值，同一个元组可以在表中出现多次 

local_content -&gt; 应用需要一个其内容对每个节点来说在本地都是唯一的表，这种类型的表只能在本地进行存取

frag_properties %分片属性

mnesia:create_table( table_name, [{ram_copies, [a@yujian,b@yujian]}] ).建表
mnesia:system_info().
mnesia:table_info(Tab, Attr)
mnesia:system_info( running_db_nodes ). 
mnesia:table_info( table_name, frag_properties ).
 


mnesia:dump_to_textfile(Filename)  
mnesia:load_textfile/1
mnesia:backup(&quot;./backup.log&quot;).%二进制数据创建检查点，不受后面写数据影响 
mnesia:restore(&quot;./backup.log&quot;, Args).%表写锁,必须要存在表 

mnesia:install_fallback(Opaque, Args) -&gt; ok | {error,Reason} 
mnesia:uninstall_fallback(Args) -&gt; ok | {error,Reason}
mnesia:dump_tables(TabList).
ets转储到磁盘上
Mnesia 事件处理
mnesia:subscribe(Event-Category) %确保所有 Event-Category 类型事件的副本会发送给调用进程
mnesia:unsubscribe(Event-Category) %删除对 Event-Category 类型事件的订阅

Event-Category 可以是原子 system 或元组{{table, Tab, simple}或{table, Tab, detailed}二者之一。
旧的事件类别{table, Tab}与事件类别{table, Tab, simple}是一样的。订阅函数激活对事件的订阅。
对函数 mnesia:subscribe/1 求值即将事件作为消息发送给进程。
系统事件的语法是{mnesia_system_event, Event},表事件的语法是{mnesia_table_event, Event}。
系统事件和表事件的含义描述如下:所有的系统事件通过 Mnesia 的通用事件处理器(gen_event handler)来订阅,
默认的通用事件处理器是 mnesia_event,但可通过应用参数 event_module 来改变。
这个参数的值必须是一个模块名,该模块是使用标准库(STDLIB)的 gen_event 模块来实现的完整的事件处理模块。

mnesia:system_info(subscribers) 和 mnesia:table_info(Tab, subscribers)用来确定哪些进程订阅了何种事件。
文件
FALLBACK.BUP %这个文件被称为备份文件,包含一个初始模式。如果我们在 mnesia:create_schema/1 函数中指定了一个以上的节点,同一个备份文件将在所有这些节点上被创建

Schema.DAT %在备份文件 FALLBACK.BUP 中的模式被用来生成文件 schema.DAT

Table.DCL %Mnesia 插入此操作到 foo.DCL 中,随后在 Mnesia 认为.DCL 文件已经变得太大时,再将数据移入.DCD 文件 
Table.DCD %写到 foo 表中的所有数据最终将存储在这个文件中

LATEST.LOG %被 Mnesia 用来对基于磁盘的事务做日志
PREVIOUS.LOG %在日志被转储之前,文件 LATEST.LOG 改名为 PREVIOUS.LOG,并且创建一个新的LATEST.LOG 文件

在默认状态下,只要日志中写入了 100 条记录或者过去了 3 分钟这两种情况之一出现,Mnesia 即转储日志。
可用两个应用程序参数-mnesia dump_log_write_threshold WriteOperations 和-mnesia dump_log_time_threshold MilliSecs 来对此进行控制

.DAT %是建有索引的文件,可用指定的键在这些文件中高效地插入和搜索记录
mnesia:set_master_nodes(Tab,
Nodes)
mnesia:set_master_nodes(Nodes)
如果应用程序发现由于通信失败导致数据库的不一致，设定从哪个节点更新数据
mnesia:force_load_table(Tab)
可用来强行加载表而无视其被激活的加载机制
数据备份、操作备份数据
mnesia:backup_checkpoint(Name, Opaque, [Mod])。这个函数执行一个包含在检查点中的表备份。

mnesia:backup(Opaque, [Mod]) 。 这个函数激活一个覆盖全部 Mnesia 表的新检查点并且执行一次备份。备份以最大冗余度执行 (也可参见函数

mnesia:activate_checkpoint(Args), {max, MaxTabs} and {min, MinTabs})。

 mnesia:traverse_backup(Source,[SourceMod,]Target,[TargetMod,]Fun,Ac)。这个函数能用来读存在的备份,从一个现存的备份创建一个新的备份,或者在不同介质之间拷贝备份。

 mnesia:uninstall_fallback()。这个函数移除先前安装的回滚文件。

 mnesia:restore(Opaque, Args)这个函数从先前的备份恢复表。

mnesia:install_fallback(Opaque, [Mod])这个函数能够配置成从一个现存的备份重启 Mnesia并且重新加载数据库表以及可能的模式表。当数据或模式表损毁时,此函数被用于灾难恢复。

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p><img src="7.%E9%A1%B9%E7%9B%AE/7.1Mnesia//images/screenshot_1534762926983.png" alt="pic1" /></p>
<pre><code class="language-erlang">查询
mnesia:add_table_index( test, name). 
mnesia:del_table_index( test, name). 
mnesia:index_read(Table, Arg, Attr).
建表时，为该表建立索引使用元组{index, [attr1, attr2,....}
mnesia:index_match_object( alias, Pattern, #alias.alias_name, read ).

fun() -&gt; mnesia:write( New ) end 
fun() -&gt; mnesia:read( { table, Id } ) end 
fun() -&gt; mnesia:delete( {product, Id} ) end 
fun() -&gt;  [R] = mnesia:read( table, Id, write ), 
               New = R#table{ Id = Ids }, 
               mnesia:write( New ) 
end.  先做读取操作，参数write为下面的mnesia:write做准备

do:q 
-include_lib( &quot;stdlib/include/qlc.hrl&quot; ). 
select(StringBin )-&gt; 
         Fun = fun( Key ) -&gt; binary:match( Key, StringBin ) =/= nomatch end, 
        do( qlc:q([ UUID||#test_select{key= UUID} &lt;- mnesia:table( test_select ), Fun(UUID)]) ). 

do( Q ) -&gt; 
    F = fun() -&gt; qlc:e( Q ) end, 
    mnesia:transaction( F ). 


指定的选项为 {lock, Lock} 、{n_objects,Integer} 和{ traverse, SelMethod}
lock 选项指定 Mnesia 是否应该请求一个读或写锁,
n_objects 指定在每个部分(chunk)应该返回多少结果给 QLC。
traverse,其指定哪一个函数 mnesia 应该用来遍历表,默认用 select。
但对 mnesia:table/2 使用{traverse, {select,MatchSpecification}}作为选项用户能够指定属于自己的表视图
mnesia:table( Tab, [{n_objects,100}, {lock,read},{traverse, select}] ).
如果没有指定选项,默认将会请求一个读锁,每部分返回 100 个结果,select 被用于遍历表

mnesia:delete_table(Tab) 
mnesia:dirty_all_keys(Tab) 
mnesia:clear_table(Tab). 
mnesia:all_keys( table ). 


mnesia:select/2, /4 


   
mnesia:select(wordItem, [{ {'$0','$1','$2','$3'}, [{'==','$1', Id}], ['$$'] }], Len, read). 

{Res, Cout} = mnesia:select(test, [{'$1', [], ['$1']}], 5000, read|write).
{Res1, Cout1} = mnesia:select(Cout).

mnesia:select(test, [{ #test{id='$1',name=Name, _ = '_' }, [], ['$1'] }]). 

mnesia:select(Tab,[{MatchHead, [Guard], [Result]}]).
 MatchHead = #person{name='$1', sex=male, age='$2', _='_'}, 
 Guard = {'&gt;', '$2', 30},      $2中所有大于30的记录 
 Result = '$1',      选出匹配记录的name字段 

ets:fun2ms( fun( #test_select{key= Key} ) 
     when ( Key &gt;= StrBin) andalso ( Key =&lt; &lt;&lt; StrBin/binary, 255&gt;&gt;) -&gt; Key end  ), 

mnesia: match_object ( Record ) 
mnesia:delete_object(Record)
mnesia:match_object(person, #person{ id = 36, _ = '_'}, read)         
mnesia:match_object(person, {'_', 36, '_'},read)

mnesia:dirty_slot(Tab, N). 
返回第N块数据




mnesia:dirty_update_counter(Table, Key, 1).
1.创建如下结构的mnesia数据库表-record(unique_id, {item, uid}); 

2.每为feature表加入一条新记录时,需要得到新的id值: 
     mnesia:dirty_update_counter(unique_id, feature, 1), 
  注意：请在建立unique_id表的时候，往里面插入数据，表名，初始值，{feature,0}

mnesia:foldl(Fun, Acc0, Tab)
mnesia:foldr(Fun, Acc0, Tab)
mnesia:foldl(Fun, Acc0, Tab, LockType)
mnesia:foldr(Fun, Acc0, Tab, LockType)
LockType 默认是读锁， 如果在迭代时写入或删除记录,那么就应该请求写锁

mnesia:first(Tab) -&gt; Key | transaction abort
mnesia:last(Tab) -&gt; Key | transaction abort
mnesia:next(Tab,Key) -&gt; Key | transaction abort
mnesia:prev(Tab,Key) -&gt; Key | transaction abort
mnesia:snmp_get_next_index(Tab,Index) -&gt; {ok, NextIndex} | endOfTable
mnesia:write_lock_table/1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>dump_log_time_threshold %转储间隔次数
dump_log_write_threshold %转储次数
dc_dump_limit %出发dump的默认值，当filesize(<em>.DCL) &gt; filesize(</em>.DCD) / dc_dump_limit，把*.DCL的记录存储到*.DCD文件中</p>
<p>application:set_env( mnesia, dc_dump_limit, 40 ),
application:set_env( mnesia, dump_log_write_threshold, 10000 ),</p>
<p>mnesia在频繁操作数据的过程可能会报错：<strong>WARNING</strong> Mnesia is overloaded: {dump_log, write_threshold}，可以看出，mnesia应该是过载了。这个警告在mnesia dump操作会发生这个问题，表类型为disc_only_copies 、disc_copies都可能会发生。
如何重现这个问题，例子的场景是多个进程同时在不断地mnesia:dirty_write/2
mnesia过载分析
1、抛出警告是在mnesia 增加dump worker的时候</p>
<p>     mnesia_controller.erl
<img src="7.%E9%A1%B9%E7%9B%AE/7.1Mnesia//images/screenshot_1534763051040.png" alt="pic1" /></p>
<p>抛出警告是当Worker的#dump_log.opt_reply_to 未定义，仔细看这里的代码，这一步先检查了dumper_queue里的worker
所以，mnesia抛出过载警告有2个条件：
  1）当worker的#dump_log.opt_reply_to 未定义
  2）dumper_queue有相同操作（InitBy）的worker</p>
<p>2、那什么样的worker的#dump_log.opt_reply_to 未定义？</p>
<p><img src="7.%E9%A1%B9%E7%9B%AE/7.1Mnesia//images/screenshot_1534763067353.png" alt="pic2" /></p>
<p>代码也在mnesia_controller.erl，这里add的worker的dump_log.opt_reply_to 未定义，而{async_dump_log, InitBy} 就是 mnesia:dirty_write/2的过程中调用 mnesia_controller:async_dump_log(write_threshold) 产生的。</p>
<p>就是说，mnesia:dirty_write/2会触发异步dump操作，而只有异步的dump会导致mnesia抛出过载警告</p>
<p>3、看一下，mnesia什么时候会修正worker？
<img src="7.%E9%A1%B9%E7%9B%AE/7.1Mnesia//images/screenshot_1534763095605.png" alt="pic3" /></p>
<p>代码也在mnesia_controller.erl，在dump完成时，mnesia会修改worker的dump_log.opt_reply_to，然后移出dumper_queue</p>
<p>从上面可以得到结论，mnesia:dirty_write/2的操作是会触发异步dump操作，每次dump操作mnesia都会加到dumper_queue队列，mnesia通过检查dumper_queue是否存有相同操作的worker来检查是否过载
mnesia dump分析
mnesia数据存储实际上使用的是ets和dets，对于ram_copies类型的表使用ets；disc_copies表也使用ets，通过 dump将数据保存到*.DCD（disc copy data）文件来持久化，中间可能会用*.DCL（disc copy log）转储；而disc_only_copies表使用的是dets，保存的文件为*.DAT。
表类型不同，mnesia记录数据的过程也不同，这里先讨论mnesia 记录disc_copies数据的过程。
1、mnesia 记录disc_copies数据有2个过程：
   1）操作先记录到日志文件LATEST.LOG，然后再dump到*.DCD文件，同时清除LATEST.LOG
   2）把修改同步到ets表中
2、mnesia disc_copies表数据dump过程
   1）将日志文件LATEST.LOG重命名为PREVIOUS.LOG，然后再新建一个空的日志文件LATEST.LOG
   2）分析PREVIOUS.LOG文件中的内容，将disc_copies的表实际修改写到*.DCL文件
   3）比较*.DCL和*.DCD的大小，当filesize(<em>.DCL) &gt; filesize(</em>.DCD) / dc_dump_limit，把*.DCL的记录存储到*.DCD文件中。dc_dump_limit默认为4，可以通过-mnesia dc_dump_limit Number设置
3、mnesia什么时候会dump
  1）定时触发
   mnesia启动后，mnesia_controller进程设置定时器，触发dump
   mnesia_controller.erl:
<img src="7.%E9%A1%B9%E7%9B%AE/7.1Mnesia//images/screenshot_1534763112696.png" alt="pic4" /></p>
<p>默认值为180000，可以通过 -mnesia dump_log_time_threshold 300000 设置。
  2）一定次数的操作后触发
     每次数据操作，mnesia都会调用mnesia_log:log/1或者mnesia_log:slog/1进行日志记录，记录一次日志就将trans_log_writes_left的值减1，当这个值为0时，触发dump
     mnesia_log.erl:
<img src="7.%E9%A1%B9%E7%9B%AE/7.1Mnesia//images/screenshot_1534763124871.png" alt="pic5" />
mnesia_dumper.erl
<img src="7.%E9%A1%B9%E7%9B%AE/7.1Mnesia//images/screenshot_1534763140040.png" alt="pic6" />
默认值为1000，可以通过 -mnesia dump_log_write_threshold 50000 设置。
  3）手动dump
   手动调用 mnesia:dump_log/0  可以强制mnesia 完成dump，而这个dump是同步的
   mnesia.erl:
<img src="7.%E9%A1%B9%E7%9B%AE/7.1Mnesia//images/screenshot_1534763154485.png" alt="pic7" />
mnesia_controller.erl:</p>
<p><img src="7.%E9%A1%B9%E7%9B%AE/7.1Mnesia//images/screenshot_1534763178943.png" alt="pic8" /></p>
<p>解决mnesia过载
结合上面的分析再谈谈mnesia过载问题，dict_copies表写数据的时候，mnesia会写记录到ets表和日志文件 LATEST.LOG，然后定时或定量dump做持久化。通过dump_log_write_threshold /dump_log_time_threshold 可以控制持久化的频率。mnesia在dump数据的时候，如果上一个worker进程dump没完成，就抛出过载警告。对 此，dump_log_write_threshold的值表示mnesia经历过多少数据操作做一次持久 化，dump_log_time_threshold的值表示mnesia多长时间做一次持久化。</p>
<p>这里再谈谈，为何同一时间只能有一个dumper？</p>
<p>dump的过程是先将日志文件重命名为PREVIOUS.LOG，然后分析PREVIOUS.LOG的数据做持久化，如果同时有第二个dump，将 会替换掉第一个dump的PREVIOUS.LOG，影响第一个dump的持久化。那么，聪明的你就会这么想，为何不重命名为XXX.LOG，每次重命名 都不同？事实上，如果同时有两个dumper，mnesia仅保证第二个dump能正常进行，放弃掉第一个dump的数据。所以，mnesia出现过载警告的时候，数据有可能会丢失。</p>
<p>这里，我做过了一项测试，修改mnesia的代码，将所有异步dump去掉，改用定时手动dump。还是原来的例子，发现第一个dump还没完成日志文件的分析和持久化，而新的日志文件已经增长到快2G。</p>
<p>dump的过程在文件io层面上其实是，一边在没有控制的追加数据，一边又在分析文件和有序写入，这个过程是在挑战磁盘io的读写极限啊。所以，就算现在有多个dumper，结果只会让cpu和硬盘更加抓狂。</p>
<p>另外，别太过依赖dump_log_write_threshold/dump_log_time_threshold这两个参数，改大了就有用吗？</p>
<p>这两个参数改大了，就是说，dump的频率就会降低，那么等待dump的数据就会更多，dump花的时间将会越长，到头来还是不能解决到问题。这两 个参数的意义在于平缓写入速度，避免一时间大量数据写入造成数据丢失。但是，如果每时每刻都是高密度写入，硬盘也承受不了，一般到了这个局面，问题应该从 数据缓冲和持久化的设计上去解决，而不是想着换一个数据库去解决。</p>
<p>这里有一点经验可以分享一下：
1、在mnesia没报过载错误的时候，不建议去改动，调节这些参数会影响持久化
2、可以多个进程读mnesia的数据，但写数据的过程只交给少数几个进程去完成
参考：
<a href="http://blog.csdn.net/mycwq/article/details/28660813">http://blog.csdn.net/mycwq/article/details/28660813</a>
<a href="http://my.oschina.net/hncscwc/blog/161763">http://my.oschina.net/hncscwc/blog/161763</a></p>
<p>来自 <a href="http://blog.csdn.net/mycwq/article/details/28660813?utm_source=tuicool">http://blog.csdn.net/mycwq/article/details/28660813?utm_source=tuicool</a></p>
<div style="break-before: page; page-break-before: always;"></div><p>原文链接：<a href="http://hideto.iteye.com/blog/235413">http://hideto.iteye.com/blog/235413</a></p>
<p>本章描述了构建分布式、容错的Mnesia数据库相关的高级特性：
1）索引
2）分布和容错
3）表分片
4）本地内容表
5）无盘节点
6）更多的schema管理
7）Mnesia事件处理
8）Mnesia应用调试
9）Mnesia里的并发进程
10）原型</p>
<p>1，索引
如果我们知道record的key，那么数据获取和匹配在执行起来都很高效
相反如果不知道record的key，那么表里所有的record都必须搜索
当表越来越大时，表的搜索就越来越耗时
Mnesia的索引就是用来解决这个问题的
下面的两个方法对已有的表操作索引：</p>
<ol>
<li>mnesia:add_table_index(Tab, AttributeName) -&gt; {aborted, R} | {atomic, ok}</li>
<li>mnesia:del_table_index(Tab, AttributeName) -&gt; {aborted, R} | {atomic, ok}</li>
</ol>
<p>这两个方法对AttributeName定义的域加索引和删除索引：</p>
<ol>
<li>mnesia:add_table_index(employee, salary)</li>
</ol>
<p>Mnesia的索引用于以下3个方法：
1）mnesia:index_read(Tab, SecondaryKey, AttributeName) -&gt; transaction abort | RecordList
通过在索引里查询SecondaryKey来找到primary key，这样就能避免对整张表穷举搜索
2）mnesia:index_match_object(Pattern, AttributeName) -&gt; transaction abort | RecordList
通过Pattern里的AttributeName域查找secondary key，然后找到primary key
3）mnesia:match_object(Pattern) -&gt; transaction abort | RecordList
该方法可以使用任何索引
2，分布和容错
Mnesia是分布式、容错的DBMS，可以以多种方式在Erlang节点上备份表
Mnesia程序员不需要了解不同的表位于哪里，只用在程序里指定表的名字
这就是“位置透明”：
1）数据位于本地节点还是远程节点对程序员没有影响，只不过远程节点会慢些
2）数据库可以重新配置，表可以在节点之间移动，这些操作不影响用户程序
每张表有许多系统属性，如index和type
在表创建之时表属性就指定了，例如创建拥有两个RAM备份的新表：</p>
<ol>
<li>mnesia:create_table(foo,</li>
<li>[{ramp_copies, [N1, N2]},</li>
<li>{attribtues, record_info(fields, foo)}]).
表可以有如下属性，每个属性使用一个Erlang节点list
1）ram_copies
表的RAM备份会存在于Erlang节点list中的每个节点上
对于RAM备份，写操作不会写到硬盘里
但是如果RAM备份需要持久化时可以这样做：
i）mnesia:dump_tables/1方法用来将RAM表备份导入到硬盘
ii）表副本可以备份
2）disc_copies
表会位于RAM中，而且表的副本会存在于Erlang节点list中的每个节点的硬盘上
对该表的写操作会同时写入到RAM和硬盘备份里
3）disc_only_copies
表的副本只会位于Erlang节点list中每个节点的硬盘上
这种类型的表副本的缺点是访问速度，优点主要是不占内存
简单的说，ram_copies表示本地节点和list中节点都会存RAM表
disc_copies则本地存RAM表，list中存硬盘表
disc_only_copies则只会list中存硬盘表
使用表副本有两个原因：容错和速度
值得注意的是，表备份对这两个系统需求都提供了解决方案
如果有两个表副本，则一旦一个表崩溃了，还有另一个可以工作
如果有两个节点上的表副本，则两个节点上的应用可以直接从本地读数据而不用访问网络
对于读频繁而写很少的分布式应用，表副本就会大大加速读的速度，因为直接在本地节点读取数据
而这样做的缺点写速度减慢了，因为执行一个写操作时要花更多代价来更新表副本
3，表分片
为了处理超大型的表，表分片的概念引入，基本原理是将表分成多个可以管理的片断
每个片断都实现为一等Mnesia表，它们可以像其他表一样备份，可以拥有索引等等，但是不能有local_content和snmp连接
为了从片断表里访问数据，Mnesia必须决定该record属于哪张表，这通过mnesia_frag模块来实现mnesia_access callback行为
（略）
4，本地内容表
所有节点上的表副本的内容一样，但是有时候不同节点的内容不同有优点
如果我们创建表时指定{local_content, true}属性，则写操作只在本地副本上执行
而且，当在启动时初始化表，则表只会在本地初始化而表内容不会复制到其他节点
5，无盘节点
可以在无盘的节点上运行Mnesia，当然在这些节点上不可能拥有disc_copies或disc_only_copies类型的备份
最麻烦的是schema表，因为Mnesia需要schema来初始化自己
schema表可以位于一个或多个节点上
schema表的存储类型可以为disc_copies或ram_copies(不能是disc_only_copies)
Mnesia启动时使用schema表来决定应该和哪些节点建立联系
如果其他节点已经启动，则启动节点将其他节点的表定义和自己的表定义合并
参数extra_db_nodes包含一个节点list，Mnesia除了schema里的节点，还要和该参数的节点建立联系，默认值为[]
因此，当无盘节点需要从网络上的一个远程节点找到schema定义，则我们需要从-mnesia extra_db_nodes参数节点列表支持该信息
如果没有这个配置参数，Mnesia会以一个单节点系统启动
可以使用mnesia:change_config/2来给'extra_db_node'赋值并且强制建立一个连接，即mnesia:change_config(extra_db_nodes, NodeList)
应用参数schema_location控制Mnesia在哪里搜索schema：
1）disc
   强制硬盘，schema假设位于Mnesia目录，如果找不到，则Mnesia拒绝启动
2）ram
   强制ram，schema只位于ram中，启动时会生成一个很小的新schema
   这个默认schema只包含schema表的定义并且只位于本地节点
3）opt_disc
   可选的硬盘，schema可能只位于硬盘或ram
   如果硬盘上找不到schema，Mnesia启动一个无盘节点（schema表的存储类型为ram_copies）
如果schema_location设置为opt_disc，则方法mnesia:change_table_copy_type/3可以用来改变schema的存储类型：</li>
</ol>
<pre><code class="language-erlang"> 1. 1&gt; mneisa:start().
 2. ok
 3. 2&gt; mnesia:change_table_copy_type(schema, node(), disc_copies).
 4. {atomic, ok}
</code></pre>
<p>6，更多的Schema管理
可以从Mnesia添加和删除节点，这可以通过添加schema副本到这些节点来完成
mnesia:add_table_copy/3和mnesia:del_table_copy/2可以用来添加和删除schema表副本
添加一个节点会影响两点：1，允许其他表备份到该节点；2，它会在启动时连接硬盘节点
mnesia:del_table_copy(schema, mynode@host)从Mnesia系统删除'mynode@host'节点
mnesia:system_info(schema_location)和mnesia:system_info(extra_db_notes)用来决定schema_location和extra_db_nodes的值
mnesia:info/0用来打印出系统信息，可以在Mnesia启动之前就运行此方法
7，Mnesia事件处理
Mnesia可能生成系统事件和表事件这两种事件
用户进程可以订阅这些事件：
mneisa:subscribe(Event-Category)保证符合Event-Category类型的事件副本会发送给调用进程
mnesia:unsubscribe(Event-Category)对符合Event-Category类型的事件删除订阅
Event-Category可以为system或{table, Tab, simple}/{table, Tab, detailed}
系统事件语法为{mnesia_system_event, Event}，表事件语法为{mnesia_table_event, Event}
所有的系统事件有Mnesia的gen_event handler来订阅，默认为mnesia_event
mnesia:system_info(subscribers)和mnesia:table_info(Tab, subscribers)用来决定哪个进程订阅了事件
系统事件
{mnesia_up, Node}
{mnesia_down, Node}
{mnesia_checkpoint_activated, Checkpoint}
{mnesia_checkpoint_deactivated, Checkpoint}
{mnesia_overload, Details}
{inconsistent_database, Context, Node}
{mnesia_fatal, Format, Args, BinaryCode}
{mnesia_info, Format, Args}
{mnesia_error, Format, Args}
{mnesia_user, Event}
表事件
{write, NewRecord, ActivityId}
{delete_object, OldRecord, ActivityId}
{delete, {Tab, Key}, ActivityId}
{write, Table, NewRecord, [OldRecords], ActivityId}
{delete, Table, What, [OldRecords], ActivityId}
9，Mnesia应用调试
Mnesia应用调试比较麻烦，因为理解事务和表加载工作机制很难，而且嵌套事务的语义也比较令人混淆
我们可以设置Mnesia的debug level:</p>
<ol>
<li>mnesia:set_debug_level(Level)
参数Level为none、verbose、debug、trace、false、true
也可以作为应用参数，在启动Erlang系统时指定：</li>
<li>% erl -mnesia debug verbose
9，Mnesia里的并发进程
Mnesia里允许并发的事务提交，程序里不用显式的控制同步的进程
而且可以在用户继续使用表时移动、删除或重新配置表
详细参考四，事务和其他访问上下文
10，原型
如果我们决定使用Mnesia，通常会先将定义和数据写在纯文本里，这样比较简单
这样在构建原型时我们把定义和数据写在纯文本文件里，然后使用下面方法来处理：</li>
</ol>
<pre><code class="language-erlang">mnesia:load_textfile(Filename)
mnesia:dump_to_textfile(Filename)
文本文件的格式为：
 1. {tables, [{Typename, [Options]}, {Typename2 ...}]}.
 2. {Typename, Attribute1, Attribute2 ...}.
 3. {Typename, Attribute1, Attribute2 ...}.
Options是{Key,Value}list，和mnesia:create_table/2的options一致
例如我们有一个healthy foods的数据库，有下面的文件FRUITS：
 1. {tables,
 2. [{fruit, [{attributes, [name, color, taste]}]},
 3. {vegetable, [{attributes, [name, color, taste, price]}]}
 4. ]}.
 5. {fruit, orange, orange, sweet}.
 6. {fruit, apple, green, sweet}.
 7. {vegetable, carrot, orange, carrotish, 2.55}.
 8. {vegetable, potato, yellow, none, 0.45}.
我们可以这样来加载fruits数据库：
 1. 1&gt; mnesia:load_textfile(&quot;FRUITS&quot;).
 2. New table fruit
 3. New table vegetable
 4. {atomic, ok}
 5. 2&gt; mnesia:info().
 6. ---&gt; Processes holding locks &lt;---
 7. ---&gt; Processes waiting for locks &lt;---
 8. ---&gt; Pending (remote) transactions &lt;---
 9. ---&gt; Active (local) transactions &lt;---
 10. ---&gt; Uncertain transactions &lt;---
 11. ---&gt; Active tables &lt;---
 12. vegetable : with 2 records occuping 299 words of mem
 13. fruit : with 2 records occuping 291 words of mem
 14. schema : with 3 records occuping 401 words of mem
 15. ===&gt; System info in version &quot;1.1&quot;, debug level = none &lt;===
 16. opt disc. Directory &quot;/var/tmp/Mnesia.nonode@nohost&quot; is used.
 17. use fallback at restart = false
 18. running db nodes = [nonode@nohost]
 19. stopped db nodes = []
 20. remote = []
 21. ram copies = [fruit,vegetable]
 22. disc copies = [schema]
 23. disc only copies = []
 24. [fnonode@nohost,disc copiesg] = [schema]
 25. [fnonode@nohost,ram copiesg] = [fruit,vegetable]
 26. 3 transactions committed, 0 aborted, 0 restarted, 2 logged to disc
 27. 0 held locks, 0 in queue; 0 local transactions, 0 remote
 28. 0 transactions waits for other nodes: []
 29. ok
```erlang

```bash
-mnesia dc_dump_limit 400
-mnesia dump_log_time_threshold 90000
-mnesia dump_log_write_threshold 150000
</code></pre>
<p><a href="http://www.tuicool.com/articles/rIBbqa">http://www.tuicool.com/articles/rIBbqa</a></p>
<p>当我们启动Mnesia的时候，一个名为LATEST.LOG的文件被创建并且放在数据库目录内。
这个文件被Mnesia用来对基于磁盘的事务做日志。这包括所有在存储类型为disc_copies或disc_only_copies的表中至少写入一条记录的事务。还包括对模式本身所作的全部操作，如创建新表等。
Mnesia的不同实现的日志格式可能有变化。当前实现的Mnesia是标准库模块disc_log。
日志文件会持续增长，因此需要定期转储。对于Mnesia“ ” 转储日志文件 意味着执行在日志中列出的所有操作并且将记录存放到对应的.DAT、.DCD和.DCL  “ 文件中。例如，如果 写记录{foo, 4,elvis, 6}” 操作被列入日志，Mnesia插入此操作到foo.DCL中，随后在Mnesia认为.DCL文件已经变得太大时，再将数据移入.DCD文件。如果日志很大，转储操作可能非常耗时。因此，理解Mesia系统在日志转储期间要持续运转是很重要的。
在默认状态下，只要日志中写入了100条记录或者过去了3分钟这两种情况之一出现，Mnesia即转储日志。
可用两个应用程序参数-mnesia dump_log_write_threshold WriteOperations和-mnesiadump_log_time_threshold MilliSecs来对此进行控制。
在日志被转储之前，文件LATEST.LOG改名为PREVIOUS.LOG，并且创建一个新的LATEST.LOG文件。日志转储成功后，文件PREVIOUS.LOG被删除。在启动时以及每当一个模式操作被执行时，也要转储日志。</p>
<div style="break-before: page; page-break-before: always;"></div><p><img src="7.%E9%A1%B9%E7%9B%AE/7.1Mnesia//images/screenshot_1534763749726.png" alt="pic1" />
解决方案：erl -name a@yujian</p>
<p>1.在两台机器上分别建立各自一个节点，我使用我的电脑和我后面的电脑</p>
<p>    我的机器                                                            test机器</p>
<p><img src="7.%E9%A1%B9%E7%9B%AE/7.1Mnesia//images/screenshot_1534763754171.png" alt="pic" />
<img src="7.%E9%A1%B9%E7%9B%AE/7.1Mnesia//images/screenshot_1534763758351.png" alt="pic" /></p>
<p>    这时运行：
     mnesia:create_schema( [ yujian@yujian, test@DP-201001010138 ]).出现错误
    <img src="7.%E9%A1%B9%E7%9B%AE/7.1Mnesia//images/screenshot_1534763762823.png" alt="pic" /></p>
<p>我猜测可能是test@DP-201001010138这个名称的问题，把这个名称修改掉，修改成test@test
    然后重新试验下
    2台机器之间有错误了
<img src="7.%E9%A1%B9%E7%9B%AE/7.1Mnesia//images/screenshot_1534763767619.png" alt="pic" /></p>
<p>该问题，出现原因未知</p>
<p>第二次试验信息：a机器：erl -name a@yujian -setcookie abc
                b机器:erl -name b@yujian -setcookie abc
此次解决方案：a机器代码修改：erl -sname a -setcookie abc
              b不变化
<img src="7.%E9%A1%B9%E7%9B%AE/7.1Mnesia//images/screenshot_1534763772945.png" alt="pic" /></p>
<p>这时我准备在我的机器上启2个节点
<img src="7.%E9%A1%B9%E7%9B%AE/7.1Mnesia//images/screenshot_1534763786574.png" alt="pic" /></p>
<p>ok
  这时mnesia:start().需要注意
然后创建表
    mnesia:create_table( baikefileRecord, [{disc_only_copies, [ yujian@yujian, test@yujian ]},
 {attributes, record_info( fields, baikefileRecord )}]).</p>
<p>mnesia:start().
mnesia:system_info().
<img src="7.%E9%A1%B9%E7%9B%AE/7.1Mnesia//images/screenshot_1534763796287.png" alt="pic" />
以task_to_file表为例，首先确保2个节点上的这张表都为空，
<img src="7.%E9%A1%B9%E7%9B%AE/7.1Mnesia//images/screenshot_1534763808187.png" alt="pic" />
<img src="7.%E9%A1%B9%E7%9B%AE/7.1Mnesia//images/screenshot_1534763812793.png" alt="pic" /></p>
<p>然后向一个节点的表中插入数据，我想yujian@yujian这个节点中插入了10条数据，选择出来
<img src="7.%E9%A1%B9%E7%9B%AE/7.1Mnesia//images/screenshot_1534763817633.png" alt="pic" />
然后再test@yujian节点上查看这个节点上现在是否有数据  
<img src="7.%E9%A1%B9%E7%9B%AE/7.1Mnesia//images/screenshot_1534763822164.png" alt="pic" />
悲剧了同步更新了
在没有插入数据的节点上删除操作，更新操作，都会同步更新所有的节点</p>
<p>好吧现在的结论是：分布式的节点中每一张的数据都会更新成同样的数据</p>
<p>细节
关闭已经打开的yaws服务器
第一台机器(hz-ejabberd-web1)
进入到/home/project/文件夹下
yaws --sname computera --mnesiadir /httx/project/Mnesia.nonode@nohost --erlarg &quot;-setcookie wexin&quot;
进入yaws后，前缀
执行下面函数
mnesia:stop().
mnesia:delete_schema( [computera@yujian] ).
<img src="7.%E9%A1%B9%E7%9B%AE/7.1Mnesia//images/screenshot_1534763829026.png" alt="pic" />
测试 <a href="http://127.0.0.1:8081/down.yaws">http://127.0.0.1:8081/down.yaws</a>,可以打开
在另一台机器
进入到/home/project/文件夹下
yaws --sname computerb --mnesiadir /httx/project/Mnesia.nonode@nohost --erlarg &quot;-setcookie wexin&quot;
进入yaws后，前缀
执行下面函数
mnesia:stop().
mnesia:delete_schema( [computerb@server] ).
<img src="7.%E9%A1%B9%E7%9B%AE/7.1Mnesia//images/screenshot_1534763836568.png" alt="pic" />
测试 <a href="http://127.0.0.1:8081/down.yaws">http://127.0.0.1:8081/down.yaws</a>,可以打开
运行
mnesia:create_schema( [computera@yujian, computerb@server]).
 <img src="7.%E9%A1%B9%E7%9B%AE/7.1Mnesia//images/screenshot_1534763841240.png" alt="pic" /></p>
<p>运行
mnesia:system_info().
 <img src="7.%E9%A1%B9%E7%9B%AE/7.1Mnesia//images/screenshot_1534763845866.png" alt="pic" /></p>
<p>如图所示stopped db nodes 包括两项第四步才算成功
运行
分别在两台机器上运行：
mnesia:start().
运行完成后，在第一台机器上执行：
mnesia:system_info().
 <img src="7.%E9%A1%B9%E7%9B%AE/7.1Mnesia//images/screenshot_1534763850414.png" alt="pic" /></p>
<p>如图所示running db nodes 包括两项才算成功
在第一台机器上运行
mnesiaDBA_init:init( computerb@server,computera@yujian ).
 <img src="7.%E9%A1%B9%E7%9B%AE/7.1Mnesia//images/screenshot_1534763855543.png" alt="pic" />
<img src="7.%E9%A1%B9%E7%9B%AE/7.1Mnesia//images/screenshot_1534763860153.png" alt="pic" /></p>
<div style="break-before: page; page-break-before: always;"></div><p>数据分片：本质把一张表分成多张表，
当使用mnesia:activity/4操作数据时，分片属性被使用，会到多张表中进程操作</p>
<p><img src="7.%E9%A1%B9%E7%9B%AE/7.1Mnesia//images/screenshot_1534763311440.png" alt="pic" /></p>
<pre><code class="language-erlang">mnesia:activity/4
WriteFun = fun( Keys ) -&gt; [ mnesia:write( {table_name, K, -K} ) || K&lt;- Keys] end.
mnesia:activity( sync_dirty, WriteFun, [ lists:seq(1,256) ], mnesia_frag ). %写入数据，[ lists:seq(1,256) ]是数据内容
mnesia:change_table_frag(Tab, Change)

{activate, FragProps} %激活一个现存表的分片属性,FragProps 应为 {node_pool, Nodes} 或是空

deactivate %解除表的分片属性, 片断的数量必须是 1 。没有其它表在其外键中引用此表

{add_frag, NodesOrDist} %加一个新的片断到分片表。
在老的片断中的全部记录将被重新处理并且其中一半的记录将被移送到新(最后的)片断。
所有通过外键引用此表的其它分片表将自动获得新的片断,其记录也将用与主表相同的方式动态重新处理。
NodesOrDist 参数可以是一个节点列表或者是来自于 mnesia:table_info(Tab,frag_dist)函数的结果 。
NodesOrDist 参数被看作是一个根据新副本首先 进 入的主机为最优来排序的有序节点列表。
新片断将获得与第一个片断同样数量的副本(看n_ram_copies , n_disc_copies 和 n_disc_only_copies)。
NodesOrDist 列表必须至少包含一个需要为每个副本分配的单元。

del_frag %从分片表删除一个片断。在最后这个片断的所有记录将被移到其它片断之一。所有通过其外键引用此表的其它分片表将自动丢失其最后的片断,其记录也将用与主表相同的方式动态重新处理。

{add_node, Node} %增加一个新节点到节点池 node_pool 。 新的节点池将影响从函数.mnesia:table_info(Tab, frag_dist)返回的列表。

{del_node, Node} %从节点池 node_pool 删除一个节点。新的节点池将影响从函数mnesia:table_info(Tab, frag_dist)返回的列表
[{frag_properties, 
[{n_fragments, 20}, 
 {n_disc_copies, 1}, 
 {node_pool, [node()]}]}] 

分片属性
{n_fragments, Int} %n_fragments 控制这个表当前有多少个片断。
这个属性可在创建表的时候设置,也可以在后来用{add_frag,NodesOrDist} 或 del_frag 改变。n_fragments 默认为 1

{node_pool, List} %节点池包含一个节点列表,可以在创建表的时候显式指定,也可以在后来用{add_node,Node}或{del_node, Node}来改变。 
在创建表的时候 Mnesia 尝试将每个片断的副本均匀地分布到节点池中的所有节点,期望所有节点都有同样数量的副本来结束。
node_pool 默认从 mnesia:system_info(db_nodes) 返回值。

{n_ram_copies, Int} %控制每个片断应该有多少 ram_copies 副本。这个属性可在创建表时显式指定。 默认值是 0 ,  
但如果 n_disc_copies 和 n_disc_only_copies 也是 0 ,则n_ram_copies将默认置为 1 

{n_disc_copies, Int}
{n_disc_only_copies, Int}
{foreign_key, ForeignKey}
{hash_module, Atom}
{hash_state, Term}
mnesia:table_info/2
在使用 mnesia_frag 模块的作业上下文中调用函数 mnesia:table_info/2,可获得一些新项目的信息
base_table %分片表的名字
n_fragments %片断的实际数量
node_pool %节点池
n_ram_copies
n_disc_copies
n_disc_only_copies
存储类型 ram_copies, disc_copies 和 disc_only_copies 各自的副本数量。源自于第一个片断的实际值是动态的。实际值通过计算每种存储类型的每个副本的数量来确定,当需要计算实际值的时候(如在增加一个新片断时),第一个片断的类型将作为计算的依
据。这表明当函数 mnesia:add_table_copy/3 , mnesia:del_table_copy/2 和mnesia:change_table_copy_type/2 被应用于第一个片断时,将会影响到n_ram_copies , n_disc_copies 和 n_disc_only_copies 的设置。

foreign_key %外键
foreigners %通过其外键引用该表的所有其它表。
frag_names所有片断的名字。
frag_dist
一个按 Count 增序排列的{Node, Count} 元组的有序列表。Count 是分片表副本所在主机节点 Node 的总数。这个列表至少包含了节点池 node_pool 中的全部节点 。 不属于节点池 node_pool 的节点即使其 Count 值较低也将被放在列表的最后。

frag_size %{Name, Size}元组列表,Name 是片断名称,Size 是其包含了多少条记录。
frag_memory %{Name, Memory} 元组列表, Name 是片断名称, Memory 是被占用内存数。
size %所有片断的总尺寸
memory %所有片断的总内存
</code></pre>
<p><img src="7.%E9%A1%B9%E7%9B%AE/7.1Mnesia//images/screenshot_1534763355284.png" alt="pic" /></p>
<pre><code class="language-erlang">Info = fun( Item ) -&gt; mnesia:table_info( table_name, Item ) end.
Dist = mnesia:activity( sync_dirty, Info, [frag_dist], mnesia_frag).

mnesia:change_table_frag( table_name, {add_frag, Dist} ). %分表，把整个表分开。
</code></pre>
<p><img src="7.%E9%A1%B9%E7%9B%AE/7.1Mnesia//images/screenshot_1534763372213.png" alt="pic" /></p>
<pre><code class="language-erlang">mnesia:change_table_frag( table_name, {add_frag, Dist} ).---继续分
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>读锁。在记录的副本能被读取之前设置读锁。.</p>
<p>写锁。当事务写一条记录时,首先在这条记录的所有副本上设置写锁。</p>
<p>读表锁。如果事务要扫描整张表来搜索一条记录,那么,对表里的记录一条一条的加锁效率很低也很耗内存(如果表很大,读锁本身会消耗很多空间)。因此,Mnesia 可以对表设
置读锁。</p>
<p>写表锁。如果事务要写大量的记录到表里,则可以对整张表设置写锁。</p>
<p>粘(Sticky)锁。即使设置锁的事务终止后,这些写锁也会一直保留在节点上。</p>
<p><img src="7.%E9%A1%B9%E7%9B%AE/7.1Mnesia//images/screenshot_1534763454242.png" alt="pic" /></p>
<pre><code class="language-erlang">mnesia的锁机制：
读锁、写锁、读表锁、写表锁、粘锁 

mnesia:transactionm( fun() -&gt; mnesia:s_write( #test{ id=123 } ) end)  s_write/1函数用粘锁来代替write/1普通的锁 

在本地节点上该粘锁效果和普通的锁一样，但是在多节点上，该表被复制后，粘锁一直存在，使用普通的锁需要在其他节点上新建 
mnesia:read_lock_table(Tab)  在表Tab上加读锁     
mnesia:lock( {table, Tab}, read||write ) 
mnesia:write_lock_table(Tab) 在表Tab上加写锁

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-erlang">select(Name, MatchSpec, N)
dets:delete_all_objects(Name)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><p>Ejabberd扩展案例
源码：<a href="https://github.com/processone/ejabberd/blob/master/src/mod_echo.erl">https://github.com/processone/ejabberd/blob/master/src/mod_echo.erl</a></p>
<p>Ejabberd通用扩展包说明
源码：<a href="https://github.com/processone/ejabberd-contrib">https://github.com/processone/ejabberd-contrib</a></p>
<p>基于现在的扩展模式，做出的通用性的拓展功能</p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-erlang">filter_packet (run_hook)
ejabberd_hooks:run_fold(filter_packet, {OrigFrom, OrigTo, OrigPacket}, []).
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-erlang">Here is the list of available events in ejabberd. The types of the corresponding hooks parameters is described below.

adhoc_local_items(Acc, From, To, Lang) -&gt; Adhoc
adhoc_sm_items(Acc, From, To, Lang) -&gt; Adhoc
anonymous_purge_hook(User, Server) -&gt; ok
c2s_auth_result(bool(), User, Server, IP) -&gt; ok
c2s_broadcast_recipients(Acc, Server, StateData, Type, From, Packet) -&gt; []
c2s_filter_packet(Acc, Server, C2SState, Feature, To, Packet) -&gt; bool()
c2s_filter_packet_in(Acc, JID, From, To) -&gt; FixedPacket
c2s_loop_debug({route, From, To, Packet}) -&gt; ok
c2s_loop_debug(Text) -&gt; ok
c2s_loop_debug({xmlstreamelement, Packet}) -&gt; ok
c2s_post_auth_features(Acc, Server) -&gt; []
c2s_presence_in(Acc, {From, To, Packet}) -&gt; C2SState
c2s_stream_features(Acc, Server) -&gt; []
c2s_unauthenticated_iq(Acc, Server, IQ, IP) -&gt; empty | Packet
c2s_update_presence(Acc, User, Server) -&gt; Packet
caps_update(From, To, get_features(Server, Caps)) -&gt; ok
csi_filter_stanza(Acc, Stanza) -&gt; send
disco_info(Acc, Host, Module, Node, Lang) -&gt; []
disco_local_features(Acc, From, To, Node, Lang) -&gt; Disco
disco_local_identity(Acc, From, To, Node, Lang) -&gt; []
disco_local_items(Acc, From, To, Node, Lang) -&gt; Disco
disco_sm_features(Acc, From, To, Node, Lang) -&gt; Disco
disco_sm_identity(Acc, From, To, Node, Lang) -&gt; []
disco_sm_items(Acc, From, To, Node, Lang) -&gt; Disco
filter_packet(Acc) -&gt; OrigPacket
forbidden_session_hook(JID) -&gt; ok
http_request_debug({LocalPath, Request}) -&gt; ok
local_send_to_resource_hook(From, To, Packet) -&gt; ok
muc_filter_message(Stanza, MUCState, RoomJID, FromJID, FromNick) -&gt; Stanza drop
muc_filter_presence(Stanza, MUCState, RoomJID, FromJID, FromNick) -&gt; Stanza drop
offline_message_hook(From, To, Packet) -&gt; ok
presence_probe_hook(From, To, Pid) -&gt; ok
privacy_check_packet(Acc, User, Server, PrivacyList, {From, To, Packet}, Dir) -&gt; Auth
privacy_get_user_list(Acc, User, Server) -&gt; #userlist{}
privacy_iq_get(Acc, From, To, IQ, PrivacyList) -&gt; {result, Packet} | {error, Error}
privacy_iq_set(Acc, From, To, IQ) -&gt; {result, Packet} | {error, Error}
privacy_updated_list(Acc, PrivacyList, PrivList) -&gt; bool()
pubsub_create_node(ServerHost, Host, Node, NodeId, NodeOptions) -&gt; ok
pubsub_delete_node(ServerHost, Host, Node, NodeId) -&gt; ok
pubsub_publish_item(ServerHost, Node, Publisher, service_jid(Host), ItemId, Payload) -&gt; ok
register_user(User, Server) -&gt; ok
remove_user(User, Server) -&gt; ok
reopen_log_hook() -&gt; ok
resend_offline_messages_hook(Acc, User, Server) -&gt; []
resend_subscription_requests_hook(Acc, User, Server) -&gt; []
roster_get(Acc, {User, Server}) -&gt; []
roster_get_jid_info(Acc, User, Server, From) -&gt; []}
roster_get_subscription_lists(Acc, User, Server) -&gt; []}
roster_get_versioning_feature(Acc, Server) -&gt; []
roster_groups(Acc, ServerHost) -&gt; []
roster_in_subscription(Acc, User, Server, From, SubscriptionInType, Reason) -&gt; bool()
roster_out_subscription(User, Server, To, SubscriptionOutType) -&gt; ok
roster_process_item(Acc, Server) -&gt; RosterItem
s2s_allow_host(Acc, Host, Host) -&gt; Auth
s2s_connect_hook(Host, Server) -&gt; ok
s2s_loop_debug({xmlstreamelement, Packet}) -&gt; ok
s2s_receive_packet(From, To, Packet) -&gt; ok
s2s_send_packet(From, To, Packet) -&gt; ok
s2s_stream_features(Acc, Server) -&gt; []
set_presence_hook(User, Server, Resource, Presence) -&gt; ok
sm_register_connection_hook(SID, JID, Info) -&gt; ok
sm_remove_connection_hook(SID, JID, Info) -&gt; ok
unset_presence_hook(User, Server, Resource, Status) -&gt; ok
user_available_hook(JID) -&gt; ok
user_ping_timeout(JID) -&gt; ok
user_receive_packet(Packet, C2SState, JID, From, To) -&gt; Packet
user_send_packet(Packet, C2SState, From, To) -&gt; Packet
vcard_set(User, Server, VCARD) -&gt; ok
webadmin_menu_host(Acc, Host, Lang) -&gt; []
webadmin_menu_hostnode(Acc, Host, Node, Lang) -&gt; []
webadmin_user(Acc, User, Server, Lang) -&gt; []
webadmin_user_parse_query(Acc, Action, User, Server, Query) -&gt; []


Hooks parameters data types
To = From = JID = ServerJID = #jid (see jlib.h)
Packet = Payload = {xmlelement, Name, Attrs, SubEl}
IQ = #iq (see jlib.h)
Error = ?STANZA_ERROR/3 (see jlib.h)
Lang = binary()
Dir = in | out
Auth = allow | deny
PrivacyList = OldPrivacyList = NewPrivacyList = none | #userlist
CtlStatus = false | ?STATUS_SUCCESS | ?STATUS_ERROR | ?STATUS_USAGE | ?STATUS_BADRPC (see ejabberd_ctl.hrl)
Adhoc = {result, I} | {error, Error} | empty
Disco = {result, Items} | {error, Error}
Items = Packet
Arg = [string()]
Node = [string()]
ItemID = string()
Route = {route, From, To, Packet}
RosterItem = #roster (see mod_roster.hrl)
Subscription = none | from | to | both | remove
SubscriptionInType = subscribe | unsubscribe
SubscriptionOutType = subscribed | unsubscribed
Reason = binary()
Groups = [string()]
SimpleJID = FromSubscription = ToSubscription = {User, Server, Resource}
User = binary()
Server = binary()
Resource = binary()
Status = binary()
SID = {Time, pid()}
Time = {MegaSecs, Secs, MicroSecs} (see erlang:now/0)
MegaSecs = Secs = MicroSecs = int()
Acc = same type as the return type of the function
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="web服务器"><a class="header" href="#web服务器">Web服务器</a></h2>
<p>git地址:<a href="https://github.com/ninenines/cowboy">https://github.com/ninenines/cowboy</a></p>
<p>Dispatch组合</p>
<p>静态文件
erlydtl模块动态文件</p>
<div style="break-before: page; page-break-before: always;"></div><p><a href="https://github.com/basho/rebar/">https://github.com/basho/rebar/</a></p>
<p>配置文件说明：<a href="https://github.com/basho/rebar/blob/master/rebar.config.sample">https://github.com/basho/rebar/blob/master/rebar.config.sample</a></p>
<p>使用案例：
<a href="http://dhq.me/build-compile-eunit-release-erlang-application-with-rebar">http://dhq.me/build-compile-eunit-release-erlang-application-with-rebar</a></p>
<p>1.git clone git://github.com/basho/rebar.git</p>
<p>2.cd rebar
./bootstrap</p>
<p>Recompile: src/rebar
==&gt; rebar (compile)
==&gt; rebar (escriptize)
Congratulations! You now have a self-contained script called &quot;rebar&quot; in
your current working directory. Place this script anywhere in your path
and you can use rebar to build OTP-compliant apps.</p>
<p>3.执行
./rebar -h
./rebar compile eunit</p>
<p>注意：rebar编译一定需要是application的文件结构，即必须包含：_app.erl_app.src_sup.erl</p>
<div style="break-before: page; page-break-before: always;"></div><p>官方wiki <a href="https://github.com/rebar/rebar/wiki">https://github.com/rebar/rebar/wiki</a></p>
<pre><code>• Getting Started
• Rebar and OTP Conventions
• Rebar Commands
• Dependency management
• Dynamic configuration
• Template Support
• Built-in templates
• Release Handling
• Upgrades
</code></pre>
<p>1.Creating the project
rebar create-app appid=appname</p>
<p>2.Compiling with rebar
rebar.config
{sub_dirs, [ &quot;apps/dummy_proj&quot;, &quot;rel&quot; ]}.
{erl_opts, [debug_info, fail_on_warning]}.
{require_otp_vsn, &quot;R14&quot;}.
./rebar compile</p>
<p>3.Running your app
erl -pa apps/*/ebin -boot start_sasl -s dummy_proj</p>
<p>4.Upgrades
Building version 0.1
rebar compile
cd rel rebar generate
mv dummy dummy_0.1
cd ..
rebar clean # start the release:
cd rel/dummy_0.1
bin/dummy console
erl&gt; dummy_server:get_state().
erl&gt; dummy_server:set_state(123).
erl&gt; dummy_server:get_state().</p>
<pre><code>Building version 0.2
# Now, in another terminal we prepare an upgrade.. 
# change release version numbers from 0.1 to 0.2 in 
$EDITOR apps/dummy/src/dummy.app.src 
$EDITOR rel/reltool.config 
rebar compile 
cd rel 
rebar generate 
rebar generate-appups previous_release=dummy_0.1 
rebar generate-upgrade previous_release=dummy_0.1 # Examine contents of upgrade package if you wish: 
tar -zvtf dummy_0.2.tar.gz 
mv dummy dummy_0.2 

Deploying with release_handler
mv dummy_0.2.tar.gz dummy_0.1/releases/ 
# Now use release_handler in the running erlang console for the deploy: 
erl&gt; release_handler:unpack_release(&quot;dummy_0.2&quot;). 
erl&gt; release_handler:install_release(&quot;0.2&quot;). 
erl&gt; release_handler:make_permanent(&quot;0.2&quot;). 
erl&gt; release_handler:which_releases(). 
erl&gt; dummy_server:get_state(). 

Building version 0.3
rm -r rel/dummy 
# Now repeat steps in 'Building version 0.2' and 'Deploying with release_handler' # while replacing '0.2' by '0.3' and '0.1' by '0.2'. 

Caveats:
    • Appup and upgrade generation do not work with zipped applications (.ez extension).
    • Downgrade instructions are not currently generated, only upgrade instructions.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-erlang">    %% -*- mode: erlang;erlang-indent-level: 4;indent-tabs-mode: nil -*-
    
    %% ex: ts=4 sw=4 ft=erlang et
    
    ExtraDeps = [{retest, &quot;.*&quot;, {git, &quot;git://github.com/dizzyd/retest.git&quot;}}],
    
    case os:getenv(&quot;REBAR_EXTRA_DEPS&quot;) of
        false -&gt;
            CONFIG;
        _ -&gt;
            case lists:keysearch(deps, 1, CONFIG) of
                {value, {deps, Deps}} -&gt;
                    NDeps = Deps ++ ExtraDeps,
                    lists:keyreplace(deps, 1, CONFIG, {deps, NDeps});
                false -&gt;
                    CONFIG ++ [{deps, ExtraDeps}]
            end
    end.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="kv文档数据库"><a class="header" href="#kv文档数据库">KV文档数据库</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h2 id="文件存储"><a class="header" href="#文件存储">文件存储</a></h2>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><p>以下是一些Erlang SMP实现的细节和与性能与伸缩性相关一些简单介绍。</p>
<p>几周之内还有有一个关于多核如何运作以及未来如何发展的更详细的介绍。我打算将一些内容放在我的报告中，将于9月27日的ICFP2008，Erlang Workshop在Victoria BC展示给大家。</p>
<p>没有SMP支持的Erlang VM只有1个运行在主处理线程中的调度器。该调度器从运行队列（run-queue）中取出可以运行的Erlang进程以及IO任务，而且因为只有一个线程访问他们所以无须锁定任何数据。</p>
<p>而带有SMP支持的Erlang VM可以有一个或多个调度器，每个运行在一个线程中。调度器从同一个公共运行队列中取出可运行的Erlang进程和IO任务。在SMP VM中所有的共享数据结构都会由锁进行保护，运行队列就是这样一个由锁保护的数据结构。</p>
<p>从OTP R12B开始，如果操作系统报告有多于1个的CPU（或者核心）VM的SMP版本会自动启动，并且根据CPU或者核心的数量启动同样数量的调度器。</p>
<p>你可以从“erl”命令打印出来的第一行看到它选择了哪些参数。例如：</p>
<p>Erlang (BEAM) emulator version 5.6.4 [source] [smp:4] [asynch-threads:0] …..
其中“[smp:4]”表示SMP VM运行了4个调度器。
默认值可以用“-smp [enable|disable|auto]”来替换，auto是默认的。如果smp被启用了（-smp enable），要设置调度器的数量可以使用“+S Number”其中Number是调度器的数量（1到1024）</p>
<p>注意1：运行多于CPU或核心总数的调度器不会有任何提升。
注意2：在某些操作系统中一个进程可使用的CPU或者核心的数量可以被限制。例如，在Linux中，命令“taskset”就可以
实现这个功能。Erlang VM目前还只能探测CPU或者核心的总数，不会考虑“taskset”所设置的掩码。正因如此，例如可能会出现（已经出现过了）即使Erlang VM运行了4个调度器，也只使用了2个核心。OS会进行限制因为它要考虑“taskset”所设置的掩码。</p>
<p>每个Erlang VM的调度器都运行于一个OS线程上，是OS来决定线程是否执行在不同的核心上。一般来说OS会很好地处理这个问题并且会保证线程在执行期间运行于同一个核心上。
Erlang进程会被不同的调度器运行，因为他们是从一个公共运行队列中被取出，由首先可用的调度器运行。</p>
<p>性能和伸缩性
只有一个调度器的SMP VM要比非SMP的VM稍微慢那么一点点。SMP VM内部需要用到各种锁，不过只要不存在锁的争用，那么由锁引起的开销不会非常大（就是锁争用上面需要花时间）。这也解释了为何在某些情况下，运行多个只有一个调度器的SMP VM要比包含多个调度器的单一SMP VM更加高效。当然运行多个VM要求应用可以按照多个并行任务的方式运行并且之间没有或者几乎不通讯。
一个程序是否能在多核上的SMP VM中良好地进行提升很大程度上取决于程序的性质，某些程序可以保持线性提升至8核甚至16核，同时其他某些程序基本不能提升，连2核都不行。实际应用中很多程序都能在主流市场的核心数上得到提升，见下文。</p>
<p>若并行的持续“通话”由每个核心一个或多个Erlang进程来表示，实际的支持大量通话的电信产品已经先现出在双核和四核处理器上不俗的伸缩性。注意，这些产品是在SMP VM和多核处理器出现很久以前按照普通的Erlang风格来写的，他们也能无须任何修改甚至不需重新编译代码就能从Erlang SMP VM中获益。</p>
<p>SMP性能得到持续改进
SMP实现正被不断改进以便能得到更好的性能和伸缩性。在每个服务发布版R12B-1,2,3,4,5…,R13B等等中，你都能发现新的优化。</p>
<p>一些已知的瓶颈
单一的常见运行队列随着CPU或核心的数量的增加会成为一个显著的瓶颈。
这从4核开始往上就会显现出来，不过4核仍然可以为多数应用程序提供不错的性能。我们正在从事一个每个调度器一个运行队列的解决方法作为目前最重要的改进。
Ets表格会引入锁。在R12B-4之前在每次对一个ets-table的访问中会用到两个锁，但是在R12B-4中meta-table的锁被优化过，可以显著减少争用（前面已经提到争用是有很大代价的）。如果很多Erlang进程访问同一个表格，就会有很多锁争用造成性能降低尤其当这些进程主要工作是访问ets-table。锁存在于表级而非记录级。注意！这也会影响到Mnesia因为Mnesia用到了很多ets-table。</p>
<p>我们关于SMP的策略
当我们开始实现SMP VM的最初，我们就确定了策略：“首先让它可以运行，然后测量，然后优化”。自从2006年五月我们发布了第一个稳定的SMP VM（R11B）以来，我们一直遵循着这个策略。
还有更多已知的东西可以改进，我们会按照性能的收益大小先后各个击破。
我们将主要的精力放在多核（大于4）上更好的连续伸缩性上。</p>
<p>卓越典范
即使SMP系统有还有一些已知的瓶颈不过已经有不错的整体性能和伸缩性，同时我相信在让程序员利用多核机器事半功倍方面，我们是一个卓越的典范。</p>
<p>SMP Erlang 用来决定它在多核CPU下如何运行</p>
<pre><code class="language-bash">$erl -smp +S n
-smp 启动SMP
+S n 使用N个调度器来运行Erlang，每一个Erlang调度器都是一个完整的虚拟机，它拥有所有其他虚拟机的信息。如果忽略这个参数，它就默认为SMP机器中逻辑处理器的数量
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>原文 <a href="http://jlouisramblings.blogspot.com/2013/01/how-erlang-does-scheduling.html">http://jlouisramblings.blogspot.com/2013/01/how-erlang-does-scheduling.html</a>
免爬墙链接 <a href="http://www.dikutal.dk/blog/jlouis/how-erlang-does-scheduling">http://www.dikutal.dk/blog/jlouis/how-erlang-does-scheduling</a></p>
<p>Jesper Louis Andersen，2013年1月12日</p>
<p>我用这篇文章解释一下Erlang和其他语言运行时相比不同之处。我还要解释为什么Erlang往往会牺牲吞吐换取更低的延迟。
太长了，我懒得读（译者注：原文TL;DR表示too long, didn’t read。原作者可能是在参与和别人的讨论中写的这篇文章，“懒得读”表现出一种“懒得跟你们争了”的有趣心态。校园网爬墙速度太慢，所以没有验证。）——Erlang和其他语言运行时不同之处在于关注的重点不同。本文描述了为什么进程很少的时候往往看上去似乎性能很差，但是进程很多的时候却表现得很好。</p>
<p>老是有人会问Erlang调度的原理。本文只是对Erlang真正调度原理的简单概述，但是描述了Erlang对其进程的操作方式。注意我这里讨论的是Erlang R15。未来Erlang可能会发生很大的变化，但是不论是Erlang还是其他系统，事物总是会朝着更好的方向发展。</p>
<p>从操作系统的角度来说，Erlang通常在机器上的每一个处理器核心上跑一个线程。每一个线程运行一个调度器。这种设定是为了确保机器上所有的核心都可以为Erlang系统卖力。通过+sbt参数可以将处理器核心和调度器绑定，也就是说调度器不会在众多核心之间跳来跳去。调度器绑定仅限于现代操作系统，因此OS X自然做不到。要实现调度器绑定，说明Erlang系统了解处理器的拓扑结构以及处理器相关的亲缘性，由于高速缓存以及迁移时间等原因，这些信息非常重要。设置+sbt参数通常都可以提升系统的速度。而且有的时候还能提升不少。</p>
<p>+A参数定义了异步线程池中异步线程的数量。驱动程序可以通过异步线程池中的线程执行阻塞的操作，这样调度器可以在线程池中有些线程阻塞的情况下依然执行其他有用的工作。最值得注意的是，文件驱动程序通过线程池加速文件I/O，而网络I/O则没有使用线程池。</p>
<p>以上内容是从操作系统内核的角度描述的，下面我们来理清Erlang进程（隶属于用户空间）的概念。通过调用spawn(fun worker/0)可以构建一个新的进程，Erlang系统会在用户空间分配进程控制块。一个进程通常需要大约600多个字节，而且32位系统和64位系统会有不同。可运行的进程放在调度器的运行队列中，之后获得时间片的时候就可以运行。
在深入描述单个调度器之前，我先简要地描述一下迁移（migration）的工作原理。每过一段时间，调度器就会通过一个非常复杂的过程在调度器之间迁移一些进程。这种启发式迁移的目标就是为了平衡多个调度器的负载，使得所有的核心都能得到充分的利用。这个平衡算法还要考虑工作量是否足够大，是否大到需要启动一些新的调度器。如果没那么大的话，那么最好让那些调度器保持关闭状态，因为反正那些线程也没有工作可做。关闭调度器意味着处理器核心可以进入节能状态，甚至关闭核心。没错，Erlang会尽可能地节省电源消耗。如果调度器做完了工作，还会从其他调度器“窃取”工作（work-steal）。细节请参见[1]。</p>
<p>重要：在R15中，调度器的启动和停止是有延迟（lagged）的。因为Erlang/OTP深知启动或停止一个调度器的开销非常大，所以不是真正需要的话是不会采取行动的。假设某一个调度器现在无事可做，那么系统不会立即将这个调度器设置为睡眠状态，而是会自旋等待一阵子，期待有任务会立即到达。如果有任务到达，那么调度器可以以低延迟立即开始处理任务。换句话说，不能使用top(1)这类工具或通过操作系统内核来测量系统执行的效率，而是必须使用Erlang系统的内部调用来测量。正因为这个原因，有不少人错误地认为R15不如R14高效。</p>
<p>每一个调度器都运行两类作业：进程作业和port作业。这些作业运行的时候是带有优先级的，就像操作系统内核一样，因此也会面对和操作系统内核一样的担忧和启发式调度。进程可以标记高优先级和低优先级等优先级。进程作业执行一个进程一小段时间。port作业考虑的是port。如果你不知道port是什么，我简单解释一下port：port就是Erlang中一种和外部世界通信的机制。文件、网络套接字、和其他程序之间建立的管道，在Erlang中都是通过port实现的。开发者可以在Erlang系统中添加“port驱动程序”来支持新的port类型，不过这就要求编写C语言代码了。调度器还要对网络套接字进行轮询（polling），这样才能从网络中读取数据。</p>
<p>进程和端口都有一个“reduction预算”，即2000个reduction。系统中的任何操作都要消耗reduction。这些操作包括循环中的函数调用、BIF（内建函数）的调用、进程中堆的垃圾回收[注1]、存取ETS和发送消息等（发送消息要考虑接收者的邮箱大小，邮箱越大发送的代价越高）。顺便提一下，会扣除reduction的地方遍及整个Erlang系统。比如Erlang的正则表达式库就做了修改，即使这个库是用C语言编写的，其中也添加了扣除reduction的相关代码。因此如果你有一个非常耗时的正则表达式，那么这个正则表达式的操作也会扣除reduction，所以在运行的过程中有可能会被抢占好几次。port也不例外！在一个port上执行I/O操作会消耗reduction，发送分布式消息也会消耗reduction，不胜枚举。开发者花了大量时间确保系统中产生的每一步进度都会消耗reduction[注2]。</p>
<p>实际上，这就是为什么我说Erlang是真正能够实现抢占式多任务并且能真正做好软实时的少数语言之一的原因。Erlang更看重的是低延迟而不是单纯的吞吐量，这在程序设计语言运行时中是不多见的。</p>
<p>准确地说，抢占（preemption）[2]指的是调度器能够强制剥夺任务的执行。所有基于协作（cooperation）的多任务都是做不到抢占的，例如Python的twisted库、Node.js和LWT（Ocaml）等。但是更有意思的是，Go（golang.org）和Haskell（GHC）也都不是完全抢占式的。Go只有在通信的时候会发生上下文切换，因此一个密集的循环就会霸占整个处理器核心。GHC会在内存分配的时候发生切换（不得不承认内存分配是Haskell程序中一个非常频繁的操作）。这些系统的问题在于，将处理器核心霸占一段时间的后果就是影响系统的响应延迟——想象一下这两种语言执行数组操作的时候的情景。</p>
<p>这就引出了软实时（soft-realtime）[3]的概念，软实时指的是如果无法满足时间截止线需求的时候会导致系统服务水准降级（而不是整个失败）。假设在运行队列中有500有100个进程。第一个进程正在做一个耗时50毫秒的数组操作。在Go或Haskell/GHC[注3]中，这意味着任务2-100都需要至少50ms。而在Erlang中则不同，任务1有2000个reduction的预算，相当于大约1ms的时间。然后用完reduction预算后，任务1会被放回运行队列，这样任务2-任务100就有机会运行。这自然意味着所有的任务都有公平的时间份额。</p>
<p>Erlang是为保证低延迟软实时的特性而精心打造的。2000的reduction预算很低，会导致很多小的上下文切换。耗时长的BIF在计算过程中被抢占的代价非常高昂。但是这样可以保证Erlang在系统负载更高的情况下能够优雅地降级。对于像Ericsson这样在乎低延迟的公司来说，这也意味着别无选择了。你不可能神奇地找到另外一种为吞吐量打造的语言同时也获得低延迟的好处，你必须为之付出努力。如果低延迟对你来说很重要，那么平心而论，不选Erlang反而显得很奇怪了。</p>
<p>[1] &quot;Characterizing the Scalability of Erlang VM on Many-core Processors&quot;<a href="http://kth.diva-portal.org/smash/record.jsf?searchId=2&amp;pid=diva2:392243">http://kth.diva-portal.org/smash/record.jsf?searchId=2&amp;pid=diva2:392243</a>
[2] <a href="http://en.wikipedia.org/wiki/Preemption_(computing">http://en.wikipedia.org/wiki/Preemption_(computing</a>)
[3] <a href="http://en.wikipedia.org/wiki/Real-time_computing">http://en.wikipedia.org/wiki/Real-time_computing</a>
[注1] 进程堆是每个进程私有的，因此一个进程不会对其他进程的GC时间造成太大影响。
[注2] 这段话也点明了为什么要小心耗时长的NIF的原因。NIF默认不会被抢占，而且也不会贡献reduction计数器。因此耗时长的NIF会引入系统延迟。
[注3] 这里考虑单核心的情况，多核心能在一定程度上“掩盖”单核心的这个问题，但是问题依然存在。</p>
<div style="break-before: page; page-break-before: always;"></div><p>erlang 是开源的，很多人都研究过源代码。但是，从erlang代码到c代码，这是个不小的跨度，而且代码也比较复杂。所以这里，我利用一些时间，整理下 erlang代码的执行过程，从erlang代码编译过程，到代码执行过程做讲解，然后重点讲下虚拟机执行代码的原理。将本篇文章，献给所有喜欢erlang的人。</p>
<p>erlang代码编译过程
erlang对开发者是友好的，从erlang程序文件编译成能被erlang虚拟机识别的beam文件，在这个编译过程还对开发者暴露中间代码。借助这个中间代码，我们就可以逐步探究erlang代码的执行过程。
<img src="8.%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/8.1%E8%B5%84%E6%96%99//images/screenshot_1536151719646.png" alt="pic" /></p>
<p>这是erlnag的编译过程，当然，最开始和大多数编译器一样，首先会将程序文件转换成语法树，但这个转换对我们来说阅读的意义不大，所以归结于以上3个过程。</p>
<ol>
<li>
<p>erlang核心代码
确切的叫法是Core Erlang，使用了类似Haskell 的语法，而且每个变量都用“Let” 声明。在erlang shell通过以下方式可以获取模块的Core Erlang代码，将会生成test.core文件
c(test, to_core).
实际上core文件可以直接编译成beam文件，如下：
c(test, from_core).</p>
</li>
<li>
<p>erlang汇编码
这 个是erlang代码编译成beam前的汇编代码，虽然在erlang打包成beam，以及加载到VM时会进一步优化，但汇编码实际上可以看成 erlang代码到c代码的纽带。但理解汇编码而不是很容易，这里要知道erlang VM的设计基于寄存器，其中有两类重要的寄存器，传递参数的x寄存器，和在函数内用作本地变量的y寄存器。在erlang shell通过以下方式可以获取模块的汇编代码，将会生成test.S文件
c(test, to_asm). 或是 c(test, ‘S‘).
当然，S文件也支持编译成beam文件，如下：
c(test, from_asm).</p>
</li>
<li>
<p>erlang BEAM
beam文件是不可阅读的，只是给VM识别，内容包括了代码，原子，导入导出函数，属性，编译信息等数据块。</p>
</li>
<li>
<p>erlang运行时代码
运行时代码是指模块加载到VM后的代码，erlang对开发者暴露了底层的接口。当模块加载后，在erlang shell下通过以下方式可以获取模块的运行时代码，就会生成test.dis文件
erts_debug:df(test).</p>
</li>
</ol>
<p>这里，细心的同学会发现，通过对比erlang汇编码和运行时代码，发现指令代码是不完全相同的。一方面，erlang会对指令进一步做优化；另 外，erlang使用了两种指令集，有限指令集和扩展指令集，在beam文件使用了有限指令集，然后在加载到VM时展开为扩展指令集。有论文说是为了减少 Beam的大小，这点我没有做过实质性的探究，我只是觉得有限指令集比较短，更容易阅读被人理解。关于有限指令集和扩展指令集的差别，我在文章最后的拓展阅读做了讨论。</p>
<p>erlang代码从编译到执行过程</p>
<p>前面介绍了erlang代码编译的过程，现在再来说明erlang代码从编译到执行的完整过程。文章erlang版本以R16B02作说明。
<img src="8.%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/8.1%E8%B5%84%E6%96%99//images/screenshot_1536151741840.png" alt="pic2" /></p>
<p>这里，erlang代码先被编译成beam，然后加载到VM中，最后再被模拟器所识别和调用。
其中，beam文件的加载过程会将beam的字节码形式的数据转成Threaded code和数据。前面也提到，beam文件的字节码数据包含有代码块，这里是将指令展开，转成Threaded code（线索化代码），每条指令包含了opcode（操作码）和operands（操作数），另外还对operands做修正，比如调用外部函数，这里会找到这个外部函数的导出地址，这样每次代码执行的时候就不用再去函数表查找到这个函数，就可以直接执行代码。</p>
<p>Beam 的加载逻辑是在 beam_load.c 完成的，指令集的转换在beam_opcodes.c做了映射，而beam_opcodes.c文件是在编译Erlang源码过程有Perl脚本 beam_makeops根据ops.tab生成的。所有有限指令集可以在genop.tab找到。</p>
<pre><code class="language-bash">File  Path
beam_makeops erts/emulator/utils/
ops.tab  erts/emulator/beam/
beam_opcodes.c erts/emulator/&lt;machine&gt;/opt/smp/
beam_load.c erts/emulator/beam/
genop.tab lib/compiler/src/
</code></pre>
<p>erlang 虚拟机执行代码的原理
这里先简单说明下erlang虚拟机、进程、堆栈，寄存器，然后侧重从指令调度，代码线索化说明虚拟机代码执行原理。
erlang虚拟机概述
通常我们说的eralng虚拟机，是指BEAM虚拟机模拟器和erlang运行时系统（ERTS），BEAM模拟器是执行Erlang程序经编译后产出的字节码的地方。
erlang虚拟机最早的版本是Joe Armstrong编写的，基于栈，叫JAM(Joe‘s Abstract Machine)，很类似WAM（Warren‘s Abstract Machine）。后来改成基于寄存器的虚拟机，也就是现在的BEAM（Bogdan‘s Abstract Machine），执行效率有了较大幅度提升，这在Joe的erlang VM演变论文有说到。</p>
<p>基于栈和基于寄存器的虚拟机有什么区别？
<img src="8.%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/8.1%E8%B5%84%E6%96%99//images/screenshot_1536151801698.png" alt="pic3" /></p>
<p>基于栈（stack-based）的虚拟机的指令长度是固定的，执行多个操作数计算时，会先将操作数做压入栈，由运算指令取出并计算。而基于寄存器（register-based）的指令长度不是固定的，可以在指令中带多个操作数。这样，基于寄存器可以减少指令数量，减少入栈出栈操作，从而减少了指令派发的次数和内存访问的次数，相比开销少了很多。但是，如果利用寄存器做数据交换，就要经常保存和恢复寄存器的结果，这就导致基于寄存器的虚拟机在实现上要比基于栈的复杂，代码编译也要复杂得多</p>
<p>erlang进程
erlang进程是在代码执行过程中动态创建和销毁，每个进程都有自己私有的栈和堆。erlang进程是erlang虚拟机进行资源分配和调度的基本单位，erlang代码的执行要通过erlang进程来实现。
1&gt; spawn(fun() -&gt; m:loop() end).
&lt;0.34.0&gt;
或许有人会问，启动erlang节点时没有使用任何进程，这是为什么？实际上，启动erlang节点的代码是运行在shell进程，同样受到erlang虚拟机调度，我们看到的是由shell进程执行后返回的结果。
为 了实现多进程并发，erlang虚拟机实现了进程挂起和调度机制。进程执行代码时会消耗调度次数（Reductions），当调度次数为0时就会挂起这个 进程，然后从调度队列中取出第一个进程执行。如果进程在等待新消息时也会被挂起，直到这个进程接收到新消息后，就重新加到调度队列。</p>
<p>进程的栈和堆
erlang进程在执行代码的过程中，栈主要用来存放调用帧的本地变量和返回地址，堆则是用来存放执行过程创建的数据。在实现上，栈和堆是在同一个内存区域的。如下图：
<img src="8.%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/8.1%E8%B5%84%E6%96%99//images/screenshot_1536151824786.png" alt="pic4" /></p>
<p>堆 栈的内存空间是先申请一块较大的内存后一点一点使用，不够再重新申请一大块，这样避免频繁申请释放内存造成开销。以上，在已分配好的内存区域内，堆从最低 的地址向上增长，而栈从最高的地址向下增长。中间堆顶和栈顶的空白区域，表示了进程堆栈还未使用到的空间，使用内存时就向里收缩，不够时就执行gc。这 样，内存溢出检查就只要比较栈顶和堆顶就好。
堆用于存储复杂的数据结构，如元组，列表或大整数。栈被用来存储简单的数据，还有指向堆中复杂数据的数据指针。栈有指针指向堆，但不会有指针从堆到栈。</p>
<p>寄存器
前 面也提到，对于基于栈的虚拟机，操作数在使用前都会被压到栈，计算时取出。也就是先将本地变量的值压入栈，然后在计算时从栈取出赋值给本地变量。所以，这 里有很大开销在本地变量和栈之间的交换上（出入栈）。为此，基于寄存器的虚拟机使用临时变量来保存这个本地变量，这个临时变量也就是寄存器。而且，这个寄 存器变量通常都被优化成CPU的寄存器变量，这样，虚拟机访问寄存器变量甚至都不用访问内存，极大的提高了系统的执行速度。
/** X register zero; also called r(0) */ register Eterm x0 REG_x0 = NIL;
register修饰符的作用是暗示编译器，某个变量将被频繁使 用，尽可能将其保存在CPU的寄存器中，以加快其存储速度。随着编译程序设计技术的进步，在决定那些变量应该被存到寄存器中时，现在的编译器能比程序员做 出更好的决定，往往会忽略register修饰符。但是就erlang虚拟机对寄存器变量的使用程度，应该是可以利用到CPU寄存器的好处。</p>
<p>erlang有哪些寄存器？
参数寄存器（R0-R1024） R0是最快的，是独立的寄存器变量，其他以reg[N]访问。R0还用来保存函数返回值
指令寄存器（IP） 引用当前正在执行的指令，可以通过I[N]取到上下文指令。
返回地址寄存器 （CP，原意Continuation Pointer） 记录当前函数调用的返回地址，在执行完当前函数后返回上一个函数中断处执行后面的代码。
栈寄存器（EP） 指向栈的栈顶，以E[N]数组形式访问栈帧数据
堆寄存器 （heap top）指向堆的堆顶，以HTOP[N]数组形式访问堆数据
临时寄存器（tmp_arg1和tmp_arg2）用于指令实现需要临时变量的场合（尽可能重用临时变量，同时利用CPU寄存器优化）
浮点寄存器（FR0-FR15）</p>
<p>其他寄存器：
‘Live‘ 表示当前需要的寄存器数量，很多指令取这个值来判断是否要执行GC申请新的空间
‘FCALLS‘ 表示当前进程剩余的调度次数（Reductions）</p>
<p>若不考虑多调度器，寄存器是所有进程共享的。当虚拟机调度运行某个进程的时候，寄存器就归这个进程使用。当进程被调出的时候，寄存器就给其他进程使用。（进程切换保存进程上下文时，只需要保存指令寄存器IP和当前函数信息，效率很高）</p>
<p>指令调度
erlang 指令调度实现是一个巨大的switch结构，每一个case语句都对应一个指令操作码（opcode），这样就可以实现指令的分发和执行。但 是，switch调度方式实现简单，但效率比较低下。所以，erlang虚拟机使用了goto语法，避免过多的使用switch造成性能损耗；同 时，erlang还使用跳转表，在一些高级编译器下（如GCC），利用label-goto语法，效率比较高（针对跳转表的概念，我之前也有文章说明，见这里）。正因为这点，虚拟机调度时解释指令的代价不容忽视，基于寄存器的虚拟机指令少，就要比基于栈高效。
while(1){ opcode = *vPC++; switch(opcode){ case i_call_fun: .. break; case call_bif_e: .. break; //and many more.. } };
字节码在虚拟机中执行，执行过程类似CPU执行指令过程，分为取指，解码，执行3个过程。通常情况下，每个操作码对应一段处理函数，然后通过一个无限循环加一个switch的方式进行分派。</p>
<p>erlang进程创建时必须指定执行函数，进程创建后就会执行这个函数。从这个函数开始一直到结束，进程都会被erlang虚拟机调度。
start()-&gt; spawn(fun() -&gt; fun1(1) end). %% 创建进程，执行 fun1/1 fun1(A) -&gt; A1 = A + 1, B = trunc(A1), %% 执行 trunc/1 {ok, A1+B}.
以上，进程在执行函数（ trunc/1）调用前，会将当前的本地变量和返回地址指针CP写入栈。然后，在执行完这个函数（trunc/1）后再从栈取出CP指令和本地变量，根据CP指针返回调用处，继续执行后面的代码。
<img src="8.%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/8.1%E8%B5%84%E6%96%99//images/screenshot_1536151841963.png" alt="pic5" />
这样，每次函数执行结束时，erlang从栈顶检查并取得CP指针（如果函数内过于简单，没有其他函数调用，就直接读取 (Process* c_p)-&gt;cp），然后将CP指针的值赋给指令寄存器IP，同时删除CP栈帧（根据需要还要回收Live借用的栈空间），继续调度执行。
备注：这里讲到的栈帧删除操作，如CP指针，本地变量数据，删除时只要将栈顶指针向高位移动N个位置，没有GC操作，代价极小。另外，这里也显露出一个问题，如果非尾递归函数调用，erlang需要反复将本地变量和CP指针入栈，容易触发GC和内存复制，引发内存抖动。</p>
<p>另外，在寄存器方面，函数调用时，erlang虚拟机会将传参写到参数寄存器x(N)，然后更新返回地址寄存器CP，在函数调用返回时，会将返回值写到x(0)寄存器。</p>
<p>Threaded Code（线索化代码）
前 面提到switch指令派发方式，每次处理完一条指令后，都要回到循环的开始，处理下一条指令。但是，每次switch操作，都可能是一次线性搜索（现代 编译器能对switch语句进行优化， 以消除这种线性搜索开销，但也是只限于特定条件，如case的数量和值的跨度范围等）。如果是少量的switch case，完全可以接受，但是对于虚拟机来说，有着成百上千的switch case，而且执行频繁非常高，执行一条指令就需要一次线性搜索，确定比较耗性能。如果能直接跳转到执行代码位置，就可以省去线性搜索的过程了。于是在字 节码的分派方式上，做了新的改进，这项技术叫作 Context Threading（上下文线索化技术，Thread目前都没有合适的中文翻译，我这里意译为线索化，表示其中的线索关系）。</p>
<p>这里取了Context Threading论文的例子，说明上下文线索化技术（Context Threading）
1.首先，代码会被编译成字节码
<img src="8.%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/8.1%E8%B5%84%E6%96%99//images/screenshot_1536151857597.png" alt="pic6" />
2.如果是switch派发指令，效率低下
<img src="8.%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/8.1%E8%B5%84%E6%96%99//images/screenshot_1536151870222.png" alt="pic7" />
3.如果是线索化代码（Threaded Code），就直接跳转（goto），无需多次switch
<img src="8.%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/8.1%E8%B5%84%E6%96%99//images/screenshot_1536151886368.png" alt="pic8" />
4.从字节码到最终执行代码的过程。
<img src="8.%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/8.1%E8%B5%84%E6%96%99//images/screenshot_1536151899286.png" alt="pic9" />
左 边是编译生成的字节码，中间就是字节码加载后生成的线索化代码，右边是对应的虚拟机实现代码。虚拟机执行时，vpc指向了iload_1指令，在执行 iload_1指令操作后根据goto *vpc++ 跳转到下一条指令地址，继续执行，如此反复。这个过程就好像穿针引线，每执行完一条指令，就直接跳转到下一条指令的地址，而不再是Switch Loop那样，每执行一条指令都要做一次switch。（这里，vPC是指虚拟PC指令，在erlang中是IP指针）</p>
<p>拓展阅读
BIF（内建函数）
BIF是erlang的内建函数，由C代码实现，用以实现在erlang层面实现效率不高或无法实现的功能。大多数BIF函数属于erlang模块，也有其他模块的BIF函数，ets或lists，os等
1&gt; erlang:now().
{1433,217791,771000}
2&gt; lists:member(1,[1,2,3]).
true</p>
<p>这里重点解释下，BIF代码如何被执行的。
erlang源代码编译时生成bif函数表信息，见 erts\emulator&lt;machine&gt;\erl_bif_table.c
Export<em>bif_export[BIF_SIZE]; BifEntry bif_table[] = { {am_erlang, am_abs, 1, abs_1, abs_1}, {am_erlang, am_adler32, 1, adler32_1, wrap_adler32_1}, {am_erlang, am_adler32, 2, adler32_2, wrap_adler32_2}, {am_erlang, am_adler32_combine, 3, adler32_combine_3, wrap_adler32_combine_3}, {am_erlang, am_apply, 3, apply_3, wrap_apply_3}, {am_erlang, am_atom_to_list, 1, atom_to_list_1, wrap_atom_to_list_1},
typedef struct bif_entry { Eterm module; Eterm name; int arity; BifFunction f; // bif函数 BifFunction traced; // 函数调用跟踪函数 } BifEntry;
erlang BEAM模拟器启动时会初始化bif函数表，
init_emulator: { em_call_error_handler = OpCode(call_error_handler); em_apply_bif = OpCode(apply_bif); beam_apply[0] = (BeamInstr) OpCode(i_apply); beam_apply[1] = (BeamInstr) OpCode(normal_exit); beam_exit[0] = (BeamInstr) OpCode(error_action_code); beam_continue_exit[0] = (BeamInstr) OpCode(continue_exit); beam_return_to_trace[0] = (BeamInstr) OpCode(i_return_to_trace); beam_return_trace[0] = (BeamInstr) OpCode(return_trace); beam_exception_trace[0] = (BeamInstr) OpCode(return_trace); /</em> UGLY <em>/ beam_return_time_trace[0] = (BeamInstr) OpCode(i_return_time_trace); /</em> <em>Enter all BIFs into the export table.</em>/ for (i = 0; i &lt; BIF_SIZE; i++) { ep = erts_export_put(bif_table[i].module, //模块名 bif_table[i].name, bif_table[i].arity); bif_export[i] = ep; ep-&gt;code[3] = (BeamInstr) OpCode(apply_bif); ep-&gt;code[4] = (BeamInstr) bif_table[i].f; // BIF函数 /<em>XXX: set func info for bifs</em>/ ep-&gt;fake_op_func_info_for_hipe[0] = (BeamInstr) BeamOp(op_i_func_info_IaaI); }</p>
<p>下面写个简单的例子说明，
<img src="8.%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/8.1%E8%B5%84%E6%96%99//images/screenshot_1536151925813.png" alt="pic10" /></p>
<p>bif函数编译后，opcode都是 call_bif_e，操作数是函数导出表地址，下面分析下这个opcode的实现：
/** 以下截取 bif 处理过程 <em>/ OpCase(call_bif_e): { Eterm (<em>bf)(Process</em>, Eterm</em>, BeamInstr*) = GET_BIF_ADDRESS(Arg(0)); // 根据参数获取bif实际执行函数 Eterm result; BeamInstr*next; PRE_BIF_SWAPOUT(c_p); c_p-&gt;fcalls = FCALLS - 1; if (FCALLS &lt;= 0) { save_calls(c_p, (Export *) Arg(0)); } PreFetch(1, next); ASSERT(!ERTS_PROC_IS_EXITING(c_p)); reg[0] = r(0); result = (*bf)(c_p, reg, I); // 执行bif函数 ASSERT(!ERTS_PROC_IS_EXITING(c_p) || is_non_value(result)); ERTS_VERIFY_UNUSED_TEMP_ALLOC(c_p); ERTS_HOLE_CHECK(c_p); ERTS_SMP_REQ_PROC_MAIN_LOCK(c_p); PROCESS_MAIN_CHK_LOCKS(c_p); if (c_p-&gt;mbuf || MSO(c_p).overhead &gt;= BIN_VHEAP_SZ(c_p)) { Uint arity = ((Export *)Arg(0))-&gt;code[2]; result = erts_gc_after_bif_call(c_p, result, reg, arity); E = c_p-&gt;stop; } HTOP = HEAP_TOP(c_p); FCALLS = c_p-&gt;fcalls; if (is_value(result)) { r(0) = result; CHECK_TERM(r(0)); NextPF(1, next); } else if (c_p-&gt;freason == TRAP) { SET_CP(c_p, I+2); SET_I(c_p-&gt;i); SWAPIN; r(0) = reg[0]; Dispatch(); }
上面涉及到一个宏，就是取得bif函数地址。</p>
<h2 id="define-get_bif_addressp-biffunction-export--p-code4"><a class="header" href="#define-get_bif_addressp-biffunction-export--p-code4">define GET_BIF_ADDRESS(p) ((BifFunction) (((Export *) p)-&gt;code[4]))</a></h2>
<p>根据前面提到的，((Export *) p)-&gt;code[4] 就是 bif_table表的中BIF函数的地址。</p>
<p>扩展指令集
BEAM文件使用的是有限指令集（limited instruction set），这些指令集会在beam文件被加载时，展开为扩展指令集（extended instruction set）。
get_list -&gt; get_list_rrx
get_list -&gt;get_list_rry
call_bif -&gt; call_bif_e</p>
<p>扩展指令集和有限指令集的差别是，扩展指令集还描述了操作数类型。</p>
<pre><code class="language-bash">Type Description
t An arbitrary term, e.g. {ok,[]}
I An integer literal, e.g. 137
x A register, r.g. R1
y A stack slot
c An immediate term, i.e. atom/small int/nil
a An atom, e.g. ‘ok‘
f A code label
s Either a literal, a register or a stack slot
d Either a register or a stack slot
r A register R0
P A unsigned integer literal
j An optional code label
e A reference to an export table entry
l A floating-point register
</code></pre>
<p>以 call_bif_e 为例， e表示了操作数为函数导出表地址，所以 call_bif_e 可以这样取到bif代码地址
((Export *) Arg(0))-&gt;code[4]</p>
<p>文献资料：
[1] The Erlang BEAM Virtual Machine Specification Bogumil Hausman
[2] Virtual Machine Showdown: Stack Versus Registers Yunhe Shi, David Gregg, Andrew Beatty
[3] Context Threading: A flexible and efficient dispatch technique for virtual machine interpreters
[4] A Peek Inside the Erlang Compiler James Hague</p>
<p>参考：
<a href="http://blog.csdn.net/mycwq/article/details/45653897">http://blog.csdn.net/mycwq/article/details/45653897</a></p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><ul>
<li>
<p>Erlang的设计哲学是为每一个独立的事件创建一个新进程.</p>
</li>
<li>
<p>Erlang的容错处理：如果不能完成一个任务就死掉 让其它正常的进程来善后。link函数就是用来建立这种进程间的双向连接来监测非正常退出，并做出处理。</p>
</li>
<li>
<p>side-effect-free无副作用,其中一种定义是说:一个程序执行前后保持程序的状态不变,不改变非局部变量的值,不改变传入参数值,也无I/O</p>
</li>
<li>
<p>Erlang GC的特点是:每个进程独立进行GC ,分代(generational garbage) ,复制回收</p>
</li>
<li>
<p>Erlang的模式匹配作用:1.变量赋值 2.提取变量值 3.控制流</p>
</li>
<li>
<p>ETS也是不参与GC的</p>
</li>
<li>
<p>Erlang是动态强类型的语言 dynamic-strong Typing</p>
</li>
<li>
<p>windows环境Erlang GUI工具:toolbar:start(). tv:start() pman:start(). appmon:start() debugger:start()</p>
</li>
<li>
<p>还有一个WebUI的工具 webtool:start().</p>
</li>
<li>
<p>Erlang属于面向消息的语言,面向消息的语言没有共享对象,进程间交互通过收发消息完成</p>
</li>
<li>
<p>Erlang中一个已经赋值的变量就是一个指针，指向存储值的存储区!</p>
</li>
<li>
<p>单次赋值实际上就是存储区的值不会被修改</p>
</li>
<li>
<p>Erlang不共享内存,也就没有了锁的问题</p>
</li>
<li>
<p>函数子句的顺序匹配的顺序是其在文件中的顺序</p>
</li>
<li>
<p>列表解析的数据生成器部分通过模式匹配也可以是达到数据过滤的目的[X||{a,X}&lt;-[{a,1},{b,12},{c,33},{a,23}]].</p>
</li>
<li>
<p>所有的BIF都在erlang模块中，所以不要奇怪这个模块包含的函数那么杂!</p>
</li>
<li>
<p>bit语法 End-Sign-Type-Unit 一个数据样例： 8/unsigned-little-integer</p>
</li>
<li>
<p>二进制数据中使用的整数都必须要在0到255之间，这是因为二进制数据包含的每个字节都是8位，</p>
</li>
</ul>
<pre><code class="language-erlang">2#11111111&lt;&lt;A&gt;&gt; = &lt;&lt;255&gt;&gt;. &lt;&lt;B&gt;&gt; = &lt;&lt;256&gt;&gt;. &lt;&lt;C&gt;&gt; = &lt;&lt;257&gt;&gt;. A B C 的值分别是255 0 1
</code></pre>
<ul>
<li>
<p>由字符序列组成的二进制数据等同于由其每一个字符ASCII编码组成的二进制数据&lt;&lt;&quot;king&quot;&gt;&gt; == &lt;&lt;$k,$i,$n,$g&gt;&gt;</p>
</li>
<li>
<p>beam_lib:chunk/2方法可以在不加载代码的情况下分析beam的元数据</p>
</li>
<li>
<p>F1=fun(X) when X==0 -&gt; X; (X) -&gt; X+100 end. %注意这里的可以使用guard</p>
</li>
<li>
<p>step_two(N, Total) when N =/= 0 -&gt; step_two(N-1, Total+N). %注意也是用了guard</p>
</li>
<li>
<p>epp erlang预处理器我之前在说宏和record的时候提到过 链接：<a href="http://www.cnblogs.com/me-sa/archive/2011/07/20/erlang0006.html">http://www.cnblogs.com/me-sa/archive/2011/07/20/erlang0006.html</a></p>
</li>
<li>
<p>进程字典用来放全局只读配置还是很合适的</p>
</li>
<li>
<p>erlang:make_ref 创建唯一标识，在gen_tcp常用到</p>
</li>
<li>
<p>. q() 是init:stop()的别名 erlang:halt() 这两个方法都可以关闭erlang系统</p>
</li>
<li>
<p>erl 参数 -s可以有多个依次执行 -noshell参数可以让程序在后台运行</p>
</li>
<li>
<p>code:clash()方法在code path中查找重名的模块</p>
</li>
<li>
<p>在shell中按下Ctrl +G 进入&quot;shell JCL&quot; job control language 常用的就是 j c r 三个命令</p>
</li>
<li>
<p>在shell里面执行help() 很多实用的辅助方法</p>
</li>
<li>
<p>spawn(fun)这个方法执行不会失败，总会返回一个pid</p>
</li>
<li>
<p>erlang:system_info/1可以取到运行时的系统信息，比如进程数 原子数 内存消耗等等</p>
</li>
<li>
<p>receive的0超时语句可以帮我们快速清空邮件队列刀</p>
</li>
<li>
<p>捕捉退出消息的进程被称为系统进程(system process),学习新东西很多时候在于术语带来的门槛</p>
</li>
<li>
<p>在线上处理问题的时候用过exit(Pid,kill)来清理僵尸进程</p>
</li>
<li>
<p>只有在不需要使用DNS服务的场景才可以使用-sname</p>
</li>
<li>
<p>要让Erlang节点在不同主机间互通需要打开TCP和UDP的4369端口,empd(Erlang Port Mapper Daemon)会使用这个端口</p>
</li>
<li>
<p>使用分布式Erlang需要打开一些端口或指定端口范围，并确保防火墙已经放开 启动参数使用-kernel inet_dist_listen_min</p>
</li>
<li>
<p>file:consult可以直接把文件中的Erlang项读取出来 file:unconsult可以把Erlang项写入文件一</p>
</li>
<li>
<p>io:format(&quot;123~w~n&quot;,[&quot;abc&quot;]). 输出：123[97,98,99] ~w以标准语法写入数据</p>
</li>
<li>
<p>io:format(&quot;123~p~n&quot;,[&quot;abc&quot;]). 输出：123“abc” ~p 完整打印参数</p>
</li>
<li>
<p>group_leader()的作用就是管理输出，比如rpc调用会把目标机执行的结果输出截获输出到当前shell</p>
</li>
<li>
<p>A Compacting Garbage Collector for ERLANG (1997) <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.34.2421">http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.34.2421</a></p>
</li>
<li>
<p>Erlang的容错处理：如果不能完成一个任务就死掉 让其它正常的进程来善后。link函数就是用来建立这种进程间的双向连接来监测非正常退出，并做出处理。</p>
</li>
<li>
<p>BIFs是built-in functions的缩写代表这些方法是Erlang运行时系统的一部分</p>
</li>
<li>
<p>写function的时候在最后添加一个catch_all的方法也被认为是最佳实践</p>
</li>
<li>
<p>如果可预见结果集的所有可能性,那么case语句不建议使用catch_all</p>
</li>
<li>
<p>process dictionary几乎被描述成洪水猛兽了,对于一次写入然后就只读的配置性数据放在进程字典应该没有问题</p>
</li>
<li>
<p>Erlang出错法则:让错误报告在它发生的地方</p>
</li>
<li>
<p>查看module的元数据信息 比如a.erl a:module_info(). m(a).</p>
</li>
<li>
<p>Erlang的元编程Meta Programming确实直接,apply/3 甚至在参数确定情况下的直接调用M:F(A)</p>
</li>
<li>
<p>Concurrency is the ability for different functions to execute in parallel without affecting each other unless explicitly programmed to do so.</p>
</li>
<li>
<p>我们要遍历ETS可以使用first/next 也可以使用foldr foldl,但是后者会把ETS数据复制到进程,数据量大时有效率问题</p>
</li>
<li>
<p>可以使用record_info()来查看record定义</p>
</li>
<li></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_line_numbers = true;
        </script>
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
    </body>
</html>
