<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>golang笔记</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">介绍</a></li><li class="chapter-item expanded "><a href="1. 开始/_index.html"><strong aria-hidden="true">1.</strong> 开始</a></li><li class="chapter-item expanded "><a href="2. 基础/_index.html"><strong aria-hidden="true">2.</strong> 基础</a></li><li class="chapter-item expanded "><a href="3. 库函数/_index.html"><strong aria-hidden="true">3.</strong> 库函数</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/archive/index.html"><strong aria-hidden="true">3.1.</strong> Archive</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/archive/tar/index.html"><strong aria-hidden="true">3.1.1.</strong> Tar</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/archive/tar/Reader.html"><strong aria-hidden="true">3.1.1.1.</strong> Reader</a></li><li class="chapter-item expanded "><a href="3. 库函数/archive/tar/Writer.html"><strong aria-hidden="true">3.1.1.2.</strong> Writer</a></li></ol></li><li class="chapter-item expanded "><a href="3. 库函数/archive/zip/index.html"><strong aria-hidden="true">3.1.2.</strong> Zip</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/archive/zip/Reader.html"><strong aria-hidden="true">3.1.2.1.</strong> Reader</a></li><li class="chapter-item expanded "><a href="3. 库函数/archive/zip/Writer.html"><strong aria-hidden="true">3.1.2.2.</strong> Writer</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="3. 库函数/bufio/index.html"><strong aria-hidden="true">3.2.</strong> Bufio</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/bufio/NewReader.html"><strong aria-hidden="true">3.2.1.</strong> New Reader</a></li><li class="chapter-item expanded "><a href="3. 库函数/bufio/NewReaderSize.html"><strong aria-hidden="true">3.2.2.</strong> New Reader Size</a></li><li class="chapter-item expanded "><a href="3. 库函数/bufio/NewWriter.html"><strong aria-hidden="true">3.2.3.</strong> New Writer</a></li><li class="chapter-item expanded "><a href="3. 库函数/bufio/NewWriterSize.html"><strong aria-hidden="true">3.2.4.</strong> New Writer Size</a></li><li class="chapter-item expanded "><a href="3. 库函数/bufio/Reader_Buffered.html"><strong aria-hidden="true">3.2.5.</strong> Reader Buffered</a></li><li class="chapter-item expanded "><a href="3. 库函数/bufio/Reader_Peek.html"><strong aria-hidden="true">3.2.6.</strong> Reader Peek</a></li><li class="chapter-item expanded "><a href="3. 库函数/bufio/Reader_Read.html"><strong aria-hidden="true">3.2.7.</strong> Reader Read</a></li><li class="chapter-item expanded "><a href="3. 库函数/bufio/Reader_ReadByte.html"><strong aria-hidden="true">3.2.8.</strong> Reader Read Byte</a></li><li class="chapter-item expanded "><a href="3. 库函数/bufio/Reader_ReadBytes.html"><strong aria-hidden="true">3.2.9.</strong> Reader Read Bytes</a></li><li class="chapter-item expanded "><a href="3. 库函数/bufio/Reader_ReadLine.html"><strong aria-hidden="true">3.2.10.</strong> Reader Read Line</a></li><li class="chapter-item expanded "><a href="3. 库函数/bufio/Reader_ReadRune.html"><strong aria-hidden="true">3.2.11.</strong> Reader Read Rune</a></li><li class="chapter-item expanded "><a href="3. 库函数/bufio/Reader_ReadSlice.html"><strong aria-hidden="true">3.2.12.</strong> Reader Read Slice</a></li><li class="chapter-item expanded "><a href="3. 库函数/bufio/Reader_ReadString.html"><strong aria-hidden="true">3.2.13.</strong> Reader Read String</a></li><li class="chapter-item expanded "><a href="3. 库函数/bufio/Reader_UnreadByte.html"><strong aria-hidden="true">3.2.14.</strong> Reader Unread Byte</a></li><li class="chapter-item expanded "><a href="3. 库函数/bufio/Reader_UnreadRune.html"><strong aria-hidden="true">3.2.15.</strong> Reader Unread Rune</a></li><li class="chapter-item expanded "><a href="3. 库函数/bufio/ReadWriter.html"><strong aria-hidden="true">3.2.16.</strong> Read Writer</a></li><li class="chapter-item expanded "><a href="3. 库函数/bufio/Writer_Available.html"><strong aria-hidden="true">3.2.17.</strong> Writer Available</a></li><li class="chapter-item expanded "><a href="3. 库函数/bufio/Writer_Buffered.html"><strong aria-hidden="true">3.2.18.</strong> Writer Buffered</a></li><li class="chapter-item expanded "><a href="3. 库函数/bufio/Writer_Flush.html"><strong aria-hidden="true">3.2.19.</strong> Writer Flush</a></li><li class="chapter-item expanded "><a href="3. 库函数/bufio/Writer_Write.html"><strong aria-hidden="true">3.2.20.</strong> Writer Write</a></li><li class="chapter-item expanded "><a href="3. 库函数/bufio/Writer_WriteByte.html"><strong aria-hidden="true">3.2.21.</strong> Writer Write Byte</a></li><li class="chapter-item expanded "><a href="3. 库函数/bufio/Writer_WriteRune.html"><strong aria-hidden="true">3.2.22.</strong> Writer Write Rune</a></li><li class="chapter-item expanded "><a href="3. 库函数/bufio/Writer_WriteString.html"><strong aria-hidden="true">3.2.23.</strong> Writer Write String</a></li></ol></li><li class="chapter-item expanded "><a href="3. 库函数/builtin/index.html"><strong aria-hidden="true">3.3.</strong> Builtin</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/builtin/append.html"><strong aria-hidden="true">3.3.1.</strong> Append</a></li><li class="chapter-item expanded "><a href="3. 库函数/builtin/bool.html"><strong aria-hidden="true">3.3.2.</strong> Bool</a></li><li class="chapter-item expanded "><a href="3. 库函数/builtin/byte.html"><strong aria-hidden="true">3.3.3.</strong> Byte</a></li><li class="chapter-item expanded "><a href="3. 库函数/builtin/cap.html"><strong aria-hidden="true">3.3.4.</strong> Cap</a></li><li class="chapter-item expanded "><a href="3. 库函数/builtin/close.html"><strong aria-hidden="true">3.3.5.</strong> Close</a></li><li class="chapter-item expanded "><a href="3. 库函数/builtin/complex.html"><strong aria-hidden="true">3.3.6.</strong> Complex</a></li><li class="chapter-item expanded "><a href="3. 库函数/builtin/complex128.html"><strong aria-hidden="true">3.3.7.</strong> Complex 128</a></li><li class="chapter-item expanded "><a href="3. 库函数/builtin/complex64.html"><strong aria-hidden="true">3.3.8.</strong> Complex 64</a></li><li class="chapter-item expanded "><a href="3. 库函数/builtin/ComplexType.html"><strong aria-hidden="true">3.3.9.</strong> Complex Type</a></li><li class="chapter-item expanded "><a href="3. 库函数/builtin/copy.html"><strong aria-hidden="true">3.3.10.</strong> Copy</a></li><li class="chapter-item expanded "><a href="3. 库函数/builtin/delete.html"><strong aria-hidden="true">3.3.11.</strong> Delete</a></li><li class="chapter-item expanded "><a href="3. 库函数/builtin/error.html"><strong aria-hidden="true">3.3.12.</strong> Error</a></li><li class="chapter-item expanded "><a href="3. 库函数/builtin/float32.html"><strong aria-hidden="true">3.3.13.</strong> Float 32</a></li><li class="chapter-item expanded "><a href="3. 库函数/builtin/float64.html"><strong aria-hidden="true">3.3.14.</strong> Float 64</a></li><li class="chapter-item expanded "><a href="3. 库函数/builtin/FloatType.html"><strong aria-hidden="true">3.3.15.</strong> Float Type</a></li><li class="chapter-item expanded "><a href="3. 库函数/builtin/imag.html"><strong aria-hidden="true">3.3.16.</strong> Imag</a></li><li class="chapter-item expanded "><a href="3. 库函数/builtin/int.html"><strong aria-hidden="true">3.3.17.</strong> Int</a></li><li class="chapter-item expanded "><a href="3. 库函数/builtin/int16.html"><strong aria-hidden="true">3.3.18.</strong> Int 16</a></li><li class="chapter-item expanded "><a href="3. 库函数/builtin/int32.html"><strong aria-hidden="true">3.3.19.</strong> Int 32</a></li><li class="chapter-item expanded "><a href="3. 库函数/builtin/int64.html"><strong aria-hidden="true">3.3.20.</strong> Int 64</a></li><li class="chapter-item expanded "><a href="3. 库函数/builtin/int8.html"><strong aria-hidden="true">3.3.21.</strong> Int 8</a></li><li class="chapter-item expanded "><a href="3. 库函数/builtin/IntegerType.html"><strong aria-hidden="true">3.3.22.</strong> Integer Type</a></li><li class="chapter-item expanded "><a href="3. 库函数/builtin/len.html"><strong aria-hidden="true">3.3.23.</strong> Len</a></li><li class="chapter-item expanded "><a href="3. 库函数/builtin/make.html"><strong aria-hidden="true">3.3.24.</strong> Make</a></li><li class="chapter-item expanded "><a href="3. 库函数/builtin/new.html"><strong aria-hidden="true">3.3.25.</strong> New</a></li><li class="chapter-item expanded "><a href="3. 库函数/builtin/panic.html"><strong aria-hidden="true">3.3.26.</strong> Panic</a></li><li class="chapter-item expanded "><a href="3. 库函数/builtin/real.html"><strong aria-hidden="true">3.3.27.</strong> Real</a></li><li class="chapter-item expanded "><a href="3. 库函数/builtin/recover.html"><strong aria-hidden="true">3.3.28.</strong> Recover</a></li><li class="chapter-item expanded "><a href="3. 库函数/builtin/rune.html"><strong aria-hidden="true">3.3.29.</strong> Rune</a></li><li class="chapter-item expanded "><a href="3. 库函数/builtin/string.html"><strong aria-hidden="true">3.3.30.</strong> String</a></li><li class="chapter-item expanded "><a href="3. 库函数/builtin/Type.html"><strong aria-hidden="true">3.3.31.</strong> Type</a></li><li class="chapter-item expanded "><a href="3. 库函数/builtin/Type1.html"><strong aria-hidden="true">3.3.32.</strong> Type 1</a></li><li class="chapter-item expanded "><a href="3. 库函数/builtin/uint.html"><strong aria-hidden="true">3.3.33.</strong> Uint</a></li><li class="chapter-item expanded "><a href="3. 库函数/builtin/uint16.html"><strong aria-hidden="true">3.3.34.</strong> Uint 16</a></li><li class="chapter-item expanded "><a href="3. 库函数/builtin/uint32.html"><strong aria-hidden="true">3.3.35.</strong> Uint 32</a></li><li class="chapter-item expanded "><a href="3. 库函数/builtin/uint64.html"><strong aria-hidden="true">3.3.36.</strong> Uint 64</a></li><li class="chapter-item expanded "><a href="3. 库函数/builtin/uint8.html"><strong aria-hidden="true">3.3.37.</strong> Uint 8</a></li><li class="chapter-item expanded "><a href="3. 库函数/builtin/uintptr.html"><strong aria-hidden="true">3.3.38.</strong> Uintptr</a></li></ol></li><li class="chapter-item expanded "><a href="3. 库函数/bytes/index.html"><strong aria-hidden="true">3.4.</strong> Bytes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/bytes/ IndexFunc.html"><strong aria-hidden="true">3.4.1.</strong> Index Func</a></li><li class="chapter-item expanded "><a href="3. 库函数/bytes/Buffer_Bytes.html"><strong aria-hidden="true">3.4.2.</strong> Buffer Bytes</a></li><li class="chapter-item expanded "><a href="3. 库函数/bytes/Buffer_Len.html"><strong aria-hidden="true">3.4.3.</strong> Buffer Len</a></li><li class="chapter-item expanded "><a href="3. 库函数/bytes/Buffer_Next.html"><strong aria-hidden="true">3.4.4.</strong> Buffer Next</a></li><li class="chapter-item expanded "><a href="3. 库函数/bytes/Buffer_Read.html"><strong aria-hidden="true">3.4.5.</strong> Buffer Read</a></li><li class="chapter-item expanded "><a href="3. 库函数/bytes/Buffer_ReadByte.html"><strong aria-hidden="true">3.4.6.</strong> Buffer Read Byte</a></li><li class="chapter-item expanded "><a href="3. 库函数/bytes/Buffer_ReadBytes.html"><strong aria-hidden="true">3.4.7.</strong> Buffer Read Bytes</a></li><li class="chapter-item expanded "><a href="3. 库函数/bytes/Buffer_ReadFrom.html"><strong aria-hidden="true">3.4.8.</strong> Buffer Read From</a></li><li class="chapter-item expanded "><a href="3. 库函数/bytes/Buffer_ReadRune.html"><strong aria-hidden="true">3.4.9.</strong> Buffer Read Rune</a></li><li class="chapter-item expanded "><a href="3. 库函数/bytes/Buffer_ReadString.html"><strong aria-hidden="true">3.4.10.</strong> Buffer Read String</a></li><li class="chapter-item expanded "><a href="3. 库函数/bytes/Buffer_Reset.html"><strong aria-hidden="true">3.4.11.</strong> Buffer Reset</a></li><li class="chapter-item expanded "><a href="3. 库函数/bytes/Buffer_String.html"><strong aria-hidden="true">3.4.12.</strong> Buffer String</a></li><li class="chapter-item expanded "><a href="3. 库函数/bytes/Buffer_Truncate.html"><strong aria-hidden="true">3.4.13.</strong> Buffer Truncate</a></li><li class="chapter-item expanded "><a href="3. 库函数/bytes/Buffer_UnreadByte.html"><strong aria-hidden="true">3.4.14.</strong> Buffer Unread Byte</a></li><li class="chapter-item expanded "><a href="3. 库函数/bytes/Buffer_UnreadRune.html"><strong aria-hidden="true">3.4.15.</strong> Buffer Unread Rune</a></li><li class="chapter-item expanded "><a href="3. 库函数/bytes/Buffer_Write.html"><strong aria-hidden="true">3.4.16.</strong> Buffer Write</a></li><li class="chapter-item expanded "><a href="3. 库函数/bytes/Buffer_WriteByte.html"><strong aria-hidden="true">3.4.17.</strong> Buffer Write Byte</a></li><li class="chapter-item expanded "><a href="3. 库函数/bytes/Buffer_WriteRune.html"><strong aria-hidden="true">3.4.18.</strong> Buffer Write Rune</a></li><li class="chapter-item expanded "><a href="3. 库函数/bytes/Buffer_WriteString.html"><strong aria-hidden="true">3.4.19.</strong> Buffer Write String</a></li><li class="chapter-item expanded "><a href="3. 库函数/bytes/Buffer_WriteTo.html"><strong aria-hidden="true">3.4.20.</strong> Buffer Write To</a></li><li class="chapter-item expanded "><a href="3. 库函数/bytes/Compare.html"><strong aria-hidden="true">3.4.21.</strong> Compare</a></li><li class="chapter-item expanded "><a href="3. 库函数/bytes/Contains.html"><strong aria-hidden="true">3.4.22.</strong> Contains</a></li><li class="chapter-item expanded "><a href="3. 库函数/bytes/Count.html"><strong aria-hidden="true">3.4.23.</strong> Count</a></li><li class="chapter-item expanded "><a href="3. 库函数/bytes/Equal.html"><strong aria-hidden="true">3.4.24.</strong> Equal</a></li><li class="chapter-item expanded "><a href="3. 库函数/bytes/EqualFold.html"><strong aria-hidden="true">3.4.25.</strong> Equal Fold</a></li><li class="chapter-item expanded "><a href="3. 库函数/bytes/Fields.html"><strong aria-hidden="true">3.4.26.</strong> Fields</a></li><li class="chapter-item expanded "><a href="3. 库函数/bytes/FieldsFunc.html"><strong aria-hidden="true">3.4.27.</strong> Fields Func</a></li><li class="chapter-item expanded "><a href="3. 库函数/bytes/HasPrefix.html"><strong aria-hidden="true">3.4.28.</strong> Has Prefix</a></li><li class="chapter-item expanded "><a href="3. 库函数/bytes/HasSuffix.html"><strong aria-hidden="true">3.4.29.</strong> Has Suffix</a></li><li class="chapter-item expanded "><a href="3. 库函数/bytes/Index.html"><strong aria-hidden="true">3.4.30.</strong> Index</a></li><li class="chapter-item expanded "><a href="3. 库函数/bytes/IndexAny.html"><strong aria-hidden="true">3.4.31.</strong> Index Any</a></li><li class="chapter-item expanded "><a href="3. 库函数/bytes/IndexByte.html"><strong aria-hidden="true">3.4.32.</strong> Index Byte</a></li><li class="chapter-item expanded "><a href="3. 库函数/bytes/IndexRune.html"><strong aria-hidden="true">3.4.33.</strong> Index Rune</a></li><li class="chapter-item expanded "><a href="3. 库函数/bytes/Join.html"><strong aria-hidden="true">3.4.34.</strong> Join</a></li><li class="chapter-item expanded "><a href="3. 库函数/bytes/LastIndex.html"><strong aria-hidden="true">3.4.35.</strong> Last Index</a></li><li class="chapter-item expanded "><a href="3. 库函数/bytes/LastIndexAny.html"><strong aria-hidden="true">3.4.36.</strong> Last Index Any</a></li><li class="chapter-item expanded "><a href="3. 库函数/bytes/LastIndexFunc.html"><strong aria-hidden="true">3.4.37.</strong> Last Index Func</a></li><li class="chapter-item expanded "><a href="3. 库函数/bytes/Map.html"><strong aria-hidden="true">3.4.38.</strong> Map</a></li><li class="chapter-item expanded "><a href="3. 库函数/bytes/NewBuffer.html"><strong aria-hidden="true">3.4.39.</strong> New Buffer</a></li><li class="chapter-item expanded "><a href="3. 库函数/bytes/NewBufferString.html"><strong aria-hidden="true">3.4.40.</strong> New Buffer String</a></li><li class="chapter-item expanded "><a href="3. 库函数/bytes/NewReader.html"><strong aria-hidden="true">3.4.41.</strong> New Reader</a></li><li class="chapter-item expanded "><a href="3. 库函数/bytes/Reader_Len.html"><strong aria-hidden="true">3.4.42.</strong> Reader Len</a></li><li class="chapter-item expanded "><a href="3. 库函数/bytes/Reader_Read.html"><strong aria-hidden="true">3.4.43.</strong> Reader Read</a></li><li class="chapter-item expanded "><a href="3. 库函数/bytes/Reader_ReadAt.html"><strong aria-hidden="true">3.4.44.</strong> Reader Read At</a></li><li class="chapter-item expanded "><a href="3. 库函数/bytes/Reader_ReadByte.html"><strong aria-hidden="true">3.4.45.</strong> Reader Read Byte</a></li><li class="chapter-item expanded "><a href="3. 库函数/bytes/Reader_ReadRune.html"><strong aria-hidden="true">3.4.46.</strong> Reader Read Rune</a></li><li class="chapter-item expanded "><a href="3. 库函数/bytes/Reader_Seek.html"><strong aria-hidden="true">3.4.47.</strong> Reader Seek</a></li><li class="chapter-item expanded "><a href="3. 库函数/bytes/Reader_UnreadByte.html"><strong aria-hidden="true">3.4.48.</strong> Reader Unread Byte</a></li><li class="chapter-item expanded "><a href="3. 库函数/bytes/Reader_UnreadRune.html"><strong aria-hidden="true">3.4.49.</strong> Reader Unread Rune</a></li><li class="chapter-item expanded "><a href="3. 库函数/bytes/Repeat.html"><strong aria-hidden="true">3.4.50.</strong> Repeat</a></li><li class="chapter-item expanded "><a href="3. 库函数/bytes/Replace.html"><strong aria-hidden="true">3.4.51.</strong> Replace</a></li><li class="chapter-item expanded "><a href="3. 库函数/bytes/Runes.html"><strong aria-hidden="true">3.4.52.</strong> Runes</a></li><li class="chapter-item expanded "><a href="3. 库函数/bytes/Split.html"><strong aria-hidden="true">3.4.53.</strong> Split</a></li><li class="chapter-item expanded "><a href="3. 库函数/bytes/SplitAfter.html"><strong aria-hidden="true">3.4.54.</strong> Split After</a></li><li class="chapter-item expanded "><a href="3. 库函数/bytes/SplitAfterN.html"><strong aria-hidden="true">3.4.55.</strong> Split After N</a></li><li class="chapter-item expanded "><a href="3. 库函数/bytes/SplitN.html"><strong aria-hidden="true">3.4.56.</strong> Split N</a></li><li class="chapter-item expanded "><a href="3. 库函数/bytes/Title.html"><strong aria-hidden="true">3.4.57.</strong> Title</a></li><li class="chapter-item expanded "><a href="3. 库函数/bytes/ToLower.html"><strong aria-hidden="true">3.4.58.</strong> To Lower</a></li><li class="chapter-item expanded "><a href="3. 库函数/bytes/ToLowerSpecial.html"><strong aria-hidden="true">3.4.59.</strong> To Lower Special</a></li><li class="chapter-item expanded "><a href="3. 库函数/bytes/ToUpper.html"><strong aria-hidden="true">3.4.60.</strong> To Upper</a></li><li class="chapter-item expanded "><a href="3. 库函数/bytes/ToUpperSpecial.html"><strong aria-hidden="true">3.4.61.</strong> To Upper Special</a></li><li class="chapter-item expanded "><a href="3. 库函数/bytes/Trim.html"><strong aria-hidden="true">3.4.62.</strong> Trim</a></li><li class="chapter-item expanded "><a href="3. 库函数/bytes/TrimFunc.html"><strong aria-hidden="true">3.4.63.</strong> Trim Func</a></li><li class="chapter-item expanded "><a href="3. 库函数/bytes/TrimLeft.html"><strong aria-hidden="true">3.4.64.</strong> Trim Left</a></li><li class="chapter-item expanded "><a href="3. 库函数/bytes/TrimLeftFunc.html"><strong aria-hidden="true">3.4.65.</strong> Trim Left Func</a></li><li class="chapter-item expanded "><a href="3. 库函数/bytes/TrimRight.html"><strong aria-hidden="true">3.4.66.</strong> Trim Right</a></li><li class="chapter-item expanded "><a href="3. 库函数/bytes/TrimRightFunc.html"><strong aria-hidden="true">3.4.67.</strong> Trim Right Func</a></li><li class="chapter-item expanded "><a href="3. 库函数/bytes/TrimSpace.html"><strong aria-hidden="true">3.4.68.</strong> Trim Space</a></li></ol></li><li class="chapter-item expanded "><a href="3. 库函数/compress/index.html"><strong aria-hidden="true">3.5.</strong> Compress</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/compress/bzip2/index.html"><strong aria-hidden="true">3.5.1.</strong> Bzip 2</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/compress/bzip2/NewReader.html"><strong aria-hidden="true">3.5.1.1.</strong> New Reader</a></li><li class="chapter-item expanded "><a href="3. 库函数/compress/bzip2/StructuralError.Error.html"><strong aria-hidden="true">3.5.1.2.</strong> StructuralError.Error</a></li></ol></li><li class="chapter-item expanded "><a href="3. 库函数/compress/flate/index.html"><strong aria-hidden="true">3.5.2.</strong> Flate</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/compress/flate/CorruptInputError.Error.html"><strong aria-hidden="true">3.5.2.1.</strong> CorruptInputError.Error</a></li><li class="chapter-item expanded "><a href="3. 库函数/compress/flate/InternalError.Error.html"><strong aria-hidden="true">3.5.2.2.</strong> InternalError.Error</a></li><li class="chapter-item expanded "><a href="3. 库函数/compress/flate/NewReader.html"><strong aria-hidden="true">3.5.2.3.</strong> New Reader</a></li><li class="chapter-item expanded "><a href="3. 库函数/compress/flate/NewReaderDict.html"><strong aria-hidden="true">3.5.2.4.</strong> New Reader Dict</a></li><li class="chapter-item expanded "><a href="3. 库函数/compress/flate/NewWriter.html"><strong aria-hidden="true">3.5.2.5.</strong> New Writer</a></li><li class="chapter-item expanded "><a href="3. 库函数/compress/flate/NewWriterDict.html"><strong aria-hidden="true">3.5.2.6.</strong> New Writer Dict</a></li><li class="chapter-item expanded "><a href="3. 库函数/compress/flate/ReadError.Error.html"><strong aria-hidden="true">3.5.2.7.</strong> ReadError.Error</a></li><li class="chapter-item expanded "><a href="3. 库函数/compress/flate/WriteError.Error.html"><strong aria-hidden="true">3.5.2.8.</strong> WriteError.Error</a></li><li class="chapter-item expanded "><a href="3. 库函数/compress/flate/Writer.Close.html"><strong aria-hidden="true">3.5.2.9.</strong> Writer.Close</a></li><li class="chapter-item expanded "><a href="3. 库函数/compress/flate/Writer.Flush.html"><strong aria-hidden="true">3.5.2.10.</strong> Writer.Flush</a></li><li class="chapter-item expanded "><a href="3. 库函数/compress/flate/Writer.Reset.html"><strong aria-hidden="true">3.5.2.11.</strong> Writer.Reset</a></li><li class="chapter-item expanded "><a href="3. 库函数/compress/flate/Writer.Write.html"><strong aria-hidden="true">3.5.2.12.</strong> Writer.Write</a></li></ol></li><li class="chapter-item expanded "><a href="3. 库函数/compress/gzip/index.html"><strong aria-hidden="true">3.5.3.</strong> Gzip</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/compress/gzip/Reader.html"><strong aria-hidden="true">3.5.3.1.</strong> Reader</a></li><li class="chapter-item expanded "><a href="3. 库函数/compress/gzip/Writer.html"><strong aria-hidden="true">3.5.3.2.</strong> Writer</a></li></ol></li><li class="chapter-item expanded "><a href="3. 库函数/compress/lzw/index.html"><strong aria-hidden="true">3.5.4.</strong> Lzw</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/compress/lzw/NewReader.html"><strong aria-hidden="true">3.5.4.1.</strong> New Reader</a></li><li class="chapter-item expanded "><a href="3. 库函数/compress/lzw/NewWriter.html"><strong aria-hidden="true">3.5.4.2.</strong> New Writer</a></li></ol></li><li class="chapter-item expanded "><a href="3. 库函数/compress/zlib/index.html"><strong aria-hidden="true">3.5.5.</strong> Zlib</a></li></ol></li><li class="chapter-item expanded "><a href="3. 库函数/container/index.html"><strong aria-hidden="true">3.6.</strong> Container</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/container/heap/index.html"><strong aria-hidden="true">3.6.1.</strong> Heap</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/container/heap/Init.html"><strong aria-hidden="true">3.6.1.1.</strong> Init</a></li><li class="chapter-item expanded "><a href="3. 库函数/container/heap/Interface.html"><strong aria-hidden="true">3.6.1.2.</strong> Interface</a></li><li class="chapter-item expanded "><a href="3. 库函数/container/heap/Pop.html"><strong aria-hidden="true">3.6.1.3.</strong> Pop</a></li><li class="chapter-item expanded "><a href="3. 库函数/container/heap/Push.html"><strong aria-hidden="true">3.6.1.4.</strong> Push</a></li><li class="chapter-item expanded "><a href="3. 库函数/container/heap/Remove.html"><strong aria-hidden="true">3.6.1.5.</strong> Remove</a></li></ol></li><li class="chapter-item expanded "><a href="3. 库函数/container/list/index.html"><strong aria-hidden="true">3.6.2.</strong> List</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/container/list/Back.html"><strong aria-hidden="true">3.6.2.1.</strong> Back</a></li><li class="chapter-item expanded "><a href="3. 库函数/container/list/Element.html"><strong aria-hidden="true">3.6.2.2.</strong> Element</a></li><li class="chapter-item expanded "><a href="3. 库函数/container/list/Front.html"><strong aria-hidden="true">3.6.2.3.</strong> Front</a></li><li class="chapter-item expanded "><a href="3. 库函数/container/list/Init.html"><strong aria-hidden="true">3.6.2.4.</strong> Init</a></li><li class="chapter-item expanded "><a href="3. 库函数/container/list/InsertAfter.html"><strong aria-hidden="true">3.6.2.5.</strong> Insert After</a></li><li class="chapter-item expanded "><a href="3. 库函数/container/list/InsertBefore.html"><strong aria-hidden="true">3.6.2.6.</strong> Insert Before</a></li><li class="chapter-item expanded "><a href="3. 库函数/container/list/Len.html"><strong aria-hidden="true">3.6.2.7.</strong> Len</a></li><li class="chapter-item expanded "><a href="3. 库函数/container/list/List.html"><strong aria-hidden="true">3.6.2.8.</strong> List</a></li><li class="chapter-item expanded "><a href="3. 库函数/container/list/MoveToBack.html"><strong aria-hidden="true">3.6.2.9.</strong> Move To Back</a></li><li class="chapter-item expanded "><a href="3. 库函数/container/list/MoveToFront.html"><strong aria-hidden="true">3.6.2.10.</strong> Move To Front</a></li><li class="chapter-item expanded "><a href="3. 库函数/container/list/New.html"><strong aria-hidden="true">3.6.2.11.</strong> New</a></li><li class="chapter-item expanded "><a href="3. 库函数/container/list/Next.html"><strong aria-hidden="true">3.6.2.12.</strong> Next</a></li><li class="chapter-item expanded "><a href="3. 库函数/container/list/Prev.html"><strong aria-hidden="true">3.6.2.13.</strong> Prev</a></li><li class="chapter-item expanded "><a href="3. 库函数/container/list/PushBack.html"><strong aria-hidden="true">3.6.2.14.</strong> Push Back</a></li><li class="chapter-item expanded "><a href="3. 库函数/container/list/PushBackList.html"><strong aria-hidden="true">3.6.2.15.</strong> Push Back List</a></li><li class="chapter-item expanded "><a href="3. 库函数/container/list/PushFront.html"><strong aria-hidden="true">3.6.2.16.</strong> Push Front</a></li><li class="chapter-item expanded "><a href="3. 库函数/container/list/PushFrontList.html"><strong aria-hidden="true">3.6.2.17.</strong> Push Front List</a></li><li class="chapter-item expanded "><a href="3. 库函数/container/list/Remove.html"><strong aria-hidden="true">3.6.2.18.</strong> Remove</a></li></ol></li><li class="chapter-item expanded "><a href="3. 库函数/container/ring/index.html"><strong aria-hidden="true">3.6.3.</strong> Ring</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/container/ring/Do.html"><strong aria-hidden="true">3.6.3.1.</strong> Do</a></li><li class="chapter-item expanded "><a href="3. 库函数/container/ring/Len.html"><strong aria-hidden="true">3.6.3.2.</strong> Len</a></li><li class="chapter-item expanded "><a href="3. 库函数/container/ring/Link.html"><strong aria-hidden="true">3.6.3.3.</strong> Link</a></li><li class="chapter-item expanded "><a href="3. 库函数/container/ring/Move.html"><strong aria-hidden="true">3.6.3.4.</strong> Move</a></li><li class="chapter-item expanded "><a href="3. 库函数/container/ring/New.html"><strong aria-hidden="true">3.6.3.5.</strong> New</a></li><li class="chapter-item expanded "><a href="3. 库函数/container/ring/Next.html"><strong aria-hidden="true">3.6.3.6.</strong> Next</a></li><li class="chapter-item expanded "><a href="3. 库函数/container/ring/Prev.html"><strong aria-hidden="true">3.6.3.7.</strong> Prev</a></li><li class="chapter-item expanded "><a href="3. 库函数/container/ring/Ring.html"><strong aria-hidden="true">3.6.3.8.</strong> Ring</a></li><li class="chapter-item expanded "><a href="3. 库函数/container/ring/Unlink.html"><strong aria-hidden="true">3.6.3.9.</strong> Unlink</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="3. 库函数/crypto/index.html"><strong aria-hidden="true">3.7.</strong> Crypto</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/crypto/aes/index.html"><strong aria-hidden="true">3.7.1.</strong> Aes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/crypto/aes/Constants.html"><strong aria-hidden="true">3.7.1.1.</strong> Constants</a></li><li class="chapter-item expanded "><a href="3. 库函数/crypto/aes/KeySizeError.Error.html"><strong aria-hidden="true">3.7.1.2.</strong> KeySizeError.Error</a></li><li class="chapter-item expanded "><a href="3. 库函数/crypto/aes/KeySizeError.html"><strong aria-hidden="true">3.7.1.3.</strong> Key Size Error</a></li><li class="chapter-item expanded "><a href="3. 库函数/crypto/aes/NewCipher.html"><strong aria-hidden="true">3.7.1.4.</strong> New Cipher</a></li></ol></li><li class="chapter-item expanded "><a href="3. 库函数/crypto/cipher/index.html"><strong aria-hidden="true">3.7.2.</strong> Cipher</a></li><li class="chapter-item expanded "><a href="3. 库函数/crypto/des/index.html"><strong aria-hidden="true">3.7.3.</strong> Des</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/crypto/des/Constants.html"><strong aria-hidden="true">3.7.3.1.</strong> Constants</a></li><li class="chapter-item expanded "><a href="3. 库函数/crypto/des/KeySizeError.Error.html"><strong aria-hidden="true">3.7.3.2.</strong> KeySizeError.Error</a></li><li class="chapter-item expanded "><a href="3. 库函数/crypto/des/KeySizeError.html"><strong aria-hidden="true">3.7.3.3.</strong> Key Size Error</a></li><li class="chapter-item expanded "><a href="3. 库函数/crypto/des/NewCipher.html"><strong aria-hidden="true">3.7.3.4.</strong> New Cipher</a></li><li class="chapter-item expanded "><a href="3. 库函数/crypto/des/NewTripleDESCipher.html"><strong aria-hidden="true">3.7.3.5.</strong> New Triple DES Cipher</a></li></ol></li><li class="chapter-item expanded "><a href="3. 库函数/crypto/dsa/index.html"><strong aria-hidden="true">3.7.4.</strong> Dsa</a></li><li class="chapter-item expanded "><a href="3. 库函数/crypto/ecdsa/index.html"><strong aria-hidden="true">3.7.5.</strong> Ecdsa</a></li><li class="chapter-item expanded "><a href="3. 库函数/crypto/elliptic/index.html"><strong aria-hidden="true">3.7.6.</strong> Elliptic</a></li><li class="chapter-item expanded "><a href="3. 库函数/crypto/hmac/index.html"><strong aria-hidden="true">3.7.7.</strong> Hmac</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/crypto/hmac/New.html"><strong aria-hidden="true">3.7.7.1.</strong> New</a></li></ol></li><li class="chapter-item expanded "><a href="3. 库函数/crypto/md5/index.html"><strong aria-hidden="true">3.7.8.</strong> Md 5</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/crypto/md5/Constants.html"><strong aria-hidden="true">3.7.8.1.</strong> Constants</a></li><li class="chapter-item expanded "><a href="3. 库函数/crypto/md5/New.html"><strong aria-hidden="true">3.7.8.2.</strong> New</a></li></ol></li><li class="chapter-item expanded "><a href="3. 库函数/crypto/rand/index.html"><strong aria-hidden="true">3.7.9.</strong> Rand</a></li><li class="chapter-item expanded "><a href="3. 库函数/crypto/rc4/index.html"><strong aria-hidden="true">3.7.10.</strong> Rc 4</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/crypto/rc4/Cipher.html"><strong aria-hidden="true">3.7.10.1.</strong> Cipher</a></li><li class="chapter-item expanded "><a href="3. 库函数/crypto/rc4/KeySizeError.Error.html"><strong aria-hidden="true">3.7.10.2.</strong> KeySizeError.Error</a></li><li class="chapter-item expanded "><a href="3. 库函数/crypto/rc4/KeySizeError.html"><strong aria-hidden="true">3.7.10.3.</strong> Key Size Error</a></li><li class="chapter-item expanded "><a href="3. 库函数/crypto/rc4/NewCipher.html"><strong aria-hidden="true">3.7.10.4.</strong> New Cipher</a></li><li class="chapter-item expanded "><a href="3. 库函数/crypto/rc4/Reset.html"><strong aria-hidden="true">3.7.10.5.</strong> Reset</a></li><li class="chapter-item expanded "><a href="3. 库函数/crypto/rc4/XORKeyStream.html"><strong aria-hidden="true">3.7.10.6.</strong> XOR Key Stream</a></li></ol></li><li class="chapter-item expanded "><a href="3. 库函数/crypto/rsa/index.html"><strong aria-hidden="true">3.7.11.</strong> Rsa</a></li><li class="chapter-item expanded "><a href="3. 库函数/crypto/sha1/index.html"><strong aria-hidden="true">3.7.12.</strong> Sha 1</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/crypto/sha1/Constants.html"><strong aria-hidden="true">3.7.12.1.</strong> Constants</a></li><li class="chapter-item expanded "><a href="3. 库函数/crypto/sha1/New.html"><strong aria-hidden="true">3.7.12.2.</strong> New</a></li></ol></li><li class="chapter-item expanded "><a href="3. 库函数/crypto/sha256/index.html"><strong aria-hidden="true">3.7.13.</strong> Sha 256</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/crypto/sha256/New.html"><strong aria-hidden="true">3.7.13.1.</strong> New</a></li><li class="chapter-item expanded "><a href="3. 库函数/crypto/sha256/New224.html"><strong aria-hidden="true">3.7.13.2.</strong> New 224</a></li></ol></li><li class="chapter-item expanded "><a href="3. 库函数/crypto/sha512/index.html"><strong aria-hidden="true">3.7.14.</strong> Sha 512</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/crypto/sha512/New.html"><strong aria-hidden="true">3.7.14.1.</strong> New</a></li><li class="chapter-item expanded "><a href="3. 库函数/crypto/sha512/New384.html"><strong aria-hidden="true">3.7.14.2.</strong> New 384</a></li></ol></li><li class="chapter-item expanded "><a href="3. 库函数/crypto/subtle/index.html"><strong aria-hidden="true">3.7.15.</strong> Subtle</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/crypto/subtle/ConstantTimeByteEq.html"><strong aria-hidden="true">3.7.15.1.</strong> Constant Time Byte Eq</a></li><li class="chapter-item expanded "><a href="3. 库函数/crypto/subtle/ConstantTimeCompare.html"><strong aria-hidden="true">3.7.15.2.</strong> Constant Time Compare</a></li><li class="chapter-item expanded "><a href="3. 库函数/crypto/subtle/ConstantTimeCopy.html"><strong aria-hidden="true">3.7.15.3.</strong> Constant Time Copy</a></li><li class="chapter-item expanded "><a href="3. 库函数/crypto/subtle/ConstantTimeEq.html"><strong aria-hidden="true">3.7.15.4.</strong> Constant Time Eq</a></li><li class="chapter-item expanded "><a href="3. 库函数/crypto/subtle/ConstantTimeSelect.html"><strong aria-hidden="true">3.7.15.5.</strong> Constant Time Select</a></li></ol></li><li class="chapter-item expanded "><a href="3. 库函数/crypto/tls/index.html"><strong aria-hidden="true">3.7.16.</strong> Tls</a></li><li class="chapter-item expanded "><a href="3. 库函数/crypto/x509/index.html"><strong aria-hidden="true">3.7.17.</strong> X 509</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/crypto/x509/pkix/index.html"><strong aria-hidden="true">3.7.17.1.</strong> Pkix</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="3. 库函数/database/index.html"><strong aria-hidden="true">3.8.</strong> Database</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/database/sql/index.html"><strong aria-hidden="true">3.8.1.</strong> Sql</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/database/sql/driver/index.html"><strong aria-hidden="true">3.8.1.1.</strong> Driver</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="3. 库函数/debug/index.html"><strong aria-hidden="true">3.9.</strong> Debug</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/debug/dwarf/index.html"><strong aria-hidden="true">3.9.1.</strong> Dwarf</a></li><li class="chapter-item expanded "><a href="3. 库函数/debug/elf/index.html"><strong aria-hidden="true">3.9.2.</strong> Elf</a></li><li class="chapter-item expanded "><a href="3. 库函数/debug/gosym/index.html"><strong aria-hidden="true">3.9.3.</strong> Gosym</a></li><li class="chapter-item expanded "><a href="3. 库函数/debug/macho/index.html"><strong aria-hidden="true">3.9.4.</strong> Macho</a></li><li class="chapter-item expanded "><a href="3. 库函数/debug/pe/index.html"><strong aria-hidden="true">3.9.5.</strong> Pe</a></li></ol></li><li class="chapter-item expanded "><a href="3. 库函数/encoding/index.html"><strong aria-hidden="true">3.10.</strong> Encoding</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/encoding/ascii85/index.html"><strong aria-hidden="true">3.10.1.</strong> Ascii 85</a></li><li class="chapter-item expanded "><a href="3. 库函数/encoding/asn1/index.html"><strong aria-hidden="true">3.10.2.</strong> Asn 1</a></li><li class="chapter-item expanded "><a href="3. 库函数/encoding/base32/index.html"><strong aria-hidden="true">3.10.3.</strong> Base 32</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/encoding/base32/CorruptInputError.html"><strong aria-hidden="true">3.10.3.1.</strong> Corrupt Input Error</a></li><li class="chapter-item expanded "><a href="3. 库函数/encoding/base32/Decode.html"><strong aria-hidden="true">3.10.3.2.</strong> Decode</a></li><li class="chapter-item expanded "><a href="3. 库函数/encoding/base32/DecodedLen.html"><strong aria-hidden="true">3.10.3.3.</strong> Decoded Len</a></li><li class="chapter-item expanded "><a href="3. 库函数/encoding/base32/DecodeString.html"><strong aria-hidden="true">3.10.3.4.</strong> Decode String</a></li><li class="chapter-item expanded "><a href="3. 库函数/encoding/base32/Encode.html"><strong aria-hidden="true">3.10.3.5.</strong> Encode</a></li><li class="chapter-item expanded "><a href="3. 库函数/encoding/base32/EncodedLen.html"><strong aria-hidden="true">3.10.3.6.</strong> Encoded Len</a></li><li class="chapter-item expanded "><a href="3. 库函数/encoding/base32/EncodeToString.html"><strong aria-hidden="true">3.10.3.7.</strong> Encode To String</a></li><li class="chapter-item expanded "><a href="3. 库函数/encoding/base32/NewDecoder.html"><strong aria-hidden="true">3.10.3.8.</strong> New Decoder</a></li><li class="chapter-item expanded "><a href="3. 库函数/encoding/base32/NewEncoder.html"><strong aria-hidden="true">3.10.3.9.</strong> New Encoder</a></li><li class="chapter-item expanded "><a href="3. 库函数/encoding/base32/NewEncoding.html"><strong aria-hidden="true">3.10.3.10.</strong> New Encoding</a></li></ol></li><li class="chapter-item expanded "><a href="3. 库函数/encoding/base64/index.html"><strong aria-hidden="true">3.10.4.</strong> Base 64</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/encoding/base64/CorruptInputError.html"><strong aria-hidden="true">3.10.4.1.</strong> Corrupt Input Error</a></li><li class="chapter-item expanded "><a href="3. 库函数/encoding/base64/Decode.html"><strong aria-hidden="true">3.10.4.2.</strong> Decode</a></li><li class="chapter-item expanded "><a href="3. 库函数/encoding/base64/DecodedLen.html"><strong aria-hidden="true">3.10.4.3.</strong> Decoded Len</a></li><li class="chapter-item expanded "><a href="3. 库函数/encoding/base64/DecodeString.html"><strong aria-hidden="true">3.10.4.4.</strong> Decode String</a></li><li class="chapter-item expanded "><a href="3. 库函数/encoding/base64/Encode.html"><strong aria-hidden="true">3.10.4.5.</strong> Encode</a></li><li class="chapter-item expanded "><a href="3. 库函数/encoding/base64/EncodedLen.html"><strong aria-hidden="true">3.10.4.6.</strong> Encoded Len</a></li><li class="chapter-item expanded "><a href="3. 库函数/encoding/base64/EncodeToString.html"><strong aria-hidden="true">3.10.4.7.</strong> Encode To String</a></li><li class="chapter-item expanded "><a href="3. 库函数/encoding/base64/NewDecoder.html"><strong aria-hidden="true">3.10.4.8.</strong> New Decoder</a></li><li class="chapter-item expanded "><a href="3. 库函数/encoding/base64/NewEncoder.html"><strong aria-hidden="true">3.10.4.9.</strong> New Encoder</a></li><li class="chapter-item expanded "><a href="3. 库函数/encoding/base64/NewEncoding.html"><strong aria-hidden="true">3.10.4.10.</strong> New Encoding</a></li></ol></li><li class="chapter-item expanded "><a href="3. 库函数/encoding/binary/index.html"><strong aria-hidden="true">3.10.5.</strong> Binary</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/encoding/binary/PutUvarint.html"><strong aria-hidden="true">3.10.5.1.</strong> Put Uvarint</a></li><li class="chapter-item expanded "><a href="3. 库函数/encoding/binary/PutVarint.html"><strong aria-hidden="true">3.10.5.2.</strong> Put Varint</a></li><li class="chapter-item expanded "><a href="3. 库函数/encoding/binary/Read.html"><strong aria-hidden="true">3.10.5.3.</strong> Read</a></li><li class="chapter-item expanded "><a href="3. 库函数/encoding/binary/ReadUvarint.html"><strong aria-hidden="true">3.10.5.4.</strong> Read Uvarint</a></li><li class="chapter-item expanded "><a href="3. 库函数/encoding/binary/ReadVarint.html"><strong aria-hidden="true">3.10.5.5.</strong> Read Varint</a></li><li class="chapter-item expanded "><a href="3. 库函数/encoding/binary/Size.html"><strong aria-hidden="true">3.10.5.6.</strong> Size</a></li><li class="chapter-item expanded "><a href="3. 库函数/encoding/binary/Uvarint.html"><strong aria-hidden="true">3.10.5.7.</strong> Uvarint</a></li><li class="chapter-item expanded "><a href="3. 库函数/encoding/binary/Varint.html"><strong aria-hidden="true">3.10.5.8.</strong> Varint</a></li><li class="chapter-item expanded "><a href="3. 库函数/encoding/binary/Write.html"><strong aria-hidden="true">3.10.5.9.</strong> Write</a></li></ol></li><li class="chapter-item expanded "><a href="3. 库函数/encoding/csv/index.html"><strong aria-hidden="true">3.10.6.</strong> Csv</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/encoding/csv/Error.html"><strong aria-hidden="true">3.10.6.1.</strong> Error</a></li><li class="chapter-item expanded "><a href="3. 库函数/encoding/csv/Flush.html"><strong aria-hidden="true">3.10.6.2.</strong> Flush</a></li><li class="chapter-item expanded "><a href="3. 库函数/encoding/csv/NewReader.html"><strong aria-hidden="true">3.10.6.3.</strong> New Reader</a></li><li class="chapter-item expanded "><a href="3. 库函数/encoding/csv/NewWriter.html"><strong aria-hidden="true">3.10.6.4.</strong> New Writer</a></li><li class="chapter-item expanded "><a href="3. 库函数/encoding/csv/Read.html"><strong aria-hidden="true">3.10.6.5.</strong> Read</a></li><li class="chapter-item expanded "><a href="3. 库函数/encoding/csv/ReadAll.html"><strong aria-hidden="true">3.10.6.6.</strong> Read All</a></li><li class="chapter-item expanded "><a href="3. 库函数/encoding/csv/Write.html"><strong aria-hidden="true">3.10.6.7.</strong> Write</a></li><li class="chapter-item expanded "><a href="3. 库函数/encoding/csv/WriteAll.html"><strong aria-hidden="true">3.10.6.8.</strong> Write All</a></li></ol></li><li class="chapter-item expanded "><a href="3. 库函数/encoding/gob/index.html"><strong aria-hidden="true">3.10.7.</strong> Gob</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/encoding/gob/Decode.html"><strong aria-hidden="true">3.10.7.1.</strong> Decode</a></li><li class="chapter-item expanded "><a href="3. 库函数/encoding/gob/Encode.html"><strong aria-hidden="true">3.10.7.2.</strong> Encode</a></li><li class="chapter-item expanded "><a href="3. 库函数/encoding/gob/NewDecoder.html"><strong aria-hidden="true">3.10.7.3.</strong> New Decoder</a></li><li class="chapter-item expanded "><a href="3. 库函数/encoding/gob/NewEncoder.html"><strong aria-hidden="true">3.10.7.4.</strong> New Encoder</a></li><li class="chapter-item expanded "><a href="3. 库函数/encoding/gob/struct.html"><strong aria-hidden="true">3.10.7.5.</strong> Struct</a></li></ol></li><li class="chapter-item expanded "><a href="3. 库函数/encoding/hex/index.html"><strong aria-hidden="true">3.10.8.</strong> Hex</a></li><li class="chapter-item expanded "><a href="3. 库函数/encoding/json/index.html"><strong aria-hidden="true">3.10.9.</strong> Json</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/encoding/json/Compact.html"><strong aria-hidden="true">3.10.9.1.</strong> Compact</a></li><li class="chapter-item expanded "><a href="3. 库函数/encoding/json/Decode.html"><strong aria-hidden="true">3.10.9.2.</strong> Decode</a></li><li class="chapter-item expanded "><a href="3. 库函数/encoding/json/Encode.html"><strong aria-hidden="true">3.10.9.3.</strong> Encode</a></li><li class="chapter-item expanded "><a href="3. 库函数/encoding/json/HTMLEscape.html"><strong aria-hidden="true">3.10.9.4.</strong> HTML Escape</a></li><li class="chapter-item expanded "><a href="3. 库函数/encoding/json/Indent.html"><strong aria-hidden="true">3.10.9.5.</strong> Indent</a></li><li class="chapter-item expanded "><a href="3. 库函数/encoding/json/Marshal.html"><strong aria-hidden="true">3.10.9.6.</strong> Marshal</a></li><li class="chapter-item expanded "><a href="3. 库函数/encoding/json/MarshalIndent.html"><strong aria-hidden="true">3.10.9.7.</strong> Marshal Indent</a></li><li class="chapter-item expanded "><a href="3. 库函数/encoding/json/NewDecoder.html"><strong aria-hidden="true">3.10.9.8.</strong> New Decoder</a></li><li class="chapter-item expanded "><a href="3. 库函数/encoding/json/NewEncoder.html"><strong aria-hidden="true">3.10.9.9.</strong> New Encoder</a></li><li class="chapter-item expanded "><a href="3. 库函数/encoding/json/Unmarshal.html"><strong aria-hidden="true">3.10.9.10.</strong> Unmarshal</a></li></ol></li><li class="chapter-item expanded "><a href="3. 库函数/encoding/pem/index.html"><strong aria-hidden="true">3.10.10.</strong> Pem</a></li><li class="chapter-item expanded "><a href="3. 库函数/encoding/xml/index.html"><strong aria-hidden="true">3.10.11.</strong> Xml</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/encoding/xml/Escape.html"><strong aria-hidden="true">3.10.11.1.</strong> Escape</a></li><li class="chapter-item expanded "><a href="3. 库函数/encoding/xml/Marshal.html"><strong aria-hidden="true">3.10.11.2.</strong> Marshal</a></li><li class="chapter-item expanded "><a href="3. 库函数/encoding/xml/MarshalIndent.html"><strong aria-hidden="true">3.10.11.3.</strong> Marshal Indent</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="3. 库函数/errors/index.html"><strong aria-hidden="true">3.11.</strong> Errors</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/errors/New.html"><strong aria-hidden="true">3.11.1.</strong> New</a></li></ol></li><li class="chapter-item expanded "><a href="3. 库函数/expvar/index.html"><strong aria-hidden="true">3.12.</strong> Expvar</a></li><li class="chapter-item expanded "><a href="3. 库函数/flag/index.html"><strong aria-hidden="true">3.13.</strong> Flag</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/flag/Arg.html"><strong aria-hidden="true">3.13.1.</strong> Arg</a></li><li class="chapter-item expanded "><a href="3. 库函数/flag/Args.html"><strong aria-hidden="true">3.13.2.</strong> Args</a></li><li class="chapter-item expanded "><a href="3. 库函数/flag/Bool.html"><strong aria-hidden="true">3.13.3.</strong> Bool</a></li><li class="chapter-item expanded "><a href="3. 库函数/flag/BoolVar.html"><strong aria-hidden="true">3.13.4.</strong> Bool Var</a></li><li class="chapter-item expanded "><a href="3. 库函数/flag/Duration.html"><strong aria-hidden="true">3.13.5.</strong> Duration</a></li><li class="chapter-item expanded "><a href="3. 库函数/flag/DurationVar.html"><strong aria-hidden="true">3.13.6.</strong> Duration Var</a></li><li class="chapter-item expanded "><a href="3. 库函数/flag/FlagSetArg.html"><strong aria-hidden="true">3.13.7.</strong> Flag Set Arg</a></li><li class="chapter-item expanded "><a href="3. 库函数/flag/FlagSetArgs.html"><strong aria-hidden="true">3.13.8.</strong> Flag Set Args</a></li><li class="chapter-item expanded "><a href="3. 库函数/flag/FlagSetBool.html"><strong aria-hidden="true">3.13.9.</strong> Flag Set Bool</a></li><li class="chapter-item expanded "><a href="3. 库函数/flag/FlagSetBoolVar.html"><strong aria-hidden="true">3.13.10.</strong> Flag Set Bool Var</a></li><li class="chapter-item expanded "><a href="3. 库函数/flag/FlagSetDuration.html"><strong aria-hidden="true">3.13.11.</strong> Flag Set Duration</a></li><li class="chapter-item expanded "><a href="3. 库函数/flag/FlagSetFloat64.html"><strong aria-hidden="true">3.13.12.</strong> Flag Set Float 64</a></li><li class="chapter-item expanded "><a href="3. 库函数/flag/FlagSetFloat64Var.html"><strong aria-hidden="true">3.13.13.</strong> Flag Set Float 64 Var</a></li><li class="chapter-item expanded "><a href="3. 库函数/flag/FlagSetInit.html"><strong aria-hidden="true">3.13.14.</strong> Flag Set Init</a></li><li class="chapter-item expanded "><a href="3. 库函数/flag/FlagSetInt.html"><strong aria-hidden="true">3.13.15.</strong> Flag Set Int</a></li><li class="chapter-item expanded "><a href="3. 库函数/flag/FlagSetInt64.html"><strong aria-hidden="true">3.13.16.</strong> Flag Set Int 64</a></li><li class="chapter-item expanded "><a href="3. 库函数/flag/FlagSetInt64Var.html"><strong aria-hidden="true">3.13.17.</strong> Flag Set Int 64 Var</a></li><li class="chapter-item expanded "><a href="3. 库函数/flag/FlagSetIntVar.html"><strong aria-hidden="true">3.13.18.</strong> Flag Set Int Var</a></li><li class="chapter-item expanded "><a href="3. 库函数/flag/FlagSetLookup.html"><strong aria-hidden="true">3.13.19.</strong> Flag Set Lookup</a></li><li class="chapter-item expanded "><a href="3. 库函数/flag/FlagSetNArg.html"><strong aria-hidden="true">3.13.20.</strong> Flag Set N Arg</a></li><li class="chapter-item expanded "><a href="3. 库函数/flag/FlagSetNFlag.html"><strong aria-hidden="true">3.13.21.</strong> Flag Set N Flag</a></li><li class="chapter-item expanded "><a href="3. 库函数/flag/FlagSetParse.html"><strong aria-hidden="true">3.13.22.</strong> Flag Set Parse</a></li><li class="chapter-item expanded "><a href="3. 库函数/flag/FlagSetParsed.html"><strong aria-hidden="true">3.13.23.</strong> Flag Set Parsed</a></li><li class="chapter-item expanded "><a href="3. 库函数/flag/FlagSetPrintDefaults.html"><strong aria-hidden="true">3.13.24.</strong> Flag Set Print Defaults</a></li><li class="chapter-item expanded "><a href="3. 库函数/flag/FlagSetSet.html"><strong aria-hidden="true">3.13.25.</strong> Flag Set Set</a></li><li class="chapter-item expanded "><a href="3. 库函数/flag/FlagSetSetOutput.html"><strong aria-hidden="true">3.13.26.</strong> Flag Set Set Output</a></li><li class="chapter-item expanded "><a href="3. 库函数/flag/FlagSetString.html"><strong aria-hidden="true">3.13.27.</strong> Flag Set String</a></li><li class="chapter-item expanded "><a href="3. 库函数/flag/FlagSetStringVar.html"><strong aria-hidden="true">3.13.28.</strong> Flag Set String Var</a></li><li class="chapter-item expanded "><a href="3. 库函数/flag/FlagSetUint.html"><strong aria-hidden="true">3.13.29.</strong> Flag Set Uint</a></li><li class="chapter-item expanded "><a href="3. 库函数/flag/FlagSetUint64.html"><strong aria-hidden="true">3.13.30.</strong> Flag Set Uint 64</a></li><li class="chapter-item expanded "><a href="3. 库函数/flag/FlagSetUint64Var.html"><strong aria-hidden="true">3.13.31.</strong> Flag Set Uint 64 Var</a></li><li class="chapter-item expanded "><a href="3. 库函数/flag/FlagSetUintVar.html"><strong aria-hidden="true">3.13.32.</strong> Flag Set Uint Var</a></li><li class="chapter-item expanded "><a href="3. 库函数/flag/FlagSetVar.html"><strong aria-hidden="true">3.13.33.</strong> Flag Set Var</a></li><li class="chapter-item expanded "><a href="3. 库函数/flag/FlagSetVisit.html"><strong aria-hidden="true">3.13.34.</strong> Flag Set Visit</a></li><li class="chapter-item expanded "><a href="3. 库函数/flag/FlagSetVisitAll.html"><strong aria-hidden="true">3.13.35.</strong> Flag Set Visit All</a></li><li class="chapter-item expanded "><a href="3. 库函数/flag/Float64.html"><strong aria-hidden="true">3.13.36.</strong> Float 64</a></li><li class="chapter-item expanded "><a href="3. 库函数/flag/Float64Var.html"><strong aria-hidden="true">3.13.37.</strong> Float 64 Var</a></li><li class="chapter-item expanded "><a href="3. 库函数/flag/Int.html"><strong aria-hidden="true">3.13.38.</strong> Int</a></li><li class="chapter-item expanded "><a href="3. 库函数/flag/Int64.html"><strong aria-hidden="true">3.13.39.</strong> Int 64</a></li><li class="chapter-item expanded "><a href="3. 库函数/flag/Int64Var.html"><strong aria-hidden="true">3.13.40.</strong> Int 64 Var</a></li><li class="chapter-item expanded "><a href="3. 库函数/flag/IntVar.html"><strong aria-hidden="true">3.13.41.</strong> Int Var</a></li><li class="chapter-item expanded "><a href="3. 库函数/flag/Lookup.html"><strong aria-hidden="true">3.13.42.</strong> Lookup</a></li><li class="chapter-item expanded "><a href="3. 库函数/flag/NArg.html"><strong aria-hidden="true">3.13.43.</strong> N Arg</a></li><li class="chapter-item expanded "><a href="3. 库函数/flag/NewFlagSet.html"><strong aria-hidden="true">3.13.44.</strong> New Flag Set</a></li><li class="chapter-item expanded "><a href="3. 库函数/flag/NFlag.html"><strong aria-hidden="true">3.13.45.</strong> N Flag</a></li><li class="chapter-item expanded "><a href="3. 库函数/flag/Parse.html"><strong aria-hidden="true">3.13.46.</strong> Parse</a></li><li class="chapter-item expanded "><a href="3. 库函数/flag/Parsed.html"><strong aria-hidden="true">3.13.47.</strong> Parsed</a></li><li class="chapter-item expanded "><a href="3. 库函数/flag/PrintDefaults.html"><strong aria-hidden="true">3.13.48.</strong> Print Defaults</a></li><li class="chapter-item expanded "><a href="3. 库函数/flag/Set.html"><strong aria-hidden="true">3.13.49.</strong> Set</a></li><li class="chapter-item expanded "><a href="3. 库函数/flag/String.html"><strong aria-hidden="true">3.13.50.</strong> String</a></li><li class="chapter-item expanded "><a href="3. 库函数/flag/StringVar.html"><strong aria-hidden="true">3.13.51.</strong> String Var</a></li><li class="chapter-item expanded "><a href="3. 库函数/flag/Uint.html"><strong aria-hidden="true">3.13.52.</strong> Uint</a></li><li class="chapter-item expanded "><a href="3. 库函数/flag/Uint64.html"><strong aria-hidden="true">3.13.53.</strong> Uint 64</a></li><li class="chapter-item expanded "><a href="3. 库函数/flag/Uint64Var.html"><strong aria-hidden="true">3.13.54.</strong> Uint 64 Var</a></li><li class="chapter-item expanded "><a href="3. 库函数/flag/UintVar.html"><strong aria-hidden="true">3.13.55.</strong> Uint Var</a></li><li class="chapter-item expanded "><a href="3. 库函数/flag/Var.html"><strong aria-hidden="true">3.13.56.</strong> Var</a></li><li class="chapter-item expanded "><a href="3. 库函数/flag/Visit.html"><strong aria-hidden="true">3.13.57.</strong> Visit</a></li><li class="chapter-item expanded "><a href="3. 库函数/flag/VisitAll.html"><strong aria-hidden="true">3.13.58.</strong> Visit All</a></li></ol></li><li class="chapter-item expanded "><a href="3. 库函数/fmt/index.html"><strong aria-hidden="true">3.14.</strong> Fmt</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/fmt/Errorf.html"><strong aria-hidden="true">3.14.1.</strong> Errorf</a></li><li class="chapter-item expanded "><a href="3. 库函数/fmt/FormatDoc.html"><strong aria-hidden="true">3.14.2.</strong> Format Doc</a></li><li class="chapter-item expanded "><a href="3. 库函数/fmt/Fprint.html"><strong aria-hidden="true">3.14.3.</strong> Fprint</a></li><li class="chapter-item expanded "><a href="3. 库函数/fmt/Fprintf.html"><strong aria-hidden="true">3.14.4.</strong> Fprintf</a></li><li class="chapter-item expanded "><a href="3. 库函数/fmt/Fprintln.html"><strong aria-hidden="true">3.14.5.</strong> Fprintln</a></li><li class="chapter-item expanded "><a href="3. 库函数/fmt/Fscan.html"><strong aria-hidden="true">3.14.6.</strong> Fscan</a></li><li class="chapter-item expanded "><a href="3. 库函数/fmt/Fscanf.html"><strong aria-hidden="true">3.14.7.</strong> Fscanf</a></li><li class="chapter-item expanded "><a href="3. 库函数/fmt/Fscanln.html"><strong aria-hidden="true">3.14.8.</strong> Fscanln</a></li><li class="chapter-item expanded "><a href="3. 库函数/fmt/Print.html"><strong aria-hidden="true">3.14.9.</strong> Print</a></li><li class="chapter-item expanded "><a href="3. 库函数/fmt/Printf.html"><strong aria-hidden="true">3.14.10.</strong> Printf</a></li><li class="chapter-item expanded "><a href="3. 库函数/fmt/Println.html"><strong aria-hidden="true">3.14.11.</strong> Println</a></li><li class="chapter-item expanded "><a href="3. 库函数/fmt/Scan.html"><strong aria-hidden="true">3.14.12.</strong> Scan</a></li><li class="chapter-item expanded "><a href="3. 库函数/fmt/Scanf.html"><strong aria-hidden="true">3.14.13.</strong> Scanf</a></li><li class="chapter-item expanded "><a href="3. 库函数/fmt/Scanln.html"><strong aria-hidden="true">3.14.14.</strong> Scanln</a></li><li class="chapter-item expanded "><a href="3. 库函数/fmt/Sprint.html"><strong aria-hidden="true">3.14.15.</strong> Sprint</a></li><li class="chapter-item expanded "><a href="3. 库函数/fmt/Sprintf.html"><strong aria-hidden="true">3.14.16.</strong> Sprintf</a></li><li class="chapter-item expanded "><a href="3. 库函数/fmt/Sprintln.html"><strong aria-hidden="true">3.14.17.</strong> Sprintln</a></li><li class="chapter-item expanded "><a href="3. 库函数/fmt/Sscan.html"><strong aria-hidden="true">3.14.18.</strong> Sscan</a></li><li class="chapter-item expanded "><a href="3. 库函数/fmt/Sscanf.html"><strong aria-hidden="true">3.14.19.</strong> Sscanf</a></li><li class="chapter-item expanded "><a href="3. 库函数/fmt/Sscanln.html"><strong aria-hidden="true">3.14.20.</strong> Sscanln</a></li></ol></li><li class="chapter-item expanded "><a href="3. 库函数/go/index.html"><strong aria-hidden="true">3.15.</strong> Go</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/go/ast/index.html"><strong aria-hidden="true">3.15.1.</strong> Ast</a></li><li class="chapter-item expanded "><a href="3. 库函数/go/build/index.html"><strong aria-hidden="true">3.15.2.</strong> Build</a></li><li class="chapter-item expanded "><a href="3. 库函数/go/doc/index.html"><strong aria-hidden="true">3.15.3.</strong> Doc</a></li><li class="chapter-item expanded "><a href="3. 库函数/go/parser/index.html"><strong aria-hidden="true">3.15.4.</strong> Parser</a></li><li class="chapter-item expanded "><a href="3. 库函数/go/printer/index.html"><strong aria-hidden="true">3.15.5.</strong> Printer</a></li><li class="chapter-item expanded "><a href="3. 库函数/go/scanner/index.html"><strong aria-hidden="true">3.15.6.</strong> Scanner</a></li><li class="chapter-item expanded "><a href="3. 库函数/go/token/index.html"><strong aria-hidden="true">3.15.7.</strong> Token</a></li></ol></li><li class="chapter-item expanded "><a href="3. 库函数/hash/index.html"><strong aria-hidden="true">3.16.</strong> Hash</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/hash/adler32/index.html"><strong aria-hidden="true">3.16.1.</strong> Adler 32</a></li><li class="chapter-item expanded "><a href="3. 库函数/hash/crc32/index.html"><strong aria-hidden="true">3.16.2.</strong> Crc 32</a></li><li class="chapter-item expanded "><a href="3. 库函数/hash/crc64/index.html"><strong aria-hidden="true">3.16.3.</strong> Crc 64</a></li><li class="chapter-item expanded "><a href="3. 库函数/hash/fnv/index.html"><strong aria-hidden="true">3.16.4.</strong> Fnv</a></li></ol></li><li class="chapter-item expanded "><a href="3. 库函数/html/index.html"><strong aria-hidden="true">3.17.</strong> Html</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/html/template/index.html"><strong aria-hidden="true">3.17.1.</strong> Template</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/html/template/HTMLEscape.html"><strong aria-hidden="true">3.17.1.1.</strong> HTML Escape</a></li><li class="chapter-item expanded "><a href="3. 库函数/html/template/HTMLEscaper.html"><strong aria-hidden="true">3.17.1.2.</strong> HTML Escaper</a></li><li class="chapter-item expanded "><a href="3. 库函数/html/template/HTMLEscapeString.html"><strong aria-hidden="true">3.17.1.3.</strong> HTML Escape String</a></li></ol></li><li class="chapter-item expanded "><a href="3. 库函数/html/EscapeString.html"><strong aria-hidden="true">3.17.2.</strong> Escape String</a></li><li class="chapter-item expanded "><a href="3. 库函数/html/UnescapeString.html"><strong aria-hidden="true">3.17.3.</strong> Unescape String</a></li></ol></li><li class="chapter-item expanded "><a href="3. 库函数/image/index.html"><strong aria-hidden="true">3.18.</strong> Image</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/image/color/index.html"><strong aria-hidden="true">3.18.1.</strong> Color</a></li><li class="chapter-item expanded "><a href="3. 库函数/image/draw/index.html"><strong aria-hidden="true">3.18.2.</strong> Draw</a></li><li class="chapter-item expanded "><a href="3. 库函数/image/gif/index.html"><strong aria-hidden="true">3.18.3.</strong> Gif</a></li><li class="chapter-item expanded "><a href="3. 库函数/image/jpeg/index.html"><strong aria-hidden="true">3.18.4.</strong> Jpeg</a></li><li class="chapter-item expanded "><a href="3. 库函数/image/png/index.html"><strong aria-hidden="true">3.18.5.</strong> Png</a></li></ol></li><li class="chapter-item expanded "><a href="3. 库函数/index/index.html"><strong aria-hidden="true">3.19.</strong> Index</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/index/suffixarray/index.html"><strong aria-hidden="true">3.19.1.</strong> Suffixarray</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/index/suffixarray/Bytes.html"><strong aria-hidden="true">3.19.1.1.</strong> Bytes</a></li><li class="chapter-item expanded "><a href="3. 库函数/index/suffixarray/FindAllIndex.html"><strong aria-hidden="true">3.19.1.2.</strong> Find All Index</a></li><li class="chapter-item expanded "><a href="3. 库函数/index/suffixarray/Lookup.html"><strong aria-hidden="true">3.19.1.3.</strong> Lookup</a></li><li class="chapter-item expanded "><a href="3. 库函数/index/suffixarray/New.html"><strong aria-hidden="true">3.19.1.4.</strong> New</a></li><li class="chapter-item expanded "><a href="3. 库函数/index/suffixarray/Read.html"><strong aria-hidden="true">3.19.1.5.</strong> Read</a></li><li class="chapter-item expanded "><a href="3. 库函数/index/suffixarray/Write.html"><strong aria-hidden="true">3.19.1.6.</strong> Write</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="3. 库函数/io/index.html"><strong aria-hidden="true">3.20.</strong> Io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/io/ioutil/index.html"><strong aria-hidden="true">3.20.1.</strong> Ioutil</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/io/ioutil/NopCloser.html"><strong aria-hidden="true">3.20.1.1.</strong> Nop Closer</a></li><li class="chapter-item expanded "><a href="3. 库函数/io/ioutil/ReadAll.html"><strong aria-hidden="true">3.20.1.2.</strong> Read All</a></li><li class="chapter-item expanded "><a href="3. 库函数/io/ioutil/ReadDir.html"><strong aria-hidden="true">3.20.1.3.</strong> Read Dir</a></li><li class="chapter-item expanded "><a href="3. 库函数/io/ioutil/ReadFile.html"><strong aria-hidden="true">3.20.1.4.</strong> Read File</a></li><li class="chapter-item expanded "><a href="3. 库函数/io/ioutil/TempDir.html"><strong aria-hidden="true">3.20.1.5.</strong> Temp Dir</a></li><li class="chapter-item expanded "><a href="3. 库函数/io/ioutil/TempFile.html"><strong aria-hidden="true">3.20.1.6.</strong> Temp File</a></li></ol></li><li class="chapter-item expanded "><a href="3. 库函数/io/Copy.html"><strong aria-hidden="true">3.20.2.</strong> Copy</a></li><li class="chapter-item expanded "><a href="3. 库函数/io/CopyN.html"><strong aria-hidden="true">3.20.3.</strong> Copy N</a></li><li class="chapter-item expanded "><a href="3. 库函数/io/LimitReader.html"><strong aria-hidden="true">3.20.4.</strong> Limit Reader</a></li><li class="chapter-item expanded "><a href="3. 库函数/io/LimitReader.Read.html"><strong aria-hidden="true">3.20.5.</strong> LimitReader.Read</a></li><li class="chapter-item expanded "><a href="3. 库函数/io/MultiReader.html"><strong aria-hidden="true">3.20.6.</strong> Multi Reader</a></li><li class="chapter-item expanded "><a href="3. 库函数/io/MultiReader.Read.html"><strong aria-hidden="true">3.20.7.</strong> MultiReader.Read</a></li><li class="chapter-item expanded "><a href="3. 库函数/io/MultiWriter.html"><strong aria-hidden="true">3.20.8.</strong> Multi Writer</a></li><li class="chapter-item expanded "><a href="3. 库函数/io/MultiWriter.Write.html"><strong aria-hidden="true">3.20.9.</strong> MultiWriter.Write</a></li><li class="chapter-item expanded "><a href="3. 库函数/io/NewSectionReader.html"><strong aria-hidden="true">3.20.10.</strong> New Section Reader</a></li><li class="chapter-item expanded "><a href="3. 库函数/io/Pipe.html"><strong aria-hidden="true">3.20.11.</strong> Pipe</a></li><li class="chapter-item expanded "><a href="3. 库函数/io/PipeReader.Close.html"><strong aria-hidden="true">3.20.12.</strong> PipeReader.Close</a></li><li class="chapter-item expanded "><a href="3. 库函数/io/PipeReader.CloseWithError.html"><strong aria-hidden="true">3.20.13.</strong> PipeReader.CloseWithError</a></li><li class="chapter-item expanded "><a href="3. 库函数/io/PipeReader.Read.html"><strong aria-hidden="true">3.20.14.</strong> PipeReader.Read</a></li><li class="chapter-item expanded "><a href="3. 库函数/io/PipeWriter.Close.html"><strong aria-hidden="true">3.20.15.</strong> PipeWriter.Close</a></li><li class="chapter-item expanded "><a href="3. 库函数/io/PipeWriter.CloseWithError.html"><strong aria-hidden="true">3.20.16.</strong> PipeWriter.CloseWithError</a></li><li class="chapter-item expanded "><a href="3. 库函数/io/PipeWriter.Write.html"><strong aria-hidden="true">3.20.17.</strong> PipeWriter.Write</a></li><li class="chapter-item expanded "><a href="3. 库函数/io/ReadAtLeast.html"><strong aria-hidden="true">3.20.18.</strong> Read At Least</a></li><li class="chapter-item expanded "><a href="3. 库函数/io/ReadFull.html"><strong aria-hidden="true">3.20.19.</strong> Read Full</a></li><li class="chapter-item expanded "><a href="3. 库函数/io/SectionReader.Read.html"><strong aria-hidden="true">3.20.20.</strong> SectionReader.Read</a></li><li class="chapter-item expanded "><a href="3. 库函数/io/SectionReader.ReadAt.html"><strong aria-hidden="true">3.20.21.</strong> SectionReader.ReadAt</a></li><li class="chapter-item expanded "><a href="3. 库函数/io/SectionReader.Seek.html"><strong aria-hidden="true">3.20.22.</strong> SectionReader.Seek</a></li><li class="chapter-item expanded "><a href="3. 库函数/io/SectionReader.Size.html"><strong aria-hidden="true">3.20.23.</strong> SectionReader.Size</a></li><li class="chapter-item expanded "><a href="3. 库函数/io/TeeReader.html"><strong aria-hidden="true">3.20.24.</strong> Tee Reader</a></li><li class="chapter-item expanded "><a href="3. 库函数/io/TeeReader.Read.html"><strong aria-hidden="true">3.20.25.</strong> TeeReader.Read</a></li><li class="chapter-item expanded "><a href="3. 库函数/io/WriteString.html"><strong aria-hidden="true">3.20.26.</strong> Write String</a></li></ol></li><li class="chapter-item expanded "><a href="3. 库函数/log/index.html"><strong aria-hidden="true">3.21.</strong> Log</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/log/syslog/index.html"><strong aria-hidden="true">3.21.1.</strong> Syslog</a></li><li class="chapter-item expanded "><a href="3. 库函数/log/Constants.html"><strong aria-hidden="true">3.21.2.</strong> Constants</a></li><li class="chapter-item expanded "><a href="3. 库函数/log/Fatal.html"><strong aria-hidden="true">3.21.3.</strong> Fatal</a></li><li class="chapter-item expanded "><a href="3. 库函数/log/Fatalf.html"><strong aria-hidden="true">3.21.4.</strong> Fatalf</a></li><li class="chapter-item expanded "><a href="3. 库函数/log/Fatalln.html"><strong aria-hidden="true">3.21.5.</strong> Fatalln</a></li><li class="chapter-item expanded "><a href="3. 库函数/log/Flags.html"><strong aria-hidden="true">3.21.6.</strong> Flags</a></li><li class="chapter-item expanded "><a href="3. 库函数/log/lFatal.html"><strong aria-hidden="true">3.21.7.</strong> L Fatal</a></li><li class="chapter-item expanded "><a href="3. 库函数/log/lFatalf.html"><strong aria-hidden="true">3.21.8.</strong> L Fatalf</a></li><li class="chapter-item expanded "><a href="3. 库函数/log/lFatalln.html"><strong aria-hidden="true">3.21.9.</strong> L Fatalln</a></li><li class="chapter-item expanded "><a href="3. 库函数/log/lFlags.html"><strong aria-hidden="true">3.21.10.</strong> L Flags</a></li><li class="chapter-item expanded "><a href="3. 库函数/log/lPanic.html"><strong aria-hidden="true">3.21.11.</strong> L Panic</a></li><li class="chapter-item expanded "><a href="3. 库函数/log/lPanicf.html"><strong aria-hidden="true">3.21.12.</strong> L Panicf</a></li><li class="chapter-item expanded "><a href="3. 库函数/log/lPanicln.html"><strong aria-hidden="true">3.21.13.</strong> L Panicln</a></li><li class="chapter-item expanded "><a href="3. 库函数/log/lPrefix.html"><strong aria-hidden="true">3.21.14.</strong> L Prefix</a></li><li class="chapter-item expanded "><a href="3. 库函数/log/lPrint.html"><strong aria-hidden="true">3.21.15.</strong> L Print</a></li><li class="chapter-item expanded "><a href="3. 库函数/log/lPrintf.html"><strong aria-hidden="true">3.21.16.</strong> L Printf</a></li><li class="chapter-item expanded "><a href="3. 库函数/log/lPrintln.html"><strong aria-hidden="true">3.21.17.</strong> L Println</a></li><li class="chapter-item expanded "><a href="3. 库函数/log/lSetFlags.html"><strong aria-hidden="true">3.21.18.</strong> L Set Flags</a></li><li class="chapter-item expanded "><a href="3. 库函数/log/lSetPrefix.html"><strong aria-hidden="true">3.21.19.</strong> L Set Prefix</a></li><li class="chapter-item expanded "><a href="3. 库函数/log/New.html"><strong aria-hidden="true">3.21.20.</strong> New</a></li><li class="chapter-item expanded "><a href="3. 库函数/log/Output.html"><strong aria-hidden="true">3.21.21.</strong> Output</a></li><li class="chapter-item expanded "><a href="3. 库函数/log/Panic.html"><strong aria-hidden="true">3.21.22.</strong> Panic</a></li><li class="chapter-item expanded "><a href="3. 库函数/log/Panicf.html"><strong aria-hidden="true">3.21.23.</strong> Panicf</a></li><li class="chapter-item expanded "><a href="3. 库函数/log/Panicln.html"><strong aria-hidden="true">3.21.24.</strong> Panicln</a></li><li class="chapter-item expanded "><a href="3. 库函数/log/Prefix.html"><strong aria-hidden="true">3.21.25.</strong> Prefix</a></li><li class="chapter-item expanded "><a href="3. 库函数/log/Print.html"><strong aria-hidden="true">3.21.26.</strong> Print</a></li><li class="chapter-item expanded "><a href="3. 库函数/log/Printf.html"><strong aria-hidden="true">3.21.27.</strong> Printf</a></li><li class="chapter-item expanded "><a href="3. 库函数/log/Println.html"><strong aria-hidden="true">3.21.28.</strong> Println</a></li><li class="chapter-item expanded "><a href="3. 库函数/log/SetFlags.html"><strong aria-hidden="true">3.21.29.</strong> Set Flags</a></li><li class="chapter-item expanded "><a href="3. 库函数/log/SetOutput.html"><strong aria-hidden="true">3.21.30.</strong> Set Output</a></li><li class="chapter-item expanded "><a href="3. 库函数/log/SetPrefix.html"><strong aria-hidden="true">3.21.31.</strong> Set Prefix</a></li></ol></li><li class="chapter-item expanded "><a href="3. 库函数/math/index.html"><strong aria-hidden="true">3.22.</strong> Math</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/math/big/index.html"><strong aria-hidden="true">3.22.1.</strong> Big</a></li><li class="chapter-item expanded "><a href="3. 库函数/math/cmplx/index.html"><strong aria-hidden="true">3.22.2.</strong> Cmplx</a></li><li class="chapter-item expanded "><a href="3. 库函数/math/rand/index.html"><strong aria-hidden="true">3.22.3.</strong> Rand</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/math/rand/ExpFloat64.html"><strong aria-hidden="true">3.22.3.1.</strong> Exp Float 64</a></li><li class="chapter-item expanded "><a href="3. 库函数/math/rand/Float32.html"><strong aria-hidden="true">3.22.3.2.</strong> Float 32</a></li><li class="chapter-item expanded "><a href="3. 库函数/math/rand/Float64.html"><strong aria-hidden="true">3.22.3.3.</strong> Float 64</a></li><li class="chapter-item expanded "><a href="3. 库函数/math/rand/Int.html"><strong aria-hidden="true">3.22.3.4.</strong> Int</a></li><li class="chapter-item expanded "><a href="3. 库函数/math/rand/Int31.html"><strong aria-hidden="true">3.22.3.5.</strong> Int 31</a></li><li class="chapter-item expanded "><a href="3. 库函数/math/rand/Int31n.html"><strong aria-hidden="true">3.22.3.6.</strong> Int 31 N</a></li><li class="chapter-item expanded "><a href="3. 库函数/math/rand/Int63.html"><strong aria-hidden="true">3.22.3.7.</strong> Int 63</a></li><li class="chapter-item expanded "><a href="3. 库函数/math/rand/Int63n.html"><strong aria-hidden="true">3.22.3.8.</strong> Int 63 N</a></li><li class="chapter-item expanded "><a href="3. 库函数/math/rand/Intn.html"><strong aria-hidden="true">3.22.3.9.</strong> Intn</a></li><li class="chapter-item expanded "><a href="3. 库函数/math/rand/New.html"><strong aria-hidden="true">3.22.3.10.</strong> New</a></li><li class="chapter-item expanded "><a href="3. 库函数/math/rand/NewSource.html"><strong aria-hidden="true">3.22.3.11.</strong> New Source</a></li><li class="chapter-item expanded "><a href="3. 库函数/math/rand/NewZipf.html"><strong aria-hidden="true">3.22.3.12.</strong> New Zipf</a></li><li class="chapter-item expanded "><a href="3. 库函数/math/rand/NormFloat64.html"><strong aria-hidden="true">3.22.3.13.</strong> Norm Float 64</a></li><li class="chapter-item expanded "><a href="3. 库函数/math/rand/Perm.html"><strong aria-hidden="true">3.22.3.14.</strong> Perm</a></li><li class="chapter-item expanded "><a href="3. 库函数/math/rand/Rand-ExpFloat64.html"><strong aria-hidden="true">3.22.3.15.</strong> Rand Exp Float 64</a></li><li class="chapter-item expanded "><a href="3. 库函数/math/rand/Rand-Float32.html"><strong aria-hidden="true">3.22.3.16.</strong> Rand Float 32</a></li><li class="chapter-item expanded "><a href="3. 库函数/math/rand/Rand-Float64.html"><strong aria-hidden="true">3.22.3.17.</strong> Rand Float 64</a></li><li class="chapter-item expanded "><a href="3. 库函数/math/rand/Rand-Int.html"><strong aria-hidden="true">3.22.3.18.</strong> Rand Int</a></li><li class="chapter-item expanded "><a href="3. 库函数/math/rand/Rand-Int31.html"><strong aria-hidden="true">3.22.3.19.</strong> Rand Int 31</a></li><li class="chapter-item expanded "><a href="3. 库函数/math/rand/Rand-Int31n.html"><strong aria-hidden="true">3.22.3.20.</strong> Rand Int 31 N</a></li><li class="chapter-item expanded "><a href="3. 库函数/math/rand/Rand-Int63.html"><strong aria-hidden="true">3.22.3.21.</strong> Rand Int 63</a></li><li class="chapter-item expanded "><a href="3. 库函数/math/rand/Rand-Int63n.html"><strong aria-hidden="true">3.22.3.22.</strong> Rand Int 63 N</a></li><li class="chapter-item expanded "><a href="3. 库函数/math/rand/Rand-Intn.html"><strong aria-hidden="true">3.22.3.23.</strong> Rand Intn</a></li><li class="chapter-item expanded "><a href="3. 库函数/math/rand/Rand-NormFloat64.html"><strong aria-hidden="true">3.22.3.24.</strong> Rand Norm Float 64</a></li><li class="chapter-item expanded "><a href="3. 库函数/math/rand/Rand-Perm.html"><strong aria-hidden="true">3.22.3.25.</strong> Rand Perm</a></li><li class="chapter-item expanded "><a href="3. 库函数/math/rand/Rand-Seed.html"><strong aria-hidden="true">3.22.3.26.</strong> Rand Seed</a></li><li class="chapter-item expanded "><a href="3. 库函数/math/rand/Rand-Uint32.html"><strong aria-hidden="true">3.22.3.27.</strong> Rand Uint 32</a></li><li class="chapter-item expanded "><a href="3. 库函数/math/rand/Rand.html"><strong aria-hidden="true">3.22.3.28.</strong> Rand</a></li><li class="chapter-item expanded "><a href="3. 库函数/math/rand/Seed.html"><strong aria-hidden="true">3.22.3.29.</strong> Seed</a></li><li class="chapter-item expanded "><a href="3. 库函数/math/rand/Source.html"><strong aria-hidden="true">3.22.3.30.</strong> Source</a></li><li class="chapter-item expanded "><a href="3. 库函数/math/rand/Uint32.html"><strong aria-hidden="true">3.22.3.31.</strong> Uint 32</a></li><li class="chapter-item expanded "><a href="3. 库函数/math/rand/Zipf-Uint64.html"><strong aria-hidden="true">3.22.3.32.</strong> Zipf Uint 64</a></li><li class="chapter-item expanded "><a href="3. 库函数/math/rand/Zipf.html"><strong aria-hidden="true">3.22.3.33.</strong> Zipf</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="3. 库函数/mime/index.html"><strong aria-hidden="true">3.23.</strong> Mime</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/mime/multipart/index.html"><strong aria-hidden="true">3.23.1.</strong> Multipart</a></li></ol></li><li class="chapter-item expanded "><a href="3. 库函数/net/index.html"><strong aria-hidden="true">3.24.</strong> Net</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/net/http/index.html"><strong aria-hidden="true">3.24.1.</strong> Http</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/net/http/cgi/index.html"><strong aria-hidden="true">3.24.1.1.</strong> Cgi</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/http/fcgi/index.html"><strong aria-hidden="true">3.24.1.2.</strong> Fcgi</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/http/httptest/index.html"><strong aria-hidden="true">3.24.1.3.</strong> Httptest</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/http/httputil/index.html"><strong aria-hidden="true">3.24.1.4.</strong> Httputil</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/http/pprof/index.html"><strong aria-hidden="true">3.24.1.5.</strong> Pprof</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/http/CanonicalHeaderKey.html"><strong aria-hidden="true">3.24.1.6.</strong> Canonical Header Key</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/http/DetectContentType.html"><strong aria-hidden="true">3.24.1.7.</strong> Detect Content Type</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/http/Error.html"><strong aria-hidden="true">3.24.1.8.</strong> Error</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/http/Handle.html"><strong aria-hidden="true">3.24.1.9.</strong> Handle</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/http/ListenAndServe.html"><strong aria-hidden="true">3.24.1.10.</strong> Listen And Serve</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/http/ListenAndServeTLS.html"><strong aria-hidden="true">3.24.1.11.</strong> Listen And Serve TLS</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/http/MaxBytesReader.html"><strong aria-hidden="true">3.24.1.12.</strong> Max Bytes Reader</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/http/NotFound.html"><strong aria-hidden="true">3.24.1.13.</strong> Not Found</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/http/ParseHTTPVersion.html"><strong aria-hidden="true">3.24.1.14.</strong> Parse HTTP Version</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/http/ProxyFromEnvironment.html"><strong aria-hidden="true">3.24.1.15.</strong> Proxy From Environment</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/http/ProxyURL.html"><strong aria-hidden="true">3.24.1.16.</strong> Proxy URL</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/http/Redirect.html"><strong aria-hidden="true">3.24.1.17.</strong> Redirect</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/http/Serve.html"><strong aria-hidden="true">3.24.1.18.</strong> Serve</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/http/ServeContent.html"><strong aria-hidden="true">3.24.1.19.</strong> Serve Content</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/http/ServeFile.html"><strong aria-hidden="true">3.24.1.20.</strong> Serve File</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/http/SetCookie.html"><strong aria-hidden="true">3.24.1.21.</strong> Set Cookie</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/http/StatusText.html"><strong aria-hidden="true">3.24.1.22.</strong> Status Text</a></li></ol></li><li class="chapter-item expanded "><a href="3. 库函数/net/mail/index.html"><strong aria-hidden="true">3.24.2.</strong> Mail</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/net/mail/Address.html"><strong aria-hidden="true">3.24.2.1.</strong> Address</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/mail/Header.html"><strong aria-hidden="true">3.24.2.2.</strong> Header</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/mail/Message.html"><strong aria-hidden="true">3.24.2.3.</strong> Message</a></li></ol></li><li class="chapter-item expanded "><a href="3. 库函数/net/rpc/index.html"><strong aria-hidden="true">3.24.3.</strong> Rpc</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/net/rpc/jsonrpc/index.html"><strong aria-hidden="true">3.24.3.1.</strong> Jsonrpc</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/rpc/Accept.html"><strong aria-hidden="true">3.24.3.2.</strong> Accept</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/rpc/Client_Call.html"><strong aria-hidden="true">3.24.3.3.</strong> Client Call</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/rpc/Client_Go.html"><strong aria-hidden="true">3.24.3.4.</strong> Client Go</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/rpc/Dial.html"><strong aria-hidden="true">3.24.3.5.</strong> Dial</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/rpc/DialHTTP.html"><strong aria-hidden="true">3.24.3.6.</strong> Dial HTTP</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/rpc/DialHTTPPath.html"><strong aria-hidden="true">3.24.3.7.</strong> Dial HTTP Path</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/rpc/HandleHTTP.html"><strong aria-hidden="true">3.24.3.8.</strong> Handle HTTP</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/rpc/NewClient.html"><strong aria-hidden="true">3.24.3.9.</strong> New Client</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/rpc/NewClientWithCodec.html"><strong aria-hidden="true">3.24.3.10.</strong> New Client With Codec</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/rpc/NewServer.html"><strong aria-hidden="true">3.24.3.11.</strong> New Server</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/rpc/Register.html"><strong aria-hidden="true">3.24.3.12.</strong> Register</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/rpc/RegisterName.html"><strong aria-hidden="true">3.24.3.13.</strong> Register Name</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/rpc/Serve_Accept.html"><strong aria-hidden="true">3.24.3.14.</strong> Serve Accept</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/rpc/Serve_HandleHTTP.html"><strong aria-hidden="true">3.24.3.15.</strong> Serve Handle HTTP</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/rpc/Serve_Register.html"><strong aria-hidden="true">3.24.3.16.</strong> Serve Register</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/rpc/Serve_RegisterName.html"><strong aria-hidden="true">3.24.3.17.</strong> Serve Register Name</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/rpc/Serve_ServeCodec.html"><strong aria-hidden="true">3.24.3.18.</strong> Serve Serve Codec</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/rpc/Serve_ServeConn.html"><strong aria-hidden="true">3.24.3.19.</strong> Serve Serve Conn</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/rpc/Serve_ServeHTTP.html"><strong aria-hidden="true">3.24.3.20.</strong> Serve Serve HTTP</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/rpc/Serve_ServeRequest.html"><strong aria-hidden="true">3.24.3.21.</strong> Serve Serve Request</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/rpc/ServeCodec.html"><strong aria-hidden="true">3.24.3.22.</strong> Serve Codec</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/rpc/ServeConn.html"><strong aria-hidden="true">3.24.3.23.</strong> Serve Conn</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/rpc/Server_Accept.html"><strong aria-hidden="true">3.24.3.24.</strong> Server Accept</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/rpc/Server_HandleHTTP.html"><strong aria-hidden="true">3.24.3.25.</strong> Server Handle HTTP</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/rpc/Server_Register.html"><strong aria-hidden="true">3.24.3.26.</strong> Server Register</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/rpc/Server_RegisterName.html"><strong aria-hidden="true">3.24.3.27.</strong> Server Register Name</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/rpc/Server_ServeCodec.html"><strong aria-hidden="true">3.24.3.28.</strong> Server Serve Codec</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/rpc/Server_ServeConn.html"><strong aria-hidden="true">3.24.3.29.</strong> Server Serve Conn</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/rpc/Server_ServeHTTP.html"><strong aria-hidden="true">3.24.3.30.</strong> Server Serve HTTP</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/rpc/Server_ServeRequest.html"><strong aria-hidden="true">3.24.3.31.</strong> Server Serve Request</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/rpc/ServeRequest.html"><strong aria-hidden="true">3.24.3.32.</strong> Serve Request</a></li></ol></li><li class="chapter-item expanded "><a href="3. 库函数/net/smtp/index.html"><strong aria-hidden="true">3.24.4.</strong> Smtp</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/net/smtp/Auth.html"><strong aria-hidden="true">3.24.4.1.</strong> Auth</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/smtp/Client.html"><strong aria-hidden="true">3.24.4.2.</strong> Client</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/smtp/SendMail.html"><strong aria-hidden="true">3.24.4.3.</strong> Send Mail</a></li></ol></li><li class="chapter-item expanded "><a href="3. 库函数/net/textproto/index.html"><strong aria-hidden="true">3.24.5.</strong> Textproto</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/url/index.html"><strong aria-hidden="true">3.24.6.</strong> Url</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/net/url/ParseQuery.html"><strong aria-hidden="true">3.24.6.1.</strong> Parse Query</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/url/QueryEscape.html"><strong aria-hidden="true">3.24.6.2.</strong> Query Escape</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/url/QueryUnescape.html"><strong aria-hidden="true">3.24.6.3.</strong> Query Unescape</a></li></ol></li><li class="chapter-item expanded "><a href="3. 库函数/net/Addr.html"><strong aria-hidden="true">3.24.7.</strong> Addr</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/AddrError.html"><strong aria-hidden="true">3.24.8.</strong> Addr Error</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/CIDRMask.html"><strong aria-hidden="true">3.24.9.</strong> CIDR Mask</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/Conn.html"><strong aria-hidden="true">3.24.10.</strong> Conn</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/Dial.html"><strong aria-hidden="true">3.24.11.</strong> Dial</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/DialIP.html"><strong aria-hidden="true">3.24.12.</strong> Dial IP</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/DialTimeout.html"><strong aria-hidden="true">3.24.13.</strong> Dial Timeout</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/DNSConfigError.html"><strong aria-hidden="true">3.24.14.</strong> DNS Config Error</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/DNSError.html"><strong aria-hidden="true">3.24.15.</strong> DNS Error</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/Error.html"><strong aria-hidden="true">3.24.16.</strong> Error</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/FileListener.html"><strong aria-hidden="true">3.24.17.</strong> File Listener</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/Flags.html"><strong aria-hidden="true">3.24.18.</strong> Flags</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/HardwareAddr.html"><strong aria-hidden="true">3.24.19.</strong> Hardware Addr</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/Interface.html"><strong aria-hidden="true">3.24.20.</strong> Interface</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/InterfaceAddrs.html"><strong aria-hidden="true">3.24.21.</strong> Interface Addrs</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/InterfaceByIndex.html"><strong aria-hidden="true">3.24.22.</strong> Interface By Index</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/InterfaceByName.html"><strong aria-hidden="true">3.24.23.</strong> Interface By Name</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/Interfaces.html"><strong aria-hidden="true">3.24.24.</strong> Interfaces</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/InvalidAddrError.html"><strong aria-hidden="true">3.24.25.</strong> Invalid Addr Error</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/IP.html"><strong aria-hidden="true">3.24.26.</strong> IP</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/IPAddr.html"><strong aria-hidden="true">3.24.27.</strong> IP Addr</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/IPConn.html"><strong aria-hidden="true">3.24.28.</strong> IP Conn</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/IPMask.html"><strong aria-hidden="true">3.24.29.</strong> IP Mask</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/IPNet.html"><strong aria-hidden="true">3.24.30.</strong> IP Net</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/IPv4.html"><strong aria-hidden="true">3.24.31.</strong> I Pv 4</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/IPv4Mask.html"><strong aria-hidden="true">3.24.32.</strong> I Pv 4 Mask</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/JoinHostPort.html"><strong aria-hidden="true">3.24.33.</strong> Join Host Port</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/Listen.html"><strong aria-hidden="true">3.24.34.</strong> Listen</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/Listener.html"><strong aria-hidden="true">3.24.35.</strong> Listener</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/ListenIP.html"><strong aria-hidden="true">3.24.36.</strong> Listen IP</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/LookupAddr.html"><strong aria-hidden="true">3.24.37.</strong> Lookup Addr</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/LookupCNAME.html"><strong aria-hidden="true">3.24.38.</strong> Lookup CNAME</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/LookupHost.html"><strong aria-hidden="true">3.24.39.</strong> Lookup Host</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/LookupIP.html"><strong aria-hidden="true">3.24.40.</strong> Lookup IP</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/LookupMX.html"><strong aria-hidden="true">3.24.41.</strong> Lookup MX</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/LookupPort.html"><strong aria-hidden="true">3.24.42.</strong> Lookup Port</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/LookupSRV.html"><strong aria-hidden="true">3.24.43.</strong> Lookup SRV</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/LookupTXT.html"><strong aria-hidden="true">3.24.44.</strong> Lookup TXT</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/MX.html"><strong aria-hidden="true">3.24.45.</strong> MX</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/OpError.html"><strong aria-hidden="true">3.24.46.</strong> Op Error</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/ParseCIDR.html"><strong aria-hidden="true">3.24.47.</strong> Parse CIDR</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/ParseIP.html"><strong aria-hidden="true">3.24.48.</strong> Parse IP</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/ParseMAC.html"><strong aria-hidden="true">3.24.49.</strong> Parse MAC</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/Pipe.html"><strong aria-hidden="true">3.24.50.</strong> Pipe</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/ResolveIPAddr.html"><strong aria-hidden="true">3.24.51.</strong> Resolve IP Addr</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/SplitHostPort.html"><strong aria-hidden="true">3.24.52.</strong> Split Host Port</a></li><li class="chapter-item expanded "><a href="3. 库函数/net/UDPAddr.html"><strong aria-hidden="true">3.24.53.</strong> UDP Addr</a></li></ol></li><li class="chapter-item expanded "><a href="3. 库函数/os/index.html"><strong aria-hidden="true">3.25.</strong> Os</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/os/exec/index.html"><strong aria-hidden="true">3.25.1.</strong> Exec</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/os/exec/CombinedOutput.html"><strong aria-hidden="true">3.25.1.1.</strong> Combined Output</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/exec/Command.html"><strong aria-hidden="true">3.25.1.2.</strong> Command</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/exec/Error.html"><strong aria-hidden="true">3.25.1.3.</strong> Error</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/exec/ExitError.html"><strong aria-hidden="true">3.25.1.4.</strong> Exit Error</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/exec/LookPath.html"><strong aria-hidden="true">3.25.1.5.</strong> Look Path</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/exec/Output.html"><strong aria-hidden="true">3.25.1.6.</strong> Output</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/exec/Run.html"><strong aria-hidden="true">3.25.1.7.</strong> Run</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/exec/Start.html"><strong aria-hidden="true">3.25.1.8.</strong> Start</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/exec/StderrPipe.html"><strong aria-hidden="true">3.25.1.9.</strong> Stderr Pipe</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/exec/StdinPipe.html"><strong aria-hidden="true">3.25.1.10.</strong> Stdin Pipe</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/exec/StdoutPipe.html"><strong aria-hidden="true">3.25.1.11.</strong> Stdout Pipe</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/exec/Wait.html"><strong aria-hidden="true">3.25.1.12.</strong> Wait</a></li></ol></li><li class="chapter-item expanded "><a href="3. 库函数/os/signal/index.html"><strong aria-hidden="true">3.25.2.</strong> Signal</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/os/signal/Notify.html"><strong aria-hidden="true">3.25.2.1.</strong> Notify</a></li></ol></li><li class="chapter-item expanded "><a href="3. 库函数/os/user/index.html"><strong aria-hidden="true">3.25.3.</strong> User</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/os/user/Current.html"><strong aria-hidden="true">3.25.3.1.</strong> Current</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/user/Lookup.html"><strong aria-hidden="true">3.25.3.2.</strong> Lookup</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/user/LookupId.html"><strong aria-hidden="true">3.25.3.3.</strong> Lookup Id</a></li></ol></li><li class="chapter-item expanded "><a href="3. 库函数/os/Chdir.html"><strong aria-hidden="true">3.25.4.</strong> Chdir</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/Chmod.html"><strong aria-hidden="true">3.25.5.</strong> Chmod</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/Chown.html"><strong aria-hidden="true">3.25.6.</strong> Chown</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/Chtimes.html"><strong aria-hidden="true">3.25.7.</strong> Chtimes</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/Clearenv.html"><strong aria-hidden="true">3.25.8.</strong> Clearenv</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/Environ.html"><strong aria-hidden="true">3.25.9.</strong> Environ</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/Exit.html"><strong aria-hidden="true">3.25.10.</strong> Exit</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/Expand.html"><strong aria-hidden="true">3.25.11.</strong> Expand</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/ExpandEnv.html"><strong aria-hidden="true">3.25.12.</strong> Expand Env</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/File_Chdir.html"><strong aria-hidden="true">3.25.13.</strong> File Chdir</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/File_Chmod.html"><strong aria-hidden="true">3.25.14.</strong> File Chmod</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/File_Chown.html"><strong aria-hidden="true">3.25.15.</strong> File Chown</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/File_Close.html"><strong aria-hidden="true">3.25.16.</strong> File Close</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/File_Create.html"><strong aria-hidden="true">3.25.17.</strong> File Create</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/File_Fd.html"><strong aria-hidden="true">3.25.18.</strong> File Fd</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/File_Name.html"><strong aria-hidden="true">3.25.19.</strong> File Name</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/File_NewFile.html"><strong aria-hidden="true">3.25.20.</strong> File New File</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/File_Open.html"><strong aria-hidden="true">3.25.21.</strong> File Open</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/File_OpenFile.html"><strong aria-hidden="true">3.25.22.</strong> File Open File</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/File_Pipe.html"><strong aria-hidden="true">3.25.23.</strong> File Pipe</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/File_Read.html"><strong aria-hidden="true">3.25.24.</strong> File Read</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/File_ReadAt.html"><strong aria-hidden="true">3.25.25.</strong> File Read At</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/File_Readdir.html"><strong aria-hidden="true">3.25.26.</strong> File Readdir</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/File_Seek.html"><strong aria-hidden="true">3.25.27.</strong> File Seek</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/File_Stat.html"><strong aria-hidden="true">3.25.28.</strong> File Stat</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/File_Sync.html"><strong aria-hidden="true">3.25.29.</strong> File Sync</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/File_Truncate.html"><strong aria-hidden="true">3.25.30.</strong> File Truncate</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/File_Write.html"><strong aria-hidden="true">3.25.31.</strong> File Write</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/File_WriteAt.html"><strong aria-hidden="true">3.25.32.</strong> File Write At</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/File_WriteString.html"><strong aria-hidden="true">3.25.33.</strong> File Write String</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/FileInfo_Lstat.html"><strong aria-hidden="true">3.25.34.</strong> File Info Lstat</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/FileInfo_Stat.html"><strong aria-hidden="true">3.25.35.</strong> File Info Stat</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/FileMode_IsDir.html"><strong aria-hidden="true">3.25.36.</strong> File Mode Is Dir</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/FileMode_Perm.html"><strong aria-hidden="true">3.25.37.</strong> File Mode Perm</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/FileMode_String.html"><strong aria-hidden="true">3.25.38.</strong> File Mode String</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/Getegid.html"><strong aria-hidden="true">3.25.39.</strong> Getegid</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/Getenv.html"><strong aria-hidden="true">3.25.40.</strong> Getenv</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/Geteuid.html"><strong aria-hidden="true">3.25.41.</strong> Geteuid</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/Getgid.html"><strong aria-hidden="true">3.25.42.</strong> Getgid</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/Getgroups.html"><strong aria-hidden="true">3.25.43.</strong> Getgroups</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/Getpagesize.html"><strong aria-hidden="true">3.25.44.</strong> Getpagesize</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/Getpid.html"><strong aria-hidden="true">3.25.45.</strong> Getpid</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/Getppid.html"><strong aria-hidden="true">3.25.46.</strong> Getppid</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/Getuid.html"><strong aria-hidden="true">3.25.47.</strong> Getuid</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/Getwd.html"><strong aria-hidden="true">3.25.48.</strong> Getwd</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/Hostname.html"><strong aria-hidden="true">3.25.49.</strong> Hostname</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/IsExist.html"><strong aria-hidden="true">3.25.50.</strong> Is Exist</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/IsNotExist.html"><strong aria-hidden="true">3.25.51.</strong> Is Not Exist</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/IsPathSeparator.html"><strong aria-hidden="true">3.25.52.</strong> Is Path Separator</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/IsPermission.html"><strong aria-hidden="true">3.25.53.</strong> Is Permission</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/Lchown.html"><strong aria-hidden="true">3.25.54.</strong> Lchown</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/Link.html"><strong aria-hidden="true">3.25.55.</strong> Link</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/LinkError_Error.html"><strong aria-hidden="true">3.25.56.</strong> Link Error Error</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/Mkdir.html"><strong aria-hidden="true">3.25.57.</strong> Mkdir</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/MkdirAll.html"><strong aria-hidden="true">3.25.58.</strong> Mkdir All</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/NewSyscallError.html"><strong aria-hidden="true">3.25.59.</strong> New Syscall Error</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/PathError_Error.html"><strong aria-hidden="true">3.25.60.</strong> Path Error Error</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/Process_FindProcess.html"><strong aria-hidden="true">3.25.61.</strong> Process Find Process</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/Process_kill.html"><strong aria-hidden="true">3.25.62.</strong> Process Kill</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/Process_Release.html"><strong aria-hidden="true">3.25.63.</strong> Process Release</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/Process_Signal.html"><strong aria-hidden="true">3.25.64.</strong> Process Signal</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/Process_StartProcess.html"><strong aria-hidden="true">3.25.65.</strong> Process Start Process</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/Process_Wait.html"><strong aria-hidden="true">3.25.66.</strong> Process Wait</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/ProcessState_Exited.html"><strong aria-hidden="true">3.25.67.</strong> Process State Exited</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/ProcessState_Pid.html"><strong aria-hidden="true">3.25.68.</strong> Process State Pid</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/ProcessState_String.html"><strong aria-hidden="true">3.25.69.</strong> Process State String</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/ProcessState_Success.html"><strong aria-hidden="true">3.25.70.</strong> Process State Success</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/ProcessState_Sys.html"><strong aria-hidden="true">3.25.71.</strong> Process State Sys</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/ProcessState_SystemTime.html"><strong aria-hidden="true">3.25.72.</strong> Process State System Time</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/ProcessState_SysUsage.html"><strong aria-hidden="true">3.25.73.</strong> Process State Sys Usage</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/ProcessState_UserTime.html"><strong aria-hidden="true">3.25.74.</strong> Process State User Time</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/Readlink.html"><strong aria-hidden="true">3.25.75.</strong> Readlink</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/Remove.html"><strong aria-hidden="true">3.25.76.</strong> Remove</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/RemoveAll.html"><strong aria-hidden="true">3.25.77.</strong> Remove All</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/Rename.html"><strong aria-hidden="true">3.25.78.</strong> Rename</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/SameFile.html"><strong aria-hidden="true">3.25.79.</strong> Same File</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/Setenv.html"><strong aria-hidden="true">3.25.80.</strong> Setenv</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/Symlink.html"><strong aria-hidden="true">3.25.81.</strong> Symlink</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/SyscallError_Error.html"><strong aria-hidden="true">3.25.82.</strong> Syscall Error Error</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/TempDir.html"><strong aria-hidden="true">3.25.83.</strong> Temp Dir</a></li><li class="chapter-item expanded "><a href="3. 库函数/os/Truncate.html"><strong aria-hidden="true">3.25.84.</strong> Truncate</a></li></ol></li><li class="chapter-item expanded "><a href="3. 库函数/path/index.html"><strong aria-hidden="true">3.26.</strong> Path</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/path/filepath/index.html"><strong aria-hidden="true">3.26.1.</strong> Filepath</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/path/filepath/Abs.html"><strong aria-hidden="true">3.26.1.1.</strong> Abs</a></li><li class="chapter-item expanded "><a href="3. 库函数/path/filepath/Base.html"><strong aria-hidden="true">3.26.1.2.</strong> Base</a></li><li class="chapter-item expanded "><a href="3. 库函数/path/filepath/Clean.html"><strong aria-hidden="true">3.26.1.3.</strong> Clean</a></li><li class="chapter-item expanded "><a href="3. 库函数/path/filepath/Dir.html"><strong aria-hidden="true">3.26.1.4.</strong> Dir</a></li><li class="chapter-item expanded "><a href="3. 库函数/path/filepath/EvalSymlinks.html"><strong aria-hidden="true">3.26.1.5.</strong> Eval Symlinks</a></li><li class="chapter-item expanded "><a href="3. 库函数/path/filepath/Ext.html"><strong aria-hidden="true">3.26.1.6.</strong> Ext</a></li><li class="chapter-item expanded "><a href="3. 库函数/path/filepath/FromSlash.html"><strong aria-hidden="true">3.26.1.7.</strong> From Slash</a></li><li class="chapter-item expanded "><a href="3. 库函数/path/filepath/Glob.html"><strong aria-hidden="true">3.26.1.8.</strong> Glob</a></li><li class="chapter-item expanded "><a href="3. 库函数/path/filepath/HasPrefix.html"><strong aria-hidden="true">3.26.1.9.</strong> Has Prefix</a></li><li class="chapter-item expanded "><a href="3. 库函数/path/filepath/IsAbs.html"><strong aria-hidden="true">3.26.1.10.</strong> Is Abs</a></li><li class="chapter-item expanded "><a href="3. 库函数/path/filepath/Join.html"><strong aria-hidden="true">3.26.1.11.</strong> Join</a></li><li class="chapter-item expanded "><a href="3. 库函数/path/filepath/Match.html"><strong aria-hidden="true">3.26.1.12.</strong> Match</a></li><li class="chapter-item expanded "><a href="3. 库函数/path/filepath/Rel.html"><strong aria-hidden="true">3.26.1.13.</strong> Rel</a></li><li class="chapter-item expanded "><a href="3. 库函数/path/filepath/Split.html"><strong aria-hidden="true">3.26.1.14.</strong> Split</a></li><li class="chapter-item expanded "><a href="3. 库函数/path/filepath/SplitList.html"><strong aria-hidden="true">3.26.1.15.</strong> Split List</a></li><li class="chapter-item expanded "><a href="3. 库函数/path/filepath/ToSlash.html"><strong aria-hidden="true">3.26.1.16.</strong> To Slash</a></li><li class="chapter-item expanded "><a href="3. 库函数/path/filepath/VolumeName.html"><strong aria-hidden="true">3.26.1.17.</strong> Volume Name</a></li><li class="chapter-item expanded "><a href="3. 库函数/path/filepath/Walk.html"><strong aria-hidden="true">3.26.1.18.</strong> Walk</a></li></ol></li><li class="chapter-item expanded "><a href="3. 库函数/path/Base.html"><strong aria-hidden="true">3.26.2.</strong> Base</a></li><li class="chapter-item expanded "><a href="3. 库函数/path/Clean.html"><strong aria-hidden="true">3.26.3.</strong> Clean</a></li><li class="chapter-item expanded "><a href="3. 库函数/path/Dir.html"><strong aria-hidden="true">3.26.4.</strong> Dir</a></li><li class="chapter-item expanded "><a href="3. 库函数/path/Ext.html"><strong aria-hidden="true">3.26.5.</strong> Ext</a></li><li class="chapter-item expanded "><a href="3. 库函数/path/IsAbs.html"><strong aria-hidden="true">3.26.6.</strong> Is Abs</a></li><li class="chapter-item expanded "><a href="3. 库函数/path/Join.html"><strong aria-hidden="true">3.26.7.</strong> Join</a></li><li class="chapter-item expanded "><a href="3. 库函数/path/Match.html"><strong aria-hidden="true">3.26.8.</strong> Match</a></li><li class="chapter-item expanded "><a href="3. 库函数/path/Split.html"><strong aria-hidden="true">3.26.9.</strong> Split</a></li></ol></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/index.html"><strong aria-hidden="true">3.27.</strong> Reflect</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/reflect/Append.html"><strong aria-hidden="true">3.27.1.</strong> Append</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/AppendSlice.html"><strong aria-hidden="true">3.27.2.</strong> Append Slice</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/ChanDir.html"><strong aria-hidden="true">3.27.3.</strong> Chan Dir</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/ChanOf.html"><strong aria-hidden="true">3.27.4.</strong> Chan Of</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Copy.html"><strong aria-hidden="true">3.27.5.</strong> Copy</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/DeepEqual.html"><strong aria-hidden="true">3.27.6.</strong> Deep Equal</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Indirect.html"><strong aria-hidden="true">3.27.7.</strong> Indirect</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Kind.html"><strong aria-hidden="true">3.27.8.</strong> Kind</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/MakeChan.html"><strong aria-hidden="true">3.27.9.</strong> Make Chan</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/MakeFunc.html"><strong aria-hidden="true">3.27.10.</strong> Make Func</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/MakeMap.html"><strong aria-hidden="true">3.27.11.</strong> Make Map</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/MakeSlice.html"><strong aria-hidden="true">3.27.12.</strong> Make Slice</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/MapOf.html"><strong aria-hidden="true">3.27.13.</strong> Map Of</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Method.html"><strong aria-hidden="true">3.27.14.</strong> Method</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/New.html"><strong aria-hidden="true">3.27.15.</strong> New</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/NewAt.html"><strong aria-hidden="true">3.27.16.</strong> New At</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/PtrTo.html"><strong aria-hidden="true">3.27.17.</strong> Ptr To</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Select.html"><strong aria-hidden="true">3.27.18.</strong> Select</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/SelectCase.html"><strong aria-hidden="true">3.27.19.</strong> Select Case</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/SelectDir.html"><strong aria-hidden="true">3.27.20.</strong> Select Dir</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/SliceHeader.html"><strong aria-hidden="true">3.27.21.</strong> Slice Header</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/SliceOf.html"><strong aria-hidden="true">3.27.22.</strong> Slice Of</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/StringHeader.html"><strong aria-hidden="true">3.27.23.</strong> String Header</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/StructField.html"><strong aria-hidden="true">3.27.24.</strong> Struct Field</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Type.Align.html"><strong aria-hidden="true">3.27.25.</strong> Type.Align</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Type.AssignableTo.html"><strong aria-hidden="true">3.27.26.</strong> Type.AssignableTo</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Type.Bits.html"><strong aria-hidden="true">3.27.27.</strong> Type.Bits</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Type.ChanDir.html"><strong aria-hidden="true">3.27.28.</strong> Type.ChanDir</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Type.ConvertibleTo.html"><strong aria-hidden="true">3.27.29.</strong> Type.ConvertibleTo</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Type.Elem.html"><strong aria-hidden="true">3.27.30.</strong> Type.Elem</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Type.Field.html"><strong aria-hidden="true">3.27.31.</strong> Type.Field</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Type.FieldAlign.html"><strong aria-hidden="true">3.27.32.</strong> Type.FieldAlign</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Type.FieldByIndex.html"><strong aria-hidden="true">3.27.33.</strong> Type.FieldByIndex</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Type.FieldByName.html"><strong aria-hidden="true">3.27.34.</strong> Type.FieldByName</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Type.FieldByNameFunc.html"><strong aria-hidden="true">3.27.35.</strong> Type.FieldByNameFunc</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Type.Implements.html"><strong aria-hidden="true">3.27.36.</strong> Type.Implements</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Type.In.html"><strong aria-hidden="true">3.27.37.</strong> Type.In</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Type.IsVariadic.html"><strong aria-hidden="true">3.27.38.</strong> Type.IsVariadic</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Type.Key.html"><strong aria-hidden="true">3.27.39.</strong> Type.Key</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Type.Kind.html"><strong aria-hidden="true">3.27.40.</strong> Type.Kind</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Type.Len.html"><strong aria-hidden="true">3.27.41.</strong> Type.Len</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Type.html"><strong aria-hidden="true">3.27.42.</strong> Type</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Type.Method.html"><strong aria-hidden="true">3.27.43.</strong> Type.Method</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Type.MethodByName.html"><strong aria-hidden="true">3.27.44.</strong> Type.MethodByName</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Type.Name.html"><strong aria-hidden="true">3.27.45.</strong> Type.Name</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Type.NumField.html"><strong aria-hidden="true">3.27.46.</strong> Type.NumField</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Type.NumIn.html"><strong aria-hidden="true">3.27.47.</strong> Type.NumIn</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Type.NumMethod.html"><strong aria-hidden="true">3.27.48.</strong> Type.NumMethod</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Type.NumOut.html"><strong aria-hidden="true">3.27.49.</strong> Type.NumOut</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Type.Out.html"><strong aria-hidden="true">3.27.50.</strong> Type.Out</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Type.PkgPath.html"><strong aria-hidden="true">3.27.51.</strong> Type.PkgPath</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Type.Size.html"><strong aria-hidden="true">3.27.52.</strong> Type.Size</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Type.String.html"><strong aria-hidden="true">3.27.53.</strong> Type.String</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/TypeOf.html"><strong aria-hidden="true">3.27.54.</strong> Type Of</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Value.Addr.html"><strong aria-hidden="true">3.27.55.</strong> Value.Addr</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Value.Bool.html"><strong aria-hidden="true">3.27.56.</strong> Value.Bool</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Value.Bytes.html"><strong aria-hidden="true">3.27.57.</strong> Value.Bytes</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Value.Call.html"><strong aria-hidden="true">3.27.58.</strong> Value.Call</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Value.CallSlice.html"><strong aria-hidden="true">3.27.59.</strong> Value.CallSlice</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Value.CanAddr.html"><strong aria-hidden="true">3.27.60.</strong> Value.CanAddr</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Value.CanInterface.html"><strong aria-hidden="true">3.27.61.</strong> Value.CanInterface</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Value.CanSet.html"><strong aria-hidden="true">3.27.62.</strong> Value.CanSet</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Value.Cap.html"><strong aria-hidden="true">3.27.63.</strong> Value.Cap</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Value.Close.html"><strong aria-hidden="true">3.27.64.</strong> Value.Close</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Value.Complex.html"><strong aria-hidden="true">3.27.65.</strong> Value.Complex</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Value.Convert.html"><strong aria-hidden="true">3.27.66.</strong> Value.Convert</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Value.Elem.html"><strong aria-hidden="true">3.27.67.</strong> Value.Elem</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Value.Field.html"><strong aria-hidden="true">3.27.68.</strong> Value.Field</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Value.FieldByIndex.html"><strong aria-hidden="true">3.27.69.</strong> Value.FieldByIndex</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Value.FieldByName.html"><strong aria-hidden="true">3.27.70.</strong> Value.FieldByName</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Value.FieldByNameFunc.html"><strong aria-hidden="true">3.27.71.</strong> Value.FieldByNameFunc</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Value.Float.html"><strong aria-hidden="true">3.27.72.</strong> Value.Float</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Value.Index.html"><strong aria-hidden="true">3.27.73.</strong> Value.Index</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Value.Int.html"><strong aria-hidden="true">3.27.74.</strong> Value.Int</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Value.Interface.html"><strong aria-hidden="true">3.27.75.</strong> Value.Interface</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Value.InterfaceData.html"><strong aria-hidden="true">3.27.76.</strong> Value.InterfaceData</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Value.IsNil.html"><strong aria-hidden="true">3.27.77.</strong> Value.IsNil</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Value.IsValid.html"><strong aria-hidden="true">3.27.78.</strong> Value.IsValid</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Value.Kind.html"><strong aria-hidden="true">3.27.79.</strong> Value.Kind</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Value.Len.html"><strong aria-hidden="true">3.27.80.</strong> Value.Len</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Value.MapIndex.html"><strong aria-hidden="true">3.27.81.</strong> Value.MapIndex</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Value.MapKeys.html"><strong aria-hidden="true">3.27.82.</strong> Value.MapKeys</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Value.html"><strong aria-hidden="true">3.27.83.</strong> Value</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Value.Method.html"><strong aria-hidden="true">3.27.84.</strong> Value.Method</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Value.MethodByName.html"><strong aria-hidden="true">3.27.85.</strong> Value.MethodByName</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Value.NumField.html"><strong aria-hidden="true">3.27.86.</strong> Value.NumField</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Value.NumMethod.html"><strong aria-hidden="true">3.27.87.</strong> Value.NumMethod</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Value.OverflowComplex.html"><strong aria-hidden="true">3.27.88.</strong> Value.OverflowComplex</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Value.OverflowFloat.html"><strong aria-hidden="true">3.27.89.</strong> Value.OverflowFloat</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Value.OverflowInt.html"><strong aria-hidden="true">3.27.90.</strong> Value.OverflowInt</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Value.OverflowUint.html"><strong aria-hidden="true">3.27.91.</strong> Value.OverflowUint</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Value.Pointer.html"><strong aria-hidden="true">3.27.92.</strong> Value.Pointer</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Value.Recv.html"><strong aria-hidden="true">3.27.93.</strong> Value.Recv</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Value.Send.html"><strong aria-hidden="true">3.27.94.</strong> Value.Send</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Value.Set.html"><strong aria-hidden="true">3.27.95.</strong> Value.Set</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Value.SetBool.html"><strong aria-hidden="true">3.27.96.</strong> Value.SetBool</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Value.SetBytes.html"><strong aria-hidden="true">3.27.97.</strong> Value.SetBytes</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Value.SetComplex.html"><strong aria-hidden="true">3.27.98.</strong> Value.SetComplex</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Value.SetFloat.html"><strong aria-hidden="true">3.27.99.</strong> Value.SetFloat</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Value.SetInt.html"><strong aria-hidden="true">3.27.100.</strong> Value.SetInt</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Value.SetLen.html"><strong aria-hidden="true">3.27.101.</strong> Value.SetLen</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Value.SetMapIndex.html"><strong aria-hidden="true">3.27.102.</strong> Value.SetMapIndex</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Value.SetPointer.html"><strong aria-hidden="true">3.27.103.</strong> Value.SetPointer</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Value.SetString.html"><strong aria-hidden="true">3.27.104.</strong> Value.SetString</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Value.SetUint.html"><strong aria-hidden="true">3.27.105.</strong> Value.SetUint</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Value.Slice.html"><strong aria-hidden="true">3.27.106.</strong> Value.Slice</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Value.String.html"><strong aria-hidden="true">3.27.107.</strong> Value.String</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Value.TryRecv.html"><strong aria-hidden="true">3.27.108.</strong> Value.TryRecv</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Value.TrySend.html"><strong aria-hidden="true">3.27.109.</strong> Value.TrySend</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Value.Type.html"><strong aria-hidden="true">3.27.110.</strong> Value.Type</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Value.Uint.html"><strong aria-hidden="true">3.27.111.</strong> Value.Uint</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Value.UnsafeAddr.html"><strong aria-hidden="true">3.27.112.</strong> Value.UnsafeAddr</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/ValueOf.html"><strong aria-hidden="true">3.27.113.</strong> Value Of</a></li><li class="chapter-item expanded "><a href="3. 库函数/reflect/Zero.html"><strong aria-hidden="true">3.27.114.</strong> Zero</a></li></ol></li><li class="chapter-item expanded "><a href="3. 库函数/regexp/index.html"><strong aria-hidden="true">3.28.</strong> Regexp</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/regexp/syntax/index.html"><strong aria-hidden="true">3.28.1.</strong> Syntax</a></li></ol></li><li class="chapter-item expanded "><a href="3. 库函数/runtime/index.html"><strong aria-hidden="true">3.29.</strong> Runtime</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/runtime/cgo/index.html"><strong aria-hidden="true">3.29.1.</strong> Cgo</a></li><li class="chapter-item expanded "><a href="3. 库函数/runtime/debug/index.html"><strong aria-hidden="true">3.29.2.</strong> Debug</a></li><li class="chapter-item expanded "><a href="3. 库函数/runtime/pprof/index.html"><strong aria-hidden="true">3.29.3.</strong> Pprof</a></li></ol></li><li class="chapter-item expanded "><a href="3. 库函数/sort/index.html"><strong aria-hidden="true">3.30.</strong> Sort</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/sort/Float64s.html"><strong aria-hidden="true">3.30.1.</strong> Float 64 S</a></li><li class="chapter-item expanded "><a href="3. 库函数/sort/Float64sAreSorted.html"><strong aria-hidden="true">3.30.2.</strong> Float 64 S Are Sorted</a></li><li class="chapter-item expanded "><a href="3. 库函数/sort/Float64Slice.html"><strong aria-hidden="true">3.30.3.</strong> Float 64 Slice</a></li><li class="chapter-item expanded "><a href="3. 库函数/sort/Interface.html"><strong aria-hidden="true">3.30.4.</strong> Interface</a></li><li class="chapter-item expanded "><a href="3. 库函数/sort/Ints.html"><strong aria-hidden="true">3.30.5.</strong> Ints</a></li><li class="chapter-item expanded "><a href="3. 库函数/sort/IntsAreSorted.html"><strong aria-hidden="true">3.30.6.</strong> Ints Are Sorted</a></li><li class="chapter-item expanded "><a href="3. 库函数/sort/IntSlice.html"><strong aria-hidden="true">3.30.7.</strong> Int Slice</a></li><li class="chapter-item expanded "><a href="3. 库函数/sort/IsSorted.html"><strong aria-hidden="true">3.30.8.</strong> Is Sorted</a></li><li class="chapter-item expanded "><a href="3. 库函数/sort/Reverse.html"><strong aria-hidden="true">3.30.9.</strong> Reverse</a></li><li class="chapter-item expanded "><a href="3. 库函数/sort/Search.html"><strong aria-hidden="true">3.30.10.</strong> Search</a></li><li class="chapter-item expanded "><a href="3. 库函数/sort/SearchFloat64s.html"><strong aria-hidden="true">3.30.11.</strong> Search Float 64 S</a></li><li class="chapter-item expanded "><a href="3. 库函数/sort/SearchInts.html"><strong aria-hidden="true">3.30.12.</strong> Search Ints</a></li><li class="chapter-item expanded "><a href="3. 库函数/sort/SearchStrings.html"><strong aria-hidden="true">3.30.13.</strong> Search Strings</a></li><li class="chapter-item expanded "><a href="3. 库函数/sort/Sort.html"><strong aria-hidden="true">3.30.14.</strong> Sort</a></li><li class="chapter-item expanded "><a href="3. 库函数/sort/Stable.html"><strong aria-hidden="true">3.30.15.</strong> Stable</a></li><li class="chapter-item expanded "><a href="3. 库函数/sort/Strings.html"><strong aria-hidden="true">3.30.16.</strong> Strings</a></li><li class="chapter-item expanded "><a href="3. 库函数/sort/StringsAreSorted.html"><strong aria-hidden="true">3.30.17.</strong> Strings Are Sorted</a></li><li class="chapter-item expanded "><a href="3. 库函数/sort/StringSlice.html"><strong aria-hidden="true">3.30.18.</strong> String Slice</a></li></ol></li><li class="chapter-item expanded "><a href="3. 库函数/strconv/index.html"><strong aria-hidden="true">3.31.</strong> Strconv</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/strconv/AppendBool.html"><strong aria-hidden="true">3.31.1.</strong> Append Bool</a></li><li class="chapter-item expanded "><a href="3. 库函数/strconv/AppendFloat.html"><strong aria-hidden="true">3.31.2.</strong> Append Float</a></li><li class="chapter-item expanded "><a href="3. 库函数/strconv/AppendInt.html"><strong aria-hidden="true">3.31.3.</strong> Append Int</a></li><li class="chapter-item expanded "><a href="3. 库函数/strconv/AppendQuote.html"><strong aria-hidden="true">3.31.4.</strong> Append Quote</a></li><li class="chapter-item expanded "><a href="3. 库函数/strconv/AppendQuoteRune.html"><strong aria-hidden="true">3.31.5.</strong> Append Quote Rune</a></li><li class="chapter-item expanded "><a href="3. 库函数/strconv/AppendQuoteRuneToASCII.html"><strong aria-hidden="true">3.31.6.</strong> Append Quote Rune To ASCII</a></li><li class="chapter-item expanded "><a href="3. 库函数/strconv/AppendUint.html"><strong aria-hidden="true">3.31.7.</strong> Append Uint</a></li><li class="chapter-item expanded "><a href="3. 库函数/strconv/Atoi.html"><strong aria-hidden="true">3.31.8.</strong> Atoi</a></li><li class="chapter-item expanded "><a href="3. 库函数/strconv/CanBackquote.html"><strong aria-hidden="true">3.31.9.</strong> Can Backquote</a></li><li class="chapter-item expanded "><a href="3. 库函数/strconv/FormatBool.html"><strong aria-hidden="true">3.31.10.</strong> Format Bool</a></li><li class="chapter-item expanded "><a href="3. 库函数/strconv/FormatFloat.html"><strong aria-hidden="true">3.31.11.</strong> Format Float</a></li><li class="chapter-item expanded "><a href="3. 库函数/strconv/FormatInt.html"><strong aria-hidden="true">3.31.12.</strong> Format Int</a></li><li class="chapter-item expanded "><a href="3. 库函数/strconv/FormatUint.html"><strong aria-hidden="true">3.31.13.</strong> Format Uint</a></li><li class="chapter-item expanded "><a href="3. 库函数/strconv/IsPrint.html"><strong aria-hidden="true">3.31.14.</strong> Is Print</a></li><li class="chapter-item expanded "><a href="3. 库函数/strconv/Itoa.html"><strong aria-hidden="true">3.31.15.</strong> Itoa</a></li><li class="chapter-item expanded "><a href="3. 库函数/strconv/NumError.Error.html"><strong aria-hidden="true">3.31.16.</strong> NumError.Error</a></li><li class="chapter-item expanded "><a href="3. 库函数/strconv/ParseBool.html"><strong aria-hidden="true">3.31.17.</strong> Parse Bool</a></li><li class="chapter-item expanded "><a href="3. 库函数/strconv/ParseFloat.html"><strong aria-hidden="true">3.31.18.</strong> Parse Float</a></li><li class="chapter-item expanded "><a href="3. 库函数/strconv/ParseInt.html"><strong aria-hidden="true">3.31.19.</strong> Parse Int</a></li><li class="chapter-item expanded "><a href="3. 库函数/strconv/ParseUint.html"><strong aria-hidden="true">3.31.20.</strong> Parse Uint</a></li><li class="chapter-item expanded "><a href="3. 库函数/strconv/Quote.html"><strong aria-hidden="true">3.31.21.</strong> Quote</a></li><li class="chapter-item expanded "><a href="3. 库函数/strconv/QuoteRune.html"><strong aria-hidden="true">3.31.22.</strong> Quote Rune</a></li><li class="chapter-item expanded "><a href="3. 库函数/strconv/QuoteRuneToASCII.html"><strong aria-hidden="true">3.31.23.</strong> Quote Rune To ASCII</a></li><li class="chapter-item expanded "><a href="3. 库函数/strconv/Unquote.html"><strong aria-hidden="true">3.31.24.</strong> Unquote</a></li><li class="chapter-item expanded "><a href="3. 库函数/strconv/UnquoteChar.html"><strong aria-hidden="true">3.31.25.</strong> Unquote Char</a></li></ol></li><li class="chapter-item expanded "><a href="3. 库函数/strings/index.html"><strong aria-hidden="true">3.32.</strong> Strings</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/strings/Contains.html"><strong aria-hidden="true">3.32.1.</strong> Contains</a></li><li class="chapter-item expanded "><a href="3. 库函数/strings/ContainsAny.html"><strong aria-hidden="true">3.32.2.</strong> Contains Any</a></li><li class="chapter-item expanded "><a href="3. 库函数/strings/ContainsRune.html"><strong aria-hidden="true">3.32.3.</strong> Contains Rune</a></li><li class="chapter-item expanded "><a href="3. 库函数/strings/Count.html"><strong aria-hidden="true">3.32.4.</strong> Count</a></li><li class="chapter-item expanded "><a href="3. 库函数/strings/EqualFold.html"><strong aria-hidden="true">3.32.5.</strong> Equal Fold</a></li><li class="chapter-item expanded "><a href="3. 库函数/strings/Fields.html"><strong aria-hidden="true">3.32.6.</strong> Fields</a></li><li class="chapter-item expanded "><a href="3. 库函数/strings/FieldsFunc.html"><strong aria-hidden="true">3.32.7.</strong> Fields Func</a></li><li class="chapter-item expanded "><a href="3. 库函数/strings/HasPrefix.html"><strong aria-hidden="true">3.32.8.</strong> Has Prefix</a></li><li class="chapter-item expanded "><a href="3. 库函数/strings/HasSuffix.html"><strong aria-hidden="true">3.32.9.</strong> Has Suffix</a></li><li class="chapter-item expanded "><a href="3. 库函数/strings/Index.html"><strong aria-hidden="true">3.32.10.</strong> Index</a></li><li class="chapter-item expanded "><a href="3. 库函数/strings/IndexAny.html"><strong aria-hidden="true">3.32.11.</strong> Index Any</a></li><li class="chapter-item expanded "><a href="3. 库函数/strings/IndexFunc.html"><strong aria-hidden="true">3.32.12.</strong> Index Func</a></li><li class="chapter-item expanded "><a href="3. 库函数/strings/IndexRune.html"><strong aria-hidden="true">3.32.13.</strong> Index Rune</a></li><li class="chapter-item expanded "><a href="3. 库函数/strings/Join.html"><strong aria-hidden="true">3.32.14.</strong> Join</a></li><li class="chapter-item expanded "><a href="3. 库函数/strings/LastIndex.html"><strong aria-hidden="true">3.32.15.</strong> Last Index</a></li><li class="chapter-item expanded "><a href="3. 库函数/strings/LastIndexAny.html"><strong aria-hidden="true">3.32.16.</strong> Last Index Any</a></li><li class="chapter-item expanded "><a href="3. 库函数/strings/LastIndexFunc.html"><strong aria-hidden="true">3.32.17.</strong> Last Index Func</a></li><li class="chapter-item expanded "><a href="3. 库函数/strings/Map.html"><strong aria-hidden="true">3.32.18.</strong> Map</a></li><li class="chapter-item expanded "><a href="3. 库函数/strings/NewReader.html"><strong aria-hidden="true">3.32.19.</strong> New Reader</a></li><li class="chapter-item expanded "><a href="3. 库函数/strings/NewReplacer.html"><strong aria-hidden="true">3.32.20.</strong> New Replacer</a></li><li class="chapter-item expanded "><a href="3. 库函数/strings/Repeat.html"><strong aria-hidden="true">3.32.21.</strong> Repeat</a></li><li class="chapter-item expanded "><a href="3. 库函数/strings/Replace.html"><strong aria-hidden="true">3.32.22.</strong> Replace</a></li><li class="chapter-item expanded "><a href="3. 库函数/strings/Split.html"><strong aria-hidden="true">3.32.23.</strong> Split</a></li><li class="chapter-item expanded "><a href="3. 库函数/strings/SplitAfter.html"><strong aria-hidden="true">3.32.24.</strong> Split After</a></li><li class="chapter-item expanded "><a href="3. 库函数/strings/SplitAfterN.html"><strong aria-hidden="true">3.32.25.</strong> Split After N</a></li><li class="chapter-item expanded "><a href="3. 库函数/strings/SplitN.html"><strong aria-hidden="true">3.32.26.</strong> Split N</a></li><li class="chapter-item expanded "><a href="3. 库函数/strings/Title.html"><strong aria-hidden="true">3.32.27.</strong> Title</a></li><li class="chapter-item expanded "><a href="3. 库函数/strings/ToLower.html"><strong aria-hidden="true">3.32.28.</strong> To Lower</a></li><li class="chapter-item expanded "><a href="3. 库函数/strings/ToLowerSpecial.html"><strong aria-hidden="true">3.32.29.</strong> To Lower Special</a></li><li class="chapter-item expanded "><a href="3. 库函数/strings/ToTitle.html"><strong aria-hidden="true">3.32.30.</strong> To Title</a></li><li class="chapter-item expanded "><a href="3. 库函数/strings/ToTitleSpecial.html"><strong aria-hidden="true">3.32.31.</strong> To Title Special</a></li><li class="chapter-item expanded "><a href="3. 库函数/strings/ToUpper.html"><strong aria-hidden="true">3.32.32.</strong> To Upper</a></li><li class="chapter-item expanded "><a href="3. 库函数/strings/ToUpperSpecial.html"><strong aria-hidden="true">3.32.33.</strong> To Upper Special</a></li><li class="chapter-item expanded "><a href="3. 库函数/strings/Trim.html"><strong aria-hidden="true">3.32.34.</strong> Trim</a></li><li class="chapter-item expanded "><a href="3. 库函数/strings/TrimFunc.html"><strong aria-hidden="true">3.32.35.</strong> Trim Func</a></li><li class="chapter-item expanded "><a href="3. 库函数/strings/TrimLeft.html"><strong aria-hidden="true">3.32.36.</strong> Trim Left</a></li><li class="chapter-item expanded "><a href="3. 库函数/strings/TrimLeftFunc.html"><strong aria-hidden="true">3.32.37.</strong> Trim Left Func</a></li><li class="chapter-item expanded "><a href="3. 库函数/strings/TrimRight.html"><strong aria-hidden="true">3.32.38.</strong> Trim Right</a></li><li class="chapter-item expanded "><a href="3. 库函数/strings/TrimRightFunc.html"><strong aria-hidden="true">3.32.39.</strong> Trim Right Func</a></li><li class="chapter-item expanded "><a href="3. 库函数/strings/TrimSpace.html"><strong aria-hidden="true">3.32.40.</strong> Trim Space</a></li></ol></li><li class="chapter-item expanded "><a href="3. 库函数/sync/index.html"><strong aria-hidden="true">3.33.</strong> Sync</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/sync/atomic/index.html"><strong aria-hidden="true">3.33.1.</strong> Atomic</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/sync/atomic/AddInt32.html"><strong aria-hidden="true">3.33.1.1.</strong> Add Int 32</a></li><li class="chapter-item expanded "><a href="3. 库函数/sync/atomic/compareandswapint32.html"><strong aria-hidden="true">3.33.1.2.</strong> Compareandswapint 32</a></li><li class="chapter-item expanded "><a href="3. 库函数/sync/atomic/loadint32.html"><strong aria-hidden="true">3.33.1.3.</strong> Loadint 32</a></li><li class="chapter-item expanded "><a href="3. 库函数/sync/atomic/storeint32.html"><strong aria-hidden="true">3.33.1.4.</strong> Storeint 32</a></li></ol></li><li class="chapter-item expanded "><a href="3. 库函数/sync/cond.html"><strong aria-hidden="true">3.33.2.</strong> Cond</a></li><li class="chapter-item expanded "><a href="3. 库函数/sync/mutex.html"><strong aria-hidden="true">3.33.3.</strong> Mutex</a></li><li class="chapter-item expanded "><a href="3. 库函数/sync/once.html"><strong aria-hidden="true">3.33.4.</strong> Once</a></li><li class="chapter-item expanded "><a href="3. 库函数/sync/rwmutex.html"><strong aria-hidden="true">3.33.5.</strong> Rwmutex</a></li><li class="chapter-item expanded "><a href="3. 库函数/sync/type_locker.html"><strong aria-hidden="true">3.33.6.</strong> Type Locker</a></li><li class="chapter-item expanded "><a href="3. 库函数/sync/waitgroup.html"><strong aria-hidden="true">3.33.7.</strong> Waitgroup</a></li></ol></li><li class="chapter-item expanded "><a href="3. 库函数/syscall/index.html"><strong aria-hidden="true">3.34.</strong> Syscall</a></li><li class="chapter-item expanded "><a href="3. 库函数/testing/index.html"><strong aria-hidden="true">3.35.</strong> Testing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/testing/iotest/index.html"><strong aria-hidden="true">3.35.1.</strong> Iotest</a></li><li class="chapter-item expanded "><a href="3. 库函数/testing/quick/index.html"><strong aria-hidden="true">3.35.2.</strong> Quick</a></li><li class="chapter-item expanded "><a href="3. 库函数/testing/B_Error.html"><strong aria-hidden="true">3.35.3.</strong> B Error</a></li><li class="chapter-item expanded "><a href="3. 库函数/testing/B_Errorf.html"><strong aria-hidden="true">3.35.4.</strong> B Errorf</a></li><li class="chapter-item expanded "><a href="3. 库函数/testing/B_Fail.html"><strong aria-hidden="true">3.35.5.</strong> B Fail</a></li><li class="chapter-item expanded "><a href="3. 库函数/testing/B_Failed.html"><strong aria-hidden="true">3.35.6.</strong> B Failed</a></li><li class="chapter-item expanded "><a href="3. 库函数/testing/B_FailNow.html"><strong aria-hidden="true">3.35.7.</strong> B Fail Now</a></li><li class="chapter-item expanded "><a href="3. 库函数/testing/B_Fatal.html"><strong aria-hidden="true">3.35.8.</strong> B Fatal</a></li><li class="chapter-item expanded "><a href="3. 库函数/testing/B_Fatalf.html"><strong aria-hidden="true">3.35.9.</strong> B Fatalf</a></li><li class="chapter-item expanded "><a href="3. 库函数/testing/B_Log.html"><strong aria-hidden="true">3.35.10.</strong> B Log</a></li><li class="chapter-item expanded "><a href="3. 库函数/testing/B_Logf.html"><strong aria-hidden="true">3.35.11.</strong> B Logf</a></li><li class="chapter-item expanded "><a href="3. 库函数/testing/B_ResetTimer.html"><strong aria-hidden="true">3.35.12.</strong> B Reset Timer</a></li><li class="chapter-item expanded "><a href="3. 库函数/testing/B_SetBytes.html"><strong aria-hidden="true">3.35.13.</strong> B Set Bytes</a></li><li class="chapter-item expanded "><a href="3. 库函数/testing/B_StartTimer.html"><strong aria-hidden="true">3.35.14.</strong> B Start Timer</a></li><li class="chapter-item expanded "><a href="3. 库函数/testing/B_StopTimer.html"><strong aria-hidden="true">3.35.15.</strong> B Stop Timer</a></li><li class="chapter-item expanded "><a href="3. 库函数/testing/B.html"><strong aria-hidden="true">3.35.16.</strong> B</a></li><li class="chapter-item expanded "><a href="3. 库函数/testing/Benchmark.html"><strong aria-hidden="true">3.35.17.</strong> Benchmark</a></li><li class="chapter-item expanded "><a href="3. 库函数/testing/BenchmarkResult_NsPerOp.html"><strong aria-hidden="true">3.35.18.</strong> Benchmark Result Ns Per Op</a></li><li class="chapter-item expanded "><a href="3. 库函数/testing/BenchmarkResult_String.html"><strong aria-hidden="true">3.35.19.</strong> Benchmark Result String</a></li><li class="chapter-item expanded "><a href="3. 库函数/testing/BenchmarkResult.html"><strong aria-hidden="true">3.35.20.</strong> Benchmark Result</a></li><li class="chapter-item expanded "><a href="3. 库函数/testing/InternalBenchmark.html"><strong aria-hidden="true">3.35.21.</strong> Internal Benchmark</a></li><li class="chapter-item expanded "><a href="3. 库函数/testing/InternalExample.html"><strong aria-hidden="true">3.35.22.</strong> Internal Example</a></li><li class="chapter-item expanded "><a href="3. 库函数/testing/InternalTest.html"><strong aria-hidden="true">3.35.23.</strong> Internal Test</a></li><li class="chapter-item expanded "><a href="3. 库函数/testing/Main.html"><strong aria-hidden="true">3.35.24.</strong> Main</a></li><li class="chapter-item expanded "><a href="3. 库函数/testing/RunBenchmarks.html"><strong aria-hidden="true">3.35.25.</strong> Run Benchmarks</a></li><li class="chapter-item expanded "><a href="3. 库函数/testing/RunExamples.html"><strong aria-hidden="true">3.35.26.</strong> Run Examples</a></li><li class="chapter-item expanded "><a href="3. 库函数/testing/RunTests.html"><strong aria-hidden="true">3.35.27.</strong> Run Tests</a></li><li class="chapter-item expanded "><a href="3. 库函数/testing/Short.html"><strong aria-hidden="true">3.35.28.</strong> Short</a></li><li class="chapter-item expanded "><a href="3. 库函数/testing/T_Error.html"><strong aria-hidden="true">3.35.29.</strong> T Error</a></li><li class="chapter-item expanded "><a href="3. 库函数/testing/T_Errorf.html"><strong aria-hidden="true">3.35.30.</strong> T Errorf</a></li><li class="chapter-item expanded "><a href="3. 库函数/testing/T_Fail.html"><strong aria-hidden="true">3.35.31.</strong> T Fail</a></li><li class="chapter-item expanded "><a href="3. 库函数/testing/T_Failed.html"><strong aria-hidden="true">3.35.32.</strong> T Failed</a></li><li class="chapter-item expanded "><a href="3. 库函数/testing/T_FailNow.html"><strong aria-hidden="true">3.35.33.</strong> T Fail Now</a></li><li class="chapter-item expanded "><a href="3. 库函数/testing/T_Fatal.html"><strong aria-hidden="true">3.35.34.</strong> T Fatal</a></li><li class="chapter-item expanded "><a href="3. 库函数/testing/T_Fatalf.html"><strong aria-hidden="true">3.35.35.</strong> T Fatalf</a></li><li class="chapter-item expanded "><a href="3. 库函数/testing/T_Log.html"><strong aria-hidden="true">3.35.36.</strong> T Log</a></li><li class="chapter-item expanded "><a href="3. 库函数/testing/T_Logf.html"><strong aria-hidden="true">3.35.37.</strong> T Logf</a></li><li class="chapter-item expanded "><a href="3. 库函数/testing/T_Parallel.html"><strong aria-hidden="true">3.35.38.</strong> T Parallel</a></li><li class="chapter-item expanded "><a href="3. 库函数/testing/T.html"><strong aria-hidden="true">3.35.39.</strong> T</a></li></ol></li><li class="chapter-item expanded "><a href="3. 库函数/text/index.html"><strong aria-hidden="true">3.36.</strong> Text</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/text/scanner/index.html"><strong aria-hidden="true">3.36.1.</strong> Scanner</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/text/scanner/Constants.html"><strong aria-hidden="true">3.36.1.1.</strong> Constants</a></li><li class="chapter-item expanded "><a href="3. 库函数/text/scanner/Init.html"><strong aria-hidden="true">3.36.1.2.</strong> Init</a></li><li class="chapter-item expanded "><a href="3. 库函数/text/scanner/IsValid.html"><strong aria-hidden="true">3.36.1.3.</strong> Is Valid</a></li><li class="chapter-item expanded "><a href="3. 库函数/text/scanner/Next.html"><strong aria-hidden="true">3.36.1.4.</strong> Next</a></li><li class="chapter-item expanded "><a href="3. 库函数/text/scanner/Peek.html"><strong aria-hidden="true">3.36.1.5.</strong> Peek</a></li><li class="chapter-item expanded "><a href="3. 库函数/text/scanner/Pos.html"><strong aria-hidden="true">3.36.1.6.</strong> Pos</a></li><li class="chapter-item expanded "><a href="3. 库函数/text/scanner/Position.html"><strong aria-hidden="true">3.36.1.7.</strong> Position</a></li><li class="chapter-item expanded "><a href="3. 库函数/text/scanner/Scan.html"><strong aria-hidden="true">3.36.1.8.</strong> Scan</a></li><li class="chapter-item expanded "><a href="3. 库函数/text/scanner/String.html"><strong aria-hidden="true">3.36.1.9.</strong> String</a></li><li class="chapter-item expanded "><a href="3. 库函数/text/scanner/TokenString.html"><strong aria-hidden="true">3.36.1.10.</strong> Token String</a></li><li class="chapter-item expanded "><a href="3. 库函数/text/scanner/TokenText.html"><strong aria-hidden="true">3.36.1.11.</strong> Token Text</a></li></ol></li><li class="chapter-item expanded "><a href="3. 库函数/text/tabwriter/index.html"><strong aria-hidden="true">3.36.2.</strong> Tabwriter</a></li><li class="chapter-item expanded "><a href="3. 库函数/text/template/index.html"><strong aria-hidden="true">3.36.3.</strong> Template</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/text/template/parse/index.html"><strong aria-hidden="true">3.36.3.1.</strong> Parse</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="3. 库函数/time/index.html"><strong aria-hidden="true">3.37.</strong> Time</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/time/Add.html"><strong aria-hidden="true">3.37.1.</strong> Add</a></li><li class="chapter-item expanded "><a href="3. 库函数/time/AddDate.html"><strong aria-hidden="true">3.37.2.</strong> Add Date</a></li><li class="chapter-item expanded "><a href="3. 库函数/time/After.html"><strong aria-hidden="true">3.37.3.</strong> After</a></li><li class="chapter-item expanded "><a href="3. 库函数/time/AfterFunc.html"><strong aria-hidden="true">3.37.4.</strong> After Func</a></li><li class="chapter-item expanded "><a href="3. 库函数/time/Constants.html"><strong aria-hidden="true">3.37.5.</strong> Constants</a></li><li class="chapter-item expanded "><a href="3. 库函数/time/Duration.html"><strong aria-hidden="true">3.37.6.</strong> Duration</a></li><li class="chapter-item expanded "><a href="3. 库函数/time/Error.html"><strong aria-hidden="true">3.37.7.</strong> Error</a></li><li class="chapter-item expanded "><a href="3. 库函数/time/FixedZone_Editing.html"><strong aria-hidden="true">3.37.8.</strong> Fixed Zone Editing</a></li><li class="chapter-item expanded "><a href="3. 库函数/time/Format.html"><strong aria-hidden="true">3.37.9.</strong> Format</a></li><li class="chapter-item expanded "><a href="3. 库函数/time/GobDecode.html"><strong aria-hidden="true">3.37.10.</strong> Gob Decode</a></li><li class="chapter-item expanded "><a href="3. 库函数/time/GobEncode.html"><strong aria-hidden="true">3.37.11.</strong> Gob Encode</a></li><li class="chapter-item expanded "><a href="3. 库函数/time/Hours.html"><strong aria-hidden="true">3.37.12.</strong> Hours</a></li><li class="chapter-item expanded "><a href="3. 库函数/time/In.html"><strong aria-hidden="true">3.37.13.</strong> In</a></li><li class="chapter-item expanded "><a href="3. 库函数/time/ISOWeek.html"><strong aria-hidden="true">3.37.14.</strong> ISO Week</a></li><li class="chapter-item expanded "><a href="3. 库函数/time/LoadLocation.html"><strong aria-hidden="true">3.37.15.</strong> Load Location</a></li><li class="chapter-item expanded "><a href="3. 库函数/time/Local.html"><strong aria-hidden="true">3.37.16.</strong> Local</a></li><li class="chapter-item expanded "><a href="3. 库函数/time/Location.html"><strong aria-hidden="true">3.37.17.</strong> Location</a></li><li class="chapter-item expanded "><a href="3. 库函数/time/MarshalJSON.html"><strong aria-hidden="true">3.37.18.</strong> Marshal JSON</a></li><li class="chapter-item expanded "><a href="3. 库函数/time/Minutes.html"><strong aria-hidden="true">3.37.19.</strong> Minutes</a></li><li class="chapter-item expanded "><a href="3. 库函数/time/Month.html"><strong aria-hidden="true">3.37.20.</strong> Month</a></li><li class="chapter-item expanded "><a href="3. 库函数/time/Nanoseconds.html"><strong aria-hidden="true">3.37.21.</strong> Nanoseconds</a></li><li class="chapter-item expanded "><a href="3. 库函数/time/NewTicker.html"><strong aria-hidden="true">3.37.22.</strong> New Ticker</a></li><li class="chapter-item expanded "><a href="3. 库函数/time/NewTimer.html"><strong aria-hidden="true">3.37.23.</strong> New Timer</a></li><li class="chapter-item expanded "><a href="3. 库函数/time/Now.html"><strong aria-hidden="true">3.37.24.</strong> Now</a></li><li class="chapter-item expanded "><a href="3. 库函数/time/Parse.html"><strong aria-hidden="true">3.37.25.</strong> Parse</a></li><li class="chapter-item expanded "><a href="3. 库函数/time/ParseDuration.html"><strong aria-hidden="true">3.37.26.</strong> Parse Duration</a></li><li class="chapter-item expanded "><a href="3. 库函数/time/ParseError.html"><strong aria-hidden="true">3.37.27.</strong> Parse Error</a></li><li class="chapter-item expanded "><a href="3. 库函数/time/Seconds.html"><strong aria-hidden="true">3.37.28.</strong> Seconds</a></li><li class="chapter-item expanded "><a href="3. 库函数/time/Since.html"><strong aria-hidden="true">3.37.29.</strong> Since</a></li><li class="chapter-item expanded "><a href="3. 库函数/time/Sleep.html"><strong aria-hidden="true">3.37.30.</strong> Sleep</a></li><li class="chapter-item expanded "><a href="3. 库函数/time/Stop.html"><strong aria-hidden="true">3.37.31.</strong> Stop</a></li><li class="chapter-item expanded "><a href="3. 库函数/time/String.html"><strong aria-hidden="true">3.37.32.</strong> String</a></li><li class="chapter-item expanded "><a href="3. 库函数/time/Sub.html"><strong aria-hidden="true">3.37.33.</strong> Sub</a></li><li class="chapter-item expanded "><a href="3. 库函数/time/Tick.html"><strong aria-hidden="true">3.37.34.</strong> Tick</a></li><li class="chapter-item expanded "><a href="3. 库函数/time/Ticker.html"><strong aria-hidden="true">3.37.35.</strong> Ticker</a></li><li class="chapter-item expanded "><a href="3. 库函数/time/Time.html"><strong aria-hidden="true">3.37.36.</strong> Time</a></li><li class="chapter-item expanded "><a href="3. 库函数/time/Timer.html"><strong aria-hidden="true">3.37.37.</strong> Timer</a></li><li class="chapter-item expanded "><a href="3. 库函数/time/Unix.html"><strong aria-hidden="true">3.37.38.</strong> Unix</a></li><li class="chapter-item expanded "><a href="3. 库函数/time/UnixNano.html"><strong aria-hidden="true">3.37.39.</strong> Unix Nano</a></li><li class="chapter-item expanded "><a href="3. 库函数/time/UnmarshalJSON.html"><strong aria-hidden="true">3.37.40.</strong> Unmarshal JSON</a></li><li class="chapter-item expanded "><a href="3. 库函数/time/UTC.html"><strong aria-hidden="true">3.37.41.</strong> UTC</a></li><li class="chapter-item expanded "><a href="3. 库函数/time/Weekday.html"><strong aria-hidden="true">3.37.42.</strong> Weekday</a></li><li class="chapter-item expanded "><a href="3. 库函数/time/Zone.html"><strong aria-hidden="true">3.37.43.</strong> Zone</a></li></ol></li><li class="chapter-item expanded "><a href="3. 库函数/unicode/index.html"><strong aria-hidden="true">3.38.</strong> Unicode</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/unicode/utf16/index.html"><strong aria-hidden="true">3.38.1.</strong> Utf 16</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3. 库函数/unicode/utf16/Decode.html"><strong aria-hidden="true">3.38.1.1.</strong> Decode</a></li><li class="chapter-item expanded "><a href="3. 库函数/unicode/utf16/DecodeRune.html"><strong aria-hidden="true">3.38.1.2.</strong> Decode Rune</a></li><li class="chapter-item expanded "><a href="3. 库函数/unicode/utf16/Encode.html"><strong aria-hidden="true">3.38.1.3.</strong> Encode</a></li><li class="chapter-item expanded "><a href="3. 库函数/unicode/utf16/EncodeRune.html"><strong aria-hidden="true">3.38.1.4.</strong> Encode Rune</a></li><li class="chapter-item expanded "><a href="3. 库函数/unicode/utf16/IsSurrogate.html"><strong aria-hidden="true">3.38.1.5.</strong> Is Surrogate</a></li></ol></li><li class="chapter-item expanded "><a href="3. 库函数/unicode/utf8/index.html"><strong aria-hidden="true">3.38.2.</strong> Utf 8</a></li></ol></li><li class="chapter-item expanded "><a href="3. 库函数/unsafe/index.html"><strong aria-hidden="true">3.39.</strong> Unsafe</a></li><li class="chapter-item expanded "><a href="3. 库函数/Printf.html"><strong aria-hidden="true">3.40.</strong> Printf</a></li><li class="chapter-item expanded "><a href="3. 库函数/todo.html"><strong aria-hidden="true">3.41.</strong> Todo</a></li></ol></li><li class="chapter-item expanded "><a href="4. 内置工具/_index.html"><strong aria-hidden="true">4.</strong> 内置工具</a></li><li class="chapter-item expanded "><a href="5. 进阶/_index.html"><strong aria-hidden="true">5.</strong> 进阶</a></li><li class="chapter-item expanded "><a href="6. 项目/_index.html"><strong aria-hidden="true">6.</strong> 项目</a></li><li class="chapter-item expanded "><a href="7. 项目研究/_index.html"><strong aria-hidden="true">7.</strong> 项目研究</a></li><li class="chapter-item expanded "><a href="8. 资料整理/_index.html"><strong aria-hidden="true">8.</strong> 资料整理</a></li><li class="chapter-item expanded "><a href="Go Project Layout.html"><strong aria-hidden="true">9.</strong> Go Project Layout</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">golang笔记</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/yujian1018/yujian1018.github.io/tree/master/golang" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="介绍"><a class="header" href="#介绍">介绍</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h3 id="c"><a class="header" href="#c">c++</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h3 id="c-1"><a class="header" href="#c-1">c++</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h3 id="golang"><a class="header" href="#golang">golang</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="archive"><a class="header" href="#archive">Archive</a></h1>
<p>二级包列表</p>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/archive/tar">archive/tar</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/archive/zip">archive/zip</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="archivetar包详解"><a class="header" href="#archivetar包详解">archive/tar包详解</a></h1>
<h3 id="常量列表"><a class="header" href="#常量列表">常量列表</a></h3>
<pre><code>const(
	TypeReg           = '0'    // 普通文件
	TypeRegA          = '\x00' // 普通文件
	TypeLink          = '1'    // 实体链接
	TypeSymlink       = '2'    // 指向链接
	TypeChar          = '3'    // 字符设备节点
	TypeBlock         = '4'    // 区块设备节点
	TypeDir           = '5'    // 目录
	TypeFifo          = '6'    // 命名管道节点
	TypeCont          = '7'    // 保留的
	TypeXHeader       = 'x'    // 扩展数据头
	TypeXGlobalHeader = 'g'    // 全局扩展数据头
)
</code></pre>
<h3 id="变量列表"><a class="header" href="#变量列表">变量列表：</a></h3>
<pre><code>var(
	ErrWriteTooLong    = errors.New(&quot;archive/tar: write too long&quot;) // 写出太长
	ErrFieldTooLong    = errors.New(&quot;archive/tar: header field too long&quot;)	// 数据头太长
	ErrWriteAfterClose = errors.New(&quot;archive/tar: write after close&quot;)	// 在关闭写出流后操作
	ErrHeader = errors.New(&quot;archive/tar: invalid tar header&quot;)	// 无效的数据头
)
</code></pre>
<h3 id="数据头结构"><a class="header" href="#数据头结构">数据头结构</a></h3>
<pre><code>type Header struct {
	Name       string    // 写入数据头的文件名称
	Mode       int64     // 许可与模式比特位(bits)
	Uid        int       // 拥有者的用户ID
	Gid        int       // 拥有者的群组ID
	Size       int64     // 以字节(bytes)为单位的长度
	ModTime    time.Time // 修改时间
	Typeflag   byte      // 写入的数据头类型（文件类型）
	Linkname   string    // 链接的目标名称
	Uname      string    // 拥有者的用户名
	Gname      string    // 拥有者的群组名
	Devmajor   int64     // 字符或区块设备的主要数字
	Devminor   int64     // 字符或区块设备的次要数字
	AccessTime time.Time // 存取时间
	ChangeTime time.Time // 权限状态改变时间
}
</code></pre>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/archive/tar/Reader.html">Reader结构 - 读取tar文件</a> </li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/archive/tar/Writer.html">Writer结构 - 创建tar文件</a> </li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="type-reader-struct-"><a class="header" href="#type-reader-struct-">type Reader struct {}</a></h2>
<p>功能说明：</p>
<p>该结构主要用于读取tar包时获取所有文件的slice，并调用Next方法逐个读取其中的文件。</p>
<p>代码实例（本示例不包含目录递归及目录判断功能，<a href="https://github.com/Unknwon/go-compresser/blob/master/go-tar.gz.go">完整实例</a>）：</p>
<pre><code>package main

import (
	&quot;os&quot;
	&quot;io&quot;
	&quot;archive/tar&quot;
)

func main() {
	fr, err := os.Open(&quot;dmeo.tar&quot;)	// 打开tar包文件，返回*io.Reader
	handleError(err)	// handleError为错误处理函数，下同
	defer fr.Close()
	
	// 实例化新的tar.Reader
	tr := tar.NewReader(fr)
	
	for	{
		hdr, err := tr.Next()	// 获取下一个文件，第一个文件也用此方法获取
		if err == io.EOF {
			break	// 已读到文件尾
		}
		handleError(err)
		
		// 通过创建文件获得*io.Writer
		fw, _ := os.Create(&quot;demo/&quot; + hdr.Name)
		handleError(err)
		
		// 拷贝数据
		_, err = io.Copy(fw, tr)
		handleError(err)
	}
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="type-writer-struct-"><a class="header" href="#type-writer-struct-">type Writer struct {}</a></h2>
<p>功能说明：</p>
<p>该结构主要用于将文件写入到tar包中，并记录每个文件的数据头。
另外要注意的是，本例所采用的是常规的方法，由于Go1.0.3版本仅允许一般的头文件名（Header.Name）总长度为100个字节，因此无法做很多层目录的递归（可以做，但文件名的总长度受限），如果您知道如何将该长度扩展至更多字节，请不吝指出，以帮助大家。</p>
<p>代码实例（本示例不包含目录递归功能，<a href="https://github.com/Unknwon/go-compresser/blob/master/go-tar.gz.go">完整实例</a>）：</p>
<pre><code>package main

import (
	&quot;os&quot;
	&quot;io&quot;
	&quot;archive/tar&quot;
)

func main() {
	fw, err := os.Create(&quot;demo.tar&quot;)	// 创建tar包文件，返回*io.Writer
	handleError(err)	// handleError为错误处理函数，下同
	defer fw.Close()
	
	// 实例化新的tar.Writer
	tw := tar.NewWriter(fw)
	defer tw.Close()
	
	// 获取要打包的文件的内容
	fr, err = os.Open(&quot;demo.txt&quot;)
	handleError(err)
	defer fr.Close()
	
	// 获取文件信息
	fi, err = fr.Stat()
	handleError(err)
	
	// 创建tar.Header
	hdr := new(tar.Header)
	hdr.Name = fi.Name()
	hdr.Size = fi.Size()
	hdr.Mode = int64(fi.Mode())
	hdr.ModTime = fi.ModTime()
	
	// 写入数据头
	err = tw.WriteHeader(hdr)
	handleError(err)
	
	// 写入文件数据
	_, err = io.Copy(tw, fr)
	handleError(err)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="archivezip包详解"><a class="header" href="#archivezip包详解">archive/zip包详解</a></h1>
<p>###常量列表
// 压缩的方法
const (
Store   uint16 = 0	// 储存
Deflate uint16 = 8	// 缩小
)
###变量列表：
var (
ErrFormat    = errors.New(&quot;zip: not a valid zip file&quot;)	// 不是一个有效的zip文件
ErrAlgorithm = errors.New(&quot;zip: unsupported compression algorithm&quot;)	// 不支持的压缩算法
ErrChecksum  = errors.New(&quot;zip: checksum error&quot;)	// 和校验错误
)
###文件结构
type File struct {
FileHeader	// 文件数据头
// 包含其它被过滤或未输出的字段
}
###文件数据头结构
type FileHeader struct {
Name             string // 写入数据头的文件名称
CreatorVersion   uint16 // 创建者版本
ReaderVersion    uint16 // 读取者版本
Flags            uint16 // 写入标志
Method           uint16 // 写入方法
ModifiedTime     uint16 // MS-DOS 时间
ModifiedDate     uint16 // MS-DOS 日期
CRC32            uint32 // CRC32校验和
CompressedSize   uint32 // 压缩后体积
UncompressedSize uint32 // 未压缩体积
Extra            []byte // 附加属性
ExternalAttrs    uint32 // 外部属性（依赖于创建者版本）
Comment          string // 文件注释
}</p>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/archive/zip/Reader.html">Reader结构 － 读取zip文件</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/archive/zip/Writer.html">Writer结构 － 创建zip文件</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="type-reader-struct--1"><a class="header" href="#type-reader-struct--1">type Reader struct {}</a></h2>
<p>功能说明：</p>
<p>该结构主要用于读取zip包时获取所有文件的slice，并使用for循环逐个读取其中的文件。
另外要注意的是，这里的ReadCloser用于读取zip的包文件，而Reader则是读取包中每个单独的文件。</p>
<p>代码实例（本示例不包含目录递归及目录判断功能，<a href="https://github.com/Unknwon/go-compresser/blob/master/go-zip.go">完整实例</a>）：</p>
<pre><code>package main

import (
	&quot;os&quot;
	&quot;io&quot;
	&quot;archive/zip&quot;
)

func main() {
	// 用zip.OpenReader打开zip包文件
	rc, err := zip.OpenReader(&quot;demo.zip&quot;)
	handleError(err)	// handleError为错误处理函数，下同		defer rc.Close()
	
	// 使用循环逐个读取zip包内的单独文件
	for _, f := range rc.File {
		// 打开包中的文件
		r, err := f.Open()
		handleError(err)
		
		// 将包中的文件数据写出
		fw, _ := os.Create(f.FileInfo().Name())
		handleError(err)
		_, err = io.Copy(fw, r)
		handleError(err)
	}
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="type-writer-struct--1"><a class="header" href="#type-writer-struct--1">type Writer struct {}</a></h2>
<p>功能说明：</p>
<p>该结构主要用于将文件写入到zip包中，并记录每个文件的数据头。
另外要注意的是，Create()与CreateHeader()两个方法的效果是一样的，都是添加新的文件数据头到zip包文件中，并返回*io.Writer，区别在于前者指需要指定文件名，而后者需要传递一个完整的FileHeader结构作为参数。</p>
<p>代码实例（本示例不包含目录递归功能，<a href="https://github.com/Unknwon/go-compresser/blob/master/go-zip.go">完整实例</a>）：</p>
<pre><code>package main

import (
	&quot;os&quot;
	&quot;io&quot;
	&quot;archive/zip&quot;
)

func main() {
	fw, err := os.Create(&quot;demo.zip&quot;)	// 创建zip包文件，返回*io.Writer
	handleError(err)	// handleError为错误处理函数，下同
	defer fw.Close()
	
	// 实例化新的zip.Writer
	zw := zip.NewWriter(fw)
	defer zw.Close()
	
	// 获取要打包的文件的内容
	fr, err = os.Open(&quot;demo.txt&quot;)
	handleError(err)
	defer fr.Close()
	
	// 获取文件信息
	fi, err = fr.Sata()
	handleError(err)
	
	// 创建zip.FileHeader
	fh := new(zip.FileHeader)
	fh.Name = fi.Name()
	fh.UncompressedSize = uint32(fi.Size())
	fw, err := zw.CreateHeader(fh)
	handleError(err)

	// 读取文件数据
	buf := make([]byte, fi.Size())
	_, err = fr.Read(buf)
	handleError(err)

	// 写入数据到zip包
	_, err = fw.Write(buf)
	handleError(err)
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bufio包函数列表"><a class="header" href="#bufio包函数列表">bufio包函数列表</a></h1>
<h3 id="variables"><a class="header" href="#variables">Variables</a></h3>
<pre><code>var (
	ErrInvalidUnreadByte = errors.New(&quot;bufio: invalid use of UnreadByte&quot;)
	ErrInvalidUnreadRune = errors.New(&quot;bufio: invalid use of UnreadRune&quot;)
	ErrBufferFull        = errors.New(&quot;bufio: buffer full&quot;)
	ErrNegativeCount     = errors.New(&quot;bufio: negative count&quot;)
)
</code></pre>
<h3 id="type-readwriter"><a class="header" href="#type-readwriter">type ReadWriter</a></h3>
<pre><code>type ReadWriter struct {
	*Reader
	*Writer
}
</code></pre>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bufio/ReadWriter.html">func NewReadWriter(r *Reader, w *Writer) *ReadWriter</a></li>
</ul>
<h3 id="type-reader"><a class="header" href="#type-reader">type Reader</a></h3>
<pre><code>type Reader struct {
	// contains filtered or unexported fields
}
</code></pre>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bufio/NewReader.html">func NewReader(rd io.Reader) *Reader</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bufio/NewReaderSize.html">func NewReaderSize(rd io.Reader, size int) *Reader</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bufio/Reader_Buffered.html">func (b *Reader) Buffered() int</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bufio/Reader_Peek.html">func (b *Reader) Peek(n int) ([]byte, error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bufio/Reader_Read.html">func (b *Reader) Read(p []byte) (n int, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bufio/Reader_ReadByte.html">func (b *Reader) ReadByte() (c byte, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bufio/Reader_ReadBytes.html">func (b *Reader) ReadBytes(delim byte) (line []byte, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bufio/Reader_ReadLine.html">func (b *Reader) ReadLine() (line []byte, isPrefix bool, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bufio/Reader_ReadRune.html">func (b *Reader) ReadRune() (r rune, size int, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bufio/Reader_ReadSlice.html">func (b *Reader) ReadSlice(delim byte) (line []byte, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bufio/Reader_ReadString.html">func (b *Reader) ReadString(delim byte) (line string, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bufio/Reader_UnreadByte.html">func (b *Reader) UnreadByte() error</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bufio/Reader_UnreadRune.html">func (b *Reader) UnreadRune() error</a></li>
</ul>
<h3 id="type-writer"><a class="header" href="#type-writer">type Writer</a></h3>
<pre><code>type Writer struct {
	// contains filtered or unexported fields
}
</code></pre>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bufio/NewWriter.html">func NewWriter(wr io.Writer) *Writer</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bufio/NewWriterSize.html">func NewWriterSize(wr io.Writer, size int) *Writer</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bufio/Writer_Available.html">func (b *Writer) Available() int</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bufio/Writer_Buffered.html">func (b *Writer) Buffered() int</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bufio/Writer_Flush.html">func (b *Writer) Flush() error</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bufio/Writer_Write.html">func (b *Writer) Write(p []byte) (nn int, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bufio/Writer_WriteByte.html">func (b *Writer) WriteByte(c byte) error</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bufio/Writer_WriteRune.html">func (b *Writer) WriteRune(r rune) (size int, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bufio/Writer_WriteString.html">func (b *Writer) WriteString(s string) (int, error)</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-newreaderrd-ioreader-reader"><a class="header" href="#func-newreaderrd-ioreader-reader">func NewReader(rd io.Reader) *Reader</a></h2>
<p>参数列表</p>
<ul>
<li>rd io.Reader接口，创建的Reader对象会从此接口读取数据</li>
</ul>
<p>返回值：</p>
<ul>
<li>*Reader</li>
</ul>
<p>功能说明：</p>
<ul>
<li>创建支持缓存读取的具有缺省长度缓冲区的Reader对象，Reader对象会从底层的io.Reader接口读取尽量多的数据进行缓存。</li>
</ul>
<p>代码示例：</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;bufio&quot;
	&quot;fmt&quot;
)

func main() {
	rb := bytes.NewBuffer([]byte(&quot;a string to be read&quot;))
	r := bufio.NewReader(rb)
	var buf [128]byte
	n, _ := r.Read(buf[:])
	fmt.Println(string(buf[:n]))
}
</code></pre>
<p>代码输出：</p>
<pre><code>a string to be read
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-newreadersizerd-ioreader-size-int-reader"><a class="header" href="#func-newreadersizerd-ioreader-size-int-reader">func NewReaderSize(rd io.Reader, size int) *Reader</a></h2>
<p>参数列表</p>
<ul>
<li>rd io.Reader接口，创建的Reader对象会从此接口读取数据</li>
<li>size 指定缓存大小（字节数）</li>
</ul>
<p>返回值：</p>
<ul>
<li>*Reader</li>
</ul>
<p>功能说明：</p>
<ul>
<li>创建的支持缓存读取的具有指定长度缓冲区的Reader对象，Reader对象会从底层的io.Reader接口读取尽量多的数据进行缓存。</li>
</ul>
<p>代码示例：</p>
<p>package main</p>
<pre><code>import (
	&quot;bytes&quot;
	&quot;bufio&quot;
	&quot;fmt&quot;
)

func main() {
	rb := bytes.NewBuffer([]byte(&quot;a string to be read&quot;))
	r := bufio.NewReaderSize(rb, 8192)
	var buf [128]byte
	n, _ := r.Read(buf[:])
	fmt.Println(string(buf[:n]))
}
</code></pre>
<p>代码输出：</p>
<pre><code>a string to be read
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-newwriterwr-iowriter-writer"><a class="header" href="#func-newwriterwr-iowriter-writer">func NewWriter(wr io.Writer) *Writer</a></h2>
<p>参数列表</p>
<ul>
<li>wr io.Writer接口，创建的Writer对象会将数据写入此接口</li>
</ul>
<p>返回值：</p>
<ul>
<li>*Writer</li>
</ul>
<p>功能说明：</p>
<ul>
<li>创建支持缓存写的具有缺省长度缓冲区的Writer对象，Writer对象会将缓存的数据批量写入底层的io.Writer接口</li>
</ul>
<p>代码示例：</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;bufio&quot;
	&quot;fmt&quot;
)

func main() {
	wb := bytes.NewBuffer(nil)
	w := bufio.NewWriter(wb)
	w.Write([]byte(&quot;hello,&quot;))
	w.Write([]byte(&quot;world!&quot;))
	fmt.Printf(&quot;%d:%s\n&quot;, len(wb.Bytes()), string(wb.Bytes()))
	w.Flush()
	fmt.Printf(&quot;%d:%s\n&quot;, len(wb.Bytes()), string(wb.Bytes()))
}
</code></pre>
<p>代码输出：</p>
<pre><code>0:
 12:hello,world! 
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-newwritersizewr-iowriter-size-int-writer"><a class="header" href="#func-newwritersizewr-iowriter-size-int-writer">func NewWriterSize(wr io.Writer, size int) *Writer</a></h2>
<p>参数列表</p>
<ul>
<li>wr io.Writer接口，创建的Writer对象会将数据写入此接口</li>
<li>size 指定的缓冲区大小（字节数）</li>
</ul>
<p>返回值：</p>
<ul>
<li>*Writer</li>
</ul>
<p>功能说明：</p>
<ul>
<li>创建支持缓存写的具有指定长度缓冲区的Writer对象，Writer对象会将缓存的数据批量写入底层的io.Writer接口</li>
</ul>
<p>代码示例：</p>
<p>package main</p>
<pre><code>import (
	&quot;bytes&quot;
	&quot;bufio&quot;
	&quot;fmt&quot;
)

func main() {
	wb := bytes.NewBuffer(nil)
	w := bufio.NewWriterSize(wb, 8192)
	w.Write([]byte(&quot;hello,&quot;))
	w.Write([]byte(&quot;world!&quot;))
	fmt.Printf(&quot;%d:%s\n&quot;, len(wb.Bytes()), string(wb.Bytes()))
	w.Flush()
	fmt.Printf(&quot;%d:%s\n&quot;, len(wb.Bytes()), string(wb.Bytes()))
}
</code></pre>
<p>代码输出：</p>
<pre><code>0:
 12:hello,world! 
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-b-reader-buffered-int"><a class="header" href="#func-b-reader-buffered-int">func (b *Reader) Buffered() int</a></h2>
<p>返回值：</p>
<ul>
<li>int 字节数</li>
</ul>
<p>功能说明：</p>
<ul>
<li>返回可从缓冲区读出数据的字节数</li>
</ul>
<p>代码示例：</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;bufio&quot;
	&quot;fmt&quot;
)

func main() {
	rb := bytes.NewBuffer([]byte(&quot;12345678&quot;))
	r := bufio.NewReader(rb)
	fmt.Println(r.Buffered())
	var buf [4]byte
	r.Read(buf[:])
	fmt.Println(r.Buffered())
	r.Read(buf[:])
	fmt.Println(r.Buffered())
}
</code></pre>
<p>代码输出：</p>
<pre><code>0
4
0
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-b-reader-peekn-int-byte-error"><a class="header" href="#func-b-reader-peekn-int-byte-error">func (b *Reader) Peek(n int) ([]byte, error)</a></h2>
<p>参数列表</p>
<ul>
<li>n 字节数</li>
</ul>
<p>返回值：</p>
<ul>
<li>[]byte 读取到的字节切片</li>
<li>error 错误</li>
</ul>
<p>功能说明：</p>
<ul>
<li>读取指定字节数的数据，这些被读取的数据不会从缓冲区中清除。在下次读取之后，本次返回的字节切片会失效。如果Peek返回的字节数不足n字节，则会同时返回一个错误说明原因。如果n比缓冲区要大，则错误为ErrBufferFull。</li>
</ul>
<p>示例代码：</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;bufio&quot;
	&quot;fmt&quot;
)

func main() {
	rb := bytes.NewBuffer([]byte(&quot;12345678&quot;))
	r := bufio.NewReader(rb)
	b1, _ := r.Peek(4)
	fmt.Println(string(b1))
	b2, _ := r.Peek(8)
	fmt.Println(string(b2))
}
</code></pre>
<p>代码输出：</p>
<pre><code>1234
12345678
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-b-reader-readp-byte-n-int-err-error"><a class="header" href="#func-b-reader-readp-byte-n-int-err-error">func (b *Reader) Read(p []byte) (n int, err error)</a></h2>
<p>参数列表：</p>
<ul>
<li>p 用于存放读取的数据的字节切片</li>
</ul>
<p>返回值</p>
<ul>
<li>n 读取的字节数</li>
<li>err 错误</li>
</ul>
<p>功能说明</p>
<ul>
<li>读取数据存放到p中，返回已读取的字节数。因为最多只调用底层的io.Reader一次，所以返回的n可能小于len(p)。在字节流结束时，n会为0并且err为io.EOF。</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;bufio&quot;
	&quot;fmt&quot;
)

func main() {
	rb := bytes.NewBuffer([]byte(&quot;12345678&quot;))
	r := bufio.NewReader(rb)
	var buf [128]byte
	n, err := r.Read(buf[:])
	fmt.Printf(&quot;%d, %v\n&quot;, n, err)
	fmt.Println(string(buf[:n]))
}
</code></pre>
<p>代码输出</p>
<pre><code>8, &lt;nil&gt;
12345678
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-b-reader-readbyte-c-byte-err-error"><a class="header" href="#func-b-reader-readbyte-c-byte-err-error">func (b *Reader) ReadByte() (c byte, err error)</a></h2>
<p>返回值</p>
<ul>
<li>c 读取的字节</li>
<li>err 错误</li>
</ul>
<p>功能说明</p>
<ul>
<li>读取并返回一个字节。如果没有字节可读，则返回错误。</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;bufio&quot;
	&quot;fmt&quot;
)

func main() {
	rb := bytes.NewBuffer([]byte(&quot;12345678&quot;))
	r := bufio.NewReader(rb)
	b, err := r.ReadByte()
	fmt.Printf(&quot;%c, %v\n&quot;, b, err)
}
</code></pre>
<p>代码输出</p>
<pre><code>1, &lt;nil&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-b-reader-readbytesdelim-byte-line-byte-err-error"><a class="header" href="#func-b-reader-readbytesdelim-byte-line-byte-err-error">func (b *Reader) ReadBytes(delim byte) (line []byte, err error)</a></h2>
<p>参数列表</p>
<ul>
<li>delim 分隔字节</li>
</ul>
<p>返回值</p>
<ul>
<li>line 读取的字节切片</li>
<li>err 错误</li>
</ul>
<p>功能说明</p>
<ul>
<li>ReadBytes读取数据直到delim第一次出现，返回读取的字节序列（包括delim）。如果ReadBytes在读到第一个delim之前出错，它返回已读取的数据和那个错误（通常是io.EOF）。只有当返回的数据不以delim结尾时，返回的err才不为空值。</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;bufio&quot;
	&quot;fmt&quot;
)

func main() {
	rb := bytes.NewBuffer([]byte(&quot;123$456&quot;))
	r := bufio.NewReader(rb)
	b, err := r.ReadBytes('$')
	fmt.Printf(&quot;%s, %v\n&quot;, string(b), err)
}
</code></pre>
<p>代码输出</p>
<pre><code>123$, &lt;nil&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-b-reader-readline-line-byte-isprefix-bool-err-error"><a class="header" href="#func-b-reader-readline-line-byte-isprefix-bool-err-error">func (b *Reader) ReadLine() (line []byte, isPrefix bool, err error)</a></h2>
<p>返回值</p>
<ul>
<li>line 对应于一行的字节切片</li>
<li>isPrefix 返回的line是否因为太长而被裁减</li>
<li>err 错误</li>
</ul>
<p>功能说明</p>
<ul>
<li>ReadLine是一个低级的用于读取一行数据的原语。大多数调用者应该使用ReadBytes('\n')或者ReadString('\n')。ReadLine试图返回一行，不包括结尾的回车字符。如果一行太长了（超过缓冲区长度），isPrefix会设置为true并且只返回前面的数据，剩余的数据会在以后的调用中返回。当返回最后一行数据时，isPrefix会设置为false。返回的字节切片只在下一次调用ReadLine前有效。ReadLine或者返回一个非空的字节切片或者返回一个错误，但它们不会同时返回。</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bufio&quot;
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func main() {
	rb := bytes.NewBuffer([]byte(&quot;123\r\n456&quot;))
	r := bufio.NewReader(rb)
	line, prefix, err := r.ReadLine()
	if err == nil {
		fmt.Printf(&quot;%v, %s, %v\n&quot;, line, string(line), prefix)
	}
}
</code></pre>
<p>代码输出</p>
<pre><code>[49 50 51], 123, false
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-b-reader-readrune-r-rune-size-int-err-error"><a class="header" href="#func-b-reader-readrune-r-rune-size-int-err-error">func (b *Reader) ReadRune() (r rune, size int, err error)</a></h2>
<p>返回值</p>
<ul>
<li>r 一个Unicode字符</li>
<li>size r所占的字节数</li>
<li>err 错误</li>
</ul>
<p>功能说明</p>
<ul>
<li>ReadRune读取一个UTF-8编码的字符，并将其对应的Unicode编码和所占字节数返回。如果编码错误，ReadRune只读取一个字节并返回unicode.ReplacementChar(U+FFFD)和长度1。</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bufio&quot;
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func main() {
	b := []byte(&quot;你好世界&quot;)
	rb := bytes.NewBuffer(b)
	r := bufio.NewReader(rb)
	c, size, err := r.ReadRune()
	if err == nil {
		fmt.Println(string(c))
		fmt.Printf(&quot;%x, %d\n&quot;, c, size)
		fmt.Printf(&quot;%x\n&quot;, b[:size])
	}
}
</code></pre>
<p>代码输出</p>
<pre><code>你
4f60, 3
e4bda0
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-b-reader-readslicedelim-byte-line-byte-err-error"><a class="header" href="#func-b-reader-readslicedelim-byte-line-byte-err-error">func (b *Reader) ReadSlice(delim byte) (line []byte, err error)</a></h2>
<p>参数说明</p>
<ul>
<li>delim 分隔字节</li>
</ul>
<p>返回值</p>
<ul>
<li>line 字节切片</li>
<li>err 错误</li>
</ul>
<p>功能说明</p>
<ul>
<li>ReadSlice读取数据直到delim出现，并返回读取数据的字节切片。下次读取数据时返回的切片会失效。如果ReadSlice在查找到delim之前遇到错误，它返回读取的所有数据和那个错误（通常是io.EOF）。如果缓冲区满时也没有查找到delim，则返回ErrBufferFull错误。因为ReadSlice返回的数据会在下次I/O操作时被覆盖，大多数调用者应该使用ReadBytes或者ReadString。只有当line不以delim结尾时，ReadSlice才会返回非空err。</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bufio&quot;
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func main() {
	rb := bytes.NewBuffer([]byte(&quot;1234$56789&quot;))
	r := bufio.NewReader(rb)
	line, err := r.ReadSlice('$')
	if err != nil {
		return
	}
	fmt.Println(string(line))
	r.ReadSlice('$')
	fmt.Println(string(line))
}
</code></pre>
<p>代码输出</p>
<pre><code>1234$
56789
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-b-reader-readstringdelim-byte-line-string-err-error"><a class="header" href="#func-b-reader-readstringdelim-byte-line-string-err-error">func (b *Reader) ReadString(delim byte) (line string, err error)</a></h2>
<p>参数说明</p>
<ul>
<li>delim 分隔字节</li>
</ul>
<p>返回值</p>
<ul>
<li>line 返回的字符串</li>
<li>err 错误</li>
</ul>
<p>功能说明</p>
<ul>
<li>ReadString读取数据直到delim第一次出现，返回一个包含delim的字符串。如果ReadString在读取到delim前遇到错误，它返回已读字符串和那个错误（通常是io.EOF）。只有当返回的字符串不以delim结尾时，ReadString才返回非空err。</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bufio&quot;
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func main() {
	rb := bytes.NewBuffer([]byte(&quot;1234$5678&quot;))
	r := bufio.NewReader(rb)
	line, err := r.ReadString('$')
	if err == nil {
		fmt.Println(line)
	}
}
</code></pre>
<p>代码输出</p>
<pre><code>1234$
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-b-reader-unreadbyte-error"><a class="header" href="#func-b-reader-unreadbyte-error">func (b *Reader) UnreadByte() error</a></h2>
<p>返回值</p>
<ul>
<li>error 错误</li>
</ul>
<p>功能说明</p>
<ul>
<li>UnreadByte取消已读取的最后一个字节（即把字节重新放回读取缓冲区的前部）。只有最近一次读取的单个字节才能取消读取。</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bufio&quot;
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func main() {
	rb := bytes.NewBuffer([]byte(&quot;1234,56$&quot;))
	r := bufio.NewReader(rb)
	line, _ := r.ReadSlice(',')
	fmt.Println(string(line))
	// unread ','
	fmt.Println(r.UnreadByte())
	line, _ = r.ReadSlice('$')
	fmt.Println(string(line))
}
</code></pre>
<p>代码输出</p>
<pre><code>1234,
&lt;nil&gt;
,56$
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-b-reader-unreadrune-error"><a class="header" href="#func-b-reader-unreadrune-error">func (b *Reader) UnreadRune() error</a></h2>
<p>返回值</p>
<ul>
<li>error 错误</li>
</ul>
<p>功能说明</p>
<ul>
<li>UnreadRune取消读取最后一次读取的Unicod字符。如果最后一次读取操作不是ReadRune，UnreadRune会返回一个错误（在这方面它比UnreadByte更严格，因为UnreadByte会取消上次任意读操作的最后一个字节）。</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bufio&quot;
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func main() {
	rb := bytes.NewBuffer([]byte(&quot;123456&quot;))
	r := bufio.NewReader(rb)
	r.ReadByte()
	// error occurs
	fmt.Println(r.UnreadRune())
	c, _, _ := r.ReadRune()
	fmt.Printf(&quot;read %s\n&quot;, string(c))
	// no error happens
	fmt.Println(r.UnreadRune())
	c, _, _ = r.ReadRune()
	fmt.Printf(&quot;read %s\n&quot;, string(c))
}
</code></pre>
<p>代码输出</p>
<pre><code>bufio: invalid use of UnreadRune
read 2
&lt;nil&gt;
read 2
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-newreadwriterr-reader-w-writer-readwriter"><a class="header" href="#func-newreadwriterr-reader-w-writer-readwriter">func NewReadWriter(r *Reader, w *Writer) *ReadWriter</a></h2>
<p>参数列表</p>
<ul>
<li>r 要读取的来源Reader</li>
<li>w 要写入的目的Writer</li>
</ul>
<p>返回值:</p>
<ul>
<li>*ReadWriter</li>
</ul>
<p>功能说明：</p>
<ul>
<li>这个函数根据指定的Reader和Writer创建一个ReadWriter对象</li>
</ul>
<p>代码示例：</p>
<pre><code>package main

import (
	&quot;bufio&quot;
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func main() {
	rb := bytes.NewBuffer([]byte(&quot;a string to be read&quot;))
	wb := bytes.NewBuffer(nil)
	r := bufio.NewReader(rb)
	w := bufio.NewWriter(wb)
	rw := bufio.NewReadWriter(r, w)
	// use rw to read
	var rbuf [128]byte
	if n, err := rw.Read(rbuf[:]); err != nil {
		return
	} else {
		fmt.Println(string(rbuf[:n]))
	}
	// use rw to write
	if _, err := rw.Write([]byte(&quot;a string to be written&quot;)); err != nil {
		return
	}
	rw.Flush()
	fmt.Println(string(wb.Bytes()))
}
</code></pre>
<p>代码输出：</p>
<pre><code>a string to be read
a string to be written
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-b-writer-available-int"><a class="header" href="#func-b-writer-available-int">func (b *Writer) Available() int</a></h2>
<p>返回值</p>
<ul>
<li>int 字节数</li>
</ul>
<p>功能说明</p>
<ul>
<li>Available返回缓冲区中未使用的字节数</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bufio&quot;
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func main() {
	wb := bytes.NewBuffer(nil)
	w := bufio.NewWriter(wb)
	fmt.Println(w.Available())
	w.WriteByte('1')
	fmt.Println(w.Available())
}
</code></pre>
<p>代码输出</p>
<pre><code>4096
4095
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-b-writer-buffered-int"><a class="header" href="#func-b-writer-buffered-int">func (b *Writer) Buffered() int</a></h2>
<p>返回值</p>
<ul>
<li>int 字节数</li>
</ul>
<p>功能说明</p>
<ul>
<li>返回已写入当前缓冲区中的字节数</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bufio&quot;
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func main() {
	wb := bytes.NewBuffer(nil)
	w := bufio.NewWriter(wb)
	fmt.Println(w.Buffered())
	w.WriteByte('1')
	fmt.Println(w.Buffered())
	w.Flush()
	fmt.Println(w.Buffered())
}
</code></pre>
<p>代码输出</p>
<pre><code>0
1
0
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-b-writer-flush-error"><a class="header" href="#func-b-writer-flush-error">func (b *Writer) Flush() error</a></h2>
<p>返回值</p>
<ul>
<li>error 错误</li>
</ul>
<p>功能说明</p>
<ul>
<li>Flush把缓冲区中的数据写入底层的io.Writer</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bufio&quot;
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func main() {
	wb := bytes.NewBuffer(nil)
	w := bufio.NewWriter(wb)
	w.Write([]byte(&quot;123456&quot;))
	fmt.Printf(&quot;%d:%s\n&quot;, len(wb.Bytes()), string(wb.Bytes()))
	w.Flush()
	fmt.Printf(&quot;%d:%s\n&quot;, len(wb.Bytes()), string(wb.Bytes()))
}
</code></pre>
<p>代码输出</p>
<pre><code>0:
6:123456
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-b-writer-writep-byte-nn-int-err-error"><a class="header" href="#func-b-writer-writep-byte-nn-int-err-error">func (b *Writer) Write(p []byte) (nn int, err error)</a></h2>
<p>参数说明</p>
<ul>
<li>p 要写入的字节切片</li>
</ul>
<p>返回值</p>
<ul>
<li>nn 已写的字节数</li>
<li>err 错误</li>
</ul>
<p>功能说明</p>
<ul>
<li>Write把p写入缓冲区，返回已写入的字节数。如果nn小于len(p)，则同时返回一个错误说明原因。</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bufio&quot;
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func main() {
	wb := bytes.NewBuffer(nil)
	w := bufio.NewWriter(wb)
	n, err := w.Write([]byte(&quot;123456&quot;))
	if err != nil {
		return
	}
	fmt.Println(n)
	w.Flush()
	fmt.Println(string(wb.Bytes()))
}
</code></pre>
<p>代码输出</p>
<pre><code>6
123456
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-b-writer-writebytec-byte-error"><a class="header" href="#func-b-writer-writebytec-byte-error">func (b *Writer) WriteByte(c byte) error</a></h2>
<p>参数说明</p>
<ul>
<li>c 要写入的字节</li>
</ul>
<p>返回值</p>
<ul>
<li>error 错误</li>
</ul>
<p>功能说明</p>
<ul>
<li>写入一个字节</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bufio&quot;
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func main() {
	wb := bytes.NewBuffer(nil)
	w := bufio.NewWriter(wb)
	w.WriteByte('a')
	w.Flush()
	fmt.Println(string(wb.Bytes()))
}
</code></pre>
<p>代码输出</p>
<pre><code>a
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-b-writer-writeruner-rune-size-int-err-error"><a class="header" href="#func-b-writer-writeruner-rune-size-int-err-error">func (b *Writer) WriteRune(r rune) (size int, err error)</a></h2>
<p>参数说明</p>
<ul>
<li>r 要写入的Unicode字符</li>
</ul>
<p>返回值</p>
<ul>
<li>size 写入的字节数</li>
<li>err 错误</li>
</ul>
<p>功能说明</p>
<ul>
<li>WriteRune以UTF-8编码写入一个Unicode字符，返回写入的字节数和错误。</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bufio&quot;
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func main() {
	wb := bytes.NewBuffer(nil)
	w := bufio.NewWriter(wb)
	n, err := w.WriteRune('你')
	if err != nil {
		return
	}
	w.Flush()
	fmt.Println(n)
	fmt.Println(wb.Bytes())
}
</code></pre>
<p>代码输出</p>
<pre><code>3
[228 189 160]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-b-writer-writestrings-string-int-error"><a class="header" href="#func-b-writer-writestrings-string-int-error">func (b *Writer) WriteString(s string) (int, error)</a></h2>
<p>参数说明</p>
<ul>
<li>s 要写入的字符串</li>
</ul>
<p>返回值</p>
<ul>
<li>int 写入字节数</li>
<li>error 错误</li>
</ul>
<p>功能说明</p>
<ul>
<li>WriteString写入一个字符串，返回写入的字节数。如果返回的字节数小于len(s)，则同时返回一个错误说明原因。</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bufio&quot;
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func main() {
	wb := bytes.NewBuffer(nil)
	w := bufio.NewWriter(wb)
	n, err := w.WriteString(&quot;123456&quot;)
	if err != nil {
		return
	}
	fmt.Println(n)
}
</code></pre>
<p>代码输出</p>
<pre><code>6
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="builtin"><a class="header" href="#builtin">builtin</a></h1>
<h2 id="概述"><a class="header" href="#概述">概述</a></h2>
<p>builtin 包为Go的预声明标识符提供了文档. 此处列出的条目其实并不在 buildin 包中，对它们的描述只是为了让 godoc 给该语言的特殊标识符提供文档。</p>
<p>##包函数列表</p>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/builtin/append.html">func append(slice []Type, elems ...Type) []Type</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/builtin/close.html">func close(c chan&lt;- Type)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/builtin/delete.html">func delete(m map[Type]Type1, key Type)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/builtin/panic.html">func panic(v interface{})</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/builtin/recover.html">func recover() interface{}</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/builtin/ComplexType.html">type ComplexType</a>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/builtin/complex.html">func complex(r, i FloatType) ComplexType</a></li>
</ul>
</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/builtin/FloatType.html">type FloatType</a>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/builtin/imag.html">func imag(c ComplexType) FloatType</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/builtin/real.html">func real(c ComplexType) FloatType</a></li>
</ul>
</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/builtin/IntegerType.html">type IntegerType</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/builtin/Type.html">type Type</a>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/builtin/make.html">func make(Type, size IntegerType) Type</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/builtin/new.html">func new(Type) *Type</a></li>
</ul>
</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/builtin/Type1.html">type Type1</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/builtin/bool.html">type bool</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/builtin/byte.html">type byte</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/builtin/complex128.html">type complex128</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/builtin/complex64.html">type complex64</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/builtin/error.html">type error</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/builtin/float32.html">type float32</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/builtin/float64.html">type float64</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/builtin/int.html">type int</a>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/builtin/cap.html">func cap(v Type) int</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/builtin/copy.html">func copy(dst, src []Type) int</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/builtin/len.html">func len(v Type) int</a></li>
</ul>
</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/builtin/int16.html">type int16</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/builtin/int32.html">type int32</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/builtin/int64.html">type int64</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/builtin/int8.html">type int8</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/builtin/rune.html">type rune</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/builtin/string.html">type string</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/builtin/uint.html">type uint</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/builtin/uint16.html">type uint16</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/builtin/uint32.html">type uint32</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/builtin/uint64.html">type uint64</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/builtin/uint8.html">type uint8</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/builtin/uintptr.html">type uintptr</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-appendslice-type-elems-type-type"><a class="header" href="#func-appendslice-type-elems-type-type">func append(slice []Type, elems ...Type) []Type</a></h2>
<p>参数列表：</p>
<ul>
<li>slice Type类型切片</li>
<li>elems Type类型元素</li>
<li>... 更多的Type类型元素</li>
</ul>
<p>返回值：</p>
<ul>
<li>Type类型切片</li>
</ul>
<p>功能说明：</p>
<p>append 内建函数将元素追加到切片的末尾。 若它有足够的容量，其目标就会重新切片以容纳新的元素。否则，就会分配一个新的基本数组。 append 返回更新后的切片。因此必须存储追加后的结果，通常为包含该切片自身的变量：</p>
<pre><code class="language-go">slice = append(slice, elem1, elem2)
slice = append(slice, anotherSlice...)
</code></pre>
<p>代码实例：</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
	a := []int{1, 2, 3, 4, 5}
	s := a[1:3]
	c := append(s, 6)
	fmt.Println(&quot;a ==&quot;, a[:cap(a)])
	fmt.Println(&quot;s ==&quot;, s[:cap(s)])
	fmt.Println(&quot;c ==&quot;, c[:cap(c)])

	d := append(a, 6)
	fmt.Println(&quot;a ==&quot;, a[:cap(a)])
	fmt.Println(&quot;d ==&quot;, d[:cap(d)])
}
</code></pre>
<p>输出:</p>
<pre><code>a == [1 2 3 6 5]
s == [2 3 6 5]
c == [2 3 6 5]
a == [1 2 3 6 5]
d == [1 2 3 6 5 6 0 0 0 0]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="type-bool-bool"><a class="header" href="#type-bool-bool">type bool bool</a></h2>
<p>功能说明：</p>
<p>bool 是布尔值的集合，即 true 和 false。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="type-byte-byte"><a class="header" href="#type-byte-byte">type byte byte</a></h2>
<p>功能说明：</p>
<p>byte 为 uint8 的别名，它完全等价于 uint8。 习惯上用它来区别字节值和8位无符号整数值。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-capv-type-int"><a class="header" href="#func-capv-type-int">func cap(v Type) int</a></h2>
<p>参数列表：</p>
<ul>
<li>v Type</li>
</ul>
<p>返回值：</p>
<ul>
<li>int</li>
</ul>
<p>功能说明：</p>
<p>cap 内建函数返回 v 的容量，返回值取决 v 的具体类型：</p>
<p>数组：v 中元素的数量（与 len(v) 相同）。</p>
<p>数组指针：*v 中元素的数量（与 len(v) 相同）。</p>
<p>切片：在重新切片时，切片能够达到的最大缓存长度；若 v 为 nil，len(v) 即为零。</p>
<p>信道：以信道元素数量为单位返回信道缓存容量；若 v 为 nil，len(v) 即为零。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-closec-chan--type"><a class="header" href="#func-closec-chan--type">func close(c chan&lt;- Type)</a></h2>
<p>参数列表：</p>
<ul>
<li>c 信道</li>
</ul>
<p>返回值：</p>
<ul>
<li>无</li>
</ul>
<p>功能说明：</p>
<p>close 内建函数关闭信道，该信道必须为双向的或只发送的。 它只能由发送者执行，不应由接收者执行，其效果是在最后发送的值被接收后停止该信道。 已关闭的信道 c 中最后一个值被接收后，任何从信道 c 的接收操作都会无阻塞成功， 关闭的信道会返回该信道元素类型的零值。对于已关闭的信道，形式</p>
<pre><code class="language-go">x, ok := &lt;-c
</code></pre>
<p>还会将 ok 置为 false。</p>
<p>代码实例：</p>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
)

func fibonacci(n int, c chan int) {
	x, y := 0, 1
	for i := 0; i &lt; n; i++ {
		c &lt;- x
		x, y = y, x+y
	}
	close(c)	// 因为使用了range调用,必须 close(c)
}

func main() {
	c := make(chan int, 10)
	go fibonacci(cap(c), c)
	for i := range c {	// range 会不断从 channel 接收值，直到它被关闭。
		fmt.Println(i)
	}
}
</code></pre>
<p>输出:</p>
<pre><code>0
1
1
2
3
5
8
13
21
34
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-complexr-i-floattype-complextype"><a class="header" href="#func-complexr-i-floattype-complextype">func complex(r, i FloatType) ComplexType</a></h2>
<p>参数列表：</p>
<ul>
<li>r FloatType 实部</li>
<li>i FloatType 虚部</li>
</ul>
<p>返回值：</p>
<ul>
<li>ComplexType</li>
</ul>
<p>功能说明：</p>
<p>complex 内建函数将两个浮点数值构造成一个复数值。 其实部和虚部的大小必须相同，即 float32 或 float64（或可赋予它们的），其返回值 即为对应的复数类型（complex64 对应 float32，complex128 对应 float64）。</p>
<p>代码实例：</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
	fmt.Println(complex(10, 2))
}
</code></pre>
<p>输出：</p>
<pre><code>(10+2i)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="type-complex128-complex128"><a class="header" href="#type-complex128-complex128">type complex128 complex128</a></h2>
<p>功能说明：</p>
<p>complex128 是所有实部和虚部为 float64 的复数集合。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="type-complex64-complex64"><a class="header" href="#type-complex64-complex64">type complex64 complex64</a></h2>
<p>功能说明：</p>
<p>complex64 是所有实部和虚部为 float32 的复数集合。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="type-complextype-complex64"><a class="header" href="#type-complextype-complex64">type ComplexType complex64</a></h2>
<p>功能说明：</p>
<p>ComplexType 在此只用作文档目的。 它代表所有的复数类型：即 complex64 或 complex128。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-copydst-src-type-int"><a class="header" href="#func-copydst-src-type-int">func copy(dst, src []Type) int</a></h2>
<p>参数列表：</p>
<ul>
<li>dst []Type 与 src 同类型</li>
<li>src []Type</li>
</ul>
<p>返回值：</p>
<ul>
<li>int 返回被复制的元素数量</li>
</ul>
<p>功能说明：</p>
<p>copy 内建函数将元素从来源切片复制到目标切片中。 （特殊情况是，它也能将字节从字符串复制到字节切片中）。来源和目标可以重叠。 copy 返回被复制的元素数量，它会是 len(src) 和 len(dst) 中较小的那个。</p>
<p>代码实例：</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
	src := []int{1, 2, 3, 4, 5}
	dst := make([]int, 3)
	len := copy(dst, src[4:])
	fmt.Println(len, dst)
	len = copy(dst, src[0:])
	fmt.Println(len, dst)
	len = copy(dst, src)
	fmt.Println(len, dst)
}
</code></pre>
<p>输出：</p>
<pre><code>1 [5 0 0]
3 [1 2 3]
3 [1 2 3]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-deletem-maptypetype1-key-type"><a class="header" href="#func-deletem-maptypetype1-key-type">func delete(m map[Type]Type1, key Type)</a></h2>
<p>参数列表：</p>
<ul>
<li>m map</li>
<li>key 键</li>
</ul>
<p>返回值：</p>
<ul>
<li>无</li>
</ul>
<p>功能说明：</p>
<p>delete 内建函数按照指定的键将元素从映射中删除。如果元素不存在，delete 为空操作。如果 m 为 nil，delete 引发 panic 错误。</p>
<p>代码实例：</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

type Vertex struct {
	Lat, Long float64
}

var m map[string]Vertex

var nilmap map[string]Vertex

func main() {
	m = make(map[string]Vertex)
	m[&quot;Bell Labs&quot;] = Vertex{
		40.68433, -74.39967,
	}
	delete(m, &quot;key&quot;)
	fmt.Println(m)
	delete(m, &quot;Bell Labs&quot;)
	fmt.Println(m)

	delete(nilmap, &quot;key&quot;)

}
</code></pre>
<p>输出:</p>
<pre><code>map[Bell Labs:{40.68433 -74.39967}]
map[]
panic: runtime error: deletion of entry in nil map

goroutine 1 [running]:
main.main()
	/tmpfs/gosandbox-ffb3cedf_c062e804_9b5b7ada_f200355f_78578d79/prog.go:23 +0x1e0
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="type-error"><a class="header" href="#type-error">type error</a></h2>
<pre><code class="language-go">type error interface {
    Error() string
}
</code></pre>
<p>功能说明：</p>
<p>error 内建接口类型是表示错误情况的约定接口，nil 值即表示没有错误。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="type-float32-float32"><a class="header" href="#type-float32-float32">type float32 float32</a></h2>
<p>功能说明：</p>
<p>float32 是所有IEEE-754 32位浮点数的集合。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="type-float64-float64"><a class="header" href="#type-float64-float64">type float64 float64</a></h2>
<p>功能说明：</p>
<p>float64 是所有IEEE-754 64位浮点数的集合。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="type-floattype-float32"><a class="header" href="#type-floattype-float32">type FloatType float32</a></h2>
<p>功能说明：</p>
<p>FloatType 在此只用作文档目的。 它代表所有的浮点数类型：即 float32 或 float64。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-imagc-complextype-floattype"><a class="header" href="#func-imagc-complextype-floattype">func imag(c ComplexType) FloatType</a></h2>
<p>参数列表：</p>
<ul>
<li>c ComplexType 复数</li>
</ul>
<p>返回值：</p>
<ul>
<li>FloatType 复数 c 的虚部</li>
</ul>
<p>功能说明：</p>
<p>imag 内建函数返回复数 c 的虚部。 返回值类型与 c 的浮点类型对应。</p>
<p>代码实例：</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
	fmt.Println(imag(10 + 2i))
}
</code></pre>
<p>输出：</p>
<pre><code>2
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="type-int-int"><a class="header" href="#type-int-int">type int int</a></h2>
<p>功能说明：</p>
<p>int 是带符号整数类型，其大小至少为32位。 它是一种确切的类型，而不是 int32 的别名。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="type-int16-int16"><a class="header" href="#type-int16-int16">type int16 int16</a></h2>
<p>功能说明：</p>
<p>int16 是所有带符号16位整数的集合。 范围：-32768 至 32767。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="type-int32-int32"><a class="header" href="#type-int32-int32">type int32 int32</a></h2>
<p>功能说明：</p>
<p>int32 是所有带符号32位整数的集合。范围: -2147483648 至 2147483647。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="type-int64-int64"><a class="header" href="#type-int64-int64">type int64 int64</a></h2>
<p>功能说明：</p>
<p>int64 是所有带符号64位整数的集合。 范围：-9223372036854775808 至 9223372036854775807。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="type-int8-int8"><a class="header" href="#type-int8-int8">type int8 int8</a></h2>
<p>功能说明：</p>
<p>int8 是所有带符号8位整数的集合。 范围：-128 至 127。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="type-integertype-int"><a class="header" href="#type-integertype-int">type IntegerType int</a></h2>
<p>功能说明：</p>
<p>IntegerType 在此只用作文档目的。 它代表所有的整数类型：如 int、uint、int8 等。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-lenv-type-int"><a class="header" href="#func-lenv-type-int">func len(v Type) int</a></h2>
<p>参数列表：</p>
<ul>
<li>v Type 要计算的值</li>
</ul>
<p>返回值：</p>
<ul>
<li>int 返回 v 的长度</li>
</ul>
<p>功能说明：</p>
<p>len 内建函数返回 v 的长度，这取决于具体类型：</p>
<pre><code>数组：v 中元素的数量。
数组指针：*v 中元素的数量（即使 v 为 nil）。
切片或映射：v 中元素的数量；若 v 为 nil，len(v) 即为零。
字符串：v 中字节的数量。
信道：信道缓存中队列（未读取）元素的数量；若 v 为 nil，len(v) 即为零。
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-maketype-size-integertype-type"><a class="header" href="#func-maketype-size-integertype-type">func make(Type, size IntegerType) Type</a></h2>
<p>参数列表：</p>
<ul>
<li>Type 类型 slice,map,chan 之一</li>
<li>size IntegerType </li>
</ul>
<p>返回值：</p>
<ul>
<li>Type</li>
</ul>
<p>功能说明：</p>
<p>make 内建函数分配并初始化一个类型为切片、映射、或（仅仅为）信道的对象。 与 new 相同的是，其第一个实参为类型，而非值。不同的是，make 的返回类型 与其参数相同，而非指向它的指针。其具体结果取决于具体的类型：</p>
<pre><code>slice：
	size 指定了切片长度。该切片的容量等于其长度。
	第二个整数实参可用来指定不同的容量；
	它必须不小于其长度，因此 make([]int, 0, 10) 
	会分配一个长度为0，	容量为10的切片。
map：
	初始分配取决于 size，但产生的 map 长度为0。
	size 可以省略，这种情况下就会分配一个最小的起始容量。
chan：
	信道的缓存根据指定的缓存容量初始化。
	若 size 为零或被省略，该信道即为无缓存的。
</code></pre>
<p>代码实例：</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
    a := make([]int, 5)
    printSlice(&quot;a&quot;, a)
    b := make([]int, 0, 5)
    printSlice(&quot;b&quot;, b)
    c := b[:2]
    printSlice(&quot;c&quot;, c)
    d := c[2:5]
    printSlice(&quot;d&quot;, d)
}

func printSlice(s string, x []int) {
    fmt.Printf(&quot;%s len=%d cap=%d %v\n&quot;,
        s, len(x), cap(x), x)
}
</code></pre>
<p>输出：</p>
<pre><code>a len=5 cap=5 [0 0 0 0 0]
b len=0 cap=5 []
c len=2 cap=5 [0 0]
d len=3 cap=3 [0 0 0]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-newtype-type"><a class="header" href="#func-newtype-type">func new(Type) *Type</a></h2>
<p>参数列表：</p>
<ul>
<li>Type</li>
</ul>
<p>返回值：</p>
<ul>
<li>*Type</li>
</ul>
<p>功能说明：</p>
<p>new 内建函数分配内存。 其第一个实参为类型，而非值，其返回值为指向该类型新分配的零值的指针。</p>
<p>代码实例：</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

type Vertex struct {
    X, Y int
}

func main() {
    var d Vertex
    v := new(Vertex)
    d.X =8
    fmt.Println(v,d)
    v.X, v.Y = 11, 9
    fmt.Println(v)
}
</code></pre>
<p>输出：</p>
<pre><code>&amp;{0 0} {8 0}
&amp;{11 9}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-panicv-interface"><a class="header" href="#func-panicv-interface">func panic(v interface{})</a></h2>
<p>参数列表：</p>
<ul>
<li>v 接口</li>
</ul>
<p>返回值：</p>
<ul>
<li>无</li>
</ul>
<p>功能说明：</p>
<p>panic 内建函数停止当前 goroutine 的正常执行。 当函数 F 调用 panic，函数 F 的执行被终止，并且 F 中的延迟函数会正常执行，然后 F 返回到调用它的地方。对于调用者 G，F 的行为就像调用了 panic，即终止 G 的执行并运行所有被推迟的函数。这一过程会到该程序中所有函数都按相反的顺序停止执行之后。此时，该程序会被终止，并产生错误报告， 包括引发该 panic 的实参值。此终止序列称为恐慌过程，可以通过内建函数 recover 控制。</p>
<p>代码实例：</p>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
)

func f() {
	defer func() {
		fmt.Println(&quot;f() defer&quot;)
	}()
	fmt.Println(&quot;f() before panic&quot;)
	panic(0)
	// 此后的代码不会被执行
	fmt.Println(&quot;after panic&quot;)
	defer func() {
		fmt.Println(&quot;f() defer agin&quot;)
	}()
}
func g() {
	defer func() {
		fmt.Println(&quot;g() defer&quot;)
	}()
	f()
	// 此后的代码不会被执行
	fmt.Println(&quot;after call f()&quot;)
}
func main() {
	g()
}
</code></pre>
<p>输出:</p>
<pre><code>f() before panic
f() defer
g() defer
panic: 0

goroutine 1 [running]:
main.f()
	/tmpfs/gosandbox-28b34fa2_537076fc_b472688a_9fdc0e9b_cba83d95/prog.go:12 +0xc9
main.g()
	/tmpfs/gosandbox-28b34fa2_537076fc_b472688a_9fdc0e9b_cba83d95/prog.go:23 +0x2f
main.main()
	/tmpfs/gosandbox-28b34fa2_537076fc_b472688a_9fdc0e9b_cba83d95/prog.go:28 +0x18
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-realc-complextype-floattype"><a class="header" href="#func-realc-complextype-floattype">func real(c ComplexType) FloatType</a></h2>
<p>参数列表：</p>
<ul>
<li>c ComplexType 复数</li>
</ul>
<p>返回值：</p>
<ul>
<li>FloatType 复数 c 的实部</li>
</ul>
<p>功能说明：</p>
<p>real 内建函数返回复数 c 的实部。 返回值类型与 c 的浮点类型对应。</p>
<p>代码实例：</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
	fmt.Println(real(10 + 2i))
}
</code></pre>
<p>输出：</p>
<pre><code>10
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-recover-interface"><a class="header" href="#func-recover-interface">func recover() interface{}</a></h2>
<p>参数列表：</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>interface{}</li>
</ul>
<p>功能说明：</p>
<p>recover 内建函数使程序可以管理恐慌中的 goroutine 。 recover 在推迟函数（其它函数总是返回 nil）中调用，通过执行 recover 停止恐慌过程序列并取回传至 panic 的参数值，恢复正常的执行。若 recover 不在推迟函数中被调用， 它将不会停止恐慌过程序列。在此情况下或该 goroutine 不在恐慌过程中，或提供给 panic 的实参为 nil ，recover 就会返回 nil。因此 recover 的返回值就报告了该 goroutine 是否进入恐慌过程序列。</p>
<p>代码实例：</p>
<pre><code class="language-go">// Go Try catch 版 Hello World
package main

import (
	&quot;fmt&quot;
)

func Try(fun func(), catch func(interface{})) {
	defer func() {
		if err := recover(); err != nil {
			catch(err)
		}
	}()
	fun()
}
func say(s string) {
	fmt.Println(s)
}
func main() {
	say(&quot;Hello&quot;)
	Try(
		func() {
			panic(&quot;World&quot;)
		},
		func(e interface{}) {
			fmt.Println(&quot;catch&quot;, e)
		})
	say(&quot;end&quot;)
}

</code></pre>
<p>输出:</p>
<pre><code>Hello
catch World
end
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="type-rune-rune"><a class="header" href="#type-rune-rune">type rune rune</a></h2>
<p>功能说明：</p>
<p>rune 为 int32 的别名，它完全等价于 int32。 习惯上用它来区别字符值和整数值。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="type-string-string"><a class="header" href="#type-string-string">type string string</a></h2>
<p>功能说明：</p>
<p>string 是所有8位字节的字符串集合，习惯上用于代表以UTF-8编码的文本，但并不必须如此。 string 可为空，但不为 nil。string 类型的值是不变的。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="type-type-int"><a class="header" href="#type-type-int">type Type int</a></h2>
<p>功能说明：</p>
<p>Type 在此只用作文档目的。 它代表所有Go的类型，但对于任何给定的函数请求来说，它都代表与其相同的类型。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="type-type1-int"><a class="header" href="#type-type1-int">type Type1 int</a></h2>
<p>功能说明：</p>
<p>Type1 在此只用作文档目的。 它代表所有Go的类型，但对于任何给定的函数请求来说，它都代表与其相同的类型。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="type-uint-uint"><a class="header" href="#type-uint-uint">type uint uint</a></h2>
<p>功能说明：</p>
<p>uint 是无符号整数类型，其大小至少为32位。 它是一种确切的类型，而不是 uint32 的别名。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="type-uint16-uint16"><a class="header" href="#type-uint16-uint16">type uint16 uint16</a></h2>
<p>功能说明：</p>
<p>uint16 是所有无符号16位整数的集合。 范围：0 至 65535。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="type-uint32-uint32"><a class="header" href="#type-uint32-uint32">type uint32 uint32</a></h2>
<p>功能说明：</p>
<p>uint32 是所有无符号32位整数的集合。 范围：0 至 4294967295。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="type-uint64-uint64"><a class="header" href="#type-uint64-uint64">type uint64 uint64</a></h2>
<p>功能说明：</p>
<p>uint64 是所有无符号64位整数的集合。 范围：0 至 18446744073709551615。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="type-uint8-uint8"><a class="header" href="#type-uint8-uint8">type uint8 uint8</a></h2>
<p>功能说明：</p>
<p>uint8 是所有无符号8位整数的集合。 范围：0 至 255。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="type-uintptr-uintptr"><a class="header" href="#type-uintptr-uintptr">type uintptr uintptr</a></h2>
<p>功能说明：</p>
<p>uintptr 为整数类型，其大小足以容纳任何指针的位模式。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bytes"><a class="header" href="#bytes">bytes</a></h1>
<p>bytes包实现了用于管理字节切片的函数，类似于strings包。</p>
<h3 id="constants"><a class="header" href="#constants">Constants</a></h3>
<pre><code>const MinRead = 512
</code></pre>
<h3 id="variables-1"><a class="header" href="#variables-1">Variables</a></h3>
<pre><code>var ErrTooLarge = errors.New(&quot;bytes.Buffer: too large&quot;)
</code></pre>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bytes/Compare.html">func Compare(a, b []byte) int</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bytes/Contains.html">func Contains(b, subslice []byte) bool</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bytes/Count.html">func Count(s, sep []byte) int</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bytes/Equal.html">func Equal(a, b []byte) bool</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bytes/EqualFold.html">func EqualFold(s, t []byte) bool</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bytes/Fields.html">func Fields(s []byte) [][]byte</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bytes/FieldsFunc.html">func FieldsFunc(s []byte, f func(rune) bool) [][]byte</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bytes/HasPrefix.html">func HasPrefix(s, prefix []byte) bool</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bytes/HasSuffix.html">func HasSuffix(s, suffix []byte) bool</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bytes/Index.html">func Index(s, sep []byte) int</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bytes/IndexAny.html">func IndexAny(s []byte, chars string) int</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bytes/IndexByte.html">func IndexByte(s []byte, c byte) int</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bytes/IndexFunc.html">func IndexFunc(s []byte, f func(r rune) bool) int</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bytes/IndexRune.html">func IndexRune(s []byte, r rune) int</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bytes/Join.html">func Join(a [][]byte, sep []byte) []byte</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bytes/LastIndex.html">func LastIndex(s, sep []byte) int</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bytes/LastIndexAny.html">func LastIndexAny(s []byte, chars string) int</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bytes/LastIndexFunc.html">func LastIndexFunc(s []byte, f func(r rune) bool) int</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bytes/Map.html">func Map(mapping func(r rune) rune, s []byte) []byte</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bytes/Repeat.html">func Repeat(b []byte, count int) []byte</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bytes/Replace.html">func Replace(s, old, new []byte, n int) []byte</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bytes/Runes.html">func Runes(s []byte) []rune</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bytes/Split.html">func Split(s, sep []byte) [][]byte</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bytes/SplitAfter.html">func SplitAfter(s, sep []byte) [][]byte</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bytes/SplitAfterN.html">func SplitAfterN(s, sep []byte, n int) [][]byte</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bytes/SplitN.html">func SplitN(s, sep []byte, n int) [][]byte</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bytes/Title.html">func Title(s []byte) []byte</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bytes/ToLower.html">func ToLower(s []byte) []byte</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bytes/ToLowerSpecial.html">func ToLowerSpecial(_case unicode.SpecialCase, s []byte) []byte</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bytes/ToTitle.html">func ToTitle(s []byte) []byte</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bytes/ToTitleSpecial.html">func ToTitleSpecial(_case unicode.SpecialCase, s []byte) []byte</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bytes/ToUpper.html">func ToUpper(s []byte) []byte</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bytes/ToUpperSpecial.html">func ToUpperSpecial(_case unicode.SpecialCase, s []byte) []byte</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bytes/Trim.html">func Trim(s []byte, cutset string) []byte</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bytes/TrimFunc.html">func TrimFunc(s []byte, f func(r rune) bool) []byte</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bytes/TrimLeft.html">func TrimLeft(s []byte, cutset string) []byte</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bytes/TrimLeftFunc.html">func TrimLeftFunc(s []byte, f func(r rune) bool) []byte</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bytes/TrimRight.html">func TrimRight(s []byte, cutset string) []byte</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bytes/TrimRightFunc.html">func TrimRightFunc(s []byte, f func(r rune) bool) []byte</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bytes/TrimSpace.html">func TrimSpace(s []byte) []byte</a></li>
</ul>
<h3 id="type-buffer"><a class="header" href="#type-buffer">type Buffer</a></h3>
<pre><code>type Buffer struct {
	// contains filtered or unexported fields
}
</code></pre>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bytes/NewBuffer.html">func NewBuffer(buf []byte) *Buffer</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bytes/NewBufferString.html">func NewBufferString(s string) *Buffer</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bytes/Buffer_Bytes.html">func (b *Buffer) Bytes() []byte</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bytes/Buffer_Len.html">func (b *Buffer) Len() int</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bytes/Buffer_Next.html">func (b *Buffer) Next(n int) []byte</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bytes/Buffer_Read.html">func (b *Buffer) Read(p []byte) (n int, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bytes/Buffer_ReadByte.html">func (b *Buffer) ReadByte() (c byte, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bytes/Buffer_ReadBytes.html">func (b *Buffer) ReadBytes(delim byte) (line []byte, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bytes/Buffer_ReadFrom.html">func (b *Buffer) ReadFrom(r io.Reader) (n int64, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bytes/Buffer_ReadRune.html">func (b *Buffer) ReadRune() (r rune, size int, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bytes/Buffer_ReadString.html">func (b *Buffer) ReadString(delim byte) (line string, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bytes/Buffer_Reset.html">func (b *Buffer) Reset()</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bytes/Buffer_String.html">func (b *Buffer) String() string</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bytes/Buffer_Truncate.html">func (b *Buffer) Truncate(n int)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bytes/Buffer_UnreadByte.html">func (b *Buffer) UnreadByte() error</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bytes/Buffer_UnreadRune.html">func (b *Buffer) UnreadRune() error</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bytes/Buffer_Write.html">func (b *Buffer) Write(p []byte) (n int, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bytes/Buffer_WriteByte.html">func (b *Buffer) WriteByte(c byte) error</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bytes/Buffer_WriteRune.html">func (b *Buffer) WriteRune(r rune) (n int, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bytes/Buffer_WriteString.html">func (b *Buffer) WriteString(s string) (n int, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bytes/Buffer_WriteTo.html">func (b *Buffer) WriteTo(w io.Writer) (n int64, err error)</a></li>
</ul>
<h3 id="type-reader-1"><a class="header" href="#type-reader-1">type Reader</a></h3>
<pre><code>type Reader struct {
	// contains filtered or unexported fields
}
</code></pre>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bytes/NewReader.html">func NewReader(b []byte) *Reader</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bytes/Reader_Len.html">func (r *Reader) Len() int</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bytes/Reader_Read.html">func (r *Reader) Read(b []byte) (n int, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bytes/Reader_ReadAt.html">func (r *Reader) ReadAt(b []byte, off int64) (n int, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bytes/Reader_ReadByte.html">func (r *Reader) ReadByte() (b byte, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bytes/Reader_ReadRune.html">func (r *Reader) ReadRune() (ch rune, size int, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bytes/Reader_Seek.html">func (r *Reader) Seek(offset int64, whence int) (int64, error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bytes/Reader_UnreadByte.html">func (r *Reader) UnreadByte() error</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/bytes/Reader_UnreadRune.html">func (r *Reader) UnreadRune() error</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-indexfuncs-byte-f-funcr-rune-bool-int"><a class="header" href="#func-indexfuncs-byte-f-funcr-rune-bool-int">func IndexFunc(s []byte, f func(r rune) bool) int</a></h2>
<p>参数列表</p>
<ul>
<li>s 要检查的字节切片</li>
<li>f 过滤函数</li>
</ul>
<p>返回值</p>
<ul>
<li>int s中的位置索引（从0开始）</li>
</ul>
<p>功能说明</p>
<ul>
<li>IndexFunc把s解释成UTF-8字节序列，并返回第一个满足f(c)==true的字符c的位置索引；如果没有字符满足f(c)==true则返回-1。</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func main() {
	s := []byte(&quot;你好世界&quot;)
	fmt.Println(bytes.IndexFunc(s, func(r rune) bool {
		return r == '好'
	}))
	fmt.Println(bytes.IndexFunc(s, func(r rune) bool {
		return r == '!'
	}))
}
</code></pre>
<p>代码输出</p>
<pre><code>3
-1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-b-buffer-bytes-byte"><a class="header" href="#func-b-buffer-bytes-byte">func (b *Buffer) Bytes() []byte</a></h2>
<p>返回值</p>
<ul>
<li>[]byte 字节切片</li>
</ul>
<p>功能说明</p>
<ul>
<li>Bytes返回Buffer中未读数据的字节切片，满足len(b.Bytes()) == b.Len()。如果调用者修改了返回字节切片的内容，Buffer中的未读数据也会被修改。</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func main() {
	b := bytes.NewBuffer([]byte(&quot;0123456&quot;))
	unread := b.Bytes()
	fmt.Println(string(unread))
	for i, c := range unread {
		unread[i] = 'A' + c - '0'
	}
	var buff [7]byte
	b.Read(buff[:])
	fmt.Println(string(buff[:]))
}
</code></pre>
<p>代码输出</p>
<pre><code>0123456
ABCDEFG
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-b-buffer-len-int"><a class="header" href="#func-b-buffer-len-int">func (b *Buffer) Len() int</a></h2>
<p>返回值</p>
<ul>
<li>int 字节数</li>
</ul>
<p>功能说明</p>
<ul>
<li>返回Buffer中未读数据的字节数。它满足条件b.Len() == len(b.Bytes())。</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func main() {
	b := bytes.NewBuffer([]byte(&quot;123456&quot;))
	fmt.Println(b.Len())
	var buff [3]byte
	b.Read(buff[:])
	fmt.Println(b.Len())
}
</code></pre>
<p>代码输出</p>
<pre><code>6
3
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-b-buffer-nextn-int-byte"><a class="header" href="#func-b-buffer-nextn-int-byte">func (b *Buffer) Next(n int) []byte</a></h2>
<p>参数列表</p>
<ul>
<li>n 要读取的字节数</li>
</ul>
<p>返回值</p>
<ul>
<li>[]byte 字节切片</li>
</ul>
<p>功能说明</p>
<ul>
<li>Next返回Buffer中下n个未读取的字节并返回，本次读取会修改Buffer中的读取位置。如果Buffer中未读数据不足n自己，则返回全部未读数据。返回的字节切片在下次读或者写前有效。</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func main() {
	b := bytes.NewBuffer([]byte(&quot;123456&quot;))
	fmt.Println(string(b.Next(4)))
	fmt.Println(string(b.Next(4)))
}
</code></pre>
<p>代码输出</p>
<pre><code>1234
56
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-b-buffer-readp-byte-n-int-err-error"><a class="header" href="#func-b-buffer-readp-byte-n-int-err-error">func (b *Buffer) Read(p []byte) (n int, err error)</a></h2>
<p>参数列表</p>
<ul>
<li>p 要存放读取数据的字节切片</li>
</ul>
<p>返回值</p>
<ul>
<li>n 已读取的字节数</li>
<li>err 错误</li>
</ul>
<p>功能说明</p>
<ul>
<li>Read从Buffer中读取len(p)个字节复制到p中；如果Buffer中未读数据不足len(p)则把所有的数据都复制到p中。返回实际读取的字节数。如果Buffer中没有数据，则err为io.EOF（除非len(p)为0）；否则err为nil。</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func main() {
	b := bytes.NewBuffer([]byte(&quot;123456&quot;))
	n, err := b.Read(nil)
	fmt.Printf(&quot;%d, %v\n&quot;, n, err)
	var buff [6]byte
	n, err = b.Read(buff[:])
	fmt.Printf(&quot;%d, %v, %s\n&quot;, n, err, buff[:n])
	n, err = b.Read(buff[:])
	fmt.Printf(&quot;%d, %v, %s\n&quot;, n, err, buff[:n])
}
</code></pre>
<p>代码输出</p>
<pre><code>0, &lt;nil&gt;
6, &lt;nil&gt;, 123456
0, EOF,
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-b-buffer-readbyte-c-byte-err-error"><a class="header" href="#func-b-buffer-readbyte-c-byte-err-error">func (b *Buffer) ReadByte() (c byte, err error)</a></h2>
<p>返回值</p>
<ul>
<li>c 读取的字节</li>
<li>err 错误</li>
</ul>
<p>功能说明</p>
<ul>
<li>ReadByte读取一个字节返回，如果没有数据可读则err为io.EOF。</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func main() {
	b := bytes.NewBuffer([]byte(&quot;123456&quot;))
	c, err := b.ReadByte()
	fmt.Println(c, err)
	fmt.Println(string(b.Bytes()))
}
</code></pre>
<p>代码输出</p>
<pre><code>49 &lt;nil&gt;
23456
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-b-buffer-readbytesdelim-byte-line-byte-err-error"><a class="header" href="#func-b-buffer-readbytesdelim-byte-line-byte-err-error">func (b *Buffer) ReadBytes(delim byte) (line []byte, err error)</a></h2>
<p>参数列表</p>
<ul>
<li>delim 分隔字节</li>
</ul>
<p>返回值</p>
<ul>
<li>line 字节切片</li>
<li>err 错误</li>
</ul>
<p>功能说明</p>
<ul>
<li>ReadBytes读取数据直到第一次遇到delim，把已读取的数据包括delim作为字节切片返回。如果在读取到delim前出现错误，则返回已读取的数据和那个错误（通常是io.EOF）。只有返回的数据不以delim结尾时，ReadBytes才返回err非空。</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func main() {
	b := bytes.NewBuffer([]byte(&quot;123,456&quot;))
	line, err := b.ReadBytes(',')
	fmt.Println(string(line))
	fmt.Println(err)
}
</code></pre>
<p>代码输出</p>
<pre><code>123,
&lt;nil&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-b-buffer-readfromr-ioreader-n-int64-err-error"><a class="header" href="#func-b-buffer-readfromr-ioreader-n-int64-err-error">func (b *Buffer) ReadFrom(r io.Reader) (n int64, err error)</a></h2>
<p>参数列表</p>
<ul>
<li>r io.Reader</li>
</ul>
<p>返回值</p>
<ul>
<li>n 已读取字节数</li>
<li>err 错误</li>
</ul>
<p>功能说明</p>
<ul>
<li>ReadFrom从r中读取数据写入Buffer直到r.Read返回io.EOF，除了io.EOF之外的错误会被ReadFrom返回。返回值n为已读取的字节数，err为r.Read返回的错误。如果读取的数据太大，ReadFrom会panic并产生ErrTooLarge异常。</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func main() {
	r := bytes.NewBuffer([]byte(&quot;123&quot;))
	b := bytes.NewBuffer(nil)
	n, err := b.ReadFrom(r)
	fmt.Println(n, err)
	fmt.Println(string(b.Bytes()))
}
</code></pre>
<p>代码输出</p>
<pre><code>3 &lt;nil&gt;
123
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-b-buffer-readrune-r-rune-size-int-err-error"><a class="header" href="#func-b-buffer-readrune-r-rune-size-int-err-error">func (b *Buffer) ReadRune() (r rune, size int, err error)</a></h2>
<p>返回值</p>
<ul>
<li>r Unicode字符</li>
<li>size r的UTF-8编码占用的字节数</li>
<li>err 错误</li>
</ul>
<p>功能说明</p>
<ul>
<li>ReadRune从Buffer中读取一个Unicode字符，同时返回它的UTF-8编码的字节数；如果没有数据可读则返回io.EOF。如果读取的不是UTF-8编码的字节序列，则读取一个字节并返回U+FFFD。</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func main() {
	b := bytes.NewBuffer([]byte(&quot;你好世界&quot;))
	r, size, err := b.ReadRune()
	fmt.Println(string(r), size, err)
}
</code></pre>
<p>代码输出</p>
<pre><code>你 3 &lt;nil&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-b-buffer-readstringdelim-byte-line-string-err-error"><a class="header" href="#func-b-buffer-readstringdelim-byte-line-string-err-error">func (b *Buffer) ReadString(delim byte) (line string, err error)</a></h2>
<p>参数列表</p>
<ul>
<li>delim 分隔字节</li>
</ul>
<p>返回值</p>
<ul>
<li>line 字符串</li>
<li>err 错误</li>
</ul>
<p>功能说明</p>
<ul>
<li>ReadString读取数据直到遇到delim，并把已读取的数据包含delim作为string返回。如果在遇到delim前出错，则把已读数据作为string和遇到的错误（通常是io.EOF）返回。当返回的string不已delim结尾时，才会返回非空err。</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func main() {
	b := bytes.NewBuffer([]byte(&quot;123*456&quot;))
	line, err := b.ReadString('*')
	fmt.Println(line, err)
}
</code></pre>
<p>代码输出</p>
<pre><code>123* &lt;nil&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-b-buffer-reset"><a class="header" href="#func-b-buffer-reset">func (b *Buffer) Reset()</a></h2>
<p>功能说明</p>
<ul>
<li>Reset把Buffer中的数据清空，等同于b.Truncate(0)。</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func main() {
	b := bytes.NewBuffer([]byte(&quot;123&quot;))
	fmt.Println(b.Len())
	b.Reset()
	fmt.Println(b.Len())
}
</code></pre>
<p>代码输出</p>
<pre><code>3
0
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-b-buffer-string-string"><a class="header" href="#func-b-buffer-string-string">func (b *Buffer) String() string</a></h2>
<p>返回值</p>
<ul>
<li>string 字符串</li>
</ul>
<p>功能说明</p>
<ul>
<li>String把Buffer中的未读数据作为string返回。如果Buffer是个nil指针，则返回<nil></li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func main() {
	var b *bytes.Buffer
	fmt.Println(b.String())
	b = bytes.NewBuffer([]byte(&quot;123&quot;))
	fmt.Println(b.String())
}
</code></pre>
<p>代码输出</p>
<pre><code>&lt;nil&gt;
123
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-b-buffer-truncaten-int"><a class="header" href="#func-b-buffer-truncaten-int">func (b *Buffer) Truncate(n int)</a></h2>
<p>参数列表</p>
<ul>
<li>n</li>
</ul>
<p>功能说明</p>
<ul>
<li>Truncate只保留前n个字节的数据并清除其余数据。如果n &lt; 0或者n &gt; b.Len()则Truncate导致panic。n为0时，等同于b.Reset()。</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func main() {
	b := bytes.NewBuffer([]byte(&quot;123456&quot;))
	b.Truncate(3)
	fmt.Println(b.String())
}
</code></pre>
<p>代码输出</p>
<pre><code>123
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-b-buffer-unreadbyte-error"><a class="header" href="#func-b-buffer-unreadbyte-error">func (b *Buffer) UnreadByte() error</a></h2>
<p>返回值</p>
<ul>
<li>err 错误</li>
</ul>
<p>功能说明</p>
<ul>
<li>UnreadByte取消上次读取的最后一个字节。如果上次读取之后有过写操作，则返回错误。</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func main() {
	b := bytes.NewBuffer([]byte(&quot;12345&quot;))
	fmt.Println(string(b.Next(3)))
	b.UnreadByte()
	fmt.Println(b.String())
}
</code></pre>
<p>代码输出</p>
<pre><code>123
345
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-b-buffer-unreadrune-error"><a class="header" href="#func-b-buffer-unreadrune-error">func (b *Buffer) UnreadRune() error</a></h2>
<p>返回值</p>
<ul>
<li>err 错误</li>
</ul>
<p>功能说明</p>
<ul>
<li>UnreadRune取消上次ReadRune读取的Unicode字符。如果最近一次读写操作不是ReadRune，则UnreadRune返回一个错误。</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func main() {
	b := bytes.NewBuffer([]byte(&quot;你好世界&quot;))
	r, _, _ := b.ReadRune()
	fmt.Println(string(r))
	fmt.Println(string(b.Bytes()))
	b.UnreadRune()
	fmt.Println(string(b.Bytes()))
}
</code></pre>
<p>代码输出</p>
<pre><code>你
好世界
你好世界
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-b-buffer-writep-byte-n-int-err-error"><a class="header" href="#func-b-buffer-writep-byte-n-int-err-error">func (b *Buffer) Write(p []byte) (n int, err error)</a></h2>
<p>参数列表</p>
<ul>
<li>p 要写入的字节切片</li>
</ul>
<p>返回值</p>
<ul>
<li>n 已写入的字节数</li>
<li>err 错误</li>
</ul>
<p>功能说明</p>
<ul>
<li>Write把p写入Buffer，返回的n满足n == len(p)，err总是为nil。如果数据太大则Write会panic并产生ErrTooLarge异常。</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func main() {
	b := bytes.NewBuffer(nil)
	fmt.Println(b.Write([]byte(&quot;12345&quot;)))
	fmt.Println(string(b.Bytes()))
}
</code></pre>
<p>代码输出</p>
<pre><code>5 &lt;nil&gt;
12345
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-b-buffer-writebytec-byte-error"><a class="header" href="#func-b-buffer-writebytec-byte-error">func (b *Buffer) WriteByte(c byte) error</a></h2>
<p>参数列表</p>
<ul>
<li>c 要写入的字节</li>
</ul>
<p>返回值</p>
<ul>
<li>err 错误</li>
</ul>
<p>功能说明</p>
<ul>
<li>WriteByte写入一个字节，总是返回nil。这个返回值只是为了匹配bufio.Writer的Write函数。如果内部数据太大，WriteByte会panic并产生ErrTooLarge异常。</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func main() {
	b := bytes.NewBuffer(nil)
	b.WriteByte('1')
	b.WriteByte('2')
	b.WriteByte('3')
	fmt.Println(string(b.Bytes()))
}
</code></pre>
<p>代码输出</p>
<pre><code>123
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-b-buffer-writeruner-rune-n-int-err-error"><a class="header" href="#func-b-buffer-writeruner-rune-n-int-err-error">func (b *Buffer) WriteRune(r rune) (n int, err error)</a></h2>
<p>参数列表</p>
<ul>
<li>r 要写入的Unicode字符</li>
</ul>
<p>返回值</p>
<ul>
<li>n 写入的字节数</li>
<li>err 错误</li>
</ul>
<p>功能说明</p>
<ul>
<li>WriteRune把一个Unicode字符的UTF-8编码写入Buffer，并返回写入字节数。err总是nil，这个返回类型是为了和bufio.Writer的WriteRune函数匹配。如果Buffer的缓冲区太大，则WriteRune会panic并产生ErrTooLarge异常。</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func main() {
	b := bytes.NewBuffer(nil)
	b.WriteRune('你')
	b.WriteRune('好')
	fmt.Println(string(b.Bytes()))
}
</code></pre>
<p>代码输出</p>
<pre><code>你好
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-b-buffer-writestrings-string-n-int-err-error"><a class="header" href="#func-b-buffer-writestrings-string-n-int-err-error">func (b *Buffer) WriteString(s string) (n int, err error)</a></h2>
<p>参数列表</p>
<ul>
<li>s 要写入的字符串</li>
</ul>
<p>返回值</p>
<ul>
<li>n 写入的字节数</li>
<li>err 错误</li>
</ul>
<p>功能说明</p>
<ul>
<li>WriteString把s写入Buffer，返回值n为len(s)，err总是为nil。如果内部缓冲区太大，WriteString会panic并产生ErrTooLarge异常。</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func main() {
	b := bytes.NewBuffer(nil)
	b.WriteString(&quot;你好世界&quot;)
	fmt.Println(string(b.Bytes()))
}
</code></pre>
<p>代码输出</p>
<pre><code>你好世界
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-b-buffer-writetow-iowriter-n-int64-err-error"><a class="header" href="#func-b-buffer-writetow-iowriter-n-int64-err-error">func (b *Buffer) WriteTo(w io.Writer) (n int64, err error)</a></h2>
<p>参数列表</p>
<ul>
<li>w io.Writer</li>
</ul>
<p>返回值</p>
<ul>
<li>n 写入字节数</li>
<li>err 错误</li>
</ul>
<p>功能说明</p>
<ul>
<li>WriteTo把Buffer中的数据写入w直到数据为空或者遇到错误，返回值n总是足够用int表示，使用int64类型是为了和io.WriterTo接口匹配。任何写入时遇到的错误都会被返回。</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func main() {
	b := bytes.NewBuffer([]byte(&quot;12345&quot;))
	w := bytes.NewBuffer(nil)
	n, err := b.WriteTo(w)
	fmt.Println(n, err)
	fmt.Println(string(w.Bytes()))
}
</code></pre>
<p>代码输出</p>
<pre><code>5 &lt;nil&gt;
12345
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-comparea-b-byte-int"><a class="header" href="#func-comparea-b-byte-int">func Compare(a, b []byte) int</a></h2>
<p>参数列表</p>
<ul>
<li>a 第一个要比较的字节切片</li>
<li>b 第二个要比较的字节切片</li>
</ul>
<p>返回值</p>
<ul>
<li>int 如果a==b返回0，如果a &lt; b返回-1，如果a &gt; b返回1</li>
</ul>
<p>功能说明</p>
<ul>
<li>Compare根据字节的值比较两个字节切片的大小</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func main() {
	fmt.Println(bytes.Compare([]byte{1}, []byte{2}))
	fmt.Println(bytes.Compare([]byte{1}, []byte{1}))
	fmt.Println(bytes.Compare([]byte{1}, []byte{0}))
	fmt.Println(bytes.Compare([]byte{1}, []byte{1, 2}))
	fmt.Println(bytes.Compare([]byte{2}, []byte{1, 2}))
}
</code></pre>
<p>代码输出</p>
<pre><code>-1
0
1
-1
1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-containsb-subslice-byte-bool"><a class="header" href="#func-containsb-subslice-byte-bool">func Contains(b, subslice []byte) bool</a></h2>
<p>参数列表</p>
<ul>
<li>b 字节切片</li>
<li>subslice 子字节切片</li>
</ul>
<p>返回值</p>
<ul>
<li>bool 是否包含子切片</li>
</ul>
<p>功能说明</p>
<ul>
<li>Contains检查字节切片b是否包含子字节切片subslice</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func main() {
	b := []byte(&quot;12345678&quot;)
	s1 := []byte(&quot;456&quot;)
	s2 := []byte(&quot;789&quot;)
	fmt.Println(bytes.Contains(b, s1))
	fmt.Println(bytes.Contains(b, s2))
}
</code></pre>
<p>代码输出</p>
<pre><code>true
false
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-counts-sep-byte-int"><a class="header" href="#func-counts-sep-byte-int">func Count(s, sep []byte) int</a></h2>
<p>参数列表</p>
<ul>
<li>s 字节切片</li>
<li>sep 子字节切片</li>
</ul>
<p>返回值</p>
<ul>
<li>int 子字节切片sep的数量</li>
</ul>
<p>功能说明</p>
<ul>
<li>Count计算子字节切片sep在字节切片s中非重叠实例的数量</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func main() {
	s := []byte(&quot;1234567777777&quot;)
	fmt.Println(bytes.Count(s, []byte(&quot;123&quot;)))
	fmt.Println(bytes.Count(s, []byte(&quot;77&quot;)))
	fmt.Println(bytes.Count(s, []byte(&quot;777&quot;)))
}
</code></pre>
<p>代码输出</p>
<pre><code>1
3
2
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-equala-b-byte-bool"><a class="header" href="#func-equala-b-byte-bool">func Equal(a, b []byte) bool</a></h2>
<p>参数列表</p>
<ul>
<li>a, b 要比较的字节切片</li>
</ul>
<p>返回值</p>
<ul>
<li>bool 是否相同</li>
</ul>
<p>功能说明</p>
<ul>
<li>比较两个字节切片是否相等，如果参数为nil，则等同于空的字节切片</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func main() {
	fmt.Println(bytes.Equal([]byte{1, 2, 3}, []byte{1, 2, 3}))
	fmt.Println(bytes.Equal([]byte{1, 2, 3}, []byte{1, 2}))
	fmt.Println(bytes.Equal([]byte{1, 2, 3}, nil))
	fmt.Println(bytes.Equal([]byte{}, nil))
	fmt.Println(bytes.Equal(nil, nil))
}
</code></pre>
<p>代码输出</p>
<pre><code>true
false
false
true
true
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-equalfolds-t-byte-bool"><a class="header" href="#func-equalfolds-t-byte-bool">func EqualFold(s, t []byte) bool</a></h2>
<p>参数列表</p>
<ul>
<li>s, t 要比较的字节切片</li>
</ul>
<p>返回值</p>
<ul>
<li>bool 是否相等</li>
</ul>
<p>功能说明</p>
<ul>
<li>EqualFold把s和t解释成UTF-8字符串，并进行大小写不敏感的比较</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func main() {
	fmt.Println(bytes.EqualFold([]byte(&quot;abc&quot;), []byte(&quot;abc&quot;)))
	fmt.Println(bytes.EqualFold([]byte(&quot;abc&quot;), []byte(&quot;abd&quot;)))
	fmt.Println(bytes.EqualFold([]byte(&quot;abc&quot;), []byte(&quot;aBc&quot;)))
}
</code></pre>
<p>代码输出</p>
<pre><code>true
false
true
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-fieldss-byte-byte"><a class="header" href="#func-fieldss-byte-byte">func Fields(s []byte) [][]byte</a></h2>
<p>参数列表</p>
<ul>
<li>s 要拆分的字节切片</li>
</ul>
<p>返回值</p>
<ul>
<li>[][]byte 已拆分的字节切片的切片</li>
</ul>
<p>功能说明</p>
<ul>
<li>Fields把字节切片s按照一个或者连续多个空白字符分隔成多个字节切片，如果s只包含空白字符则返回空字节切片</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func main() {
	s := []byte(&quot;a b\tc\rd\ne   f&quot;)
	for i, f := range bytes.Fields(s) {
		fmt.Printf(&quot;[%d]%s, %d\n&quot;, i, string(f), len(f))
	}
}
</code></pre>
<p>代码输出</p>
<pre><code>[0]a, 1
[1]b, 1
[2]c, 1
[3]d, 1
[4]e, 1
[5]f, 1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-fieldsfuncs-byte-f-funcrune-bool-byte"><a class="header" href="#func-fieldsfuncs-byte-f-funcrune-bool-byte">func FieldsFunc(s []byte, f func(rune) bool) [][]byte</a></h2>
<p>参数列表</p>
<ul>
<li>s 字节切片</li>
<li>f 过滤函数</li>
</ul>
<p>返回值</p>
<ul>
<li>[][]byte 被分割的字节切片的切片</li>
</ul>
<p>功能说明</p>
<ul>
<li>FieldsFunc把s解释为UTF-8编码的字符序列，对于每个Unicode字符c，如果f(c)返回true就把c作为分隔字符对s进行拆分。如果所有都字符满足f(c)为true，则返回空的切片。</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func main() {
	fields1 := bytes.FieldsFunc([]byte(&quot;ab,cd,,,e&quot;), func(c rune) bool {
		return c == ','
	})
	fields2 := bytes.FieldsFunc([]byte(&quot;你好啊世界&quot;), func(c rune) bool {
		return c == '啊'
	})
	for i, s := range fields1 {
		fmt.Printf(&quot;%d: %s\n&quot;, i, string(s))
	}
	for i, s := range fields2 {
		fmt.Printf(&quot;%d: %s\n&quot;, i, string(s))
	}
}
</code></pre>
<p>代码输出</p>
<pre><code>0: ab
1: cd
2: e
0: 你好
1: 世界
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-hasprefixs-prefix-byte-bool"><a class="header" href="#func-hasprefixs-prefix-byte-bool">func HasPrefix(s, prefix []byte) bool</a></h2>
<p>参数列表</p>
<ul>
<li>s 要检查的字节切片</li>
<li>prefix 前缀字节切片</li>
</ul>
<p>返回值</p>
<ul>
<li>bool 是否符合前缀</li>
</ul>
<p>功能说明</p>
<ul>
<li>HasPrefix检查s的前缀是否为prefix</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func main() {
	s := []byte(&quot;abcdef&quot;)
	fmt.Println(bytes.HasPrefix(s, []byte(&quot;abc&quot;)))
	fmt.Println(bytes.HasPrefix(s, []byte(&quot;bcd&quot;)))
	fmt.Println(bytes.HasPrefix(s, []byte(&quot;dabc&quot;)))
}
</code></pre>
<p>代码输出</p>
<pre><code>true
false
false
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-hassuffixs-suffix-byte-bool"><a class="header" href="#func-hassuffixs-suffix-byte-bool">func HasSuffix(s, suffix []byte) bool</a></h2>
<p>参数列表</p>
<ul>
<li>s 要检查的字节切片</li>
<li>suffix 后缀字节切片</li>
</ul>
<p>返回值</p>
<ul>
<li>bool 是否有指定后缀</li>
</ul>
<p>功能说明</p>
<ul>
<li>HasSuffix检查s是否以suffix为后缀</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func main() {
	s := []byte(&quot;1234567&quot;)
	fmt.Println(bytes.HasSuffix(s, []byte(&quot;567&quot;)))
	fmt.Println(bytes.HasSuffix(s, []byte(&quot;456&quot;)))
	fmt.Println(bytes.HasSuffix(s, []byte(&quot;678&quot;)))
}
</code></pre>
<p>代码输出</p>
<pre><code>true
false
false
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-indexs-sep-byte-int"><a class="header" href="#func-indexs-sep-byte-int">func Index(s, sep []byte) int</a></h2>
<p>参数列表</p>
<ul>
<li>s 要检查的字节切片</li>
<li>sep 子字节切片</li>
</ul>
<p>返回值</p>
<ul>
<li>int sep的位置索引（从0开始）</li>
</ul>
<p>功能说明</p>
<ul>
<li>Index返回sep在s中第一次出现的位置索引，如果sep不在s中则返回-1</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func main() {
	s := []byte(&quot;1234,12345678&quot;)
	fmt.Println(bytes.Index(s, []byte(&quot;34&quot;)))
	fmt.Println(bytes.Index(s, []byte(&quot;789&quot;)))
}
</code></pre>
<p>代码输出</p>
<pre><code>2
-1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-indexanys-byte-chars-string-int"><a class="header" href="#func-indexanys-byte-chars-string-int">func IndexAny(s []byte, chars string) int</a></h2>
<p>参数列表</p>
<ul>
<li>s 要检查的字节切片</li>
<li>chars 要检查是否包含字符的字符串</li>
</ul>
<p>返回值</p>
<ul>
<li>int s中的位置索引（从0开始）</li>
</ul>
<p>功能说明</p>
<ul>
<li>IndexAny把s解释为UTF-8编码的字节序列，返回chars中任一个字符在s中第一次出现的位置索引；如果s中不包含chars中任何一个字符则返回-1.</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func main() {
	s := []byte(&quot;大家好大家早&quot;)
	index := bytes.IndexAny(s, &quot;好早&quot;)
	if index &gt;= 0 {
		fmt.Printf(&quot;%d: %s\n&quot;, index, string(s[index:]))
	}
}
</code></pre>
<p>代码输出</p>
<pre><code>6: 好大家早
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-indexbytes-byte-c-byte-int"><a class="header" href="#func-indexbytes-byte-c-byte-int">func IndexByte(s []byte, c byte) int</a></h2>
<p>参数列表</p>
<ul>
<li>s 字节切片</li>
<li>c 字节</li>
</ul>
<p>返回值</p>
<ul>
<li>int s中的位置索引（从0开始）</li>
</ul>
<p>功能说明</p>
<ul>
<li>IndexByte检查c在s中第一次出现的位置索引；如果s中不包含c则返回-1</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func main() {
	fmt.Println(bytes.IndexByte([]byte(&quot;1234&quot;), '3'))
}
</code></pre>
<p>代码输出</p>
<pre><code>2
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-indexrunes-byte-r-rune-int"><a class="header" href="#func-indexrunes-byte-r-rune-int">func IndexRune(s []byte, r rune) int</a></h2>
<p>参数列表</p>
<ul>
<li>s 字节切片</li>
<li>r Unicode字符</li>
</ul>
<p>返回值</p>
<ul>
<li>int s中的位置索引（从0开始）</li>
</ul>
<p>功能说明</p>
<ul>
<li>IndexRune把s解释为UTF-8字节序列，并返回r在s中的位置索引；如果s中不包含r则返回-1</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func main() {
	s := []byte(&quot;你好世界&quot;)
	index := bytes.IndexRune(s, '好')
	if index &gt;= 0 {
		fmt.Println(index)
		fmt.Println(string(s[index:]))
	}
}
</code></pre>
<p>代码输出</p>
<pre><code>3
好世界
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-joina-byte-sep-byte-byte"><a class="header" href="#func-joina-byte-sep-byte-byte">func Join(a [][]byte, sep []byte) []byte</a></h2>
<p>参数列表</p>
<ul>
<li>a 包含要被连接的字节切片的切片</li>
<li>sep 用于连接的字节切片</li>
</ul>
<p>返回值</p>
<ul>
<li>[]byte 连接后的字节切片</li>
</ul>
<p>功能说明</p>
<ul>
<li>Join用sep把a中的每个字节切片连接成一个字节切片并返回。</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func main() {
	a := [][]byte{
		[]byte(&quot;hello&quot;),
		[]byte(&quot;world&quot;),
	}
	fmt.Println(string(bytes.Join(a, []byte(&quot;, &quot;))))
	fmt.Println(string(bytes.Join(a, []byte{})))
	fmt.Println(string(bytes.Join(a, nil)))
}
</code></pre>
<p>代码输出</p>
<pre><code>hello, world
helloworld
helloworld
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-lastindexs-sep-byte-int"><a class="header" href="#func-lastindexs-sep-byte-int">func LastIndex(s, sep []byte) int</a></h2>
<p>参数列表</p>
<ul>
<li>s 字节切片</li>
<li>sep  字节切片</li>
</ul>
<p>返回值</p>
<ul>
<li>int s中的位置索引（从0开始）</li>
</ul>
<p>功能说明</p>
<ul>
<li>LastIndex返回sep在s中最后一次出现的位置索引，如果s中不包含sep则返回-1。</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func main() {
	s := []byte(&quot;abcd,abcd&quot;)
	fmt.Println(bytes.LastIndex(s, []byte(&quot;abc&quot;)))
}
</code></pre>
<p>代码输出</p>
<pre><code>5
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-lastindexanys-byte-chars-string-int"><a class="header" href="#func-lastindexanys-byte-chars-string-int">func LastIndexAny(s []byte, chars string) int</a></h2>
<p>参数列表</p>
<ul>
<li>s 字节切片</li>
<li>chars 字符串</li>
</ul>
<p>返回值</p>
<ul>
<li>int s的位置索引（从0开始）</li>
</ul>
<p>功能说明</p>
<ul>
<li>LastIndexAny把s解释为UTF-8编码的字节序列，返回chars中任意字符在s中最后出现的位置索引。如果chars为空或者s中不包含chars中的任意字符，则返回-1。</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func main() {
	s := []byte(&quot;123456789&quot;)
	fmt.Println(bytes.LastIndexAny(s, &quot;789&quot;))
	fmt.Println(bytes.LastIndexAny(s, &quot;987&quot;))
	fmt.Println(bytes.LastIndexAny(s, &quot;0&quot;))
	fmt.Println(bytes.LastIndexAny(s, &quot;&quot;))
}
</code></pre>
<p>代码输出</p>
<pre><code>8
8
-1
-1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-lastindexfuncs-byte-f-funcr-rune-bool-int"><a class="header" href="#func-lastindexfuncs-byte-f-funcr-rune-bool-int">func LastIndexFunc(s []byte, f func(r rune) bool) int</a></h2>
<p>参数列表</p>
<ul>
<li>s 字节切片</li>
<li>f 检查函数</li>
</ul>
<p>返回值</p>
<ul>
<li>int s中字节的位置索引</li>
</ul>
<p>功能说明</p>
<ul>
<li>LastIndexFunc把s解释为UTF-8编码的字节序列，返回满足f(c)==true的字符c在s中最后一次出现的位置索引；如果没有找到这样的字符则返回-1。</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func main() {
	f1 := func(r rune) bool { return r == '7' }
	f2 := func(r rune) bool { return r == '9' }
	s := []byte(&quot;12345678&quot;)
	fmt.Println(bytes.LastIndexFunc(s, f1))
	fmt.Println(bytes.LastIndexFunc(s, f2))
}
</code></pre>
<p>代码输出</p>
<pre><code>6
-1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-mapmapping-funcr-rune-rune-s-byte-byte"><a class="header" href="#func-mapmapping-funcr-rune-rune-s-byte-byte">func Map(mapping func(r rune) rune, s []byte) []byte</a></h2>
<p>参数列表</p>
<ul>
<li>mapping 映射函数</li>
<li>s 字节切片</li>
</ul>
<p>返回值</p>
<ul>
<li>[]byte 被映射后的s的副本字节切片</li>
</ul>
<p>功能说明</p>
<ul>
<li>Map把s解释为UTF-8编码的字节序列，并把s中的每个Unicode字符用mapping函数获得对应的字符并存放到一个新创建的字节切片的对应位置，并返回此新创建的字节切片。</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func main() {
	s1 := []byte(&quot;大家上午好&quot;)
	s2 := []byte(&quot;12345678&quot;)
	m1 := func(r rune) rune {
		if r == '上' {
			return '下'
		}
		return r
	}
	m2 := func(r rune) rune {
		return r + 1
	}
	fmt.Println(string(bytes.Map(m1, s1)))
	fmt.Println(string(s1))
	fmt.Println(string(bytes.Map(m2, s2)))
	fmt.Println(string(s2))
}
</code></pre>
<p>代码输出</p>
<pre><code>大家下午好
大家上午好
23456789
12345678
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-newbufferbuf-byte-buffer"><a class="header" href="#func-newbufferbuf-byte-buffer">func NewBuffer(buf []byte) *Buffer</a></h2>
<p>参数列表</p>
<ul>
<li>buf 字节切片</li>
</ul>
<p>返回值</p>
<ul>
<li>*Buffer</li>
</ul>
<p>功能说明</p>
<ul>
<li>NewBuffer创建一个新的Buffer，并使用buf进行初始化。这个buf用来作为准备要读的数据；也可以用来指定写缓冲区的大小，这时buf应该是cap(buf)为指定大小，但是len(buf)为0。</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func main() {
	buf := []byte(&quot;123456&quot;)
	b := bytes.NewBuffer(buf)
	var data [6]byte
	b.Read(data[:])
	fmt.Println(string(data[:]))
}
</code></pre>
<p>代码输出</p>
<pre><code>123456
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-newbufferstrings-string-buffer"><a class="header" href="#func-newbufferstrings-string-buffer">func NewBufferString(s string) *Buffer</a></h2>
<p>参数列表</p>
<ul>
<li>s 用于初始化Buffer内容的字符串</li>
</ul>
<p>返回值</p>
<ul>
<li>*Buffer</li>
</ul>
<p>功能说明</p>
<ul>
<li>NewBufferString创建一个Buffer，并用s初始化它的内容。它用于读已经存在的数据。大多数情况下，new(Buffer)或者直接声明一个Buffer变量就可以了。</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func main() {
	b := bytes.NewBufferString(&quot;123456&quot;)
	var data [6]byte
	b.Read(data[:])
	fmt.Println(string(data[:]))
}
</code></pre>
<p>代码输出</p>
<pre><code>123456
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-newreaderb-byte-reader"><a class="header" href="#func-newreaderb-byte-reader">func NewReader(b []byte) *Reader</a></h2>
<p>参数列表</p>
<ul>
<li>b 字节切片</li>
</ul>
<p>返回值</p>
<ul>
<li>*Reader</li>
</ul>
<p>功能说明</p>
<ul>
<li>NewReader创建一个Reader，数据为b。</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func main() {
	b := bytes.NewReader([]byte(&quot;12345&quot;))
	fmt.Println(b.Len())
}
</code></pre>
<p>代码输出</p>
<pre><code>5
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-r-reader-len-int"><a class="header" href="#func-r-reader-len-int">func (r *Reader) Len() int</a></h2>
<p>返回值</p>
<ul>
<li>int Reader中未读数据的字节数</li>
</ul>
<p>功能说明</p>
<ul>
<li>Len返回Reader中未读数据的字节数</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func main() {
	b := bytes.NewReader([]byte(&quot;12345&quot;))
	fmt.Println(b.Len())
}
</code></pre>
<p>代码输出</p>
<pre><code>5
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-r-reader-readb-byte-n-int-err-error"><a class="header" href="#func-r-reader-readb-byte-n-int-err-error">func (r *Reader) Read(b []byte) (n int, err error)</a></h2>
<p>参数列表</p>
<ul>
<li>b 要存放读取数据的字节切片</li>
</ul>
<p>返回值</p>
<ul>
<li>n 已读取的字节数</li>
<li>err 错误</li>
</ul>
<p>功能说明</p>
<ul>
<li>Read从Reader中读取len(b)个字节，返回已读取的字节数，如果遇到错误则返回错误（通常是io.EOF）。</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func main() {
	b := bytes.NewReader([]byte(&quot;12345&quot;))
	var buff [3]byte
	n, err := b.Read(buff[:])
	fmt.Println(n, err, string(buff[:n]))
	n, err = b.Read(buff[:])
	fmt.Println(n, err, string(buff[:n]))
	n, err = b.Read(buff[:])
	fmt.Println(n, err, string(buff[:n]))
}
</code></pre>
<p>代码输出</p>
<pre><code>3 &lt;nil&gt; 123
2 &lt;nil&gt; 45
0 EOF
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-r-reader-readatb-byte-off-int64-n-int-err-error"><a class="header" href="#func-r-reader-readatb-byte-off-int64-n-int-err-error">func (r *Reader) ReadAt(b []byte, off int64) (n int, err error)</a></h2>
<p>参数列表</p>
<ul>
<li>b 要存放读取数据的字节切片</li>
<li>off 要读取数据的偏移位置</li>
</ul>
<p>返回值</p>
<ul>
<li>n 已读取数据的字节数</li>
<li>err 错误</li>
</ul>
<p>功能说明</p>
<ul>
<li>ReadAt从Reader中偏移为off字节的位置读取len(b)个字节，并返回已读取的字节数；如果遇到错误则返回错误（通常是io.EOF）。ReadAt读取的数据不会从Reader中清除。</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func main() {
	b := bytes.NewReader([]byte(&quot;12345&quot;))
	var buff [4]byte
	n, err := b.ReadAt(buff[:], 2)
	fmt.Println(n, err, string(buff[:n]))
	n, err = b.ReadAt(buff[:], 2)
	fmt.Println(n, err, string(buff[:n]))
	n, err = b.Read(buff[:])
	fmt.Println(n, err, string(buff[:n]))
}
</code></pre>
<p>代码输出</p>
<pre><code>3 EOF 345
3 EOF 345
4 &lt;nil&gt; 1234
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-r-reader-readbyte-b-byte-err-error"><a class="header" href="#func-r-reader-readbyte-b-byte-err-error">func (r *Reader) ReadByte() (b byte, err error)</a></h2>
<p>返回值</p>
<ul>
<li>b 读取的字节</li>
<li>err 错误</li>
</ul>
<p>功能说明</p>
<ul>
<li>ReadByte从Reader中读取一个字节并返回，如果遇到错误则返回错误（通常是io.EOF）。</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func main() {
	b := bytes.NewReader([]byte(&quot;12345&quot;))
	c, err := b.ReadByte()
	fmt.Println(string(c), err)
}
</code></pre>
<p>代码输出</p>
<pre><code>1 &lt;nil&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-r-reader-readrune-ch-rune-size-int-err-error"><a class="header" href="#func-r-reader-readrune-ch-rune-size-int-err-error">func (r *Reader) ReadRune() (ch rune, size int, err error)</a></h2>
<p>返回值</p>
<ul>
<li>ch 读取的Unicode字符</li>
<li>size ch的UTF-8编码的字节数</li>
<li>err 错误</li>
</ul>
<p>功能说明</p>
<ul>
<li>ReadRune从Reader中按照UTF-8编码读取一个Unicode字符，返回此字符，其字符的UTF-8编码占用的字节数，如果遇到错误则返回错误（通常是io.EOF）。</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func main() {
	b := bytes.NewReader([]byte(&quot;你好世界&quot;))
	r, size, err := b.ReadRune()
	fmt.Println(string(r), size, err)
}
</code></pre>
<p>代码输出</p>
<pre><code>你 3 &lt;nil&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-r-reader-seekoffset-int64-whence-int-int64-error"><a class="header" href="#func-r-reader-seekoffset-int64-whence-int-int64-error">func (r *Reader) Seek(offset int64, whence int) (int64, error)</a></h2>
<p>参数列表</p>
<ul>
<li>offset 相对whence的字节偏移（从0开始计算）</li>
<li>whence 位置</li>
</ul>
<p>返回值</p>
<ul>
<li>int64 新的偏移字节数（从0开始计算）</li>
<li>err 错误</li>
</ul>
<p>功能说明</p>
<ul>
<li>Seek实现了io.Seeker接口，用于设置下次读或写操作的位置，返回新的偏移位置字节数和错误（如果有的话）。</li>
<li>whence的含义为：
<ul>
<li>0：从起始位置计算offset</li>
<li>1: 从当前位置计算offset</li>
<li>2：从尾部位置计算offset</li>
</ul>
</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
)

var (
	data = []byte(&quot;123456&quot;)
)

func seekhead() {
	fmt.Println(&quot;seekhead:&quot;)
	b := bytes.NewReader(data)
	// 把位置移到起始位置+1字节处，即0+1==1，对应数据为'2'
	fmt.Println(b.Seek(1, 0))
	c, _ := b.ReadByte()
	fmt.Println(string(c))
}

func seekcur() {
	fmt.Println(&quot;seekcur:&quot;)
	b := bytes.NewReader(data)
	// 连续读取两个字节后，当前偏移位置为2字节
	b.ReadByte()
	b.ReadByte()
	// 把位置移到当前位置+1字节处，即2+1==3，对应数据为'4'
	fmt.Println(b.Seek(1, 1))
	c, _ := b.ReadByte()
	fmt.Println(string(c))
}

func seektail() {
	fmt.Println(&quot;seektail:&quot;)
	b := bytes.NewReader(data)
	// 把位置移到尾部位置-2字节处，即6-2==4，对应数据为'5'
	fmt.Println(b.Seek(-2, 2))
	c, _ := b.ReadByte()
	fmt.Println(string(c))
}

func main() {
	seekhead()
	seekcur()
	seektail()
}
</code></pre>
<p>代码输出</p>
<pre><code>seekhead:
1 &lt;nil&gt;
2
seekcur:
3 &lt;nil&gt;
4
seektail:
4 &lt;nil&gt;
5
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-r-reader-unreadbyte-error"><a class="header" href="#func-r-reader-unreadbyte-error">func (r *Reader) UnreadByte() error</a></h2>
<p>返回值</p>
<ul>
<li>error 错误</li>
</ul>
<p>功能说明</p>
<ul>
<li>UnreadByte取消上次读取的最后一个字节，如果Buffer没有被读取过则UnreadByte也返回一个错误。</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func main() {
	b := bytes.NewReader([]byte(&quot;12345&quot;))
	fmt.Println(b.UnreadByte())
	var buff [6]byte
	n, _ := b.Read(buff[:])
	fmt.Printf(&quot;read: %s\n&quot;, string(buff[:n]))
	fmt.Println(b.UnreadByte())
	n, _ = b.Read(buff[:])
	fmt.Printf(&quot;read: %s\n&quot;, string(buff[:n]))
}
</code></pre>
<p>代码输出</p>
<pre><code>bytes.Reader: at beginning of slice
read: 12345
&lt;nil&gt;
read: 5
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-r-reader-unreadrune-error"><a class="header" href="#func-r-reader-unreadrune-error">func (r *Reader) UnreadRune() error</a></h2>
<p>返回值</p>
<ul>
<li>error 错误</li>
</ul>
<p>功能说明</p>
<ul>
<li>UnreadRune取消上次ReadRune读取的Unicode字符；如果上次读取操作不是ReadRune，则返回错误。</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func main() {
	b := bytes.NewReader([]byte(&quot;你好世界&quot;))
	var buff [3]byte
	// 用Read读取第一个Unicode字符'你'
	b.Read(buff[:])
	fmt.Println(b.UnreadRune())
	// 用ReadRuen读取第二个Unicode字符'好'
	r, _, _ := b.ReadRune()
	fmt.Println(string(r))
	// 取消读取字符'好'
	fmt.Println(b.UnreadRune())
	// 重新读取字符'好'
	r, _, _ = b.ReadRune()
	fmt.Println(string(r))
}
</code></pre>
<p>代码输出</p>
<pre><code>bytes.Reader: previous operation was not ReadRune
好
&lt;nil&gt;
好
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-repeatb-byte-count-int-byte"><a class="header" href="#func-repeatb-byte-count-int-byte">func Repeat(b []byte, count int) []byte</a></h2>
<p>参数列表</p>
<ul>
<li>b 字节切片</li>
<li>count 重复次数</li>
</ul>
<p>返回值</p>
<ul>
<li>[]byte 新建的字节切片</li>
</ul>
<p>功能说明</p>
<ul>
<li>Repeat把b复制count次组合成一个新的字节切片并返回。</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func main() {
	b := []byte(&quot;123&quot;)
	fmt.Println(string(bytes.Repeat(b, 3)))
}
</code></pre>
<p>代码输出</p>
<pre><code>123123123
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-replaces-old-new-byte-n-int-byte"><a class="header" href="#func-replaces-old-new-byte-n-int-byte">func Replace(s, old, new []byte, n int) []byte</a></h2>
<p>参数列表</p>
<ul>
<li>s 字节切片</li>
<li>old 字节切片</li>
<li>new 字节切片</li>
<li>n 替换次数</li>
</ul>
<p>返回值</p>
<ul>
<li>[]byte 字节切片s的一个副本</li>
</ul>
<p>功能说明</p>
<ul>
<li>Replace返回字节切片s的一个副本，并把前n个不重叠的old替换为new；如果n &lt; 0则不限制替换的数量。</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func main() {
	s := []byte(&quot;1234,234,234&quot;)
	d := bytes.Replace(s, []byte(&quot;234&quot;), []byte(&quot;5678&quot;), 2)
	fmt.Println(string(d))
}
</code></pre>
<p>代码输出</p>
<pre><code>15678,5678,234
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-runess-byte-rune"><a class="header" href="#func-runess-byte-rune">func Runes(s []byte) []rune</a></h2>
<p>参数列表</p>
<ul>
<li>s 字节切片</li>
</ul>
<p>返回值</p>
<ul>
<li>[]rune s对应的Unicode字符切片</li>
</ul>
<p>功能说明</p>
<ul>
<li>Runes把s解释为UTF-8编码的字节序列，并返回对应的Unicode切片。</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func main() {
	s := []byte(&quot;你好世界&quot;)
	fmt.Printf(&quot;%d, %s\n&quot;, len(s), string(s))
	r := bytes.Runes(s)
	fmt.Printf(&quot;%d, %s\n&quot;, len(r), string(r))
}
</code></pre>
<p>代码输出</p>
<pre><code>12, 你好世界
4, 你好世界
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-splits-sep-byte-byte"><a class="header" href="#func-splits-sep-byte-byte">func Split(s, sep []byte) [][]byte</a></h2>
<p>参数列表</p>
<ul>
<li>s 要分割的字节切片</li>
<li>sep 用作分隔符的字节切片</li>
</ul>
<p>返回值</p>
<ul>
<li>[][]byte 把s分割后的字节切片的切片</li>
</ul>
<p>功能说明</p>
<ul>
<li>Split把s用sep分割成多个字节切片返回。如果sep为空，Split则把s切分成每个字节切片对应一个UTF-8字符。Split等效于参数n为-1的SplitN函数。</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func main() {
	s := []byte(&quot;你,好&quot;)
	for i, c := range bytes.Split(s, []byte{','}) {
		fmt.Printf(&quot;%d: %s(%d)\n&quot;, i, string(c), len(c))
	}
	for i, c := range bytes.Split(s, nil) {
		fmt.Printf(&quot;%d: %s(%d)\n&quot;, i, string(c), len(c))
	}
}
</code></pre>
<p>代码输出</p>
<pre><code>0: 你(3)
1: 好(3)
0: 你(3)
1: ,(1)
2: 好(3)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-splitafters-sep-byte-byte"><a class="header" href="#func-splitafters-sep-byte-byte">func SplitAfter(s, sep []byte) [][]byte</a></h2>
<p>参数列表</p>
<ul>
<li>s 要分割的字节切片</li>
<li>sep 用作切分标志的字节切片</li>
</ul>
<p>返回值</p>
<ul>
<li>[][]byte 切分后的字节切片的切片</li>
</ul>
<p>功能说明</p>
<ul>
<li>SplitAfter用sep作为后缀把s切分成多个字节切片返回。如果sep为空，则把s切分成每个字节切片对应一个UTF-8字符。</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func print(s [][]byte) {
	if len(s) == 0 {
		fmt.Println(&quot;nil&quot;)
		return
	}
	for i, c := range s {
		fmt.Printf(&quot;%d: %s\n&quot;, i, string(c))
	}
}

func main() {
	s := []byte(&quot;1,2,3&quot;)
	sep := []byte{','}
	print(bytes.SplitAfter(s, sep))
	print(bytes.SplitAfter(s, nil))
}
</code></pre>
<p>代码输出</p>
<pre><code>0: 1,
1: 2,
2: 3
0: 1
1: ,
2：2
3：,
4：3
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-splitafterns-sep-byte-n-int-byte"><a class="header" href="#func-splitafterns-sep-byte-n-int-byte">func SplitAfterN(s, sep []byte, n int) [][]byte</a></h2>
<p>参数列表</p>
<ul>
<li>s 要分割的字节切片</li>
<li>sep 用作切分标志的字节切片</li>
<li>n 返回的切片的长度</li>
</ul>
<p>返回值</p>
<ul>
<li>[][]byte 切分后的字节切片的切片</li>
</ul>
<p>功能说明</p>
<ul>
<li>SplitAfterN用sep作为后缀把s切分成多个字节切片返回。如果sep为空，则把s切分成每个字节切片对应一个UTF-8字符。</li>
<li>n决定返回的切片的长度：
<ul>
<li>n &gt; 0: 最多返回n个子切片；最后可能子切片可能包含未切分的字节序列。</li>
<li>n == 0: 返回空切片</li>
<li>n &lt; 0: 返回所有的子切片</li>
</ul>
</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func print(s [][]byte) {
	if len(s) == 0 {
		fmt.Println(&quot;nil&quot;)
		return
	}
	for i, c := range s {
		fmt.Printf(&quot;%d: %s\n&quot;, i, string(c))
	}
}

func main() {
	s := []byte(&quot;1,2,3,4&quot;)
	sep := []byte{','}
	print(bytes.SplitAfterN(s, sep, 2))
	print(bytes.SplitAfterN(s, sep, 0))
	print(bytes.SplitAfterN(s, sep, -1))
}
</code></pre>
<p>代码输出</p>
<pre><code>0: 1,
1: 2,3,4
nil
0: 1,
1: 2,
2: 3,
3: 4
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-splitns-sep-byte-n-int-byte"><a class="header" href="#func-splitns-sep-byte-n-int-byte">func SplitN(s, sep []byte, n int) [][]byte</a></h2>
<p>参数列表</p>
<ul>
<li>s 要分割的字节切片</li>
<li>sep 用作分隔符的字节切片</li>
<li>n 返回切片的长度</li>
</ul>
<p>返回值</p>
<ul>
<li>[][]byte 把s分割后的字节切片的切片</li>
</ul>
<p>功能说明</p>
<ul>
<li>SplitN把s用sep分割成多个字节切片返回。如果sep为空，Split则把s切分成每个字节切片对应一个UTF-8字符。</li>
<li>参数n决定返回切片的长度：
<ul>
<li>n &gt; 0: 最多返回n个子切片；最后可能子切片可能包含未切分的字节序列。</li>
<li>n == 0: 返回空切片</li>
<li>n &lt; 0: 返回所有的子切片</li>
</ul>
</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func print(s [][]byte) {
	if len(s) == 0 {
		fmt.Println(&quot;nil&quot;)
		return
	}
	for i, c := range s {
		fmt.Printf(&quot;%d: %s\n&quot;, i, string(c))
	}
}

func main() {
	s := []byte(&quot;1,2,3,4&quot;)
	sep := []byte{','}
	print(bytes.SplitN(s, sep, 2))
	print(bytes.SplitN(s, sep, 0))
	print(bytes.SplitN(s, sep, -1))
}
</code></pre>
<p>代码输出</p>
<pre><code>0: 1
1: 2,3,4
nil
0: 1
1: 2
2: 3
3: 4
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-titles-byte-byte"><a class="header" href="#func-titles-byte-byte">func Title(s []byte) []byte</a></h2>
<p>参数列表</p>
<ul>
<li>s 字节切片</li>
</ul>
<p>返回值</p>
<ul>
<li>[]byte 被转换为首字母大写的字节切片</li>
</ul>
<p>功能说明</p>
<ul>
<li>Title返回s的一个副本，把s中每个单词的首字母改为Unicode字符的大写。</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func main() {
	s := []byte(&quot;hello, world!&quot;)
	fmt.Println(string(bytes.Title(s)))
	fmt.Println(string(s))
}
</code></pre>
<p>代码输出</p>
<pre><code>Hello, World!
hello, world!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-tolowers-byte-byte"><a class="header" href="#func-tolowers-byte-byte">func ToLower(s []byte) []byte</a></h2>
<p>参数列表</p>
<ul>
<li>s 字节切片</li>
</ul>
<p>返回值</p>
<ul>
<li>[]byte 被转换为字符小写的字节切片</li>
</ul>
<p>功能说明</p>
<ul>
<li>ToLower返回s的一个副本，并把其中所有的Unicode字符转换为小写。</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func main() {
	s := []byte(&quot;Hello, World!&quot;)
	fmt.Println(string(bytes.ToLower(s)))
	fmt.Println(string(s))
}
</code></pre>
<p>代码输出</p>
<pre><code>hello, world!
Hello, World!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-tolowerspecial_case-unicodespecialcase-s-byte-byte"><a class="header" href="#func-tolowerspecial_case-unicodespecialcase-s-byte-byte">func ToLowerSpecial(_case unicode.SpecialCase, s []byte) []byte</a></h2>
<p>参数列表</p>
<ul>
<li>_case 转换规则</li>
<li>s 要转换的字节切片</li>
</ul>
<p>返回值</p>
<ul>
<li>[]byte</li>
</ul>
<p>功能说明</p>
<ul>
<li>ToLowerSpecial返回s的一个副本，并把其中的所有Unicode字符都根据_case指定的规则转换成小写。</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
	&quot;unicode&quot;
)

func main() {
	s := []byte(&quot;Hello, world!&quot;)
	fmt.Println(string(bytes.ToLowerSpecial(unicode.AzeriCase, s)))
	fmt.Println(string(s))
}
</code></pre>
<p>代码输出</p>
<pre><code>hello, world!
Hello, world!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-touppers-byte-byte"><a class="header" href="#func-touppers-byte-byte">func ToUpper(s []byte) []byte</a></h2>
<p>参数列表</p>
<ul>
<li>s 字节切片</li>
</ul>
<p>返回值</p>
<ul>
<li>[]byte 被转换为字符大写的字节切片</li>
</ul>
<p>功能说明</p>
<ul>
<li>ToUpper返回s的一个副本，并把其中所有的Unicode字符转换为大写。</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func main() {
	s := []byte(&quot;hello, world!&quot;)
	fmt.Println(string(bytes.ToUpper(s)))
	fmt.Println(string(s))
}
</code></pre>
<p>代码输出</p>
<pre><code>HELLO, WORLD!
hello, world!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-toupperspecial_case-unicodespecialcase-s-byte-byte"><a class="header" href="#func-toupperspecial_case-unicodespecialcase-s-byte-byte">func ToUpperSpecial(_case unicode.SpecialCase, s []byte) []byte</a></h2>
<p>参数列表</p>
<ul>
<li>_case 转换规则</li>
<li>s 要转换的字节切片</li>
</ul>
<p>返回值</p>
<ul>
<li>[]byte</li>
</ul>
<p>功能说明</p>
<ul>
<li>ToUpperSpecial返回s的一个副本，并把其中的所有Unicode字符都根据_case指定的规则转换成大写。</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
	&quot;unicode&quot;
)

func main() {
	s := []byte(&quot;Hello, world!&quot;)
	fmt.Println(string(bytes.ToUpperSpecial(unicode.AzeriCase, s)))
	fmt.Println(string(s))
}
</code></pre>
<p>代码输出</p>
<pre><code>HELLO, WORLD!
Hello, world!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-trims-byte-cutset-string-byte"><a class="header" href="#func-trims-byte-cutset-string-byte">func Trim(s []byte, cutset string) []byte</a></h2>
<p>参数列表</p>
<ul>
<li>s 字节切片</li>
<li>cutset 字符串</li>
</ul>
<p>返回值</p>
<ul>
<li>[]byte s的子字节切片</li>
</ul>
<p>功能说明</p>
<ul>
<li>Trim返回s的子字节切片，不包含s首部和尾部的连续的cutset中的任意字符。</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func main() {
	s := []byte(&quot;123456789&quot;)
	fmt.Println(string(bytes.Trim(s, &quot;1389&quot;)))
}
</code></pre>
<p>代码输出</p>
<pre><code>234567
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-trimfuncs-byte-f-funcr-rune-bool-byte"><a class="header" href="#func-trimfuncs-byte-f-funcr-rune-bool-byte">func TrimFunc(s []byte, f func(r rune) bool) []byte</a></h2>
<p>参数列表</p>
<ul>
<li>s 字节切片</li>
<li>f 检查函数</li>
</ul>
<p>返回值</p>
<ul>
<li>[]byte s的子字节切片</li>
</ul>
<p>功能说明</p>
<ul>
<li>TrimFunc返回s的子字节切片，不包含s首部和尾部连接的满足f(c)==true的字符c。</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func main() {
	s := []byte(&quot;12345678&quot;)
	f := func(r rune) bool {
		return r &lt;= '3' || r &gt;= '6'	
	}
	fmt.Println(string(bytes.TrimFunc(s, f)))
}
</code></pre>
<p>代码输出</p>
<pre><code>45
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-trimlefts-byte-cutset-string-byte"><a class="header" href="#func-trimlefts-byte-cutset-string-byte">func TrimLeft(s []byte, cutset string) []byte</a></h2>
<p>参数列表</p>
<ul>
<li>s 字节切片</li>
<li>cutset 字符串</li>
</ul>
<p>返回值</p>
<ul>
<li>[]byte s的子字节切片</li>
</ul>
<p>功能说明</p>
<ul>
<li>TrimLeft返回s的子字节切片，不包含s首部的连续的cutset中的任意字符。</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func main() {
	s := []byte(&quot;9812345&quot;)
	fmt.Println(string(bytes.TrimLeft(s, &quot;129&quot;)))
}
</code></pre>
<p>代码输出</p>
<pre><code>812345
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-trimleftfuncs-byte-f-funcr-rune-bool-byte"><a class="header" href="#func-trimleftfuncs-byte-f-funcr-rune-bool-byte">func TrimLeftFunc(s []byte, f func(r rune) bool) []byte</a></h2>
<p>参数列表</p>
<ul>
<li>s 字节切片</li>
<li>f 检查函数</li>
</ul>
<p>返回值</p>
<ul>
<li>[]byte s的子字节切片</li>
</ul>
<p>功能说明</p>
<ul>
<li>TrimLeftFunc返回s的一个子字节切片，不包含s首部连续满足f(c)==true的字符c。</li>
</ul>
<p>代码示例</p>
<p>package main</p>
<pre><code>import (
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func main() {
	s := []byte(&quot;123456789&quot;)
	f := func(r rune) bool {
		return r &lt; '4'
	}
	fmt.Println(string(bytes.TrimLeftFunc(s, f)))
}
</code></pre>
<p>代码输出</p>
<pre><code>456789
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-trimrights-byte-cutset-string-byte"><a class="header" href="#func-trimrights-byte-cutset-string-byte">func TrimRight(s []byte, cutset string) []byte</a></h2>
<p>参数列表</p>
<ul>
<li>s 字节切片</li>
<li>cutset 字符串</li>
</ul>
<p>返回值</p>
<ul>
<li>[]byte s的子字节切片</li>
</ul>
<p>功能说明</p>
<ul>
<li>TrimRight返回s的子字节切片，不包含s尾部的连续的cutset中的任意字符。</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func main() {
	s := []byte(&quot;98123456789&quot;)
	fmt.Println(string(bytes.TrimRight(s, &quot;689&quot;)))
}
</code></pre>
<p>代码输出</p>
<pre><code>981234567
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-trimrightfuncs-byte-f-funcr-rune-bool-byte"><a class="header" href="#func-trimrightfuncs-byte-f-funcr-rune-bool-byte">func TrimRightFunc(s []byte, f func(r rune) bool) []byte</a></h2>
<p>参数列表</p>
<ul>
<li>s 字节切片</li>
<li>f 检查函数</li>
</ul>
<p>返回值</p>
<ul>
<li>[]byte s的子字节切片</li>
</ul>
<p>功能说明</p>
<ul>
<li>TrimRightFunc返回s的一个子字节切片，不包含s尾部连续满足f(c)==true的字符c。</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func main() {
	s := []byte(&quot;123456789&quot;)
	f := func(r rune) bool {
		return r &gt; '7'
	}
	fmt.Println(string(bytes.TrimRightFunc(s, f)))
}
</code></pre>
<p>代码输出</p>
<pre><code>1234567
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-trimspaces-byte-byte"><a class="header" href="#func-trimspaces-byte-byte">func TrimSpace(s []byte) []byte</a></h2>
<p>参数列表</p>
<ul>
<li>s 字节切片</li>
</ul>
<p>返回值</p>
<ul>
<li>[]byte</li>
</ul>
<p>功能说明</p>
<ul>
<li>TrimSpace返回s的一个子字节切片，不包含s中开始和结尾处的连续的Unicode空白字符。</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
)

func main() {
	s1 := bytes.TrimSpace([]byte(&quot;   \t  hello, world!\r\n&quot;))
	s2 := bytes.TrimSpace([]byte(&quot;   \t  \r\n&quot;))
	fmt.Printf(&quot;%d %s\n&quot;, len(s1), string(s1))
	fmt.Printf(&quot;%d %s\n&quot;, len(s2), string(s2))
}
</code></pre>
<p>代码输出</p>
<pre><code>13 hello, world!
0
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compress"><a class="header" href="#compress">compress</a></h1>
<p>二级包列表</p>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/compress/bzip2">compress/bzip2</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/compress/flate">compress/flate</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/compress/gzip">compress/gzip</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/compress/lzw">compress/lzw</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/compress/zlib">compress/zlib</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名-compressbzip2"><a class="header" href="#包名-compressbzip2">包名 compress/bzip2</a></h1>
<p>函数列表</p>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/compress/bzip2/NewReader.html">func NewReader(r io.Reader) io.Reader</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/compress/bzip2/StructuralError.Error.html">func (s StructuralError) Error() string</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-newreaderr-ioreader-ioreader"><a class="header" href="#func-newreaderr-ioreader-ioreader">func NewReader(r io.Reader) io.Reader</a></h1>
<p>参数列表：</p>
<ul>
<li>r bzip2压缩数据</li>
</ul>
<p>返回值：解压后的数据</p>
<p>功能说明：</p>
<p>返回一个从r读取bzip2压缩数据，然后返回一个解压后io.Reader</p>
<p>示例：</p>
<pre><code>package main

import (
	&quot;archive/tar&quot;
	&quot;compress/bzip2&quot;
	&quot;fmt&quot;
	&quot;io&quot;
	&quot;os&quot;
	&quot;path&quot;
)

func main() {
	//打开一个bz2压缩文件
	bzip2File, _ := os.Open(&quot;demo.tar.bz2&quot;)
	defer bzip2File.Close()

	//进行解压
	r := bzip2.NewReader(bzip2File)
	//使用tar读取输出文件
	tr := tar.NewReader(r)
	for {
		tarHead, err := tr.Next()
		if err == io.EOF {
			break
		}
		if err != nil {
			fmt.Println(&quot;the tar file err is &quot;, err)
			continue
		}
		fmt.Println(tarHead.Name)

		os.MkdirAll(path.Dir(tarHead.Name), os.ModePerm)
		fw, _ := os.Create(tarHead.Name)
		defer fw.Close()

		_, err = io.Copy(fw, tr)
		if err != nil {
			fmt.Println(&quot;copy file err is &quot;, err)
			continue
		}
	}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-s-structuralerror-error-string"><a class="header" href="#func-s-structuralerror-error-string">func (s StructuralError) Error() string</a></h1>
<p>返回值：非法的bzip2数据错误信息</p>
<p>功能说明：StructuralError其实是一个string，他实现了error接口，用于很方便的返回非法的bzip2数据的错误信息</p>
<p>示例：</p>
<pre><code>package main

import (
	&quot;archive/tar&quot;
	&quot;compress/bzip2&quot;
	&quot;fmt&quot;
	&quot;io&quot;
	&quot;log&quot;
	&quot;os&quot;
	&quot;reflect&quot;
)

func main() {
	//打开一个非bzip2压缩文件
	bzip2File, _ := os.Open(&quot;main.go&quot;)
	defer bzip2File.Close()

	//尝试进行解压
	r := bzip2.NewReader(bzip2File)
	//使用tar读取输出文件
	tr := tar.NewReader(r)
	for {
		_, err := tr.Next()
		if err == io.EOF {
			break
		}
		if err != nil {
			fmt.Println(&quot;the type is &quot;, reflect.TypeOf(err))
			log.Fatalln(err)
		}
	}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名-compressflate"><a class="header" href="#包名-compressflate">包名 compress/flate</a></h1>
<p>常量列表</p>
<pre><code>const (
    NoCompression = 0//不压缩
    BestSpeed     = 1//最快速度压缩

    BestCompression    = 9//最佳压缩比压缩
    DefaultCompression = -1//默认压缩
)
</code></pre>
<p>函数列表</p>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/compress/flate/NewReader.html">func NewReader(r io.Reader) io.ReadCloser</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/compress/flate/NewReaderDict.html">func NewReaderDict(r io.Reader, dict []byte) io.ReadCloser</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/compress/flate/CorruptInputError.Error.html">func (e CorruptInputError) Error() string</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/compress/flate/InternalError.Error.html">func (e InternalError) Error() string</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/compress/flate/ReadError.Error.html">func (e *ReadError) Error() string</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/compress/flate/WriteError.Error.html">func (e *WriteError) Error() string</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/compress/flate/NewWriter.html">func NewWriter(w io.Writer, level int) (*Writer, error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/compress/flate/NewWriterDict.html">func NewWriterDict(w io.Writer, level int, dict []byte) (*Writer, error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/compress/flate/Writer.Close.html">func (w *Writer) Close() error</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/compress/flate/Writer.Flush.html">func (w *Writer) Flush() error</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/compress/flate/Writer.Reset.html">func (w *Writer) Reset(dst io.Writer)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/compress/flate/Writer.Write.html">func (w *Writer) Write(data []byte) (n int, err error)</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-e-corruptinputerror-error-string"><a class="header" href="#func-e-corruptinputerror-error-string">func (e CorruptInputError) Error() string</a></h1>
<p>返回值：在输入的指定偏移量位置存在损坏的错误信息</p>
<p>功能说明：CorruptInputError其实是一个int64，他实现了error接口，用于很方便的返回输入的指定偏移量位置存在损坏的错误信息</p>
<p>示例：</p>
<p>可能是一些读取、写入、拷贝等函数返回的error信息，这里不再举例。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-e-internalerror-error-string"><a class="header" href="#func-e-internalerror-error-string">func (e InternalError) Error() string</a></h1>
<p>返回值：表示flate数据自身的错误信息</p>
<p>功能说明：InternalError其实是一个string，他实现了error接口，用于很方便的返回flate数据自身的错误信息</p>
<p>示例：</p>
<p>函数返回的error信息，这里不再举例。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-newreaderr-ioreader-ioreadcloser"><a class="header" href="#func-newreaderr-ioreader-ioreadcloser">func NewReader(r io.Reader) io.ReadCloser</a></h1>
<p>参数列表</p>
<ul>
<li>r DEFLATE压缩的数据</li>
</ul>
<p>返回值：解压后的ReadCloser数据 </p>
<p>功能说明：</p>
<p>从r读取DEFLATE压缩数据，返回一个解压过的io.ReadCloser，使用后需要调用者关闭该io.ReadCloser</p>
<p>示例：</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;compress/flate&quot;
	&quot;fmt&quot;
	&quot;io&quot;
	&quot;log&quot;
	&quot;os&quot;
)

func main() {
	//一个缓冲区存储压缩的内容
	buf := bytes.NewBuffer(nil)

	//创建一个flate.Writer
	flateWrite, err := flate.NewWriter(buf, flate.BestCompression)
	if err != nil {
		log.Fatalln(err)
	}
	defer flateWrite.Close()
	//写入待压缩内容
	flateWrite.Write([]byte(&quot;compress/flate\n&quot;))
	flateWrite.Flush()
	fmt.Println(buf)

	//解压刚刚压缩的内容
	flateReader := flate.NewReader(buf)
	defer flateReader.Close()
	//输出
	io.Copy(os.Stdout, flateReader)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-newreaderdictr-ioreader-dict-byte-ioreadcloser"><a class="header" href="#func-newreaderdictr-ioreader-dict-byte-ioreadcloser">func NewReaderDict(r io.Reader, dict []byte) io.ReadCloser</a></h1>
<p>参数列表</p>
<ul>
<li>r DEFLATE压缩的数据</li>
<li>dict 解压数据时预设的字典，和NewWriterDict函数里的dict相同</li>
</ul>
<p>返回值：解压后的ReadCloser数据 </p>
<p>功能说明：</p>
<p>从r读取DEFLATE压缩数据，使用预设的dict字典解压数据，返回一个解压过的io.ReadCloser，使用后需要调用者关闭该io.ReadCloser。主要用来读取NewWriterDict压缩的数据</p>
<p>示例：</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;compress/flate&quot;
	&quot;fmt&quot;
	&quot;io&quot;
	&quot;log&quot;
	&quot;os&quot;
)

func main() {
	//一个缓冲区存储压缩的内容
	buf := bytes.NewBuffer(nil)

	//创建一个flate.Writer
	flateWrite, err := flate.NewWriterDict(buf, flate.BestCompression, []byte(&quot;key&quot;))
	if err != nil {
		log.Fatalln(err)
	}
	defer flateWrite.Close()
	//写入待压缩内容
	flateWrite.Write([]byte(&quot;compress/flate\n&quot;))
	flateWrite.Flush()
	fmt.Println(buf)

	//解压刚刚压缩的内容
	flateReader := flate.NewReaderDict(buf, []byte(&quot;key&quot;))
	//flateReader := flate.NewReader(buf)
	defer flateReader.Close()
	//输出
	io.Copy(os.Stdout, flateReader)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-newwriterw-iowriter-level-int-writer-error"><a class="header" href="#func-newwriterw-iowriter-level-int-writer-error">func NewWriter(w io.Writer, level int) (*Writer, error)</a></h1>
<p>参数列表；</p>
<ul>
<li>w 输出数据的Writer</li>
<li>level 压缩级别</li>
</ul>
<p>返回列表：</p>
<ul>
<li>*Writer 基于压缩级别新生成的压缩数据的Writer</li>
<li>error 该函数的错误信息</li>
</ul>
<p>功能说明：</p>
<p>该函数返回一个压缩级别为level的新的压缩用的Writer。压缩级别的范围是1 (BestSpeed) to 9 (BestCompression)。压缩效果越好的意味着压缩速度越慢。0 (NoCompression)表示不做任何压缩；仅仅只需要添加必要的DEFLATE信息。-1 (DefaultCompression)表示用默认的压缩级别。
如果压缩级别在-1到9的范围内，error返回nil，否则将返回非nil的错误信息</p>
<p>示例：</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;compress/flate&quot;
	&quot;fmt&quot;
	&quot;log&quot;
)

func main() {
	//一个缓冲区存储压缩的内容
	buf := bytes.NewBuffer(nil)

	//创建一个flate.Writer，压缩级别最好
	flateWrite, err := flate.NewWriter(buf, flate.BestCompression)
	if err != nil {
		log.Fatalln(err)
	}
	defer flateWrite.Close()
	//写入待压缩内容
	flateWrite.Write([]byte(&quot;compress/flate\n&quot;))
	flateWrite.Flush()
	fmt.Println(buf)

}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-newwriterdictw-iowriter-level-int-dict-byte-writer-error"><a class="header" href="#func-newwriterdictw-iowriter-level-int-dict-byte-writer-error">func NewWriterDict(w io.Writer, level int, dict []byte) (*Writer, error)</a></h1>
<p>参数列表；</p>
<ul>
<li>w 输出数据的Writer</li>
<li>level 压缩级别</li>
<li>dict 压缩预设字典</li>
</ul>
<p>返回列表：</p>
<ul>
<li>*Writer 基于压缩级别和预设字典新生成的压缩数据的Writer</li>
<li>error 该函数的错误信息</li>
</ul>
<p>功能说明：</p>
<p>该函数和NewWriter差不多，只不过使用了预设字典进行初始化Writer，使用该Writer压缩的数据只能被使用同样字典初始化的Reader解压。可以实现基于密码的解压缩。</p>
<p>示例：</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;compress/flate&quot;
	&quot;fmt&quot;
	&quot;log&quot;
)

func main() {
	//一个缓冲区存储压缩的内容
	buf := bytes.NewBuffer(nil)

	//创建一个flate.Writer，压缩级别最好
	flateWrite, err := flate.NewWriterDict(buf, flate.BestCompression,[]byte(&quot;key&quot;))
	if err != nil {
		log.Fatalln(err)
	}
	defer flateWrite.Close()
	//写入待压缩内容
	flateWrite.Write([]byte(&quot;compress/flate\n&quot;))
	flateWrite.Flush()
	fmt.Println(buf)

}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-e-readerror-error-string"><a class="header" href="#func-e-readerror-error-string">func (e *ReadError) Error() string</a></h1>
<p>返回值：表示flate读取拷贝数据时的错误信息</p>
<p>功能说明：ReadError其实是一个struct，他实现了error接口，用于很方便的返回flate读取拷贝数据时的错误信息</p>
<p>示例：</p>
<p>flate读取拷贝数据时的错误信息，这里不再举例。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-e-writeerror-error-string"><a class="header" href="#func-e-writeerror-error-string">func (e *WriteError) Error() string</a></h1>
<p>返回值：表示flate输出数据的错误信息</p>
<p>功能说明：WriteError是一个struct，他实现了error接口，用于很方便的返回flate输出数据的错误信息</p>
<p>示例：</p>
<p>返回输出数据的错误信息，这里不再举例。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-w-writer-close-error"><a class="header" href="#func-w-writer-close-error">func (w *Writer) Close() error</a></h1>
<p>返回值：返回一个error，没有错误时该error为nil</p>
<p>功能说明：</p>
<p>刷新缓冲并关闭w</p>
<p>示例：</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;compress/flate&quot;
	&quot;fmt&quot;
	&quot;log&quot;
)

func main() {
	//一个缓冲区存储压缩的内容
	buf := bytes.NewBuffer(nil)

	//创建一个flate.Writer
	flateWrite, err := flate.NewWriterDict(buf, flate.BestCompression, []byte(&quot;key&quot;))
	if err != nil {
		log.Fatalln(err)
	}
	//刷新缓存并关闭flateWrite
	defer flateWrite.Close()
	//写入待压缩内容
	flateWrite.Write([]byte(&quot;compress/flate\n&quot;))
	flateWrite.Flush()
	fmt.Println(buf)

}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-w-writer-flush-error"><a class="header" href="#func-w-writer-flush-error">func (w *Writer) Flush() error</a></h1>
<p>返回值：返回一个error，没有错误时该error为nil</p>
<p>功能说明：</p>
<p>Flush将缓存中的压缩数据刷新到下层的io.writer中。它主要用在压缩的网络协议中，目的是确保远程读取器有足够的数据重建一个数据包。Flush是阻塞的，直到缓冲中的数据都被写入到下层io.writer中才返回。如果下层io.writer返回一个error，那么Flush也会返回该error。</p>
<p>在zlib库的术语中，Flush等同于Z_SYNC_FLUSH。</p>
<p>示例：</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;compress/flate&quot;
	&quot;fmt&quot;
	&quot;log&quot;
)

func main() {
	//一个缓冲区存储压缩的内容
	buf := bytes.NewBuffer(nil)

	//创建一个flate.Writer
	flateWrite, err := flate.NewWriterDict(buf, flate.BestCompression, []byte(&quot;key&quot;))
	if err != nil {
		log.Fatalln(err)
	}
	//刷新缓存并关闭flateWrite
	defer flateWrite.Close()
	//写入待压缩内容
	flateWrite.Write([]byte(&quot;compress/flate\n&quot;))
	flateWrite.Flush()
	fmt.Println(buf)

}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-w-writer-resetdst-iowriter"><a class="header" href="#func-w-writer-resetdst-iowriter">func (w *Writer) Reset(dst io.Writer)</a></h1>
<p>参数列表：</p>
<ul>
<li>dst 重置时将为作w的下层io.Writer</li>
</ul>
<p>功能说明：</p>
<p>Reset会丢弃当前的w的状态，这相当于把dst、w的级别和字典作为参数，重新调用NewWriter或者NewWriterDict函数一样。</p>
<p>示例：</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;compress/flate&quot;
	&quot;fmt&quot;
	&quot;log&quot;
)

func main() {
	//一个缓冲区存储压缩的内容
	buf := bytes.NewBuffer(nil)

	//创建一个flate.Writer
	flateWrite, err := flate.NewWriterDict(buf, flate.BestCompression, []byte(&quot;key&quot;))
	if err != nil {
		log.Fatalln(err)
	}
	defer flateWrite.Close()

	//reset
	buf1 := bytes.NewBuffer(nil)
	flateWrite.Reset(buf1)
	//写入待压缩内容
	flateWrite.Write([]byte(&quot;compress/flate\n&quot;))
	flateWrite.Flush()
	fmt.Println(buf)  //什么都没有一个空行，因为我们reset重置了
	fmt.Println(buf1) //这个会输出结果，因为下层io.Writer被替换为buf1了
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-w-writer-writedata-byte-n-int-err-error"><a class="header" href="#func-w-writer-writedata-byte-n-int-err-error">func (w *Writer) Write(data []byte) (n int, err error)</a></h1>
<p>参数列表：</p>
<ul>
<li>data 要写入的字节数据</li>
</ul>
<p>返回值：</p>
<ul>
<li>n 写入的字节数</li>
<li>err 错误信息，无错误返回nil</li>
</ul>
<p>功能说明：</p>
<p>Write向w写入数据，最终会将压缩格式的数据写入到w的下层io.Writer中</p>
<p>示例：</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;compress/flate&quot;
	&quot;fmt&quot;
	&quot;log&quot;
)

func main() {
	//一个缓冲区存储压缩的内容
	buf := bytes.NewBuffer(nil)

	//创建一个flate.Writer
	flateWrite, err := flate.NewWriterDict(buf, flate.BestCompression, []byte(&quot;key&quot;))
	if err != nil {
		log.Fatalln(err)
	}
	defer flateWrite.Close()

	//写入待压缩内容
	n, _ := flateWrite.Write([]byte(&quot;compress/flate\n&quot;))
	flateWrite.Flush()
	fmt.Println(n) //15
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compressgzip包详解"><a class="header" href="#compressgzip包详解">compress/gzip包详解</a></h1>
<p>###常量列表
// 压缩的方法
const (
NoCompression      = flate.NoCompression	// 不压缩
BestSpeed          = flate.BestSpeed	// 最快速度
BestCompression    = flate.BestCompression	// 最佳压缩比
DefaultCompression = flate.DefaultCompression	// 默认压缩比
)
###变量列表：
var (
// 当读取gzip数据时发现无效的校验和时将返回该错误
ErrChecksum = errors.New(&quot;gzip: invalid checksum&quot;)
// 当读取gzip数据时发现无效的数据头时将返回该错误
ErrHeader = errors.New(&quot;gzip: invalid header&quot;)
)
###数据头结构
type Header struct {
Comment string    // 文件注释
Extra   []byte    // 附加数据
ModTime time.Time // 文件修改时间
Name    string    // 文件名
OS      byte      // 操作系统类型
}</p>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/compress/gzip/Reader.html">Reader结构 － 读取gzip文件</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/compress/gzip/Writer.html">Writer结构 － 创建gzip文件</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="type-reader-struct--2"><a class="header" href="#type-reader-struct--2">type Reader struct {}</a></h2>
<p>功能说明：</p>
<p>该结构主要用于读取gzip包的数据，但Go并没有提供像zip或tar那样便利的方法直接返回文件的切片，因此强烈建议和tar包一起使用！</p>
<p>代码实例（一般gzip与tar同时使用，具体方法请参考，<a href="https://github.com/Unknwon/go-compresser/blob/master/go-tar.gz.go">完整实例</a>）：</p>
<pre><code>package main

import (
	&quot;os&quot;
	&quot;io&quot;
	&quot;archive/zip&quot;
)

func main() {
	// 打开gzip文件
	fr, err := os.Open(&quot;demo.gzip&quot;)		
	handleError(err)	// handleError为错误处理函数，下同
	defer fr.Close()
	
	// 创建gzip.Reader
	gr, err := gzip.NewReader(fr)
	handleError(err)
	defer gr.Close()
	
	// 读取文件内容
	buf := make([]byte, SIZE)	// 如果单独使用，需自己决定要读多少内容，根据官方文档的说法，你读出的内容可能超出你的所需（当你压缩多个文件时，再次强烈建议直接和tar组合使用）
	gr.Read(buf)
	
	// 将包中的文件数据写出
	fw, err := os.Create(gr.Header.Name)
	handleError(err)
	_, err = fw.Write(buf)
	handleError(err)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="type-writer-struct--2"><a class="header" href="#type-writer-struct--2">type Writer struct {}</a></h2>
<p>功能说明：</p>
<p>该结构主要用于将文件写入到gzip包中，并记录每个文件的数据头。
另外要注意的是，NewWriter()与NewWriterLevel()的主要区别在于前者使用默认的压缩级别，而后者可以指定自定义的压缩级别。单独操作gzip很蛋疼，建议直接与tar结合将会十分方便。</p>
<p>代码实例（一般gzip与tar同时使用，具体方法请参考，<a href="https://github.com/Unknwon/go-compresser/blob/master/go-tar.gz.go">完整实例</a>）：</p>
<pre><code>package main

import (
	&quot;os&quot;
	&quot;io&quot;
	&quot;compress/gzip&quot;
)

func main() {
	fw, err := os.Create(&quot;demo.gzip&quot;)	// 创建gzip包文件，返回*io.Writer
	handleError(err)	// handleError为错误处理函数，下同
	defer fw.Close()
	
	// 实例化新的gzip.Writer
	gw := gzip.NewWriter(fw)
	defer gw.Close()
	
	// 获取要打包的文件的内容
	fr, err = os.Open(&quot;demo.txt&quot;)
	handleError(err)
	defer fr.Close()
	
	// 获取文件信息
	fi, err = fr.Stat()
	handleError(err)
	
	// 创建gzip.Header
	gw.Header.Name = fi.Name()

	// 读取文件数据
	buf := make([]byte, fi.Size())
	_, err = fr.Read(buf)
	handleError(err)

	// 写入数据到zip包
	_, err = gw.Write(buf)
	handleError(err)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名-compresslzw"><a class="header" href="#包名-compresslzw">包名 compress/lzw</a></h1>
<p>函数列表</p>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/compress/lzw/NewReader.html">func NewReader(r io.Reader, order Order, litWidth int) io.ReadCloser</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/compress/lzw/NewWriter.html">func NewWriter(w io.Writer, order Order, litWidth int) io.WriteCloser</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-newreaderr-ioreader-order-order-litwidth-int-ioreadcloser"><a class="header" href="#func-newreaderr-ioreader-order-order-litwidth-int-ioreadcloser">func NewReader(r io.Reader, order Order, litWidth int) io.ReadCloser</a></h1>
<p>参数列表：</p>
<ul>
<li>r 待解压的数据</li>
<li>order lzw数据流的位顺序，有LSB和MSB</li>
<li>litWidth 字面码的位数，必须在[2,8]范围内，一般为8</li>
</ul>
<p>返回值：一个解压过的io.ReadCloser，调用者使用后要将其关闭</p>
<p>功能说明:</p>
<p>NewReader创建一个新的io.ReadCloser。它从r读取并解压数据。调用者要在读取完之后调用返回io.ReadCloser的Close函数关闭。litWidth是字面码的为数，必须在[2,8]范围内，一般为8.</p>
<p>示例：</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;compress/lzw&quot;
	&quot;fmt&quot;
	&quot;io&quot;
	&quot;os&quot;
)

func main() {
	//一个缓冲区存储压缩的内容
	buf := bytes.NewBuffer(nil)

	w := lzw.NewWriter(buf, lzw.LSB, 8)
	//写入待压缩内容
	w.Write([]byte(&quot;compress/flate\n&quot;))
	w.Close()
	fmt.Println(buf)

	//解压
	r := lzw.NewReader(buf, lzw.LSB, 8)
	defer r.Close()
	io.Copy(os.Stdout, r)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-newwriterw-iowriter-order-order-litwidth-int-iowritecloser"><a class="header" href="#func-newwriterw-iowriter-order-order-litwidth-int-iowritecloser">func NewWriter(w io.Writer, order Order, litWidth int) io.WriteCloser</a></h1>
<p>参数列表：</p>
<ul>
<li>w 输出压缩数据的io.Writer</li>
<li>order lzw数据流的位顺序，有LSB和MSB</li>
<li>litWidth 字面码的位数，必须在[2,8]范围内，一般为8</li>
</ul>
<p>返回值：一个io.WriteCloser，可以将压缩的数据写入其下层的w，调用者使用后要将其关闭</p>
<p>功能说明:</p>
<p>NewWriter创建一个新的io.WriteCloser。它将数据压缩后写入w。调用者要在写入结束之后调用返回io.WriteCloser的Close函数关闭。litWidth是字面码的为数，必须在[2,8]范围内，一般为8.</p>
<p>示例：</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;compress/lzw&quot;
	&quot;fmt&quot;
	&quot;io&quot;
	&quot;os&quot;
)

func main() {
	//一个缓冲区存储压缩的内容
	buf := bytes.NewBuffer(nil)

	w := lzw.NewWriter(buf, lzw.LSB, 8)
	//写入待压缩内容
	w.Write([]byte(&quot;compress/flate\n&quot;))
	w.Close()
	fmt.Println(buf)

	//解压
	r := lzw.NewReader(buf, lzw.LSB, 8)
	defer r.Close()
	io.Copy(os.Stdout, r)
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名"><a class="header" href="#包名">包名</a></h1>
<p>函数列表</p>
<ul>
<li>xxx1</li>
<li>xxx2</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="container"><a class="header" href="#container">container</a></h1>
<h2 id="概述-1"><a class="header" href="#概述-1">概述</a></h2>
<p>常用的容器工具包，目前有heap、list、ring三种数据结构</p>
<h2 id="子包列表"><a class="header" href="#子包列表">子包列表</a></h2>
<ul>
<li>heap 堆（可实现最大堆和最小堆）</li>
<li>list 双向链表</li>
<li>ring 环形链表</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="heap包"><a class="header" href="#heap包">heap包</a></h1>
<h2 id="概述-2"><a class="header" href="#概述-2">概述:</a></h2>
<p>任何实现了<code>heap.Interface</code>接口的对象都可以使用heap包提供的方法对堆进行操作(堆是一个完全二叉树)。通过对<code>heap.Interface</code>中的<code>Less</code>方法的不同实现，来实现最大堆和最小堆。通常堆的数据结构为一个一维数组。</p>
<p>维基百科：[堆（数据结构）](http://zh.wikipedia.org/wiki/%E5%A0%86_(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84))</p>
<h2 id="函数列表"><a class="header" href="#函数列表">函数列表:</a></h2>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/container/heap/Init.html">func Init(h Interface)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/container/heap/Pop.html">func Pop(h Interface) interface{}</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/container/heap/Push.html">func Push(h Interface, x interface{})</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/container/heap/Remove.html">func Remove(h Interface, i int) interface{}</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/container/heap/Interface.html">type Interface</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-inith-interface"><a class="header" href="#func-inith-interface">func Init(h Interface)</a></h1>
<p>参数列表：</p>
<ul>
<li><code>h</code>：实现了<code>heap.Interface</code>接口的堆对象</li>
</ul>
<p>功能说明：</p>
<p>在对堆h进行操作前必须保证堆已经初始化（即符合堆结构），该方法可以在堆中元素的顺序不符合堆的要求时调用，调用后堆会调整为标准的堆结构，该方法的时间复杂度为：O(n)，n为堆h中元素的总个数。</p>
<p>代码实例：</p>
<pre><code class="language-go">
	package main

	import (
		&quot;container/heap&quot;
		&quot;fmt&quot;
	)

	type myHeap []int // 定义一个堆，存储结构为数组

	// 实现了heap.Interface中组合的sort.Interface接口的Less方法
	func (h *myHeap) Less(i, j int) bool {
		return (*h)[i] &lt; (*h)[j]
	}

	// 实现了heap.Interface中组合的sort.Interface接口的Swap方法
	func (h *myHeap) Swap(i, j int) {
		(*h)[i], (*h)[j] = (*h)[j], (*h)[i]
	}

	// 实现了heap.Interface中组合的sort.Interface接口的Push方法
	func (h *myHeap) Len() int {
		return len(*h)
	}

	// 实现了heap.Interface的Pop方法
	func (h *myHeap) Pop() (v interface{}) {
		*h, v = (*h)[:h.Len()-1], (*h)[h.Len()-1]
		return
	}

	// 实现了heap.Interface的Push方法
	func (h *myHeap) Push(v interface{}) {
		*h = append(*h, v.(int))
	}

	// 按层来遍历和打印堆数据，第一行只有一个元素，即堆顶元素
	func (h myHeap) printHeap() {
		n := 1
		levelCount := 1
		for n &lt;= h.Len() {
			fmt.Println(h[n-1 : n-1+levelCount])
			n += levelCount
			levelCount *= 2
		}
	}

	func main() {
		data := [7]int{13, 25, 1, 9, 5, 12, 11}
		aheap := new(myHeap)
		// 用堆本身的Push方法将数组中的元素依次存入堆中
		for _, value := range data {
			aheap.Push(value)
		}

		// 此时堆数组内容为：13, 25, 1, 9, 5, 12, 11
		// 不是正确的堆结构
		aheap.printHeap()
		// 输出：
		//  [13]
		//  [25 1]
		//  [9 5 12 11]

		heap.Init(aheap) // 对堆进行调整，调整后为规范的堆结构
		
		fmt.Println(*aheap) // 输出：[1 5 11 9 25 12 13]
		aheap.printHeap()
		// 输出：
		//	[1]
		//	[5 11]
		//	[9 25 12 13]
	}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-interface"><a class="header" href="#type-interface">type Interface</a></h1>
<p>接口代码：</p>
<pre><code class="language-go">
	type Interface interface {
	    sort.Interface
	    Push(x interface{})
	    Pop() interface{}
	}
	
</code></pre>
<p>功能说明：</p>
<p>这是堆的接口，<code>heap</code>包里面的方法只是提供堆的一些堆算法操作，要想使用这些算法操作，就必须实现这些接口，每个接口方法都有具体的含义，堆本身的数据结构由这个接口的具体实现决定，可以是数组、列表。</p>
<p>接口方法：</p>
<ul>
<li>
<p>sort.Interface </p>
<p>参见<a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/container/heap/../../sort/README.html">sort.Interface</a>接口。</p>
<p>其中的Less(i, j int)方法的实现决定了堆是最大堆还是最小堆，如果该方法的实现是指元素i是否小于元素j，则是最小堆，反之为最大堆，代码实例：</p>
</li>
</ul>
<pre><code class="language-go">		type myHeap []int  // 定义一个堆，存储结构为数组
		
		// 最小堆的Less方法实现
		func (h *myHeap) Less(i, j int) bool {
			return (*h)[i] &lt; (*h)[j]
		}
		
		// 最大堆的Less方法实现
		func (h *myHeap) Less(i, j int) bool {
			return (*h)[i] &lt; (*h)[j]
		}
</code></pre>
<ul>
<li>
<p>Push(x interface{}) </p>
<p>参数列表：</p>
<p>x 将存到堆中的元素</p>
<p>功能说明：</p>
<p>把元素x存放到索引号为Len()的位置上，比如，一个列表中元素有7个，索引号从0开始，那么x将被存放到索引号为7的位置上，即最末尾。</p>
<p>代码实例：</p>
</li>
</ul>
<pre><code class="language-go">		type myHeap []int  // 定义一个堆，存储结构为数组
		
		func (h *myHeap) Push(v interface{}) {
			*h = append(*h, v.(int))
		}
</code></pre>
<ul>
<li>
<p>Pop() interface{}</p>
<p>返回值：</p>
<p>被移除的索引号为Len()-1的元素</p>
<p>功能说明：</p>
<p>把索引号为Len()-1的元素移除并返回这个被移除的元素。比如，如果这个堆是一个数组，那么才操作就是把数组的最后一个元素移除并返回。</p>
<p>代码实例：</p>
</li>
</ul>
<pre><code class="language-go">		type myHeap []int  // 定义一个堆，存储结构为数组
		
		func (h *myHeap) Pop() (v interface{}) {
			*h, v = (*h)[:h.Len()-1], (*h)[h.Len()-1]
			return
		}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-poph-interface-interface"><a class="header" href="#func-poph-interface-interface">func Pop(h Interface) interface{}</a></h1>
<p>参数列表：</p>
<ul>
<li><code>h</code>：实现了<code>heap.Interface</code>的堆对象</li>
</ul>
<p>返回值：</p>
<ul>
<li><code>interface{}</code>：堆顶的元素</li>
</ul>
<p>功能说明：</p>
<p>从堆<code>h</code>中取出堆顶的元素并自动调整堆结构。根据<code>h</code>的<code>Less</code>方法实现的不同，堆顶元素可以是最大的元素或者是最小的元素。该方法的时间复杂度为O(log(n))，n为堆中元素的总和。</p>
<p>代码实例：</p>
<pre><code class="language-go">	package main

	import (
		&quot;container/heap&quot;
		&quot;fmt&quot;
	)

	type myHeap []int // 定义一个堆，存储结构为数组

	// 实现了heap.Interface中组合的sort.Interface接口的Less方法
	func (h *myHeap) Less(i, j int) bool {
		return (*h)[i] &lt; (*h)[j]
	}

	// 实现了heap.Interface中组合的sort.Interface接口的Swap方法
	func (h *myHeap) Swap(i, j int) {
		(*h)[i], (*h)[j] = (*h)[j], (*h)[i]
	}

	// 实现了heap.Interface中组合的sort.Interface接口的Push方法
	func (h *myHeap) Len() int {
		return len(*h)
	}

	// 实现了heap.Interface的Pop方法
	func (h *myHeap) Pop() (v interface{}) {
		*h, v = (*h)[:h.Len()-1], (*h)[h.Len()-1]
		return
	}

	// 实现了heap.Interface的Push方法
	func (h *myHeap) Push(v interface{}) {
		*h = append(*h, v.(int))
	}

	// 按层来遍历和打印堆数据，从堆顶开始
	func (h myHeap) printHeap() {
		i := 0          // 当前元素的索引号
		levelCount := 1 // 当前层级的元素个数
		for i+1 &lt;= h.Len() {
			fmt.Println(h[i : i+levelCount])
			i += levelCount
			if (i + levelCount*2) &lt;= h.Len() {
				levelCount *= 2
			} else {
				levelCount = h.Len() - i
			}
		}
	}

	func main() {
		data := [7]int{13, 25, 1, 9, 5, 12, 11}
		aheap := new(myHeap) // 创建空堆

		// 用heap包中的Push方法将数组中的元素依次存入堆中，
		// 每次Push都会保证堆是规范的堆结构
		for _, value := range data {
			heap.Push(aheap, value)
		}
		fmt.Println(*aheap) // 输出：[1 5 11 25 9 13 12]
		aheap.printHeap()
		// 输出：
		//  [1]
		//  [5 11]
		//  [25 9 13 12]

		// 依次调用heap包的Pop方法来获取堆顶元素
		for aheap.Len() &gt; 0 {
			fmt.Printf(&quot;%d &quot;, heap.Pop(aheap))
		}
		// 输出：1 5 9 11 12 13 25 
	}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-pushh-interface-x-interface"><a class="header" href="#func-pushh-interface-x-interface">func Push(h Interface, x interface{})</a></h1>
<p>参数列表：</p>
<ul>
<li><code>h</code>：实现了<code>heap.Interface</code>的堆对象</li>
<li><code>x</code>：将被存到堆中的元素对象</li>
</ul>
<p>功能说明：</p>
<p>把元素<code>x</code>存到堆中。该方法的时间复杂度为O(log(n))，n为堆中元素的总和。</p>
<p>代码实例：</p>
<pre><code class="language-go">	package main

	import (
		&quot;container/heap&quot;
		&quot;fmt&quot;
	)

	type myHeap []int // 定义一个堆，存储结构为数组

	// 实现了heap.Interface中组合的sort.Interface接口的Less方法
	func (h *myHeap) Less(i, j int) bool {
		return (*h)[i] &lt; (*h)[j]
	}

	// 实现了heap.Interface中组合的sort.Interface接口的Swap方法
	func (h *myHeap) Swap(i, j int) {
		(*h)[i], (*h)[j] = (*h)[j], (*h)[i]
	}

	// 实现了heap.Interface中组合的sort.Interface接口的Push方法
	func (h *myHeap) Len() int {
		return len(*h)
	}

	// 实现了heap.Interface的Pop方法
	func (h *myHeap) Pop() (v interface{}) {
		*h, v = (*h)[:h.Len()-1], (*h)[h.Len()-1]
		return
	}

	// 实现了heap.Interface的Push方法
	func (h *myHeap) Push(v interface{}) {
		*h = append(*h, v.(int))
	}

	// 按层来遍历和打印堆数据，从堆顶开始
	func (h myHeap) printHeap() {
		i := 0 // 当前元素的索引号
		levelCount := 1 // 当前层级的元素个数
		for i+1 &lt;= h.Len() {
			fmt.Println(h[i : i+levelCount])
			i += levelCount
			if (i + levelCount * 2) &lt;= h.Len() {
				levelCount *= 2
			} else {
				levelCount = h.Len() - i
			}
		}
	}

	func main() {
		data := [7]int{13, 25, 1, 9, 5, 12, 11}
		aheap := new(myHeap) // 此时是空堆
		
		// 用heap包中的Push方法将数组中的元素依次存入堆中，
		// 每次Push都会保证堆是规范的堆结构
		for _, value := range data {
			heap.Push(aheap, value)
			fmt.Printf(&quot;插入%d\n&quot;, value)
			aheap.printHeap()
			fmt.Println()
		}
		fmt.Println(*aheap)
		// 输出：
		//	插入13
		//	[13]
		//	
		//	插入25
		//	[13]
		//	[25]
		//	
		//	插入1
		//	[1]
		//	[25 13]
		//	
		//	插入9
		//	[1]
		//	[9 13]
		//	[25]
		//	
		//	插入5
		//	[1]
		//	[5 13]
		//	[25 9]
		//	
		//	插入12
		//	[1]
		//	[5 12]
		//	[25 9 13]
		//	
		//	插入11
		//	[1]
		//	[5 11]
		//	[25 9 13 12]
		//	
		//	[1 5 11 25 9 13 12]

	}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-removeh-interface-i-int-interface"><a class="header" href="#func-removeh-interface-i-int-interface">func Remove(h Interface, i int) interface{}</a></h1>
<p>参数列表：</p>
<ul>
<li><code>h</code>：实现了<code>heap.Interface</code>的堆对象</li>
<li><code>i</code>：将被移除的元素在堆中的索引号</li>
</ul>
<p>返回值：</p>
<ul>
<li>interface{}：堆顶的元素</li>
</ul>
<p>功能说明：</p>
<p>把索引号为i的元素从堆中移除。该方法的时间复杂度为O(log(n))，n为堆中元素的总和。</p>
<p>代码实例：</p>
<pre><code class="language-go">	package main

	import (
		&quot;container/heap&quot;
		&quot;fmt&quot;
	)

	type myHeap []int // 定义一个堆，存储结构为数组

	// 实现了heap.Interface中组合的sort.Interface接口的Less方法
	func (h *myHeap) Less(i, j int) bool {
		return (*h)[i] &lt; (*h)[j]
	}

	// 实现了heap.Interface中组合的sort.Interface接口的Swap方法
	func (h *myHeap) Swap(i, j int) {
		(*h)[i], (*h)[j] = (*h)[j], (*h)[i]
	}

	// 实现了heap.Interface中组合的sort.Interface接口的Push方法
	func (h *myHeap) Len() int {
		return len(*h)
	}

	// 实现了heap.Interface的Pop方法
	func (h *myHeap) Pop() (v interface{}) {
		*h, v = (*h)[:h.Len()-1], (*h)[h.Len()-1]
		return
	}

	// 实现了heap.Interface的Push方法
	func (h *myHeap) Push(v interface{}) {
		*h = append(*h, v.(int))
	}

	// 按层来遍历和打印堆数据，从堆顶开始
	func (h myHeap) printHeap() {
		i := 0          // 当前元素的索引号
		levelCount := 1 // 当前层级的元素个数
		for i+1 &lt;= h.Len() {
			fmt.Println(h[i : i+levelCount])
			i += levelCount
			if (i + levelCount*2) &lt;= h.Len() {
				levelCount *= 2
			} else {
				levelCount = h.Len() - i
			}
		}
		fmt.Println()
	}

	func main() {
		data := [7]int{13, 25, 1, 9, 5, 12, 11}
		aheap := new(myHeap) // 创建空堆

		// 用heap包中的Push方法将数组中的元素依次存入堆中，
		// 每次Push都会保证堆是规范的堆结构
		for _, value := range data {
			heap.Push(aheap, value)
		}
		fmt.Println(*aheap) // 输出：[1 5 11 25 9 13 12]
		aheap.printHeap()
		// 输出：
		//  [1]
		//  [5 11]
		//  [25 9 13 12]

		value := heap.Remove(aheap, 2) // 删除索引号为3的元素（即数组中的第4个元素）
		fmt.Println(value) // 输出：25
		aheap.printHeap()
		// 输出：
		//	[1]
		//	[5 12]
		//	[25 9 13]
	}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="list包"><a class="header" href="#list包">list包</a></h1>
<h2 id="概述-3"><a class="header" href="#概述-3">概述:</a></h2>
<p>list包实现了双向链表的功能。</p>
<p>遍历一个list的代码实例（其中<code>l</code>为*list对象）：</p>
<pre><code class="language-go">
	for e := l.Front(); e != nil; e = e.Next() {
		// do something with e.Value
	}

</code></pre>
<h2 id="结构体"><a class="header" href="#结构体">结构体：</a></h2>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/container/list/Element.html">type Element</a>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/container/list/Next.html">func (e *Element) Next() *Element</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/container/list/Prev.html">func (e *Element) Prev() *Element</a></li>
</ul>
</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/container/list/List.html">type List</a>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/container/list/New.html">func New() *List</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/container/list/Back.html">func (l *List) Back() *Element</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/container/list/Front.html">func (l *List) Front() *Element</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/container/list/Init.html">func (l *List) Init() *List</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/container/list/InsertAfter.html">func (l *List) InsertAfter(value interface{}, mark *Element) *Element</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/container/list/InsertBefore.html">func (l *List) InsertBefore(value interface{}, mark *Element) *Element</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/container/list/Len.html">func (l *List) Len() int</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/container/list/MoveToBack.html">func (l *List) MoveToBack(e *Element)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/container/list/MoveToFront.html">func (l *List) MoveToFront(e *Element)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/container/list/PushBack.html">func (l *List) PushBack(value interface{}) *Element</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/container/list/PushBackList.html">func (l *List) PushBackList(ol *List)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/container/list/PushFront.html">func (l *List) PushFront(value interface{}) *Element</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/container/list/PushFrontList.html">func (l *List) PushFrontList(ol *List)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/container/list/Remove.html">func (l *List) Remove(e *Element) interface{}</a></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-l-list-back-element"><a class="header" href="#func-l-list-back-element">func (l *List) Back() *Element</a></h1>
<p>返回值：</p>
<ul>
<li><code>*Element</code>：链表中最后一个节点的指针，如果链表长度为0，则为<code>nil</code></li>
</ul>
<p>功能说明:</p>
<p>获得最后一个节点的指针，如果链表长度为0，则为<code>nil</code></p>
<p>代码实例：</p>
<pre><code class="language-go">
	package main

	import (
		&quot;container/list&quot;
		&quot;fmt&quot;
	)

	func main() {
		l := list.New()
		e := l.Back()
		fmt.Println(e == nil)
		l.PushBack(&quot;a&quot;)
		e = l.Back()
		fmt.Println(e.Value) // 输出：a
	}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-element"><a class="header" href="#type-element">type Element</a></h1>
<h2 id="结构体代码"><a class="header" href="#结构体代码">结构体代码：</a></h2>
<pre><code class="language-go">
	type Element struct {
		next, prev *Element

		list *List

		Value interface{}
	}

</code></pre>
<h2 id="功能说明"><a class="header" href="#功能说明">功能说明：</a></h2>
<p>链表中的一个节点。</p>
<h2 id="结构体字段"><a class="header" href="#结构体字段">结构体字段：</a></h2>
<ul>
<li><code>next *Element</code>：指向链表中的下一个节点的指针，最后一个节点的下一个节点为<code>nil</code></li>
<li><code>prev *Element</code>：指向链表中的上一个节点的指针，第一个节点的上一个节点为<code>nil</code></li>
<li><code>list *List</code>：指向当前这个节点所属的链表的指针</li>
<li><code>Value interface{}</code>: 该节点的内容，可以是任何对象</li>
</ul>
<h2 id="函数链表"><a class="header" href="#函数链表">函数链表：</a></h2>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/container/list/Next.html">func (e *Element) Next() *Element</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/container/list/Prev.html">func (e *Element) Prev() *Element</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-l-list-front-element"><a class="header" href="#func-l-list-front-element">func (l *List) Front() *Element</a></h1>
<p>返回值：</p>
<ul>
<li><code>*Element</code>：链表中第一个节点的指针，如果链表长度为0，则为<code>nil</code></li>
</ul>
<p>功能说明:</p>
<p>获得第一个节点的指针，如果链表长度为0，则为<code>nil</code></p>
<p>代码实例：</p>
<pre><code class="language-go">
	package main

	import (
		&quot;container/list&quot;
		&quot;fmt&quot;
	)

	func main() {
		l := list.New()
		e := l.Front()
		fmt.Println(e == nil)
		l.PushFront(&quot;b&quot;)
		e = l.Front()
		fmt.Println(e.Value) // 输出：b
	}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-l-list-init-list"><a class="header" href="#func-l-list-init-list">func (l *List) Init() *List</a></h1>
<p>返回值：</p>
<ul>
<li><code>*List</code>：初始化或者清空后的链表</li>
</ul>
<p>功能说明:</p>
<p>初始化或者清空链表，该方法调用后，链表的长度为0</p>
<p>代码实例：</p>
<pre><code class="language-go">
	package main

	import (
		&quot;container/list&quot;
		&quot;fmt&quot;
	)

	func main() {
		l := list.New()
		l.PushBack(&quot;a&quot;)
		l.PushBack(&quot;b&quot;)
		l.PushBack(&quot;c&quot;)
		fmt.Println(l.Len()) // 输出：3
		
		l.Init()
		fmt.Println(l.Len()) // 输出：0
	}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-l-list-insertaftervalue-interface-mark-element-element"><a class="header" href="#func-l-list-insertaftervalue-interface-mark-element-element">func (l *List) InsertAfter(value interface{}, mark *Element) *Element</a></h1>
<p>参数列表：</p>
<ul>
<li><code>value</code>：要插入的数据的内容</li>
<li><code>mark</code>：链表中的一个节点指针</li>
</ul>
<p>返回值：</p>
<ul>
<li><code>*Element</code>：被插入的节点指针，该节点的<code>Value</code>为数据内容</li>
</ul>
<p>功能说明：</p>
<p>把数据<code>value</code>插入到<code>mark</code>节点的后面，并返回这个被插入的节点。</p>
<p>代码实例：</p>
<pre><code class="language-go">
	package main

	import (
		&quot;container/list&quot;
		&quot;fmt&quot;
	)

	func main() {
		l := list.New()
		e := l.PushBack(&quot;a&quot;)
		l.PushBack(&quot;c&quot;)
		fmt.Println(e.Next().Value) // 输出：c
		l.InsertAfter(&quot;b&quot;, e)
		fmt.Println(e.Next().Value) // 输出：b
	}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-l-list-insertbeforevalue-interface-mark-element-element"><a class="header" href="#func-l-list-insertbeforevalue-interface-mark-element-element">func (l *List) InsertBefore(value interface{}, mark *Element) *Element</a></h1>
<p>参数列表：</p>
<ul>
<li><code>value</code>：要插入的数据的内容</li>
<li><code>mark</code>：链表中的一个节点指针</li>
</ul>
<p>返回值：</p>
<ul>
<li><code>*Element</code>：被插入的节点指针，该节点的<code>Value</code>为数据内容</li>
</ul>
<p>功能说明：</p>
<p>把数据<code>value</code>插入到<code>mark</code>节点的前面，并返回这个被插入的节点。</p>
<p>代码实例：</p>
<pre><code class="language-go">
	package main

	import (
		&quot;container/list&quot;
		&quot;fmt&quot;
	)

	func main() {
		l := list.New()
		l.PushBack(&quot;a&quot;)
		e := l.PushBack(&quot;c&quot;)
		fmt.Println(e.Prev().Value) // 输出：a
		l.InsertBefore(&quot;b&quot;, e) // 在c前面插入b
		fmt.Println(e.Prev().Value) // 输出：b
	}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-l-list-len-int"><a class="header" href="#func-l-list-len-int">func (l *List) Len() int</a></h1>
<p>返回值：</p>
<ul>
<li><code>int</code>：链接中节点的个数</li>
</ul>
<p>功能说明：</p>
<p>获得链接中节点的个数</p>
<p>代码实例：</p>
<pre><code class="language-go">
	package main

	import (
		&quot;container/list&quot;
		&quot;fmt&quot;
	)

	func main() {
		l := list.New()
		fmt.Println(l.Len()) // 输出：0
		l.PushBack(&quot;a&quot;)
		fmt.Println(l.Len()) // 输出：1
		e := l.PushBack(&quot;b&quot;)
		fmt.Println(l.Len()) // 输出：2
		l.PushBack(&quot;c&quot;)
		fmt.Println(l.Len()) // 输出：3
		l.Remove(e)
		fmt.Println(l.Len()) // 输出：2
	}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-list"><a class="header" href="#type-list">type List</a></h1>
<h2 id="结构体代码-1"><a class="header" href="#结构体代码-1">结构体代码</a></h2>
<pre><code class="language-go">
 type List struct {
  front, back *Element
  len         int
 }

</code></pre>
<h2 id="结构体字段-1"><a class="header" href="#结构体字段-1">结构体字段</a></h2>
<ul>
<li><code>front *Element</code>：链表中的第一个节点的指针</li>
<li><code>back *Element</code>：链表中最后一个节点的指针</li>
<li><code>len int</code>：链表中节点的个数</li>
</ul>
<h2 id="函数链表-1"><a class="header" href="#函数链表-1">函数链表</a></h2>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/container/list/New.html">func New() *List</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/container/list/Back.html">func (l *List) Back() *Element</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/container/list/Front.html">func (l *List) Front() *Element</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/container/list/Init.html">func (l *List) Init() *List</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/container/list/InsertAfter.html">func (l *List) InsertAfter(value interface{}, mark *Element) *Element</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/container/list/InsertBefore.html">func (l *List) InsertBefore(value interface{}, mark *Element) *Element</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/container/list/Len.html">func (l *List) Len() int</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/container/list/MoveToBack.html">func (l *List) MoveToBack(e *Element)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/container/list/MoveToFront.html">func (l *List) MoveToFront(e *Element)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/container/list/PushBack.html">func (l *List) PushBack(value interface{}) *Element</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/container/list/PushBackList.html">func (l *List) PushBackList(ol *List)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/container/list/PushFront.html">func (l *List) PushFront(value interface{}) *Element</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/container/list/PushFrontList.html">func (l *List) PushFrontList(ol *List)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/container/list/Remove.html">func (l *List) Remove(e *Element) interface{}</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-l-list-movetobacke-element"><a class="header" href="#func-l-list-movetobacke-element">func (l *List) MoveToBack(e *Element)</a></h1>
<p>参数列表：</p>
<ul>
<li><code>e</code>：链表中的节点</li>
</ul>
<p>功能说明：</p>
<p>把节点<code>e</code>移到链表的末尾</p>
<p>代码实例：</p>
<pre><code class="language-go">
	package main

	import (
		&quot;container/list&quot;
		&quot;fmt&quot;
	)

	func main() {
		l := list.New()
		e := l.PushBack(&quot;a&quot;)
		l.PushBack(&quot;b&quot;)
		l.PushBack(&quot;c&quot;)
		
		fmt.Println(l.Front().Value) // 输出：a
		fmt.Println(l.Back().Value)  // 输出：c
		
		l.MoveToBack(e)
		
		fmt.Println(l.Front().Value) // 输出：b
		fmt.Println(l.Back().Value)  // 输出：a
	}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-l-list-movetofronte-element"><a class="header" href="#func-l-list-movetofronte-element">func (l *List) MoveToFront(e *Element)</a></h1>
<p>参数列表：</p>
<ul>
<li><code>e</code>：链表中的节点</li>
</ul>
<p>功能说明：</p>
<p>把节点<code>e</code>移到链表的开头</p>
<p>代码实例：</p>
<pre><code class="language-go">
	package main

	import (
		&quot;container/list&quot;
		&quot;fmt&quot;
	)

	func main() {
		l := list.New()
		l.PushBack(&quot;a&quot;)
		l.PushBack(&quot;b&quot;)
		e := l.PushBack(&quot;c&quot;)
		
		fmt.Println(l.Front().Value) // 输出：a
		fmt.Println(l.Back().Value)  // 输出：c
		
		l.MoveToFront(e)
		
		fmt.Println(l.Front().Value) // 输出：c
		fmt.Println(l.Back().Value)  // 输出：b
	}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-new-list"><a class="header" href="#func-new-list">func New() *List</a></h1>
<p>返回值：</p>
<ul>
<li><code>*List</code>：空链表的指针</li>
</ul>
<p>功能说明:</p>
<p>创建一个空链表，链表的长度为0，开头和末尾节点都是<code>nil</code></p>
<p>代码实例：</p>
<pre><code class="language-go">
	package main

	import (
		&quot;container/list&quot;
		&quot;fmt&quot;
	)

	func main() {
		l := list.New()
		e := l.Front()        // 取出链表开头的节点，即节点a
		fmt.Println(e == nil) // 输出：true
	}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-e-element-next-element"><a class="header" href="#func-e-element-next-element">func (e *Element) Next() *Element</a></h1>
<p>返回值：</p>
<ul>
<li><code>*Element</code>：链表中该节点的下一个节点元素的指针，如果该节点是最后一个节点，则返回<code>nil</code></li>
</ul>
<p>功能说明：</p>
<p>获得该节点在链表中的下一个节点元素的指针，如果该节点是最后一个节点，则返回<code>nil</code></p>
<p>代码实例：</p>
<pre><code class="language-go">
	package main

	import (
		&quot;container/list&quot;
		&quot;fmt&quot;
	)

	func main() {
		l := list.New()
		l.PushBack(&quot;a&quot;) // 把a加入链表的末尾
		l.PushBack(&quot;b&quot;) // 把b加入链表的末尾
		e := l.Front()   // 取出链表开头的节点，即节点a
		if e != nil {
			fmt.Println(e.Next().Value) // 输出：b
		}
	}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-e-element-prev-element"><a class="header" href="#func-e-element-prev-element">func (e *Element) Prev() *Element</a></h1>
<p>返回值：</p>
<ul>
<li><code>*Element</code>：链表中该节点的上一个节点元素的指针，如果该节点是第一个节点，则返回<code>nil</code></li>
</ul>
<p>功能说明：</p>
<p>获得该节点在链表中的上一个节点元素的指针，如果该节点是第一个节点，则返回<code>nil</code></p>
<p>代码实例：</p>
<pre><code class="language-go">
	package main

	import (
		&quot;container/list&quot;
		&quot;fmt&quot;
	)

	func main() {
		l := list.New()
		l.PushBack(&quot;a&quot;) // 把a加入链表的末尾
		l.PushBack(&quot;b&quot;) // 把b加入链表的末尾
		e := l.Back()   // 取出链表开头的节点，即节点b
		if e != nil {
			fmt.Println(e.Prev().Value) // 输出：a
		}
	}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-l-list-pushbackvalue-interface-element"><a class="header" href="#func-l-list-pushbackvalue-interface-element">func (l *List) PushBack(value interface{}) *Element</a></h1>
<p>参数列表：</p>
<ul>
<li><code>value</code>：将被存到链表末尾的任意对象</li>
</ul>
<p>返回值：</p>
<ul>
<li><code>*Element</code>：被存到末尾的节点的指针</li>
</ul>
<p>功能说明：</p>
<p>把一个对象存到链表末尾，并返回这个节点</p>
<p>代码实例：</p>
<pre><code class="language-go">
	package main

	import (
		&quot;fmt&quot;
		&quot;container/list&quot;
	)

	func main(){
		l := list.New()
		l.PushBack(&quot;a&quot;)
		fmt.Println(l.Back().Value) // 输出：a
		l.PushBack(&quot;b&quot;)
		fmt.Println(l.Back().Value) // 输出：b
		l.PushBack(&quot;c&quot;)
		fmt.Println(l.Back().Value) // 输出：c
	}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-l-list-pushbacklistol-list"><a class="header" href="#func-l-list-pushbacklistol-list">func (l *List) PushBackList(ol *List)</a></h1>
<p>参数列表：</p>
<ul>
<li><code>ol</code>：将被插入到链表<code>l</code>末尾的链表</li>
</ul>
<p>功能说明：</p>
<p>把一个链表存到链表末尾</p>
<p>代码实例：</p>
<pre><code class="language-go">
	package main

	import (
		&quot;fmt&quot;
		&quot;container/list&quot;
	)

	func main(){
		l1 := list.New()
		l1.PushBack(&quot;a&quot;)
		l1.PushBack(&quot;b&quot;)
		fmt.Println(l1.Len()) // 输出：2
		
		l2 := list.New()
		l2.PushBack(&quot;c&quot;)
		l2.PushBack(&quot;d&quot;)
		
		l1.PushBackList(l2) // l2中所有节点的list字段都是l2，在l2的所有节点都加到l1的末尾后，list字段编程了l1
		fmt.Println(l1.Len()) // 输出：4
		elementFromL1 := l1.Back();
		fmt.Println(elementFromL1.Value) // 输出：d
		l1.Remove(elementFromL1) // 删除末尾的元素
		fmt.Println(l1.Len()) // 输出：3
		fmt.Println(l1.Back().Value) // 输出：c
	}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-l-list-pushfrontvalue-interface-element"><a class="header" href="#func-l-list-pushfrontvalue-interface-element">func (l *List) PushFront(value interface{}) *Element</a></h1>
<p>参数列表：</p>
<ul>
<li><code>value</code>：将被存到链表开头的任意对象</li>
</ul>
<p>返回值：</p>
<ul>
<li><code>*Element</code>：被存到开头的节点的指针</li>
</ul>
<p>功能说明：</p>
<p>把一个对象存到链表开头，并返回这个节点</p>
<p>代码实例：</p>
<pre><code class="language-go">
	package main

	import (
		&quot;fmt&quot;
		&quot;container/list&quot;
	)

	func main(){
		l := list.New()
		l.PushFront(&quot;a&quot;)
		fmt.Println(l.Front().Value) // 输出：a
		l.PushFront(&quot;b&quot;)
		fmt.Println(l.Front().Value) // 输出：b
		l.PushFront(&quot;c&quot;)
		fmt.Println(l.Front().Value) // 输出：c
	}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-l-list-pushfrontlistol-list"><a class="header" href="#func-l-list-pushfrontlistol-list">func (l *List) PushFrontList(ol *List)</a></h1>
<p>参数列表：</p>
<ul>
<li><code>ol</code>：将被插入到链表<code>l</code>开头的链表</li>
</ul>
<p>功能说明：</p>
<p>把一个链表存到链表开头</p>
<p>代码实例：</p>
<pre><code class="language-go">
	package main

	import (
		&quot;fmt&quot;
		&quot;container/list&quot;
	)

	func main(){
		l1 := list.New()
		l1.PushFront(&quot;a&quot;)
		l1.PushFront(&quot;b&quot;)
		fmt.Println(l1.Len()) // 输出：2
		
		l2 := list.New()
		l2.PushFront(&quot;c&quot;)
		l2.PushFront(&quot;d&quot;)
		
		l1.PushFrontList(l2) // l2中所有节点的list字段都是l2，在l2的所有节点都加到l1的开头后，list字段编程了l1
		fmt.Println(l1.Len()) // 输出：4
		elementFromL1 := l1.Front();
		fmt.Println(elementFromL1.Value) // 输出：d
		l1.Remove(elementFromL1) // 删除开头的元素
		fmt.Println(l1.Len()) // 输出：3
		fmt.Println(l1.Front().Value) // 输出：c
	}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-l-list-removeeelement-interface"><a class="header" href="#func-l-list-removeeelement-interface">func (l <em>List) Remove(e</em>Element) interface{}</a></h1>
<p>参数列表：</p>
<ul>
<li><code>e</code>：将被删除的节点，该节点必须是属于链表<code>l</code>的</li>
</ul>
<p>返回值：</p>
<ul>
<li><code>interface{}</code>：被删除的节点的内容</li>
</ul>
<p>功能说明：</p>
<p>删除指定的节点，并返回这个节点的内容</p>
<p>代码实例：</p>
<pre><code class="language-go">
 package main

 import (
  &quot;fmt&quot;
  &quot;container/list&quot;
 )

 func main(){
  l1 := list.New()
  l1.PushBack(&quot;a&quot;)
  l1.PushBack(&quot;b&quot;)
  fmt.Println(l1.Len()) // 输出：2
  
  l2 := list.New()
  l2.PushBack(&quot;c&quot;)
  elementFromL2 := l2.PushBack(&quot;d&quot;)
  
  l1.PushBackList(l2) // l2中所有节点的list字段都是l2，在l2的所有节点都加到l1的末尾后，list字段编程了l1
  fmt.Println(l1.Len()) // 输出：4
  
  elementFromL1 := l1.Back();
  fmt.Println(elementFromL1.Value) // 输出：d
  l1.Remove(elementFromL2) // elementFromL2是属于l2的，不属于l1，所以l1不会有节点被删除
  fmt.Println(l1.Len()) // 输出：4
  fmt.Println(l1.Back().Value) // 输出：d
  l1.Remove(elementFromL1) // 成功的删除
  fmt.Println(l1.Len()) // 输出：3
  fmt.Println(l1.Back().Value) // 输出：c
 }

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ring包"><a class="header" href="#ring包">ring包</a></h1>
<h2 id="概述-4"><a class="header" href="#概述-4">概述:</a></h2>
<p>ring包实现了环形双向链表的功能。</p>
<h2 id="函数列表-1"><a class="header" href="#函数列表-1">函数列表：</a></h2>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/container/ring/Ring.html">type Ring</a>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/container/ring/New.html">func New(n int) *Ring</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/container/ring/Do.html">func (r *Ring) Do(f func(interface{}))</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/container/ring/Len.html">func (r *Ring) Len() int</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/container/ring/Link.html">func (r *Ring) Link(s *Ring) *Ring</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/container/ring/Move.html">func (r *Ring) Move(n int) *Ring</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/container/ring/Next.html">func (r *Ring) Next() *Ring</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/container/ring/Prev.html">func (r *Ring) Prev() *Ring</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/container/ring/Unlink.html">func (r *Ring) Unlink(n int) *Ring</a></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-r-ring-dof-funcinterface"><a class="header" href="#func-r-ring-dof-funcinterface">func (r *Ring) Do(f func(interface{}))</a></h1>
<p>参数列表：</p>
<ul>
<li><code>f</code>：一个回调函数，该函数的参数为环形双向链表中的节点的<code>Value</code>字段值</li>
</ul>
<p>功能说明：</p>
<p>正向遍历环形双向链表，并对每个链表中的元素执行回调函数<code>f</code>，如果这个回调函数<code>f</code>会修改链表<code>r</code>，那这个回调函数的行为将不可确定</p>
<p>代码实例：</p>
<pre><code class="language-go">
	package main

	import (
		&quot;container/ring&quot;
		&quot;fmt&quot;
	)

	func main() {
		r := ring.New(10)
		n := 0
		r.Do(func(v interface{}){
			n++
			v = n
			fmt.Printf(&quot;%d &quot;, v) // 输出：1 2 3 4 5 6 7 8 9 10 
		})
	}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-r-ring-len-int"><a class="header" href="#func-r-ring-len-int">func (r *Ring) Len() int</a></h1>
<p>返回值：</p>
<ul>
<li><code>int</code>：环形链表中元素的个数</li>
</ul>
<p>功能说明:</p>
<p>遍历环形双向链表来统计链表中的元素的个数</p>
<p>代码实例：</p>
<pre><code class="language-go">
	package main

	import (
		&quot;container/ring&quot;
		&quot;fmt&quot;
	)

	func main() {
		r := ring.New(10)
		fmt.Println(r.Len() == 10) // 输出：true
	}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-r-ring-links-ring-ring"><a class="header" href="#func-r-ring-links-ring-ring">func (r *Ring) Link(s *Ring) *Ring</a></h1>
<p>参数列表：</p>
<ul>
<li><code>s</code>：环形双向链表</li>
</ul>
<p>返回值：</p>
<ul>
<li><code>*Ring</code>：<code>s</code>和<code>r</code>相连前<code>r.Next()</code>的值，也是相连后<code>s.Next()</code>的值</li>
</ul>
<p>功能说明:</p>
<p>把一个环形双向链表<code>s</code>与环形双向链表<code>r</code>相链接，链接后<code>r.Next()</code>为s，并返回相连前时<code>r.Next()</code>的值。<code>r</code>不能为空。</p>
<ul>
<li>
<p>如果<code>s</code>和<code>r</code>不是同一个环形链表，则相连后，只产生一个环形链表，并返回相连前时<code>r.Next()</code>的值，也是相连后<code>s.Next()</code>的值。</p>
</li>
<li>
<p>如果<code>s</code>和<code>r</code>是同一个环形链表，但<code>s != r</code>时，相连后，产生两个环形链表，其中一个是由<code>r</code>和<code>s</code>之间的节点构成（不包括<code>r</code>和<code>s</code>），返回值为相连前时<code>r.Next()</code>的值，即<code>r</code>和<code>s</code>之间的节点（不包括<code>r</code>和<code>s</code>）构成的环形链表的表头节点。</p>
</li>
<li>
<p>如果<code>s</code>和<code>r</code>是同一个环形链表，且<code>s == r</code>时，相连后，产生两个环形链表，其中一个是由<code>r</code>指向的节点构成的长度为1的环形链表，其他节点构成另一个环形链表，返回值为相连前时<code>r.Next()</code>的值，即其他节点构成的环形链表的表头节点。</p>
</li>
</ul>
<p>代码实例：</p>
<pre><code class="language-go">
	package main

	import (
		&quot;container/ring&quot;
		&quot;fmt&quot;
	)

	func makeN(n int, begin int) *ring.Ring {
		r := ring.New(n)
		for i := begin; i &lt; n+begin; i++ {
			r.Value = i
			r = r.Next()
		}
		return r
	}

	// Link两个不同的环形链表
	func linkDiffRing() {
		r1 := makeN(5, 0)
		r1.Do(func(v interface{}) {
			fmt.Printf(&quot;%d &quot;, v) // 输出：0 1 2 3 4 
		})
		fmt.Println()

		r2 := makeN(5, 10)
		r2.Do(func(v interface{}) {
			fmt.Printf(&quot;%d &quot;, v) // 输出：10 11 12 13 14 
		})
		fmt.Println()

		r1.Link(r2)
		fmt.Println(r1.Value) // 输出：0

		r1.Do(func(v interface{}) {
			fmt.Printf(&quot;%d &quot;, v.(int)) // 输出：0 10 11 12 13 14 1 2 3 4 
		})
	}

	// 如果两个链表是同一个链表，但是两个指针不是指这个链表中的节点时，即s != r时
	func linkSameRing() {
		r1 := makeN(10, 0)
		r1.Do(func(v interface{}) {
			fmt.Printf(&quot;%d &quot;, v) // 输出：0 1 2 3 4 5 6 7 8 9 
		})
		fmt.Println()

		r2 := r1.Move(5)
		fmt.Println(r1.Value, r2.Value) // 输出：0 5
		
		r3 := r1.Link(r2)
		
		r1.Do(func(v interface{}) {
			fmt.Printf(&quot;%d &quot;, v.(int)) // 输出：0 5 6 7 8 9 
		})
		fmt.Println()
		r3.Do(func(v interface{}) {
			fmt.Printf(&quot;%d &quot;, v.(int)) // 输出：1 2 3 4 
		})
	}

	// 如果两个链表是同一个链表，且两个指针指向这个链表中的同一个节点时，即s == r时
	func linkSameElement() {
		r1 := makeN(10, 0)
		r1.Do(func(v interface{}) {
			fmt.Printf(&quot;%d &quot;, v) // 输出：0 1 2 3 4 5 6 7 8 9 
		})
		fmt.Println()
		fmt.Println(r1.Value) // 输出：0
		
		r2 := r1.Link(r1)
		
		r1.Do(func(v interface{}) {
			fmt.Printf(&quot;%d &quot;, v.(int)) // 输出：0 
		})
		fmt.Println()
		r2.Do(func(v interface{}) {
			fmt.Printf(&quot;%d &quot;, v.(int)) // 输出：1 2 3 4 5 6 7 8 9 
		})
	}

	func main() {
		linkDiffRing()
		fmt.Println()
		linkSameRing()
		fmt.Println()
		linkSameElement()
	}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-r-ring-moven-int-ring"><a class="header" href="#func-r-ring-moven-int-ring">func (r *Ring) Move(n int) *Ring</a></h1>
<p>参数列表：</p>
<ul>
<li><code>n</code>：指针<code>r</code>在双向链表上移动的位置的个数。n&gt;0时，为正向移动；反之为反向移动。</li>
</ul>
<p>返回值：</p>
<ul>
<li>*Ring：移动结束后，指针<code>r</code>指向的节点</li>
</ul>
<p>功能说明：</p>
<p>指向节点<code>r</code>的指针，正向或者逆向移动<code>n % r.Len()</code>个节点，并返回这个指针移动后指向的节点。但是<code>r.Move(n)</code>不对改变r的值，<code>r</code>不能为空</p>
<p>代码实例：</p>
<pre><code class="language-go">
	package main

	import (
		&quot;container/ring&quot;
		&quot;fmt&quot;
	)

	func makeN(n int, begin int) *ring.Ring {
		r := ring.New(n)
		for i := begin; i &lt; n+begin; i++ {
			r.Value = i
			r = r.Next()
		}
		return r
	}

	func main() {
		r := makeN(5, 0)
		r.Do(func(v interface{}) {
			fmt.Printf(&quot;%d &quot;, v) // 输出：0 1 2 3 4 
		})
		fmt.Println()

		fmt.Println(r.Value) // 输出：0
		rr := r.Move(3)
		fmt.Println(r.Value) // 输出：0
		fmt.Println(rr.Value) // 输出：3
	}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-newn-int-ring"><a class="header" href="#func-newn-int-ring">func New(n int) *Ring</a></h1>
<p>参数列表：</p>
<ul>
<li><code>n</code>：环形双向链表的节点的个数</li>
</ul>
<p>返回值：</p>
<ul>
<li><code>*Ring</code>：空链表的指针</li>
</ul>
<p>功能说明:</p>
<p>创建一个有n个节点的环形双向链表</p>
<p>代码实例：</p>
<pre><code class="language-go">
	package main

	import (
		&quot;container/ring&quot;
		&quot;fmt&quot;
	)

	func main() {
		r := ring.New(10)
		fmt.Println(r.Len() == 10) // 输出：true
	}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-r-ring-next-ring"><a class="header" href="#func-r-ring-next-ring">func (r *Ring) Next() *Ring</a></h1>
<p>返回值：</p>
<ul>
<li><code>*Ring</code>：指向下一个节点的指针</li>
</ul>
<p>功能说明：</p>
<p>获得指向下一个节点的指针</p>
<p>代码实例：</p>
<pre><code class="language-go">
	package main

	import (
		&quot;container/ring&quot;
		&quot;fmt&quot;
	)

	func makeN(n int, begin int) *ring.Ring {
		r := ring.New(n)
		for i := begin; i &lt; n+begin; i++ {
			r.Value = i
			r = r.Next()
		}
		return r
	}

	func main() {
		r := makeN(5, 0)
		r.Do(func(v interface{}) {
			fmt.Printf(&quot;%d &quot;, v) // 输出：0 1 2 3 4 
		})
		fmt.Println()

		fmt.Printf(&quot;%d &quot;, r.Value)
		rr := r.Next()
		for ; rr != r; rr = rr.Next() {
			fmt.Printf(&quot;%d &quot;, rr.Value)
		}
		// 输出：0 1 2 3 4 
	}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-r-ring-prev-ring"><a class="header" href="#func-r-ring-prev-ring">func (r *Ring) Prev() *Ring</a></h1>
<p>返回值：</p>
<ul>
<li><code>*Ring</code>：指向上一个节点的指针</li>
</ul>
<p>功能说明：</p>
<p>获得指向上一个节点的指针</p>
<p>代码实例：</p>
<pre><code class="language-go">
	package main

	import (
		&quot;container/ring&quot;
		&quot;fmt&quot;
	)

	func makeN(n int, begin int) *ring.Ring {
		r := ring.New(n)
		for i := begin; i &lt; n+begin; i++ {
			r.Value = i
			r = r.Next()
		}
		return r
	}

	func main() {
		r := makeN(5, 0)
		r.Do(func(v interface{}) {
			fmt.Printf(&quot;%d &quot;, v) // 输出：0 1 2 3 4 
		})
		fmt.Println()

		fmt.Printf(&quot;%d &quot;, r.Value)
		rr := r.Prev()
		for ; rr != r; rr = rr.Prev() {
			fmt.Printf(&quot;%d &quot;, rr.Value)
		}
		// 输出：0 1 2 3 4 
	}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-ring"><a class="header" href="#type-ring">type Ring</a></h1>
<h2 id="结构体代码-2"><a class="header" href="#结构体代码-2">结构体代码：</a></h2>
<pre><code class="language-go">
	type Ring struct {
		next, prev *Ring
		Value      interface{}
	}

</code></pre>
<h2 id="功能说明-1"><a class="header" href="#功能说明-1">功能说明：</a></h2>
<p>环形双向链表</p>
<h2 id="结构体字段-2"><a class="header" href="#结构体字段-2">结构体字段：</a></h2>
<ul>
<li><code>next *Ring</code>：指向链表中的下一个节点的指针</li>
<li><code>prev *Ring</code>：指向链表中的上一个节点的指针</li>
<li><code>Value interface{}</code>：该节点中存储的内容，可以是任何对象</li>
</ul>
<h2 id="函数链表-2"><a class="header" href="#函数链表-2">函数链表：</a></h2>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/container/ring/Do.html">func (r *Ring) Do(f func(interface{}))</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/container/ring/Len.html">func (r *Ring) Len() int</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/container/ring/Link.html">func (r *Ring) Link(s *Ring) *Ring</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/container/ring/Move.html">func (r *Ring) Move(n int) *Ring</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/container/ring/Next.html">func (r *Ring) Next() *Ring</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/container/ring/Prev.html">func (r *Ring) Prev() *Ring</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/container/ring/Unlink.html">func (r *Ring) Unlink(n int) *Ring</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-r-ring-unlinkn-int-ring"><a class="header" href="#func-r-ring-unlinkn-int-ring">func (r *Ring) Unlink(n int) *Ring</a></h1>
<p>参数列表：</p>
<ul>
<li><code>n</code>：要被移除的节点的数个</li>
</ul>
<p>功能说明：</p>
<p>从节点<code>r</code>的下一个节点（包含该节点）开始移除<code>n % r.Len()</code>个节点。如果<code>n % r.Len() == 0</code>，则链表不会有改变。<code>r</code>不能为空。</p>
<p>代码实例：</p>
<pre><code class="language-go">
	package main

	import (
		&quot;container/ring&quot;
		&quot;fmt&quot;
	)

	func makeN(n int, begin int) *ring.Ring {
		r := ring.New(n)
		for i := begin; i &lt; n+begin; i++ {
			r.Value = i
			r = r.Next()
		}
		return r
	}

	func main() {
		r := makeN(10, 0)
		r.Do(func(v interface{}) {
			fmt.Printf(&quot;%d &quot;, v) // 输出：0 1 2 3 4 5 6 7 8 9 
		})
		fmt.Println()

		fmt.Printf(&quot;%d\n&quot;, r.Value) // 输出：0
		r.Unlink(5)
		r.Do(func(v interface{}){
			fmt.Printf(&quot;%d &quot;, v)
		})
		// 输出：0 6 7 8 9 
	}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名-1"><a class="header" href="#包名-1">包名</a></h1>
<p>函数列表</p>
<ul>
<li>xxx1</li>
<li>xxx2</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cryptoaes包函数列表"><a class="header" href="#cryptoaes包函数列表">crypto/aes包函数列表</a></h1>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/crypto/aes/Constants.html">Constants</a> </li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/crypto/aes/NewCipher.html">func NewCipher(key []byte) (cipher.Block, error)</a> </li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/crypto/aes/KeySizeError.html">type KeySizeError</a>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/crypto/aes/KeySizeError.Error.html">func (k KeySizeError) Error() string</a></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="const-blocksize--16"><a class="header" href="#const-blocksize--16">const BlockSize = 16</a></h2>
<p>功能说明：</p>
<p>The AES block size in bytes.<br />
AES算法的块（加密数据块）的字节长度。</p>
<p>具体使用参见<a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/crypto/aes/NewCipher.html">func NewCipher(key []byte) (cipher.Block, error)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-k-keysizeerror-error-string"><a class="header" href="#func-k-keysizeerror-error-string">func (k KeySizeError) Error() string</a></h2>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回string</li>
</ul>
<p>功能说明：</p>
<p>返回密钥长度的错误</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;crypto/aes&quot;
	&quot;fmt&quot;
)

func main() {
	// 密钥，这个密钥的长度是错误的，AES要求只能是16，24或32个字节，本例是26个字节
	key := &quot;1234567890abcdef12345678ab&quot;
	// 这个err是KeySizeError类型
	_, err := aes.NewCipher([]byte(key))
	if err != nil {
		fmt.Printf(&quot;Error: NewCipher(%d bytes) = %s&quot;, len(key), err.Error())
	}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="type-keysizeerror-int"><a class="header" href="#type-keysizeerror-int">type KeySizeError int</a></h2>
<p>功能说明：</p>
<p>密钥长度错误的类型定义。</p>
<p>具体使用参见<a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/crypto/aes/KeySizeError.Error.html">func (k KeySizeError) Error() string</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-newcipherkey-byte-cipherblock-error"><a class="header" href="#func-newcipherkey-byte-cipherblock-error">func NewCipher(key []byte) (cipher.Block, error)</a></h2>
<p>参数列表</p>
<ul>
<li>key 密钥</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回cipher.Block, error</li>
</ul>
<p>功能说明：</p>
<p>NewCipher creates and returns a new cipher.Block. The key argument should be the AES key, either 16, 24, or 32 bytes to select AES-128, AES-192, or AES-256.<br />
返回cipher.Block，这个块是加密和解密的参数(AES为对称加密算法，即加密和解密需要相同的密钥)。参数key应该是AES的密钥，可以为16, 24, 32字节，分别对应AES-128, AES-192或AES-256。</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;crypto/aes&quot;
	&quot;crypto/cipher&quot;
	&quot;fmt&quot;
	&quot;os&quot;
)

func main() {
	// 消息明文
	src := []byte(&quot;hello, world&quot;)
	// 密钥，长度可以为16、24、32字节
	key := &quot;1234567890abcdef&quot;
	// 初始向量，长度必须为16个字节(128bit)
	var iv = []byte(&quot;abcdef1234567890&quot;)[:aes.BlockSize]
	// 得到块，用于加密和解密
	block, err := aes.NewCipher([]byte(key))
	if err != nil {
		fmt.Printf(&quot;Error: NewCipher(%d bytes) = %s&quot;, len(key), err)
		os.Exit(1)
	}
	fmt.Printf(&quot;NewClipher(%d bytes)\n&quot;, len(key))

	// 加密，使用CFB模式(密文反馈模式)，其他模式参见crypto/cipher
	encrypter := cipher.NewCFBEncrypter(block, iv)

	encrypted := make([]byte, len(src))
	encrypter.XORKeyStream(encrypted, src)
	fmt.Printf(&quot;Encrypting %s : %v -&gt; %v\n&quot;, src, []byte(src), encrypted)

	// 解密
	decrypter := cipher.NewCFBDecrypter(block, iv)

	decrypted := make([]byte, len(src))
	decrypter.XORKeyStream(decrypted, encrypted)
	fmt.Printf(&quot;Decrypting %v -&gt; %v : %s\n&quot;, encrypted, decrypted, decrypted)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名-2"><a class="header" href="#包名-2">包名</a></h1>
<p>函数列表</p>
<ul>
<li>xxx1</li>
<li>xxx2</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cryptodes包函数列表"><a class="header" href="#cryptodes包函数列表">crypto/des包函数列表</a></h1>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/crypto/des/Constants.html">Constants</a> </li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/crypto/des/NewCipher.html">func NewCipher(key []byte) (cipher.Block, error)</a> </li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/crypto/des/NewTripleDESCipher.html">func NewTripleDESCipher(key []byte) (cipher.Block, error)</a> </li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/crypto/des/KeySizeError.html">type KeySizeError</a>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/crypto/des/KeySizeError.Error.html">func (k KeySizeError) Error() string</a></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="const-blocksize--8"><a class="header" href="#const-blocksize--8">const BlockSize = 8</a></h2>
<p>功能说明：</p>
<p>The DES block size in bytes.<br />
DES算法的块（加密数据块）的字节长度。</p>
<p>具体使用参见<a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/crypto/des/NewCipher.html">func NewCipher(key []byte) (cipher.Block, error)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-k-keysizeerror-error-string-1"><a class="header" href="#func-k-keysizeerror-error-string-1">func (k KeySizeError) Error() string</a></h2>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回string</li>
</ul>
<p>功能说明：</p>
<p>返回密钥长度的错误.</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;crypto/des&quot;
	&quot;fmt&quot;
)

func main() {
	// 密钥，这个密钥的长度是错误的，DES要求只能是8个字节，本例是16个字节
	key := &quot;1234567890abcdef&quot;
	// 这个err是KeySizeError类型
	_, err := des.NewCipher([]byte(key))
	if err != nil {
		fmt.Printf(&quot;Error: NewCipher(%d bytes) = %s&quot;, len(key), err.Error())
	}
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="type-keysizeerror-int-1"><a class="header" href="#type-keysizeerror-int-1">type KeySizeError int</a></h2>
<p>功能说明：</p>
<p>密钥长度错误的类型定义。</p>
<p>具体使用参见<a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/crypto/des/KeySizeError.Error.html">func (k KeySizeError) Error() string</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-newcipherkey-byte-cipherblock-error-1"><a class="header" href="#func-newcipherkey-byte-cipherblock-error-1">func NewCipher(key []byte) (cipher.Block, error)</a></h2>
<p>参数列表</p>
<ul>
<li>key 密钥</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回cipher.Block, error</li>
</ul>
<p>功能说明：</p>
<p>NewCipher creates and returns a new cipher.Block.<br />
创建并返回cipher.Block。</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;crypto/cipher&quot;
	&quot;crypto/des&quot;
	&quot;fmt&quot;
	&quot;os&quot;
)

// 本例使用DES演示使用CBC模式（CBC模式必须有填充）
// 算法/模式/填充
// DES/CBC/PKCS5Padding
func main() {
	// 消息明文
	src := []byte(&quot;hello, world&quot;)
	// 密钥，长度为8字节
	key := &quot;12345678&quot;
	// 初始向量，长度大于8个字节
	var iv = []byte(&quot;12345678&quot;)
	// 得到块，用于加密和解密
	block, err := des.NewCipher([]byte(key))
	if err != nil {
		fmt.Printf(&quot;Error: NewCipher(%d bytes) = %s&quot;, len(key), err)
		os.Exit(1)
	}
	fmt.Printf(&quot;des.NewClipher(%d bytes)\n&quot;, len(key))

	// 加密，使用CBC模式(密码块链接模式)
	encrypter := cipher.NewCBCEncrypter(block, iv)
	// CBC要求明文必须是16字节的倍数，否则需要Padding
	src = PKCS5Padding(src, block.BlockSize())
	encrypted := make([]byte, len(src))
	encrypter.CryptBlocks(encrypted, src)
	fmt.Printf(&quot;Encrypting %s : %v -&gt; %v\n&quot;, src, []byte(src), encrypted)

	// 解密
	decrypter := cipher.NewCBCDecrypter(block, iv)

	decrypted := make([]byte, len(src))
	decrypter.CryptBlocks(decrypted, encrypted)
	decrypted = PKCS5UnPadding(decrypted)

	fmt.Printf(&quot;Decrypting %v -&gt; %v : %s\n&quot;, encrypted, decrypted, decrypted)
}

// PKCS5Padding
func PKCS5Padding(src []byte, blockSize int) []byte {
	padding := blockSize - len(src)%blockSize
	padtext := bytes.Repeat([]byte{byte(padding)}, padding)
	return append(src, padtext...)
}

// PKCS5UnPadding
func PKCS5UnPadding(src []byte) []byte {
	length := len(src)
	// 去掉最后一个字节 unpadding 次
	unpadding := int(src[length-1])
	return src[:(length - unpadding)]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-newtripledescipherkey-byte-cipherblock-error"><a class="header" href="#func-newtripledescipherkey-byte-cipherblock-error">func NewTripleDESCipher(key []byte) (cipher.Block, error)</a></h2>
<p>参数列表</p>
<ul>
<li>key 密钥</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回cipher.Block, error</li>
</ul>
<p>功能说明：</p>
<p>NewTripleDESCipher creates and returns a new cipher.Block.<br />
创建并返回cipher.Block。<br />
3DES是对每个数据块进行3次DES加密算法，密钥更长而已。</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;crypto/cipher&quot;
	&quot;crypto/des&quot;
	&quot;fmt&quot;
	&quot;os&quot;
)

// 本例使用3DES演示使用CBC模式（CBC模式必须有填充）
// 算法/模式/填充
// 3DES/CBC/PKCS5Padding
func main() {
	// 消息明文
	src := []byte(&quot;hello, world&quot;)
	// 密钥，长度为24字节
	key := &quot;12345678&quot; + &quot;12345678&quot; + &quot;12345678&quot;
	// 初始向量，长度大于8个字节
	var iv = []byte(&quot;12345678&quot;)
	// 得到块，用于加密和解密
	block, err := des.NewTripleDESCipher([]byte(key))
	if err != nil {
		fmt.Printf(&quot;Error: NewTripleDESCipher(%d bytes) = %s&quot;, len(key), err)
		os.Exit(1)
	}
	fmt.Printf(&quot;des.NewTripleDESCipher(%d bytes)\n&quot;, len(key))

	// 加密，使用CBC模式(密码块链接模式)
	encrypter := cipher.NewCBCEncrypter(block, iv)
	// CBC要求明文必须是16字节的倍数，否则需要Padding
	src = PKCS5Padding(src, block.BlockSize())
	encrypted := make([]byte, len(src))
	encrypter.CryptBlocks(encrypted, src)
	fmt.Printf(&quot;Encrypting %s : %v -&gt; %v\n&quot;, src, []byte(src), encrypted)

	// 解密
	decrypter := cipher.NewCBCDecrypter(block, iv)

	decrypted := make([]byte, len(src))
	decrypter.CryptBlocks(decrypted, encrypted)
	decrypted = PKCS5UnPadding(decrypted)

	fmt.Printf(&quot;Decrypting %v -&gt; %v : %s\n&quot;, encrypted, decrypted, decrypted)
}

// PKCS5Padding
func PKCS5Padding(src []byte, blockSize int) []byte {
	padding := blockSize - len(src)%blockSize
	padtext := bytes.Repeat([]byte{byte(padding)}, padding)
	return append(src, padtext...)
}

// PKCS5UnPadding
func PKCS5UnPadding(src []byte) []byte {
	length := len(src)
	// 去掉最后一个字节 unpadding 次
	unpadding := int(src[length-1])
	return src[:(length - unpadding)]
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名-3"><a class="header" href="#包名-3">包名</a></h1>
<p>函数列表</p>
<ul>
<li>xxx1</li>
<li>xxx2</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名-4"><a class="header" href="#包名-4">包名</a></h1>
<p>函数列表</p>
<ul>
<li>xxx1</li>
<li>xxx2</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名-5"><a class="header" href="#包名-5">包名</a></h1>
<p>函数列表</p>
<ul>
<li>xxx1</li>
<li>xxx2</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cryptohmac包函数列表"><a class="header" href="#cryptohmac包函数列表">crypto/hmac包函数列表</a></h1>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/crypto/hmac/New.html">func New(h func() hash.Hash, key []byte) hash.Hash</a> </li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-newh-func-hashhash-key-byte-hashhash"><a class="header" href="#func-newh-func-hashhash-key-byte-hashhash">func New(h func() hash.Hash, key []byte) hash.Hash</a></h2>
<p>参数列表</p>
<ul>
<li>h 哈希类型</li>
<li>key 密钥</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回hash.Hash</li>
</ul>
<p>功能说明：</p>
<p>New returns a new HMAC hash using the given hash.Hash type and key.<br />
根据一个给定的哈希类型和一个密钥，返回一个新的HMAC哈希</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;crypto/hmac&quot;
	&quot;crypto/sha256&quot;
	&quot;fmt&quot;
)

// HMAC-SHA256的例子, 提取自hmac_test.go
func main() {
	// 明文
	in := []byte(&quot;Sample message for keylen&lt;blocklen&quot;)
	// 密钥
	key := []byte{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
		0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
		0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
		0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f}
	// 输出
	out := &quot;a28cf43130ee696a98f14a37678b56bcfcbdd9e5cf69717fecf5480f0ebdf790&quot;
	// 使用HMAC-SHA256得到哈希运算消息认证码，其他如MD5, SHA1, SHA224, SHA384, SHA512
	h := hmac.New(sha256.New, key)
	n, err := h.Write(in)
	if n != len(in) || err != nil {
		fmt.Printf(&quot;Write(%d) = %d, %v&quot;, len(in), n, err)
	}
	sum := fmt.Sprintf(&quot;%x&quot;, h.Sum(nil))
	if sum != out {
		fmt.Println(&quot;Sum error.&quot;)
	}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cryptomd5包函数列表"><a class="header" href="#cryptomd5包函数列表">crypto/md5包函数列表</a></h1>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/crypto/md5/Constants.html">Constants</a> </li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/crypto/md5/New.html">func New() hash.Hash</a> </li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="const-blocksize--64"><a class="header" href="#const-blocksize--64">const BlockSize = 64</a></h2>
<p>功能说明：</p>
<p>The blocksize of MD5 in bytes.<br />
MD5的数据块的字节长度为64字节。</p>
<h2 id="const-size--16"><a class="header" href="#const-size--16">const Size = 16</a></h2>
<p>功能说明：</p>
<p>The size of an MD5 checksum in bytes.<br />
MD5的校验和的字节长度为16字节。</p>
<p>具体使用参见<a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/crypto/md5/New.html">func New() hash.Hash</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-new-hashhash"><a class="header" href="#func-new-hashhash">func New() hash.Hash</a></h2>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回hash.Hash类型</li>
</ul>
<p>功能说明：</p>
<p>New returns a new hash.Hash computing the MD5 checksum.<br />
New方法返回一个hash.Hash类型，用于计算MD5的校验和。</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;crypto/md5&quot;
	&quot;fmt&quot;
	&quot;io&quot;
)

// 官网的例子：http://golang.org/pkg/crypto/md5/
func main() {
	h := md5.New()
	io.WriteString(h, &quot;The fog is getting thicker!&quot;)
	io.WriteString(h, &quot;And Leon's getting laaarger!&quot;)
	fmt.Printf(&quot;%x&quot;, h.Sum(nil))
}
// e2c569be17396eca2a2e3c11578123ed
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名-6"><a class="header" href="#包名-6">包名</a></h1>
<p>函数列表</p>
<ul>
<li>xxx1</li>
<li>xxx2</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cryptorc4包函数列表"><a class="header" href="#cryptorc4包函数列表">crypto/rc4包函数列表</a></h1>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/crypto/rc4/Cipher.html">type Cipher</a> 
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/crypto/rc4/NewCipher.html">func NewCipher(key []byte) (*Cipher, error)</a> </li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/crypto/rc4/Reset.html">func (c *Cipher) Reset()</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/crypto/rc4/XORKeyStream.html">func (c *Cipher) XORKeyStream(dst, src []byte)</a></li>
</ul>
</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/crypto/rc4/KeySizeError.html">type KeySizeError</a>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/crypto/rc4/KeySizeError.Error.html">func (k KeySizeError) Error() string</a></li>
</ul>
</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/crypto/rc4/Bugs.html">Bugs</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="type-cipher"><a class="header" href="#type-cipher">type Cipher</a></h2>
<p>type Cipher struct {
// contains filtered or unexported fields
}</p>
<p>功能说明：</p>
<p>RC4加密算法需要的Cipher的结构定义。<br />
具体使用参见<a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/crypto/rc4/NewCipher.html">func NewCipher(key []byte) (*Cipher, error)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-k-keysizeerror-error-string-2"><a class="header" href="#func-k-keysizeerror-error-string-2">func (k KeySizeError) Error() string</a></h2>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回string</li>
</ul>
<p>功能说明：</p>
<p>返回密钥长度的错误</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;crypto/rand&quot;
	&quot;crypto/rc4&quot;
	&quot;fmt&quot;
)

func main() {
	// 密钥，这个密钥的长度是错误的，RC4要求最少1个字节，最多256个字节，本例是257个字节
	key := make([]byte, 257)
	rand.Read(key)
	
	// 这个err是KeySizeError类型
	_, err := rc4.NewCipher(key)
	if err != nil {
		fmt.Printf(&quot;failed to make RC4 cipher: %s&quot;, err)
	}
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="type-keysizeerror-int-2"><a class="header" href="#type-keysizeerror-int-2">type KeySizeError int</a></h2>
<p>功能说明：</p>
<p>密钥长度错误的类型定义。</p>
<p>具体使用参见<a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/crypto/rc4/KeySizeError.Error.html">func (k KeySizeError) Error() string</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-newcipherkey-byte-cipher-error"><a class="header" href="#func-newcipherkey-byte-cipher-error">func NewCipher(key []byte) (*Cipher, error)</a></h2>
<p>参数列表</p>
<ul>
<li>key 密钥</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回*Cipher(rc4的Cipher类型), error</li>
</ul>
<p>功能说明：</p>
<p>NewCipher creates and returns a new Cipher. The key argument should be the RC4 key, at least 1 byte and at most 256 bytes.<br />
NewCipher方法创建并返回一个新的Cipher类型。参数key应该是RC4的密钥，最少1个字节，最多256个字节。</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;crypto/rc4&quot;
	&quot;fmt&quot;
)

// RC4为对称加密算法
func main() {
	// 明文
	src := []byte(&quot;Hello, world!&quot;)
	// 密钥(长度：1到256个字节)
	key := []byte(&quot;12345&quot;)

	cipher, err := rc4.NewCipher(key)
	if err != nil {
		fmt.Println(&quot;rc4.NewCipher error:&quot; + err.Error())
	}

	encrypted := make([]byte, len(src))
	cipher.XORKeyStream(encrypted, src)
	fmt.Printf(&quot;Encrypting %s : %v -&gt; %v\n&quot;, src, []byte(src), encrypted)

	decrypted := make([]byte, len(encrypted))
	// 下面这个很奇怪? 不知道为什么解密时也得NewCipher一次，上面已经创建了....
	cipher, err = rc4.NewCipher(key)
	if err != nil {
		fmt.Println(&quot;rc4.NewCipher error:&quot; + err.Error())
	}
	cipher.XORKeyStream(decrypted, encrypted)
	fmt.Printf(&quot;Decrypting %v -&gt; %v : %s\n&quot;, encrypted, decrypted, decrypted)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-c-cipher-reset"><a class="header" href="#func-c-cipher-reset">func (c *Cipher) Reset()</a></h2>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>无</li>
</ul>
<p>功能说明：</p>
<p>Reset zeros the key data so that it will no longer appear in the process's memory.<br />
Reset（重置）方法清空密钥数据，所以它将不会在进程的内存中出现。</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;crypto/rc4&quot;
	&quot;fmt&quot;
)

func main() {
	// 明文
	src := []byte(&quot;Hello, world!&quot;)
	// 密钥(长度：1到256个字节)
	key := []byte(&quot;12345&quot;)

	cipher, _ := rc4.NewCipher(key)

	encrypted := make([]byte, len(src))
	cipher.XORKeyStream(encrypted, src)
	fmt.Printf(&quot;Encrypting %s : %v -&gt; %v\n&quot;, src, []byte(src), encrypted)
	
	// 重置，再进行异或运算已经无效
	cipher.Reset()
	decrypted := make([]byte, len(encrypted))
	cipher.XORKeyStream(decrypted, encrypted)
	fmt.Printf(&quot;Decrypting %v -&gt; %v : %s\n&quot;, encrypted, decrypted, decrypted)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-c-cipher-xorkeystreamdst-src-byte"><a class="header" href="#func-c-cipher-xorkeystreamdst-src-byte">func (c *Cipher) XORKeyStream(dst, src []byte)</a></h2>
<p>参数列表</p>
<ul>
<li>dst 目标</li>
<li>src 源</li>
</ul>
<p>返回值：</p>
<ul>
<li>无</li>
</ul>
<p>功能说明：</p>
<p>XORKeyStream sets dst to the result of XORing src with the key stream. Dst and src may be the same slice but otherwise should not overlap.<br />
XORKeyStream方法设置dst为src与密钥流的xor(异或)运算结果。dst和src应该是同一的slice但不应重叠。</p>
<p>代码实例：</p>
<p>具体使用参见<a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/crypto/rc4/NewCipher.html">func NewCipher(key []byte) (*Cipher, error)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名-7"><a class="header" href="#包名-7">包名</a></h1>
<p>函数列表</p>
<ul>
<li>xxx1</li>
<li>xxx2</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cryptosha1包函数列表"><a class="header" href="#cryptosha1包函数列表">crypto/sha1包函数列表</a></h1>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/crypto/sha1/Constants.html">Constants</a> </li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/crypto/sha1/New.html">func New() hash.Hash</a> </li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="const-blocksize--64-1"><a class="header" href="#const-blocksize--64-1">const BlockSize = 64</a></h2>
<p>功能说明：</p>
<p>The blocksize of MD5 in bytes.<br />
SHA1的数据块的字节长度为64字节。</p>
<h2 id="const-size--20"><a class="header" href="#const-size--20">const Size = 20</a></h2>
<p>功能说明：</p>
<p>The size of an MD5 checksum in bytes.<br />
SHA1的校验和的字节长度为20字节。</p>
<p>具体使用参见<a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/crypto/sha1/New.html">func New() hash.Hash</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-new-hashhash-1"><a class="header" href="#func-new-hashhash-1">func New() hash.Hash</a></h2>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回hash.Hash类型</li>
</ul>
<p>功能说明：</p>
<p>New returns a new hash.Hash computing the SHA1 checksum.<br />
New方法返回一个hash.Hash类型，用于计算SHA1的校验和。</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;crypto/sha1&quot;
	&quot;fmt&quot;
	&quot;io&quot;
)
// 官网的例子：http://golang.org/pkg/crypto/sha1/
func main() {
	h := sha1.New()
	io.WriteString(h, &quot;His money is twice tainted: 'taint yours and 'taint mine.&quot;)
	fmt.Printf(&quot;% x&quot;, h.Sum(nil))
}

// 59 7f 6a 54 00 10 f9 4c 15 d7 18 06 a9 9a 2c 87 10 e7 47 bd
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cryptosha256包函数列表"><a class="header" href="#cryptosha256包函数列表">crypto/sha256包函数列表</a></h1>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/crypto/sha256/New.html">func New() hash.Hash</a> </li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/crypto/sha256/New224.html">func New224() hash.Hash</a> </li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-new-hashhash-2"><a class="header" href="#func-new-hashhash-2">func New() hash.Hash</a></h2>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回hash.Hash</li>
</ul>
<p>功能说明：</p>
<p>New returns a new hash.Hash computing the SHA256 checksum.<br />
返回hash.Hash，可以进行SHA256（安全哈希算法）计算校验和值。</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;crypto/sha256&quot;
	&quot;fmt&quot;
	&quot;io&quot;
)

func main() {
	h := sha256.New()
	io.WriteString(h, &quot;His money is twice tainted: 'taint yours and 'taint mine.&quot;)
	fmt.Printf(&quot;% x&quot;, h.Sum(nil))
}

//结果，长度为32个字节
//80 01 f1 90 df b5 27 26 1c 4c fc ab 70 c9 8e 80 97 a7 a1 92 21 29 bc 40 96 95 0e 57 c7 99 9a 5a
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-new224-hashhash"><a class="header" href="#func-new224-hashhash">func New224() hash.Hash</a></h2>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回hash.Hash</li>
</ul>
<p>功能说明：</p>
<p>New224 returns a new hash.Hash computing the SHA224 checksum.<br />
返回hash.Hash，可以进行SHA224（安全哈希算法）计算校验和值。</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;crypto/sha256&quot;
	&quot;fmt&quot;
	&quot;io&quot;
)

func main() {
	h := sha256.New224()
	io.WriteString(h, &quot;His money is twice tainted: 'taint yours and 'taint mine.&quot;)
	fmt.Printf(&quot;% x&quot;, h.Sum(nil))
}

//结果，长度为28个字节
//35 a1 89 ce 98 71 51 df d0 0b 35 77 58 3c c6 a7 4b 98 69 ee cf 89 44 59 cb 52 03 8d
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cryptosha512包函数列表"><a class="header" href="#cryptosha512包函数列表">crypto/sha512包函数列表</a></h1>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/crypto/sha512/New.html">func New() hash.Hash</a> </li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/crypto/sha512/New384.html">func New384() hash.Hash</a> </li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-new-hashhash-3"><a class="header" href="#func-new-hashhash-3">func New() hash.Hash</a></h2>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回hash.Hash</li>
</ul>
<p>功能说明：</p>
<p>New returns a new hash.Hash computing the SHA512 checksum.<br />
返回hash.Hash，可以进行SHA512（安全哈希算法）计算校验和值。</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;crypto/sha512&quot;
	&quot;fmt&quot;
	&quot;io&quot;
)

func main() {
	h := sha512.New()
	io.WriteString(h, &quot;His money is twice tainted: 'taint yours and 'taint mine.&quot;)
	fmt.Printf(&quot;% x&quot;, h.Sum(nil))
}

//结果，长度为64个字节
//9a 98 dd 9b b6 7d 0d a7 bf 83 da 53 13 df f4 fd 60 a4 ba c0 09 4f 1b 05 63 36 90 ff a7 f6 d6 1d e9 a1 d4 f8 61 79 37 d5 60 83 3a 9a aa 9c ca fe 3f d2 4d b4 18 d0 e7 28 83 35 45 ca dd 3a d9 2d
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-new384-hashhash"><a class="header" href="#func-new384-hashhash">func New384() hash.Hash</a></h2>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回hash.Hash</li>
</ul>
<p>功能说明：</p>
<p>New384 returns a new hash.Hash computing the SHA384 checksum.<br />
返回hash.Hash，可以进行SHA384（安全哈希算法）计算校验和值。</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;crypto/sha512&quot;
	&quot;fmt&quot;
	&quot;io&quot;
)

func main() {
	h := sha512.New384()
	io.WriteString(h, &quot;His money is twice tainted: 'taint yours and 'taint mine.&quot;)
	fmt.Printf(&quot;% x&quot;, h.Sum(nil))
}

//结果，长度为48个字节
//ac 1c c0 f5 ac 8d 5f 55 14 a7 b7 38 ac 32 2b 7f b5 2a 16 1b 44 9c 36 72 e9 b6 a6 ad 1a 5e 4b 26 b0 01 cf 3b ad 24 c5 65 98 67 6c a1 7d 4b 44 5a
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cryptosubtle包函数列表"><a class="header" href="#cryptosubtle包函数列表">crypto/subtle包函数列表</a></h1>
<p>Package subtle implements functions that are often useful in cryptographic code but require careful thought to use correctly.<br />
subtle包是在加密的代码经常使用的一些方法，但是需要仔细考虑并正确使用。</p>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/crypto/subtle/ConstantTimeByteEq.html">func ConstantTimeByteEq(x, y uint8) int</a> </li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/crypto/subtle/ConstantTimeCompare.html">func ConstantTimeCompare(x, y []byte) int</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/crypto/subtle/ConstantTimeCopy.html">func ConstantTimeCopy(v int, x, y []byte)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/crypto/subtle/ConstantTimeEq.html">func ConstantTimeEq(x, y int32) int</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/crypto/subtle/ConstantTimeSelect.html">func ConstantTimeSelect(v, x, y int) int</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-constanttimebyteeqx-y-uint8-int"><a class="header" href="#func-constanttimebyteeqx-y-uint8-int">func ConstantTimeByteEq(x, y uint8) int</a></h2>
<p>参数列表</p>
<ul>
<li>x, y 8位无符号整型</li>
</ul>
<p>返回值：</p>
<ul>
<li>int 整型</li>
</ul>
<p>功能说明：</p>
<p>ConstantTimeByteEq returns 1 if x == y and 0 otherwise.<br />
如果x与y相等，返回1。否则返回0。</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;crypto/subtle&quot;
	&quot;fmt&quot;
)

func main() {
	fmt.Printf(&quot;%d\n&quot;, subtle.ConstantTimeByteEq(23, 45)) // x != y, return 0
	fmt.Printf(&quot;%d\n&quot;, subtle.ConstantTimeByteEq(23, 23)) // x == y, return 1
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-constanttimecomparex-y-byte-int"><a class="header" href="#func-constanttimecomparex-y-byte-int">func ConstantTimeCompare(x, y []byte) int</a></h2>
<p>参数列表</p>
<ul>
<li>x, y []byte</li>
</ul>
<p>返回值：</p>
<ul>
<li>int 整型</li>
</ul>
<p>功能说明：</p>
<p>ConstantTimeCompare returns 1 if the two equal length slices, x and y, have equal contents. The time taken is a function of the length of the slices and is independent of the contents.<br />
如果两个长度相等的slices（x与y）并且内容也相等，返回1。所花费的时间与slice的长度有关于内容无关。</p>
<p>注意： 文档没有说两个slices不相等时的返回值情况，注意下面的例子，小心使用</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;crypto/subtle&quot;
	&quot;fmt&quot;
)

func main() {
	fmt.Printf(&quot;%d\n&quot;, subtle.ConstantTimeCompare([]byte(&quot;lilei&quot;), []byte(&quot;lilei&quot;))) // 1
	fmt.Printf(&quot;%d\n&quot;, subtle.ConstantTimeCompare([]byte(&quot;lilei&quot;), []byte(&quot;lilei2&quot;))) // 0
	fmt.Printf(&quot;%d\n&quot;, subtle.ConstantTimeCompare([]byte(&quot;lilei&quot;), []byte(&quot; lilei&quot;))) // 0
	fmt.Printf(&quot;%d\n&quot;, subtle.ConstantTimeCompare([]byte(&quot;lilei &quot;), []byte(&quot;liming&quot;))) // 0
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-constanttimecopyv-int-x-y-byte"><a class="header" href="#func-constanttimecopyv-int-x-y-byte">func ConstantTimeCopy(v int, x, y []byte)</a></h2>
<p>参数列表</p>
<ul>
<li>v int</li>
<li>x, y []byte</li>
</ul>
<p>返回值：</p>
<ul>
<li>无</li>
</ul>
<p>功能说明：</p>
<p>ConstantTimeCopy copies the contents of y into x if v == 1. If v == 0, x is left unchanged. Its behavior is undefined if v takes any other value.<br />
如果参数v等于1，将y的内容拷贝到x中。如果参数v等于0，x不变。如果参数v是其他值，行为未被定义。</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;crypto/subtle&quot;
	&quot;fmt&quot;
)

func main() {

	y := []byte(&quot;lilei&quot;)
	x := make([]byte, len(y))
	subtle.ConstantTimeCopy(0, x, y)
	fmt.Printf(&quot;%s\n&quot;, x) // x = nil*5

	subtle.ConstantTimeCopy(1, x, y)
	fmt.Printf(&quot;%s\n&quot;, x) // x = lilei
	
	x = make([]byte, len(y))
	subtle.ConstantTimeCopy(13, x, y) // 不要如此使用，行为未被定义，结果未知。
	fmt.Printf(&quot;%s\n&quot;, x)

}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-constanttimeeqx-y-int32-int"><a class="header" href="#func-constanttimeeqx-y-int32-int">func ConstantTimeEq(x, y int32) int</a></h2>
<p>参数列表</p>
<ul>
<li>x, y 32位整型</li>
</ul>
<p>返回值：</p>
<ul>
<li>int 整型</li>
</ul>
<p>功能说明：</p>
<p>ConstantTimeEq returns 1 if x == y and 0 otherwise.<br />
如果x与y相等，返回1。否则返回0。</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;crypto/subtle&quot;
	&quot;fmt&quot;
)

func main() {
	fmt.Printf(&quot;%d\n&quot;, subtle.ConstantTimeEq(0, 1)) // 0
	fmt.Printf(&quot;%d\n&quot;, subtle.ConstantTimeEq(-1, -1)) // 1
	fmt.Printf(&quot;%d\n&quot;, subtle.ConstantTimeEq(-1, 1)) // 0
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-constanttimeselectv-x-y-int-int"><a class="header" href="#func-constanttimeselectv-x-y-int-int">func ConstantTimeSelect(v, x, y int) int</a></h2>
<p>参数列表</p>
<ul>
<li>v, x, y 整型</li>
</ul>
<p>返回值：</p>
<ul>
<li>int 整型</li>
</ul>
<p>功能说明：</p>
<p>ConstantTimeSelect returns x if v is 1 and y if v is 0. Its behavior is undefined if v takes any other value.<br />
如果v等于1， 返回x，如果v等于0，返回y。如果v是其他值，行为未被定义。</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;crypto/subtle&quot;
	&quot;fmt&quot;
)

func main() {
	fmt.Printf(&quot;%d\n&quot;, subtle.ConstantTimeSelect(1, 2, 3)) // v=1, 返回x, 即2
	fmt.Printf(&quot;%d\n&quot;, subtle.ConstantTimeSelect(0, 2, 3)) // v=1, 返回y, 即3

	// 不要使用v不是0或1的值，行为未被定义，结果未定。
	fmt.Printf(&quot;%d\n&quot;, subtle.ConstantTimeSelect(13, 2, 3))
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名-8"><a class="header" href="#包名-8">包名</a></h1>
<p>函数列表</p>
<ul>
<li>xxx1</li>
<li>xxx2</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名-9"><a class="header" href="#包名-9">包名</a></h1>
<p>函数列表</p>
<ul>
<li>xxx1</li>
<li>xxx2</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名-10"><a class="header" href="#包名-10">包名</a></h1>
<p>函数列表</p>
<ul>
<li>xxx1</li>
<li>xxx2</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="database-包名"><a class="header" href="#database-包名">database 包名</a></h1>
<p>database包主要是数据库的接口定义，下面有子包sql</p>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/database/sql/README.html">sql</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sql包"><a class="header" href="#sql包">sql包</a></h1>
<p>sql包实现了基于sql的通用接口，里面有查询、执行、事务等接口</p>
<ul>
<li>func Register(name string, driver driver.Driver)</li>
<li>type DB
<ul>
<li>func Open(driverName, dataSourceName string) (*DB, error)</li>
<li>func (db *DB) Begin() (*Tx, error)</li>
<li>func (db *DB) Close() error</li>
<li>func (db *DB) Driver() driver.Driver</li>
<li>func (db *DB) Exec(query string, args ...interface{}) (Result, error)</li>
<li>func (db *DB) Prepare(query string) (*Stmt, error)</li>
<li>func (db *DB) Query(query string, args ...interface{}) (*Rows, error)</li>
<li>func (db *DB) QueryRow(query string, args ...interface{}) *Row</li>
</ul>
</li>
<li>type NullBool
<ul>
<li>func (n *NullBool) Scan(value interface{}) error</li>
<li>func (n NullBool) Value() (driver.Value, error)</li>
</ul>
</li>
<li>type NullFloat64
<ul>
<li>func (n *NullFloat64) Scan(value interface{}) error</li>
<li>func (n NullFloat64) Value() (driver.Value, error)</li>
</ul>
</li>
<li>type NullInt64
<ul>
<li>func (n *NullInt64) Scan(value interface{}) error</li>
<li>func (n NullInt64) Value() (driver.Value, error)</li>
</ul>
</li>
<li>type NullString
<ul>
<li>func (ns *NullString) Scan(value interface{}) error</li>
<li>func (ns NullString) Value() (driver.Value, error)</li>
</ul>
</li>
<li>type RawBytes</li>
<li>type Result</li>
<li>type Row
<ul>
<li>func (r *Row) Scan(dest ...interface{}) error</li>
</ul>
</li>
<li>type Rows
<ul>
<li>func (rs *Rows) Close() error</li>
<li>func (rs *Rows) Columns() ([]string, error)</li>
<li>func (rs *Rows) Err() error</li>
<li>func (rs *Rows) Next() bool</li>
<li>func (rs *Rows) Scan(dest ...interface{}) error</li>
</ul>
</li>
<li>type Scanner</li>
<li>type Stmt
<ul>
<li>func (s *Stmt) Close() error</li>
<li>func (s *Stmt) Exec(args ...interface{}) (Result, error)</li>
<li>func (s *Stmt) Query(args ...interface{}) (*Rows, error)</li>
<li>func (s *Stmt) QueryRow(args ...interface{}) *Row</li>
</ul>
</li>
<li>type Tx
<ul>
<li>func (tx *Tx) Commit() error</li>
<li>func (tx *Tx) Exec(query string, args ...interface{}) (Result, error)</li>
<li>func (tx *Tx) Prepare(query string) (*Stmt, error)</li>
<li>func (tx *Tx) Query(query string, args ...interface{}) (*Rows, error)</li>
<li>func (tx *Tx) QueryRow(query string, args ...interface{}) *Row</li>
<li>func (tx *Tx) Rollback() error</li>
<li>func (tx *Tx) Stmt(stmt *Stmt) *Stmt</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="driver包"><a class="header" href="#driver包">driver包</a></h1>
<p>这个包里面定义很多需要实现的接口，以便/database/sql来调用</p>
<ul>
<li>func IsScanValue(v interface{}) bool</li>
<li>func IsValue(v interface{}) bool</li>
<li>type ColumnConverter</li>
<li>type Conn</li>
<li>type Driver</li>
<li>type Execer</li>
<li>type NotNull
<ul>
<li>func (n NotNull) ConvertValue(v interface{}) (Value, error)</li>
</ul>
</li>
<li>type Null
<ul>
<li>func (n Null) ConvertValue(v interface{}) (Value, error)</li>
</ul>
</li>
<li>type Result</li>
<li>type Rows</li>
<li>type RowsAffected
<ul>
<li>func (RowsAffected) LastInsertId() (int64, error)</li>
<li>func (v RowsAffected) RowsAffected() (int64, error)</li>
</ul>
</li>
<li>type Stmt</li>
<li>type Tx</li>
<li>type Value</li>
<li>type ValueConverter</li>
<li>type Valuer</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名-11"><a class="header" href="#包名-11">包名</a></h1>
<p>函数列表</p>
<ul>
<li>xxx1</li>
<li>xxx2</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名-12"><a class="header" href="#包名-12">包名</a></h1>
<p>函数列表</p>
<ul>
<li>xxx1</li>
<li>xxx2</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名-13"><a class="header" href="#包名-13">包名</a></h1>
<p>函数列表</p>
<ul>
<li>xxx1</li>
<li>xxx2</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名-14"><a class="header" href="#包名-14">包名</a></h1>
<p>函数列表</p>
<ul>
<li>xxx1</li>
<li>xxx2</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名-15"><a class="header" href="#包名-15">包名</a></h1>
<p>函数列表</p>
<ul>
<li>xxx1</li>
<li>xxx2</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名-16"><a class="header" href="#包名-16">包名</a></h1>
<p>函数列表</p>
<ul>
<li>xxx1</li>
<li>xxx2</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名-17"><a class="header" href="#包名-17">包名</a></h1>
<p>函数列表</p>
<ul>
<li>xxx1</li>
<li>xxx2</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名-18"><a class="header" href="#包名-18">包名</a></h1>
<p>函数列表</p>
<ul>
<li>xxx1</li>
<li>xxx2</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名-19"><a class="header" href="#包名-19">包名</a></h1>
<p>函数列表</p>
<ul>
<li>xxx1</li>
<li>xxx2</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="encodingbase32-包"><a class="header" href="#encodingbase32-包">encoding/base32 包</a></h1>
<p>实现了 RFC 4648 定义的 base32 编码</p>
<h3 id="变量"><a class="header" href="#变量">变量</a></h3>
<p>RFC 4648 定义的标准 base32 编码</p>
<pre><code class="language-go">var StdEncoding = NewEncoding(encodeStd)
</code></pre>
<p>RFC 4648 里定义的 “Extended Hex Alphabet”, 一般用于 DNS</p>
<pre><code class="language-go">var HexEncoding = NewEncoding(encodeHex)
</code></pre>
<h3 id="函数"><a class="header" href="#函数">函数</a></h3>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/encoding/base32/NewDecoder.html">func NewDecoder(enc *Encoding, r io.Reader) io.Reader</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/encoding/base32/NewEncoder.html">func NewEncoder(enc *Encoding, w io.Writer) io.WriteCloser</a></li>
</ul>
<h3 id="corruptinputerror-类型"><a class="header" href="#corruptinputerror-类型">CorruptInputError 类型</a></h3>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/encoding/base32/CorruptInputError.html">func (e CorruptInputError) Error() string</a></li>
</ul>
<h3 id="encoding-类型"><a class="header" href="#encoding-类型">Encoding 类型</a></h3>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/encoding/base32/NewEncoding.html">func NewEncoding(encoder string) *Encoding</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/encoding/base32/Decode.html">func (enc *Encoding) Decode(dst, src []byte) (n int, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/encoding/base32/DecodeString.html">func (enc *Encoding) DecodeString(s string) ([]byte, error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/encoding/base32/DecodedLen.html">func (enc *Encoding) DecodedLen(n int) int</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/encoding/base32/Encode.html">func (enc *Encoding) Encode(dst, src []byte)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/encoding/base32/EncodeToString.html">func (enc *Encoding) EncodeToString(src []byte) string</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/encoding/base32/EncodedLen.html">func (enc *Encoding) EncodedLen(n int) int</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-e-corruptinputerror-error-string-1"><a class="header" href="#func-e-corruptinputerror-error-string-1">func (e CorruptInputError) Error() string</a></h2>
<p>参数列表：</p>
<p>无</p>
<p>返回值：</p>
<ul>
<li>错误描述</li>
</ul>
<p>功能说明：</p>
<p>返回错误描述</p>
<p>代码实例：</p>
<pre><code class="language-go">package examples

import (
    &quot;fmt&quot;
    &quot;encoding/base32&quot;
)

func ExampleCorruptInputError1() {

    // 不合法的 base32 串
    src := &quot;ORUGS4ZANF@ZSAYJAORSXG5BAON2HE2LOM4XA====&quot;
    maxlen := base32.StdEncoding.DecodedLen(len(src))
    dst := make([]byte, maxlen)
    _, err := base32.StdEncoding.Decode(dst, []byte(src))
    if err != nil {
        fmt.Println(err.Error())
    }

    // Output:
    // illegal base32 data at input byte 10

}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-enc-encoding-decodedst-src-byte-n-int-err-error"><a class="header" href="#func-enc-encoding-decodedst-src-byte-n-int-err-error">func (enc *Encoding) Decode(dst, src []byte) (n int, err error)</a></h2>
<p>参数列表：</p>
<ul>
<li>dst 解码缓冲区</li>
<li>src 要解码的字符串切片</li>
</ul>
<p>返回值：</p>
<ul>
<li>n 解码到缓冲区的字节数</li>
<li>err 可能的错误</li>
</ul>
<p>功能说明：</p>
<p>对输入的字符串进行 base32 解码</p>
<p>代码实例：</p>
<pre><code class="language-go">package examples

import (
    &quot;fmt&quot;
    &quot;encoding/base32&quot;
)

func ExampleDecode1() {

    // 原始字符串
    origin := &quot;this is a test string.&quot;

    // 要解码的字符串
    src := &quot;ORUGS4ZANFZSAYJAORSXG5BAON2HE2LOM4XA====&quot;
    // 计算解码缓冲区需要的长度
    maxlen := base32.StdEncoding.DecodedLen(len(src))

    // 创建足够长度的缓冲区
    dst := make([]byte, maxlen)

    // 解码
    n, err := base32.StdEncoding.Decode(dst, []byte(src))
    fmt.Println(err == nil)

    // n 小于等于缓冲区长度
    fmt.Println(n &lt;= maxlen)

    // n 等于原始字符串的长度
    fmt.Println(n == len(origin))

    // 原始字符串和解码后字符串相同
    fmt.Println(string(dst[0:n]) == origin)

    // Output:
    // true
    // true
    // true
    // true

}

// 测试待解码内容中含有 &quot;\r&quot; &quot;\n&quot; 的情况(会被忽略)
func ExampleDecode2() {

    origin := &quot;this is a test string.&quot;
    src := &quot;ORUGS4ZANFZSAY\r\nJAOR\nSXG5BAON\r2HE2LOM4XA====&quot;
    maxlen := base32.StdEncoding.DecodedLen(len(src))
    dst := make([]byte, maxlen)
    n, err := base32.StdEncoding.Decode(dst, []byte(src))
    fmt.Println(err == nil)
    fmt.Println(n &lt;= maxlen)
    fmt.Println(n == len(origin))
    fmt.Println(string(dst[0:n]) == origin)

    // Output:
    // true
    // true
    // true
    // true

}

// 测试解码失败的情况
func ExampleDecode3() {

    origin := &quot;this is a test string.&quot;
    src := &quot;ORUGS4ZANFZSA@YJAORSXG5BAON2HE2LOM4XA====&quot;
    maxlen := base32.StdEncoding.DecodedLen(len(src))
    dst := make([]byte, maxlen)
    n, err := base32.StdEncoding.Decode(dst, []byte(src))
    fmt.Println(err != nil)
    fmt.Println(n &lt;= maxlen)
    fmt.Println(n != len(origin))
    fmt.Println(string(dst[0:n]) == &quot;this &quot;)

    // Output:
    // true
    // true
    // true
    // true

}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-enc-encoding-decodedlenn-int-int"><a class="header" href="#func-enc-encoding-decodedlenn-int-int">func (enc *Encoding) DecodedLen(n int) int</a></h2>
<p>参数列表：</p>
<ul>
<li>n 要进行 base32 解码的字节数</li>
</ul>
<p>返回值：</p>
<ul>
<li>base32 解码输出需要的最大字节数</li>
</ul>
<p>功能说明：</p>
<p>计算 base32 解码输出需要的最大字节数</p>
<p>代码实例：</p>
<pre><code class="language-go">package examples

import (
    &quot;fmt&quot;
    &quot;encoding/base32&quot;
)

func ExampleDecodedLen1() {

    src := &quot;ORUGS4ZANFZSAYJAORSXG5BAON2HE2LOM4XA====&quot;

    // 解码需要的缓冲区的最大长度
    l := base32.StdEncoding.DecodedLen(len(src))

    dst, _ := base32.StdEncoding.DecodeString(src)
    fmt.Println(len(dst) &lt;= l)

    // Output:
    // true
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-enc-encoding-decodestrings-string-byte-error"><a class="header" href="#func-enc-encoding-decodestrings-string-byte-error">func (enc *Encoding) DecodeString(s string) ([]byte, error)</a></h2>
<p>参数列表：</p>
<ul>
<li>s 要进行 base32 解码的字符串</li>
</ul>
<p>返回值：</p>
<ul>
<li>经过 base32 解码后的字符串切片</li>
<li>可能的错误</li>
</ul>
<p>功能说明：</p>
<p>对传入的字符串进行 base323 解码</p>
<p>代码实例：</p>
<pre><code class="language-go">package examples

import (
    &quot;fmt&quot;
    &quot;encoding/base32&quot;
)

func ExampleDecodeString1() {

    src := &quot;ORUGS4ZANFZSAYJAORSXG5BAON2HE2LOM4XA====&quot;
    dst, _ := base32.StdEncoding.DecodeString(src)
    fmt.Println(string(dst) == &quot;this is a test string.&quot;)

    dst, _ = base32.StdEncoding.DecodeString(&quot;&quot;)
    fmt.Println(string(dst) == &quot;&quot;)

    dst, _ = base32.StdEncoding.DecodeString(&quot;MY======&quot;)
    fmt.Println(string(dst) == &quot;f&quot;)

    dst, _ = base32.StdEncoding.DecodeString(&quot;MZXQ====&quot;)
    fmt.Println(string(dst) == &quot;fo&quot;)

    dst, _ = base32.StdEncoding.DecodeString(&quot;MZXW6===&quot;)
    fmt.Println(string(dst) == &quot;foo&quot;)

    dst, _ = base32.StdEncoding.DecodeString(&quot;MZXW6YQ=&quot;)
    fmt.Println(string(dst) == &quot;foob&quot;)

    dst, _ = base32.StdEncoding.DecodeString(&quot;MZXW6YTB&quot;)
    fmt.Println(string(dst) == &quot;fooba&quot;)

    dst, _ = base32.StdEncoding.DecodeString(&quot;MZXW6YTBOI======&quot;)
    fmt.Println(string(dst) == &quot;foobar&quot;)

    // Output:
    // true
    // true
    // true
    // true
    // true
    // true
    // true
    // true

}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-enc-encoding-encodedst-src-byte"><a class="header" href="#func-enc-encoding-encodedst-src-byte">func (enc *Encoding) Encode(dst, src []byte)</a></h2>
<p>参数列表：</p>
<ul>
<li>dst 编码缓冲区</li>
<li>src 要编码的字符串切片</li>
</ul>
<p>返回值：</p>
<p>无</p>
<p>功能说明：</p>
<p>对输入的字符串进行 base32 编码</p>
<p>代码实例：</p>
<pre><code class="language-go">package examples

import (
    &quot;fmt&quot;
    &quot;encoding/base32&quot;
)

func ExampleEncode1() {

    // 要编码的字符串
    src := &quot;this is a test string.&quot;
    // 计算编码缓冲区需要的长度
    l := base32.StdEncoding.EncodedLen(len(src))

    // 创建足够长度的缓冲区
    dst := make([]byte, l)

    // 编码
    base32.StdEncoding.Encode(dst, []byte(src))

    fmt.Println(string(dst) == &quot;ORUGS4ZANFZSAYJAORSXG5BAON2HE2LOM4XA====&quot;)
    fmt.Println(l == len(dst))
    fmt.Println(l%8 == 0)

    // Output:
    // true
    // true
    // true

}

func ExampleEncode2() {

    // 编码缓冲区需要的长度会被填充到8的倍数
    for ii := 0; ii &lt; 20; ii++ {
        l := base32.StdEncoding.EncodedLen(ii)
        fmt.Println(l, l%8 == 0) // true
    }

    // Output:
    // 0 true
    // 8 true
    // 8 true
    // 8 true
    // 8 true
    // 8 true
    // 16 true
    // 16 true
    // 16 true
    // 16 true
    // 16 true
    // 24 true
    // 24 true
    // 24 true
    // 24 true
    // 24 true
    // 32 true
    // 32 true
    // 32 true
    // 32 true

}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-enc-encoding-encodedlenn-int-int"><a class="header" href="#func-enc-encoding-encodedlenn-int-int">func (enc *Encoding) EncodedLen(n int) int</a></h2>
<p>参数列表：</p>
<ul>
<li>n 要进行 base32 编码的字节数</li>
</ul>
<p>返回值：</p>
<ul>
<li>经过 base32 编码后的字节数</li>
</ul>
<p>功能说明：</p>
<p>计算编码输出的字节数</p>
<p>代码实例：</p>
<pre><code class="language-go">package examples

import (
    &quot;fmt&quot;
    &quot;encoding/base32&quot;
)

func ExampleEncodedLen1() {

    src := []byte(&quot;this is a test string.&quot;)

    // 编码需要的缓冲区长度
    l := base32.StdEncoding.EncodedLen(len(src))

    dst := base32.StdEncoding.EncodeToString(src)
    fmt.Println(len(dst) == l)

    // Output:
    // true
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-enc-encoding-encodetostringsrc-byte-string"><a class="header" href="#func-enc-encoding-encodetostringsrc-byte-string">func (enc *Encoding) EncodeToString(src []byte) string</a></h2>
<p>参数列表：</p>
<ul>
<li>src 要进行 base32 编码的字符串切片</li>
</ul>
<p>返回值：</p>
<ul>
<li>经过 base32 编码后的字符串</li>
</ul>
<p>功能说明：</p>
<p>对传入的字符串切片进行 base32 编码</p>
<p>代码实例：</p>
<pre><code class="language-go">package examples

import (
    &quot;fmt&quot;
    &quot;encoding/base32&quot;
)

func ExampleEncodeToString1() {

    src := []byte(&quot;this is a test string.&quot;)
    dst := base32.StdEncoding.EncodeToString(src)
    fmt.Println(dst == &quot;ORUGS4ZANFZSAYJAORSXG5BAON2HE2LOM4XA====&quot;)

    fmt.Println(base32.StdEncoding.EncodeToString([]byte(&quot;&quot;)) == &quot;&quot;)
    fmt.Println(base32.StdEncoding.EncodeToString([]byte(&quot;f&quot;)) == &quot;MY======&quot;)
    fmt.Println(base32.StdEncoding.EncodeToString([]byte(&quot;fo&quot;)) == &quot;MZXQ====&quot;)
    fmt.Println(base32.StdEncoding.EncodeToString([]byte(&quot;foo&quot;)) == &quot;MZXW6===&quot;)
    fmt.Println(base32.StdEncoding.EncodeToString([]byte(&quot;foob&quot;)) == &quot;MZXW6YQ=&quot;)
    fmt.Println(base32.StdEncoding.EncodeToString([]byte(&quot;fooba&quot;)) == &quot;MZXW6YTB&quot;)
    fmt.Println(base32.StdEncoding.EncodeToString([]byte(&quot;foobar&quot;)) == &quot;MZXW6YTBOI======&quot;)

    // Output:
    // true
    // true
    // true
    // true
    // true
    // true
    // true
    // true

}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-newdecoderenc-encoding-r-ioreader-ioreader"><a class="header" href="#func-newdecoderenc-encoding-r-ioreader-ioreader">func NewDecoder(enc *Encoding, r io.Reader) io.Reader</a></h2>
<p>参数列表：</p>
<ul>
<li>enc Encoding 结构指针</li>
<li>w io.Reader 接口</li>
</ul>
<p>返回值：</p>
<ul>
<li>io.Reader 接口</li>
</ul>
<p>功能说明：</p>
<p>返回一个 io.Reader 接口，用于流式解码</p>
<p>代码实例：</p>
<pre><code class="language-go">package examples

import (
    &quot;fmt&quot;
    &quot;strings&quot;
    &quot;encoding/base32&quot;
)

// 从 string 取得输入
func ExampleNewDecoder1() {

    src := &quot;ORUGS4ZANFZSAYJAORSXG5BAON2HE2LOM4XA====&quot;
    reader := strings.NewReader(src)

    dst := &quot;&quot;

    decoder := base32.NewDecoder(base32.StdEncoding, reader)
    // 使用一个很小的输出buffer，测试流式解码
    buf := make([]byte, 2)
    for {
        n, err := decoder.Read(buf)
        if err != nil {
            break
        }
        if n == 0 {
            break
        }
        dst += string(buf[0:n])
    }
    fmt.Print(dst)

    // Output:
    // this is a test string.

}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-newencoderenc-encoding-w-iowriter-iowritecloser"><a class="header" href="#func-newencoderenc-encoding-w-iowriter-iowritecloser">func NewEncoder(enc *Encoding, w io.Writer) io.WriteCloser</a></h2>
<p>参数列表：</p>
<ul>
<li>enc Encoding 结构指针</li>
<li>w io.Writer 接口</li>
</ul>
<p>返回值：</p>
<ul>
<li>io.WriteCloser 接口</li>
</ul>
<p>功能说明：</p>
<p>返回一个 io.WriteCloser 接口，用于流式编码</p>
<p>代码实例：</p>
<pre><code class="language-go">package examples

import (
    &quot;fmt&quot;
    &quot;os&quot;
    &quot;encoding/base32&quot;
)

func ExampleNewEncoder1() {

    // 输出到标准输出
    encoder := base32.NewEncoder(base32.StdEncoding, os.Stdout)
    encoder.Write([]byte(&quot;this is a test string.&quot;))
    // 必须调用Close，刷新输出
    encoder.Close()

    // Output:
    // ORUGS4ZANFZSAYJAORSXG5BAON2HE2LOM4XA====

}

type StringWriter struct {
    S string
}
func (this *StringWriter) Write(p []byte) (n int, err error) {
    this.S += string(p);
    return len(p), nil
}

// 输出到自定义 Writer
func ExampleNewEncoder2() {

    buf := &amp;StringWriter{}

    encoder := base32.NewEncoder(base32.StdEncoding, buf)
    encoder.Write([]byte(&quot;this is a test string.&quot;))
    encoder.Close()

    fmt.Print(buf.S == &quot;ORUGS4ZANFZSAYJAORSXG5BAON2HE2LOM4XA====&quot;)

    // Output:
    // true

}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-newencodingencoder-string-encoding"><a class="header" href="#func-newencodingencoder-string-encoding">func NewEncoding(encoder string) *Encoding</a></h2>
<p>参数列表：</p>
<ul>
<li>encoder 32字节长的字符串，用做转换表</li>
</ul>
<p>返回值：</p>
<ul>
<li>Encoding 结构指针</li>
</ul>
<p>功能说明：</p>
<p>计算 base32 解码输出需要的最大字节数</p>
<p>代码实例：</p>
<pre><code class="language-go">package examples

import (
    &quot;fmt&quot;
    &quot;encoding/base32&quot;
)

// 我们的编码表，32 字节
const encodeTest = &quot;--------------------------------&quot;

func ExampleNewEncoding1() {

    enc := base32.NewEncoding(encodeTest)

    src := &quot;this is a test string.&quot;
    dst := enc.EncodeToString([]byte(src))

    // 最后不足8字节的会用&quot;=&quot;补全
    fmt.Println(dst)
    fmt.Println(len(dst) % 8 == 0)

    // Output:
    // ------------------------------------====
    // true

}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="encodingbase64-包"><a class="header" href="#encodingbase64-包">encoding/base64 包</a></h1>
<p>实现了 RFC 4648 定义的 base64 编码</p>
<h3 id="变量-1"><a class="header" href="#变量-1">变量</a></h3>
<p>RFC 4648 里定义的标准 base64 编码方法</p>
<pre><code class="language-go">var StdEncoding = NewEncoding(encodeStd)
</code></pre>
<p>修改过的 base64 编码，一般用于URL和文件名</p>
<pre><code class="language-go">var URLEncoding = NewEncoding(encodeURL)
</code></pre>
<h3 id="函数-1"><a class="header" href="#函数-1">函数</a></h3>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/encoding/base64/NewDecoder.html">func NewDecoder(enc *Encoding, r io.Reader) io.Reader</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/encoding/base64/NewEncoder.html">func NewEncoder(enc *Encoding, w io.Writer) io.WriteCloser</a></li>
</ul>
<h3 id="corruptinputerror-类型-1"><a class="header" href="#corruptinputerror-类型-1">CorruptInputError 类型</a></h3>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/encoding/base64/CorruptInputError.html">func (e CorruptInputError) Error() string</a></li>
</ul>
<h3 id="encoding-类型-1"><a class="header" href="#encoding-类型-1">Encoding 类型</a></h3>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/encoding/base64/NewEncoding.html">func NewEncoding(encoder string) *Encoding</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/encoding/base64/Decode.html">func (enc *Encoding) Decode(dst, src []byte) (n int, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/encoding/base64/DecodeString.html">func (enc *Encoding) DecodeString(s string) ([]byte, error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/encoding/base64/DecodedLen.html">func (enc *Encoding) DecodedLen(n int) int</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/encoding/base64/Encode.html">func (enc *Encoding) Encode(dst, src []byte)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/encoding/base64/EncodeToString.html">func (enc *Encoding) EncodeToString(src []byte) string</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/encoding/base64/EncodedLen.html">func (enc *Encoding) EncodedLen(n int) int</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-e-corruptinputerror-error-string-2"><a class="header" href="#func-e-corruptinputerror-error-string-2">func (e CorruptInputError) Error() string</a></h2>
<p>参数列表：</p>
<p>无</p>
<p>返回值：</p>
<ul>
<li>错误描述</li>
</ul>
<p>功能说明：</p>
<p>返回错误描述</p>
<p>代码实例：</p>
<pre><code class="language-go">package examples

import (
    &quot;fmt&quot;
    &quot;encoding/base64&quot;
)

func ExampleCorruptInputError1() {

    // 不合法的 base64 串
    src := &quot;dGhpcyBpcyBhI@HRlc3Qgc3RyaW5nLg==&quot;
    maxlen := base64.StdEncoding.DecodedLen(len(src))
    dst := make([]byte, maxlen)
    _, err := base64.StdEncoding.Decode(dst, []byte(src))
    if err != nil {
        fmt.Println(err.Error())
    }

    // Output:
    // illegal base64 data at input byte 13
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-enc-encoding-decodedst-src-byte-n-int-err-error-1"><a class="header" href="#func-enc-encoding-decodedst-src-byte-n-int-err-error-1">func (enc *Encoding) Decode(dst, src []byte) (n int, err error)</a></h2>
<p>参数列表：</p>
<ul>
<li>dst 解码缓冲区</li>
<li>src 要解码的字符串切片</li>
</ul>
<p>返回值：</p>
<ul>
<li>n 解码到缓冲区的字节数</li>
<li>err 可能的错误</li>
</ul>
<p>功能说明：</p>
<p>对输入的字符串进行 base64 解码</p>
<p>代码实例：</p>
<pre><code class="language-go">package examples

import (
    &quot;fmt&quot;
    &quot;encoding/base64&quot;
)

func ExampleDecode1() {

    // 原始字符串
    origin := &quot;this is a test string.&quot;

    // 要解码的字符串
    src := &quot;dGhpcyBpcyBhIHRlc3Qgc3RyaW5nLg==&quot;
    // 计算解码缓冲区需要的长度
    maxlen := base64.StdEncoding.DecodedLen(len(src))

    // 创建足够长度的缓冲区
    dst := make([]byte, maxlen)

    // 解码
    n, err := base64.StdEncoding.Decode(dst, []byte(src))
    fmt.Println(err == nil)

    // n 小于等于缓冲区长度
    fmt.Println(n &lt;= maxlen)

    // n 等于原始字符串的长度
    fmt.Println(n == len(origin))

    // 原始字符串和解码后字符串相同
    fmt.Println(string(dst[0:n]) == origin)

    // Output:
    // true
    // true
    // true
    // true

}

// 测试待解码内容中含有 &quot;\r&quot; &quot;\n&quot; 的情况(会被忽略)
func ExampleDecode2() {

    origin := &quot;this is a test string.&quot;
    src := &quot;dGhpcyBpcyBhI\rHRl\nc3Qgc\n\r3RyaW5nLg==&quot;
    maxlen := base64.StdEncoding.DecodedLen(len(src))
    dst := make([]byte, maxlen)
    n, err := base64.StdEncoding.Decode(dst, []byte(src))
    fmt.Println(err == nil)
    fmt.Println(n &lt;= maxlen)
    fmt.Println(n == len(origin))
    fmt.Println(string(dst[0:n]) == origin)

    // Output:
    // true
    // true
    // true
    // true

}

// 测试解码失败的情况
func ExampleDecode3() {

    origin := &quot;this is a test string.&quot;
    src := &quot;dGhpcyBpcyBhI@HRlc3Qgc3RyaW5nLg==&quot;
    maxlen := base64.StdEncoding.DecodedLen(len(src))
    dst := make([]byte, maxlen)
    n, err := base64.StdEncoding.Decode(dst, []byte(src))
    fmt.Println(err != nil)
    fmt.Println(n &lt;= maxlen)
    fmt.Println(n != len(origin))
    fmt.Println(string(dst[0:n]) == &quot;this is a&quot;)

    // Output:
    // true
    // true
    // true
    // true

}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-enc-encoding-decodedlenn-int-int-1"><a class="header" href="#func-enc-encoding-decodedlenn-int-int-1">func (enc *Encoding) DecodedLen(n int) int</a></h2>
<p>参数列表：</p>
<ul>
<li>n 要进行 base64 解码的字节数</li>
</ul>
<p>返回值：</p>
<ul>
<li>base64 解码输出需要的最大字节数</li>
</ul>
<p>功能说明：</p>
<p>计算 base64 解码输出需要的最大字节数</p>
<p>代码实例：</p>
<pre><code class="language-go">package examples

import (
    &quot;fmt&quot;
    &quot;encoding/base64&quot;
)

func ExampleDecodedLen1() {

    src := &quot;dGhpcyBpcyBhIHRlc3Qgc3RyaW5nLg==&quot;

    // 解码需要的缓冲区的最大长度
    l := base64.StdEncoding.DecodedLen(len(src))

    dst, _ := base64.StdEncoding.DecodeString(src)
    fmt.Println(len(dst) &lt;= l)

    // Output:
    // true
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-enc-encoding-decodestrings-string-byte-error-1"><a class="header" href="#func-enc-encoding-decodestrings-string-byte-error-1">func (enc *Encoding) DecodeString(s string) ([]byte, error)</a></h2>
<p>参数列表：</p>
<ul>
<li>s 要进行 base64 解码的字符串</li>
</ul>
<p>返回值：</p>
<ul>
<li>经过 base64 解码后的字符串切片</li>
<li>可能的错误</li>
</ul>
<p>功能说明：</p>
<p>对传入的字符串进行 base64 解码</p>
<p>代码实例：</p>
<pre><code class="language-go">package examples

import (
    &quot;fmt&quot;
    &quot;encoding/base64&quot;
)

func ExampleDecodeString1() {

    src := &quot;dGhpcyBpcyBhIHRlc3Qgc3RyaW5nLg==&quot;
    dst, _ := base64.StdEncoding.DecodeString(src)
    fmt.Println(string(dst) == &quot;this is a test string.&quot;)

    dst, _ = base64.StdEncoding.DecodeString(&quot;&quot;)
    fmt.Println(string(dst) == &quot;&quot;)

    dst, _ = base64.StdEncoding.DecodeString(&quot;Zg==&quot;)
    fmt.Println(string(dst) == &quot;f&quot;)

    dst, _ = base64.StdEncoding.DecodeString(&quot;Zm8=&quot;)
    fmt.Println(string(dst) == &quot;fo&quot;)

    dst, _ = base64.StdEncoding.DecodeString(&quot;Zm9v&quot;)
    fmt.Println(string(dst) == &quot;foo&quot;)

    dst, _ = base64.StdEncoding.DecodeString(&quot;Zm9vYg==&quot;)
    fmt.Println(string(dst) == &quot;foob&quot;)

    dst, _ = base64.StdEncoding.DecodeString(&quot;Zm9vYmE=&quot;)
    fmt.Println(string(dst) == &quot;fooba&quot;)

    dst, _ = base64.StdEncoding.DecodeString(&quot;Zm9vYmFy&quot;)
    fmt.Println(string(dst) == &quot;foobar&quot;)

    // Output:
    // true
    // true
    // true
    // true
    // true
    // true
    // true
    // true

}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-enc-encoding-encodedst-src-byte-1"><a class="header" href="#func-enc-encoding-encodedst-src-byte-1">func (enc *Encoding) Encode(dst, src []byte)</a></h2>
<p>参数列表：</p>
<ul>
<li>dst 编码缓冲区</li>
<li>src 要编码的字符串切片</li>
</ul>
<p>返回值：</p>
<p>无</p>
<p>功能说明：</p>
<p>对输入的字符串进行 base64 编码</p>
<p>代码实例：</p>
<pre><code class="language-go">package examples

import (
    &quot;fmt&quot;
    &quot;encoding/base64&quot;
)

func ExampleEncode1() {

    // 要编码的字符串
    src := &quot;this is a test string.&quot;
    // 计算编码缓冲区需要的长度
    l := base64.StdEncoding.EncodedLen(len(src))

    // 创建足够长度的缓冲区
    dst := make([]byte, l)

    // 编码
    base64.StdEncoding.Encode(dst, []byte(src))

    fmt.Println(string(dst) == &quot;dGhpcyBpcyBhIHRlc3Qgc3RyaW5nLg==&quot;)
    fmt.Println(l == len(dst))
    fmt.Println(l%4 == 0)

    // Output:
    // true
    // true
    // true

}

func ExampleEncode2() {

    // 编码缓冲区需要的长度会被填充到4的倍数
    for ii := 0; ii &lt; 20; ii++ {
        l := base64.StdEncoding.EncodedLen(ii)
        fmt.Println(l, l%4 == 0)
    }

    // Output:
    // 0 true
    // 4 true
    // 4 true
    // 4 true
    // 8 true
    // 8 true
    // 8 true
    // 12 true
    // 12 true
    // 12 true
    // 16 true
    // 16 true
    // 16 true
    // 20 true
    // 20 true
    // 20 true
    // 24 true
    // 24 true
    // 24 true
    // 28 true
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-enc-encoding-encodedlenn-int-int-1"><a class="header" href="#func-enc-encoding-encodedlenn-int-int-1">func (enc *Encoding) EncodedLen(n int) int</a></h2>
<p>参数列表：</p>
<ul>
<li>n 要进行 base64 编码的字节数</li>
</ul>
<p>返回值：</p>
<ul>
<li>经过 base64 编码后的字节数</li>
</ul>
<p>功能说明：</p>
<p>计算编码输出的字节数</p>
<p>代码实例：</p>
<pre><code class="language-go">package examples

import (
    &quot;fmt&quot;
    &quot;encoding/base64&quot;
)

func ExampleEncodedLen1() {

    src := []byte(&quot;this is a test string.&quot;)

    // 编码需要的缓冲区长度
    l := base64.StdEncoding.EncodedLen(len(src))

    dst := base64.StdEncoding.EncodeToString(src)
    fmt.Println(len(dst) == l)

    // Output:
    // true

}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-enc-encoding-encodetostringsrc-byte-string-1"><a class="header" href="#func-enc-encoding-encodetostringsrc-byte-string-1">func (enc *Encoding) EncodeToString(src []byte) string</a></h2>
<p>参数列表：</p>
<ul>
<li>src 要进行 base64 编码的字符串切片</li>
</ul>
<p>返回值：</p>
<ul>
<li>经过 base64 编码后的字符串</li>
</ul>
<p>功能说明：</p>
<p>对传入的字符串切片进行 base64 编码</p>
<p>代码实例：</p>
<pre><code class="language-go">package examples

import (
    &quot;fmt&quot;
    &quot;encoding/base64&quot;
)

func ExampleEncodeToString1() {

    src := []byte(&quot;this is a test string.&quot;)
    dst := base64.StdEncoding.EncodeToString(src)
    fmt.Println(dst == &quot;dGhpcyBpcyBhIHRlc3Qgc3RyaW5nLg==&quot;)

    fmt.Println(base64.StdEncoding.EncodeToString([]byte(&quot;&quot;)) == &quot;&quot;)
    fmt.Println(base64.StdEncoding.EncodeToString([]byte(&quot;f&quot;)) == &quot;Zg==&quot;)
    fmt.Println(base64.StdEncoding.EncodeToString([]byte(&quot;fo&quot;)) == &quot;Zm8=&quot;)
    fmt.Println(base64.StdEncoding.EncodeToString([]byte(&quot;foo&quot;)) == &quot;Zm9v&quot;)
    fmt.Println(base64.StdEncoding.EncodeToString([]byte(&quot;foob&quot;)) == &quot;Zm9vYg==&quot;)
    fmt.Println(base64.StdEncoding.EncodeToString([]byte(&quot;fooba&quot;)) == &quot;Zm9vYmE=&quot;)
    fmt.Println(base64.StdEncoding.EncodeToString([]byte(&quot;foobar&quot;)) == &quot;Zm9vYmFy&quot;)

    // Output:
    // true
    // true
    // true
    // true
    // true
    // true
    // true
    // true

}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-newdecoderenc-encoding-r-ioreader-ioreader-1"><a class="header" href="#func-newdecoderenc-encoding-r-ioreader-ioreader-1">func NewDecoder(enc *Encoding, r io.Reader) io.Reader</a></h2>
<p>参数列表：</p>
<ul>
<li>enc Encoding 结构指针</li>
<li>w io.Reader 接口</li>
</ul>
<p>返回值：</p>
<ul>
<li>io.Reader 接口</li>
</ul>
<p>功能说明：</p>
<p>返回一个 io.Reader 接口，用于流式解码</p>
<p>代码实例：</p>
<pre><code class="language-go">package examples

import (
    &quot;fmt&quot;
    &quot;strings&quot;
    &quot;encoding/base64&quot;
)

// 从 string 取得输入
func ExampleNewDecoder1() {

    src := &quot;dGhpcyBpcyBhIHRlc3Qgc3RyaW5nLg==&quot;
    reader := strings.NewReader(src)

    dst := &quot;&quot;

    decoder := base64.NewDecoder(base64.StdEncoding, reader)
    // 使用一个很小的输出buffer，测试流式解码
    buf := make([]byte, 2)
    for {
        n, err := decoder.Read(buf)
        if err != nil {
            break
        }
        if n == 0 {
            break
        }
        dst += string(buf[0:n])
    }
    fmt.Print(dst)

    // Output:
    // this is a test string.

}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-newencoderenc-encoding-w-iowriter-iowritecloser-1"><a class="header" href="#func-newencoderenc-encoding-w-iowriter-iowritecloser-1">func NewEncoder(enc *Encoding, w io.Writer) io.WriteCloser</a></h2>
<p>参数列表：</p>
<ul>
<li>enc Encoding 结构指针</li>
<li>w io.Writer 接口</li>
</ul>
<p>返回值：</p>
<ul>
<li>io.WriteCloser 接口</li>
</ul>
<p>功能说明：</p>
<p>返回一个 io.WriteCloser 接口，用于流式编码</p>
<p>代码实例：</p>
<pre><code class="language-go">package examples

import (
    &quot;fmt&quot;
    &quot;os&quot;
    &quot;encoding/base64&quot;
)

func Example1() {

    // 输出到标准输出
    encoder := base64.NewEncoder(base64.StdEncoding, os.Stdout)
    encoder.Write([]byte(&quot;this is a test string.&quot;))
    // 必须调用Close，刷新输出
    encoder.Close()

    // Output:
    // dGhpcyBpcyBhIHRlc3Qgc3RyaW5nLg==

}

type StringWriter struct {
    S string
}
func (this *StringWriter) Write(p []byte) (n int, err error) {
    this.S += string(p);
    return len(p), nil
}

// 输出到自定义 Writer
func ExampleNewEncoder2() {

    buf := &amp;StringWriter{}

    encoder := base64.NewEncoder(base64.StdEncoding, buf)
    encoder.Write([]byte(&quot;this is a test string.&quot;))
    encoder.Close()

    fmt.Print(buf.S == &quot;dGhpcyBpcyBhIHRlc3Qgc3RyaW5nLg==&quot;)

    // Output:
    // true

}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-newencodingencoder-string-encoding-1"><a class="header" href="#func-newencodingencoder-string-encoding-1">func NewEncoding(encoder string) *Encoding</a></h2>
<p>参数列表：</p>
<ul>
<li>encoder 64字节长的字符串，用做转换表</li>
</ul>
<p>返回值：</p>
<ul>
<li>Encoding 结构指针</li>
</ul>
<p>功能说明：</p>
<p>计算 base64 解码输出需要的最大字节数</p>
<p>代码实例：</p>
<pre><code class="language-go">package examples

import (
    &quot;fmt&quot;
    &quot;encoding/base64&quot;
)

// 我们的编码表，64 字节
const encodeTest = &quot;----------------------------------------------------------------&quot;

func ExampleNewEncoding1() {

    enc := base64.NewEncoding(encodeTest)

    src := &quot;this is a test string.&quot;
    dst := enc.EncodeToString([]byte(src))

    // 最后不足4字节的会用&quot;=&quot;补全
    fmt.Println(dst)
    fmt.Println(len(dst) % 4 == 0)

    // Output:
    // ------------------------------==
    // true

}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="encodingbinary"><a class="header" href="#encodingbinary">encoding/binary</a></h1>
<p>此包实现了对数据与byte之间的转换，以及varint的编解码。</p>
<p>##函数列表</p>
<p>数据的byte序列化转换</p>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/encoding/binary/Read.html">func Read(r io.Reader, order ByteOrder, data interface{}) error</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/encoding/binary/Write.html">func Write(w io.Writer, order ByteOrder, data interface{}) error</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/encoding/binary/Size.html">func Size(v interface{}) int</a></li>
</ul>
<p>uvarint和varint的编解码</p>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/encoding/binary/PutUvarint.html">func PutUvarint(buf []byte, x uint64) int</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/encoding/binary/PutVarint.html">func PutVarint(buf []byte, x int64) int</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/encoding/binary/Uvarint.html">func Uvarint(buf []byte) (uint64, int)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/encoding/binary/Varint.html">func Varint(buf []byte) (int64, int)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/encoding/binary/ReadUvarint.html">func ReadUvarint(r io.ByteReader) (uint64, error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/encoding/binary/ReadVarint.html">func ReadVarint(r io.ByteReader) (int64, error)</a></li>
</ul>
<p>##结构体</p>
<ul>
<li>type ByteOrder：可以定义自己的字节序结构，用于序列化和反序列化数据。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-putuvarintbuf-byte-x-uint64-int"><a class="header" href="#func-putuvarintbuf-byte-x-uint64-int">func PutUvarint(buf []byte, x uint64) int</a></h2>
<p>###参数列表</p>
<ul>
<li>buf 需写入的缓冲区 </li>
<li>x uint64类型数字</li>
</ul>
<p>###返回值：</p>
<ul>
<li>int 写入字节数。</li>
<li>panic buf过小。</li>
</ul>
<p>###功能说明：</p>
<p>PutUvarint主要是将uint64类型放入buf中，并返回写入的字节数。如果buf过小，PutUvarint将抛出panic。</p>
<p>###代码实例：</p>
<pre><code>package main

import (
    &quot;encoding/binary&quot;
	&quot;fmt&quot;
)

func main() {
	var u16 uint16 = 1234 //0x1020
	var u64 uint64 = 0x1020304040302010
	var sbuf []byte = make([]byte, 4)
	var buf []byte = make([]byte, 10)

	ret := binary.PutUvarint(sbuf, uint64(u16))
	fmt.Println(ret, sbuf) // 2 [210 9 0 0]

	//ret = binary.PutUvarint(sbuf, u64) //panic

	ret = binary.PutUvarint(buf, u64)
	fmt.Println(ret, buf) //9 [144 192 192 129 132 136 140 144 16 0]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-putvarintbuf-byte-x-int64-int"><a class="header" href="#func-putvarintbuf-byte-x-int64-int">func PutVarint(buf []byte, x int64) int</a></h2>
<p>###参数列表</p>
<ul>
<li>buf 需写入的缓冲区 </li>
<li>x int64类型数字</li>
</ul>
<p>###返回值：</p>
<ul>
<li>int 写入字节数。</li>
<li>panic buf过小。</li>
</ul>
<p>###功能说明：</p>
<p>PutVarint主要是将int64类型放入buf中，并返回写入的字节数。如果buf过小，PutVarint将抛出panic。</p>
<p>###代码实例：</p>
<pre><code>package main

import (
  &quot;encoding/binary&quot;
	&quot;fmt&quot;
)

func main() {
	var i16 int16 = 1234
	var i64 int64 = -1234567890
	var sbuf []byte = make([]byte, 4)
	var buf []byte = make([]byte, 10)

	ret := binary.PutVarint(sbuf, int64(i16))
	fmt.Println(ret, sbuf) // 2 [164 19 0 0]

	//ret = binary.PutVarint(sbuf, i64) //panic

	ret = binary.PutVarint(buf, i64)
	fmt.Println(ret, buf) // 5 [163 139 176 153 9 0 0 0 0 0]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-readr-ioreader-order-byteorder-data-interface-error"><a class="header" href="#func-readr-ioreader-order-byteorder-data-interface-error">func Read(r io.Reader, order ByteOrder, data interface{}) error</a></h2>
<p>###参数列表</p>
<ul>
<li>r 可以读出字节流的数据源 </li>
<li>order 特殊字节序，包中提供大端字节序和小端字节序</li>
<li>data 需要解码成的数据</li>
</ul>
<p>###返回值：</p>
<ul>
<li>error 返回错误</li>
</ul>
<p>###功能说明：</p>
<p>Read从r中读出字节数据并反序列化成结构数据。data必须是固定长的数据值或固定长数据的slice。从r中读出的数据可以使用特殊的
字节序来解码，并顺序写入value的字段。当填充结构体时，使用(_)名的字段将被跳过。例如：为了字节对齐而添加的空字段。</p>
<p>###代码实例：
package main</p>
<pre><code>import (
  &quot;bytes&quot;
	&quot;encoding/binary&quot;
	&quot;fmt&quot;
)

func main() {
	var pi float64
	b := []byte{0x18, 0x2d, 0x44, 0x54, 0xfb, 0x21, 0x09, 0x40}
	buf := bytes.NewBuffer(b)

	err := binary.Read(buf, binary.LittleEndian, &amp;pi)
	if err != nil {
		fmt.Println(&quot;binary.Read failed:&quot;, err)
	}
	fmt.Println(pi) //3.141592653589793
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-readuvarintr-iobytereader-uint64-error"><a class="header" href="#func-readuvarintr-iobytereader-uint64-error">func ReadUvarint(r io.ByteReader) (uint64, error)</a></h2>
<p>###参数列表</p>
<ul>
<li>r 实现ReadByte()接口的对象</li>
</ul>
<p>###返回值：</p>
<ul>
<li>uint64 解析出的数据</li>
<li>error 返回的错误</li>
</ul>
<p>###功能说明：</p>
<p>ReadUvarint从r中解析并返回一个uint64类型的数据及出现的错误。</p>
<p>###代码实例：</p>
<pre><code>package main

import (
  &quot;bytes&quot;
	&quot;encoding/binary&quot;
	&quot;fmt&quot;
)

func main() {
	var sbuf []byte
	var buf []byte = []byte{144, 192, 192, 129, 132, 136, 140, 144, 16, 0, 1, 1}
	var bbuf []byte = []byte{144, 192, 192, 129, 132, 136, 140, 144, 192, 192, 1, 1}

	num, err := binary.ReadUvarint(bytes.NewBuffer(sbuf))
	fmt.Println(num, err) //0 EOF

	num, err = binary.ReadUvarint(bytes.NewBuffer(buf))
	fmt.Println(num, err) //1161981756374523920 &lt;nil&gt;

	num, err = binary.ReadUvarint(bytes.NewBuffer(bbuf))
	fmt.Println(num, err) //4620746270195064848 binary: varint overflows a 64-bit integer
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-readvarintr-iobytereader-int64-error"><a class="header" href="#func-readvarintr-iobytereader-int64-error">func ReadVarint(r io.ByteReader) (int64, error)</a></h2>
<p>###参数列表</p>
<ul>
<li>r 实现ByteReader接口的对象</li>
</ul>
<p>###返回值：</p>
<ul>
<li>int64 解析出的数据</li>
<li>error 返回的错误</li>
</ul>
<p>###功能说明：</p>
<p>ReadVarint从r中解析并返回一个int64类型的数据及出现的错误。</p>
<p>###代码实例：</p>
<pre><code>package main

import (
  &quot;bytes&quot;
	&quot;encoding/binary&quot;
	&quot;fmt&quot;
)

func main() {
	var sbuf []byte
	var buf []byte = []byte{144, 192, 192, 129, 132, 136, 140, 144, 16, 0, 1, 1}
	var bbuf []byte = []byte{144, 192, 192, 129, 132, 136, 140, 144, 192, 192, 1, 1}

	num, err := binary.ReadVarint(bytes.NewBuffer(sbuf))
	fmt.Println(num, err) //0 EOF

	num, err = binary.ReadVarint(bytes.NewBuffer(buf))
	fmt.Println(num, err) //580990878187261960 &lt;nil&gt;

	num, err = binary.ReadVarint(bytes.NewBuffer(bbuf))
	fmt.Println(num, err) //2310373135097532424 binary: varint overflows a 64-bit integer
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-sizev-interface-int"><a class="header" href="#func-sizev-interface-int">func Size(v interface{}) int</a></h2>
<p>###参数列表</p>
<ul>
<li>v 需要计算长度的数据</li>
</ul>
<p>###返回值：</p>
<ul>
<li>int 数据序列化之后的字节长度</li>
</ul>
<p>###功能说明：</p>
<p>Size将返回数据序列化之后的字节长度，数据必须是固定长数据类型、slice和结构体及其指针等。</p>
<p>###代码实例：
package main</p>
<pre><code>import (
  &quot;encoding/binary&quot;
	&quot;fmt&quot;
)

func main() {
	var a int
	b := [5]int64{1}

	fmt.Println(binary.Size(a)) //-1
	fmt.Println(binary.Size(b)) //40
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-uvarintbuf-byte-uint64-int"><a class="header" href="#func-uvarintbuf-byte-uint64-int">func Uvarint(buf []byte) (uint64, int)</a></h2>
<p>###参数列表</p>
<ul>
<li>buf 需要解码的缓冲区 </li>
</ul>
<p>###返回值：</p>
<ul>
<li>uint64 解码的数据。</li>
<li>int 解析的字节数。</li>
</ul>
<p>###功能说明：</p>
<p>Uvarint是从buf中解码并返回一个uint64的数据，及解码的字节数（&gt;0）。
如果出错，则返回数据0和一个小于等于0的字节数n，其意义为：</p>
<pre><code>n == 0：buf太小
n  &lt; 0：数据太大，超过64位，且-n为已解析字节数
</code></pre>
<p>###代码实例：</p>
<pre><code>package main

import (
  &quot;encoding/binary&quot;
	&quot;fmt&quot;
)

func main() {
	var sbuf []byte
	var buf []byte = []byte{144, 192, 192, 129, 132, 136, 140, 144, 16, 0, 1, 1}
	var bbuf []byte = []byte{144, 192, 192, 129, 132, 136, 140, 144, 192, 192, 1, 1}

	num, ret := binary.Uvarint(sbuf)
	fmt.Println(num, ret) //0 0

	num, ret = binary.Uvarint(buf)
	fmt.Println(num, ret) //1161981756374523920 9

	num, ret = binary.Uvarint(bbuf)
	fmt.Println(num, ret) //0 -11
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-varintbuf-byte-int64-int"><a class="header" href="#func-varintbuf-byte-int64-int">func Varint(buf []byte) (int64, int)</a></h2>
<p>###参数列表</p>
<ul>
<li>buf 需要解码的缓冲区 </li>
</ul>
<p>###返回值：</p>
<ul>
<li>int64 解码的数据。</li>
<li>int 解析的字节数。</li>
</ul>
<p>###功能说明：</p>
<p>Varint是从buf中解码并返回一个int64的数据，及解码的字节数（&gt;0）。
如果出错，则返回数据0和一个小于等于0的字节数n，其意义为：</p>
<pre><code>n == 0：buf太小
n  &lt; 0：数据太大，超过64位，且-n为已解析字节数
</code></pre>
<p>###代码实例：</p>
<pre><code>package main

import (
  &quot;encoding/binary&quot;
	&quot;fmt&quot;
)

func main() {
	var sbuf []byte
	var buf []byte = []byte{144, 192, 192, 129, 132, 136, 140, 144, 16, 0, 1, 1}
	var bbuf []byte = []byte{144, 192, 192, 129, 132, 136, 140, 144, 192, 192, 1, 1}

	num, ret := binary.Varint(sbuf)
	fmt.Println(num, ret) //0 0

	num, ret = binary.Varint(buf)
	fmt.Println(num, ret) //580990878187261960 9

	num, ret = binary.Varint(bbuf)
	fmt.Println(num, ret) //0 -11
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="writew-iowriter-order-byteorder-data-interface-error"><a class="header" href="#writew-iowriter-order-byteorder-data-interface-error">Write(w io.Writer, order ByteOrder, data interface{}) error</a></h2>
<p>###参数列表</p>
<ul>
<li>w 可写入字节流的数据 </li>
<li>order 特殊字节序，包中提供大端字节序和小端字节序</li>
<li>data 需要解码成的数据</li>
</ul>
<p>###返回值：</p>
<ul>
<li>error 返回错误</li>
</ul>
<p>###功能说明：</p>
<p>Write将data序列化成字节流写入w中。data必须是固定长的数据值或固定长数据的slice，或指向此类数据的指针。写入w的字节流可用特殊的字节序来编码。另外，结构体中的(_)名的字段将忽视。</p>
<p>###代码实例：
package main</p>
<pre><code>import (
  &quot;bytes&quot;
	&quot;encoding/binary&quot;
	&quot;fmt&quot;
	&quot;math&quot;
)

func main() {
	buf := new(bytes.Buffer)
	var pi float64 = math.Pi

	err := binary.Write(buf, binary.LittleEndian, pi)
	if err != nil {
		fmt.Println(&quot;binary.Write failed:&quot;, err)
	}
	fmt.Println(buf.Bytes()) //[24 45 68 84 251 33 9 64]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="encodingcsv包函数列表"><a class="header" href="#encodingcsv包函数列表">encoding/csv包函数列表</a></h1>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/encoding/csv/Error.html">func (e *ParseError) Error() string</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/encoding/csv/NewReader.html">func NewReader(r io.Reader) *Reader</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/encoding/csv/Read.html">func (r *Reader) Read() (record []string, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/encoding/csv/ReadAll.html">func (r *Reader) ReadAll() (records [][]string, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/encoding/csv/NewWriter.html">func NewWriter(w io.Writer) *Writer</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/encoding/csv/Flush.html">func (w *Writer) Flush()</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/encoding/csv/Write.html">func (w *Writer) Write(record []string) (err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/encoding/csv/WriteAll.html">func (w *Writer) WriteAll(records [][]string) (err error)</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-e-parseerror-error-string"><a class="header" href="#func-e-parseerror-error-string">func (e *ParseError) Error() string</a></h2>
<h3 id="参数列表"><a class="header" href="#参数列表">参数列表：</a></h3>
<h3 id="返回值"><a class="header" href="#返回值">返回值：</a></h3>
<ul>
<li>返回字符串</li>
</ul>
<h3 id="功能说明-2"><a class="header" href="#功能说明-2">功能说明：</a></h3>
<p>这个函数主要用来返回 ParseError 实例的具体错误信息。</p>
<h3 id="代码实例"><a class="header" href="#代码实例">代码实例：</a></h3>
<pre><code class="language-go">package main

import (
	&quot;encoding/csv&quot;
	&quot;fmt&quot;
	&quot;strings&quot;
)

func main() {
	reader := csv.NewReader(strings.NewReader(&quot;cell10,cell11\ncell20&quot;))
	_, err := reader.ReadAll()
	if err != nil {
		fmt.Println(err.Error())
	}
}

</code></pre>
<p>运行后，终端将输出 <code>line 2, column 0: wrong number of fields in line</code> .</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-w-writer-flush"><a class="header" href="#func-w-writer-flush">func (w *Writer) Flush()</a></h2>
<h3 id="参数列表-1"><a class="header" href="#参数列表-1">参数列表：</a></h3>
<h3 id="返回值-1"><a class="header" href="#返回值-1">返回值：</a></h3>
<h3 id="功能说明-3"><a class="header" href="#功能说明-3">功能说明：</a></h3>
<p>该函数将缓冲内的数据写入真实文件。</p>
<h3 id="代码实例-1"><a class="header" href="#代码实例-1">代码实例：</a></h3>
<pre><code class="language-go">package main

import (
	&quot;encoding/csv&quot;
	&quot;fmt&quot;
	&quot;os&quot;
)

func main() {
	file, err := os.Create(&quot;demo.csv&quot;)
	if err != nil {
		fmt.Println(&quot;Error:&quot;, err)
		return
	}
	defer file.Close()

	records := [][]string{{&quot;10&quot;, &quot;11&quot;, &quot;12&quot;}, {&quot;20&quot;, &quot;21&quot;, &quot;22&quot;}, {&quot;30&quot;, &quot;31&quot;, &quot;32&quot;}}

	writer := csv.NewWriter(file)
	for _, record := range records {
		err := writer.Write(record)
		if err != nil {
			fmt.Println(&quot;Error:&quot;, err)
			return
		}
	}
	writer.Flush()
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-newreaderr-ioreader-reader"><a class="header" href="#func-newreaderr-ioreader-reader">func NewReader(r io.Reader) *Reader</a></h2>
<h3 id="参数列表-2"><a class="header" href="#参数列表-2">参数列表：</a></h3>
<ul>
<li>r io.Reader 类型的输入对象</li>
</ul>
<h3 id="返回值-2"><a class="header" href="#返回值-2">返回值：</a></h3>
<ul>
<li>返回能够解析 csv 格式输入的 Reader 对象</li>
</ul>
<h3 id="功能说明-4"><a class="header" href="#功能说明-4">功能说明：</a></h3>
<p>该函数返回一个能够解析 csv 格式的 Reader 对象。</p>
<h3 id="代码实例-2"><a class="header" href="#代码实例-2">代码实例：</a></h3>
<pre><code class="language-go">package main

import (
	&quot;encoding/csv&quot;
	&quot;fmt&quot;
	&quot;io&quot;
	&quot;os&quot;
)

func main() {
	file, err := os.Open(&quot;demo.csv&quot;)
	if err != nil {
		fmt.Println(&quot;Error:&quot;, err)
		return
	}
	defer file.Close()

	reader := csv.NewReader(file)
	for {
		record, err := reader.Read()
		if err == io.EOF { // EOF 表示已经读取了所有的数据
			break
		} else if err != nil {
			fmt.Println(&quot;Error:&quot;, err)
			return
		}
		fmt.Println(record) // record has the type []string

	}
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-newwriterw-iowriter-writer"><a class="header" href="#func-newwriterw-iowriter-writer">func NewWriter(w io.Writer) *Writer</a></h2>
<h3 id="参数列表-3"><a class="header" href="#参数列表-3">参数列表：</a></h3>
<ul>
<li>r io.Writer 类型的输出对象</li>
</ul>
<h3 id="返回值-3"><a class="header" href="#返回值-3">返回值：</a></h3>
<ul>
<li>返回一个 Writer 对象，将数据以 csv 格式输出。</li>
</ul>
<h3 id="功能说明-5"><a class="header" href="#功能说明-5">功能说明：</a></h3>
<p>该函数生成一个能够将数据以 csv 格式输出的 Writer 对象。</p>
<h3 id="代码实例-3"><a class="header" href="#代码实例-3">代码实例：</a></h3>
<pre><code class="language-go">package main

import (
	&quot;encoding/csv&quot;
	&quot;fmt&quot;
	&quot;os&quot;
)

func main() {
	file, err := os.Create(&quot;demo.csv&quot;)
	if err != nil {
		fmt.Println(&quot;Error:&quot;, err)
		return
	}
	defer file.Close()

	records := [][]string{{&quot;10&quot;, &quot;11&quot;, &quot;12&quot;}, {&quot;20&quot;, &quot;21&quot;, &quot;22&quot;}, {&quot;30&quot;, &quot;31&quot;, &quot;32&quot;}}

	writer := csv.NewWriter(file)
	for _, record := range records {
		err := writer.Write(record)
		if err != nil {
			fmt.Println(&quot;Error:&quot;, err)
			return
		}
	}
	writer.Flush()
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-r-reader-read-record-string-err-error"><a class="header" href="#func-r-reader-read-record-string-err-error">func (r *Reader) Read() (record []string, err error)</a></h2>
<h3 id="参数列表-4"><a class="header" href="#参数列表-4">参数列表：</a></h3>
<h3 id="返回值-4"><a class="header" href="#返回值-4">返回值：</a></h3>
<ul>
<li>record 字符串类型的 slice ，对应于 csv 文件的一行数据。</li>
<li>err 读取时产生的错误</li>
</ul>
<h3 id="功能说明-6"><a class="header" href="#功能说明-6">功能说明：</a></h3>
<p>该函数用于读取一行数据。当读取完所有数据后，继续调用 <code>Read()</code> ，产生的是 EOF 错误，需要与因原始数据的格式问题导致产生 ParseError 的错误区分开来。</p>
<h3 id="代码实例-4"><a class="header" href="#代码实例-4">代码实例：</a></h3>
<pre><code class="language-go">package main

import (
	&quot;encoding/csv&quot;
	&quot;fmt&quot;
	&quot;io&quot;
	&quot;os&quot;
)

func main() {
	file, err := os.Open(&quot;demo.csv&quot;)
	if err != nil {
		fmt.Println(&quot;Error:&quot;, err)
		return
	}
	defer file.Close()

	reader := csv.NewReader(file)
	for {
		record, err := reader.Read()
		if err == io.EOF { // EOF 表示已经读取了所有的数据
			break
		} else if err != nil {
			fmt.Println(&quot;Error:&quot;, err)
			return
		}
		fmt.Println(record) // record has the type []string

	}
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-r-reader-readall-records-string-err-error"><a class="header" href="#func-r-reader-readall-records-string-err-error">func (r *Reader) ReadAll() (records [][]string, err error)</a></h2>
<h3 id="参数列表-5"><a class="header" href="#参数列表-5">参数列表：</a></h3>
<h3 id="返回值-5"><a class="header" href="#返回值-5">返回值：</a></h3>
<ul>
<li>records []][]string 类型，对应于 csv 文件的多行数据。</li>
<li>err 读取时产生的错误</li>
</ul>
<h3 id="功能说明-7"><a class="header" href="#功能说明-7">功能说明：</a></h3>
<p>该函数用于一次性读取所有未读的多行数据。</p>
<h3 id="代码实例-5"><a class="header" href="#代码实例-5">代码实例：</a></h3>
<pre><code class="language-go">package main

import (
	&quot;encoding/csv&quot;
	&quot;fmt&quot;
	&quot;os&quot;
)

func main() {
	file, err := os.Open(&quot;demo.csv&quot;)
	if err != nil {
		fmt.Println(&quot;Error:&quot;, err)
		return
	}
	defer file.Close()

	reader := csv.NewReader(file)
	records, err := reader.ReadAll()
	if err != nil {
		fmt.Println(&quot;Error:&quot;, err)
		return
	}
	fmt.Println(records)
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-w-writer-writerecord-string-err-error"><a class="header" href="#func-w-writer-writerecord-string-err-error">func (w *Writer) Write(record []string) (err error)</a></h2>
<h3 id="参数列表-6"><a class="header" href="#参数列表-6">参数列表：</a></h3>
<ul>
<li>record 将要输出的数据</li>
</ul>
<h3 id="返回值-6"><a class="header" href="#返回值-6">返回值：</a></h3>
<ul>
<li>err 输出时产生的错误</li>
</ul>
<h3 id="功能说明-8"><a class="header" href="#功能说明-8">功能说明：</a></h3>
<p>该函数将数据以 csv 的格式输出。</p>
<h3 id="代码实例-6"><a class="header" href="#代码实例-6">代码实例：</a></h3>
<pre><code class="language-go">package main

import (
	&quot;encoding/csv&quot;
	&quot;fmt&quot;
	&quot;os&quot;
)

func main() {
	file, err := os.Create(&quot;demo.csv&quot;)
	if err != nil {
		fmt.Println(&quot;Error:&quot;, err)
		return
	}
	defer file.Close()

	records := [][]string{{&quot;10&quot;, &quot;11&quot;, &quot;12&quot;}, {&quot;20&quot;, &quot;21&quot;, &quot;22&quot;}, {&quot;30&quot;, &quot;31&quot;, &quot;32&quot;}}

	writer := csv.NewWriter(file)
	for _, record := range records {
		err := writer.Write(record)
		if err != nil {
			fmt.Println(&quot;Error:&quot;, err)
			return
		}
	}
	writer.Flush() // 不要忘记调用 Flush 函数。
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-w-writer-writeallrecords-string-err-error"><a class="header" href="#func-w-writer-writeallrecords-string-err-error">func (w *Writer) WriteAll(records [][]string) (err error)</a></h2>
<h3 id="参数列表-7"><a class="header" href="#参数列表-7">参数列表：</a></h3>
<ul>
<li>records 将要输出的数据</li>
</ul>
<h3 id="返回值-7"><a class="header" href="#返回值-7">返回值：</a></h3>
<ul>
<li>err 输出时产生的错误</li>
</ul>
<h3 id="功能说明-9"><a class="header" href="#功能说明-9">功能说明：</a></h3>
<p>该函数将(多行)数据以 csv 的格式输出。<code>WriteAll</code> 通过调用 <code>Write</code> 函数输出每行数据，最后调用 <code>Flush</code> 函数。</p>
<h3 id="代码实例-7"><a class="header" href="#代码实例-7">代码实例：</a></h3>
<pre><code class="language-go">package main

import (
	&quot;encoding/csv&quot;
	&quot;fmt&quot;
	&quot;os&quot;
)

func main() {
	file, err := os.Create(&quot;demo.csv&quot;)
	if err != nil {
		fmt.Println(&quot;Error:&quot;, err)
		return
	}
	defer file.Close()

	records := [][]string{{&quot;10&quot;, &quot;11&quot;, &quot;12&quot;}, {&quot;20&quot;, &quot;21&quot;, &quot;22&quot;}, {&quot;30&quot;, &quot;31&quot;, &quot;32&quot;}}

	err = writer.WriteAll(records)
	if err != nil {
		fmt.Println(&quot;Error:&quot;, err)
		return
	}

}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="encodinggob"><a class="header" href="#encodinggob">encoding/gob</a></h1>
<p>gob is Go's own format for serializing and deserializing program data in binary format </p>
<p>函数列表</p>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/encoding/gob/Decode_Encode.html">func NewDecoder(r io.Reader) *Decoder</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/encoding/gob/Decode_Encode.html">func (dec *Decoder) Decode(e interface{}) error</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/encoding/gob/DecodeValue.html">func (dec *Decoder) DecodeValue(v reflect.Value) error</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/encoding/gob/Decode_Encode.html">func NewEncoder(w io.Writer) *Encoder</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/encoding/gob/Decode_Encode.html">func (enc *Encoder) Encode(e interface{}) error</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/encoding/gob/EncodeValue.html">func (enc *Encoder) EncodeValue(value reflect.Value) error</a></li>
</ul>
<p>结构体：</p>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/encoding/gob/struct.html">type Decoder struct</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/encoding/gob/struct.html">type Encoder struct</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>func (dec *Decoder) Decode(e interface{}) error </p>
<p>参数列表：</p>
<ul>
<li>e 空接口类型，可以处理任何类型的数据</li>
</ul>
<p>返回值：</p>
<ul>
<li>error </li>
</ul>
<p>功能说明： 
此函数是Decoder的方法即(Method),需要使用NewDecoder()创建*Decoder对象后，才可以使用</p>
<p>代码：
<a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/encoding/gob/Decode_Encode.go">Decode_Encode.go</a></p>
<div style="break-before: page; page-break-before: always;"></div><p>func (enc *Encoder) Encode(e interface{}) error</p>
<p>参数列表:</p>
<ul>
<li>v 序列化gob对象</li>
</ul>
<p>返回值:</p>
<ul>
<li>error 错误</li>
</ul>
<p>功能说明:</p>
<p>这个函数主要是将encode编码的gob数据写入到相关联的对象</p>
<p>代码：
<a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/encoding/gob/Decode_Encode.go">Decode_Encode.go</a></p>
<div style="break-before: page; page-break-before: always;"></div><p>func NewDecoder(r io.Reader) *Decoder</p>
<p>参数列表:</p>
<ul>
<li>r Reader对象</li>
</ul>
<p>返回值:</p>
<ul>
<li>*Decoder 指向Decoder的指针</li>
</ul>
<p>功能说明:</p>
<p>这个函数主要是给r创建一个decoder实例</p>
<p>代码: </p>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/encoding/gob/gob.go">gob.go</a></p>
<div style="break-before: page; page-break-before: always;"></div><p>func NewEncoder(w io.writer) *Encoder </p>
<p>参数列表:</p>
<ul>
<li>r Writer对象</li>
</ul>
<p>返回值:</p>
<ul>
<li>*Encoderr 指向Encoder的指针</li>
</ul>
<p>功能说明:</p>
<p>这个函数主要是给w创建一个encoder实例</p>
<p>代码：</p>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/encoding/gob/gob.go">gob.go</a></p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-go">// A Decoder manages the receipt of type and data information read from the
// remote side of a connection.
type Decoder struct {
	mutex        sync.Mutex                              // each item must be received atomically
	r            io.Reader                               // source of the data
	buf          bytes.Buffer                            // buffer for more efficient i/o from r
	wireType     map[typeId]*wireType                    // map from remote ID to local description
	decoderCache map[reflect.Type]map[typeId]**decEngine // cache of compiled engines
	ignorerCache map[typeId]**decEngine                  // ditto for ignored objects
	freeList     *decoderState                           // list of free decoderStates; avoids reallocation
	countBuf     []byte                                  // used for decoding integers while parsing messages
	tmp          []byte                                  // temporary storage for i/o; saves reallocating
	err          error
}


// An Encoder manages the transmission of type and data information to the
// other side of a connection.
type Encoder struct {
	mutex      sync.Mutex              // each item must be sent atomically
	w          []io.Writer             // where to send the data
	sent       map[reflect.Type]typeId // which types we've already sent
	countState *encoderState           // stage for writing counts
	freeList   *encoderState           // list of free encoderStates; avoids reallocation
	byteBuf    bytes.Buffer            // buffer for top-level encoderState
	err        error
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名-20"><a class="header" href="#包名-20">包名</a></h1>
<p>函数列表</p>
<ul>
<li>xxx1</li>
<li>xxx2</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="json"><a class="header" href="#json">json</a></h1>
<p>功能介绍:
主要用于处理JSON数据，序列化和反序列化等。
相关文档可以参考，&quot;JSON and Go&quot;  <a href="http://golang.org/doc/articles/json_and_go.html">http://golang.org/doc/articles/json_and_go.html</a></p>
<p>函数列表:</p>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/encoding/json/Compact.html">func Compact(dst *bytes.Buffer, src []byte) error</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/encoding/json/HTMLEscape.html">func HTMLEscape(dst *bytes.Buffer, src []byte)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/encoding/json/Indent.html">func Indent(dst *bytes.Buffer, src []byte, prefix, indent string) error</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/encoding/json/Marshal.html">func Marshal(v interface{}) ([]byte, error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/encoding/json/MarshalIndent.html">func MarshalIndent(v interface{}, prefix, indent string) ([]byte, error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/encoding/json/Unmarshal.html">func Unmarshal(data []byte, v interface{}) error</a></li>
<li>type Decoder</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/encoding/json/NewDecoder.html">func NewDecoder(r io.Reader) *Decoder</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/encoding/json/Decode.html">func (dec *Decoder) Decode(v interface{}) error</a></li>
<li>type Encoder</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/encoding/json/NewEncoder.html">func NewEncoder(w io.Writer) *Encoder</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/encoding/json/Encoder.html">func (enc *Encoder) Encode(v interface{}) error</a></li>
<li>type InvalidUTF8Error</li>
<li>func (e *InvalidUTF8Error) Error() string</li>
<li>type InvalidUnmarshalError</li>
<li>func (e *InvalidUnmarshalError) Error() string</li>
<li>type Marshaler</li>
<li>type MarshalerError</li>
<li>func (e *MarshalerError) Error() string</li>
<li>type RawMessage</li>
<li>func (m *RawMessage) MarshalJSON() ([]byte, error)</li>
<li>func (m *RawMessage) UnmarshalJSON(data []byte) error</li>
<li>type SyntaxError</li>
<li>func (e *SyntaxError) Error() string</li>
<li>type UnmarshalFieldError</li>
<li>func (e *UnmarshalFieldError) Error() string</li>
<li>type UnmarshalTypeError</li>
<li>func (e *UnmarshalTypeError) Error() string</li>
<li>type Unmarshaler</li>
<li>type UnsupportedTypeError</li>
<li>func (e *UnsupportedTypeError) Error() string</li>
<li>type UnsupportedValueError</li>
<li>func (e *UnsupportedValueError) Error() string</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>##func Compact(dst *bytes.Buffer, src []byte) error</p>
<p>参数列表:</p>
<ul>
<li>dst 表示字符缓冲区指针</li>
<li>src 表示JSON格式的字符串切片</li>
</ul>
<p>返回值:</p>
<ul>
<li>返回error错误信息</li>
</ul>
<p>功能说明:</p>
<p>这个函数主要是用于将JSON格式的src追加到dst中，正确则返回nil，如果发生错误则返回error信息</p>
<p>代码实例:</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;encoding/json&quot;
	&quot;fmt&quot;
)

func main() {
	dst := new(bytes.Buffer)
	src := []byte(`{
		&quot;Name&quot;:&quot;tony.shao&quot;,
		&quot;Age&quot;:25,
		&quot;Job&quot;:&quot;Programmer&quot;
		}`)
	err := json.Compact(dst, src)
	if err != nil {
		fmt.Println(err)
	}
	fmt.Println(dst)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>func (dec *Decoder) Decode(v interface{}) error</p>
<p>参数列表:</p>
<ul>
<li>v 反序列化json对象</li>
</ul>
<p>返回值:</p>
<ul>
<li>error 错误</li>
</ul>
<p>功能说明:</p>
<p>这个函数主要是 反序列化下一个JSON编码的数据，并将结果存储到一个指向v的指针</p>
<p>代码实例:</p>
<pre><code>package main

import (
	&quot;encoding/json&quot;
	&quot;fmt&quot;
	&quot;io&quot;
	&quot;log&quot;
	&quot;strings&quot;
)

func main() {
	const jsonStream = `
		{&quot;Name&quot;: &quot;Ed&quot;, &quot;Text&quot;: &quot;Knock knock.&quot;}
		{&quot;Name&quot;: &quot;Sam&quot;, &quot;Text&quot;: &quot;Who's there?&quot;}
		{&quot;Name&quot;: &quot;Ed&quot;, &quot;Text&quot;: &quot;Go fmt.&quot;}
		{&quot;Name&quot;: &quot;Sam&quot;, &quot;Text&quot;: &quot;Go fmt who?&quot;}
		{&quot;Name&quot;: &quot;Ed&quot;, &quot;Text&quot;: &quot;Go fmt yourself!&quot;}
	`
	type Message struct {
		Name, Text string
	}
	dec := json.NewDecoder(strings.NewReader(jsonStream))
	for {
		var m Message
		if err := dec.Decode(&amp;m); err == io.EOF {
			break
		} else if err != nil {
			log.Fatal(err)
		}
		fmt.Printf(&quot;%s: %s\n&quot;, m.Name, m.Text)
	}
}
</code></pre>
<p>显示结果:</p>
<pre><code>Ed: Knock knock.
Sam: Who's there?
Ed: Go fmt.
Sam: Go fmt who?
Ed: Go fmt yourself!</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>func (enc *Encoder) Encode(v interface{}) error</p>
<p>参数列表:</p>
<ul>
<li>v 序列化json对象</li>
</ul>
<p>返回值:</p>
<ul>
<li>error 错误</li>
</ul>
<p>功能说明:</p>
<p>这个函数主要是将encode编码的JSON数据写入到相关联的对象</p>
<p>代码实例:</p>
<pre><code>package main

import (
	&quot;encoding/json&quot;
	&quot;fmt&quot;
	&quot;os&quot;
)

type ColorGroup struct {
	ID     int
	Name   string
	Colors []string
}

func main() {
	group := ColorGroup{
		ID:     1,
		Name:   &quot;Reds&quot;,
		Colors: []string{&quot;Crimson&quot;, &quot;Red&quot;, &quot;Ruby&quot;, &quot;Maroon&quot;},
	}
	encoder := json.NewEncoder(os.Stdout)
	if err := encoder.Encode(group); err != nil {
		fmt.Printf(&quot;failed encoding to writer: %s&quot;, err)
	}
}
</code></pre>
<p>显示结果:</p>
<pre><code>{&quot;ID&quot;:1,&quot;Name&quot;:&quot;Reds&quot;,&quot;Colors&quot;:[&quot;Crimson&quot;,&quot;Red&quot;,&quot;Ruby&quot;,&quot;Maroon&quot;]}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>##func HTMLEscape(dst *bytes.Buffer, src []byte) error</p>
<p>参数列表:</p>
<ul>
<li>dst 表示字符缓冲区指针</li>
<li>src 表示JSON格式的字符串切片</li>
</ul>
<p>返回值:</p>
<ul>
<li>无</li>
</ul>
<p>功能说明:</p>
<p>这个函数主要是用于将JSON格式的src追加到dst中，与Compact不同的是会将&lt;， &gt;， 和 &amp; 编码成 \u003c, \u003e, \u0026，以便于可以安全的嵌入到html的&lt;script&gt;标签中,(这么做主要是介于历史原因，浏览器在&lt;script&gt;标签中不支持标准的html转义)</p>
<p>代码实例:</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;encoding/json&quot;
	&quot;fmt&quot;
)

func main() {
	dst := new(bytes.Buffer)
	src := []byte(`{
		&quot;Name&quot;:&quot;tony.shao&quot;,
		&quot;Age&quot;:25,
		&quot;Job&quot;:&quot;Programmer&lt;Escaping&gt;&quot;
		}`)
	json.HTMLEscape(dst, src)
	fmt.Println(dst)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>func Indent(dst *bytes.Buffer, src []byte, prefix, indent string) error</p>
<p>参数列表:</p>
<ul>
<li>dst 表示字符缓冲区指针</li>
<li>src 表示JSON格式的字符串切片</li>
<li>prefix 字首</li>
<li>indent 缩减的字段</li>
</ul>
<p>返回值:</p>
<ul>
<li>error</li>
</ul>
<p>功能说明:</p>
<p>这个函数主要是用于将src以缩进形式添加到缩进的JSON内容dst中, prefix用于填充字首，indent用于填充缩进。</p>
<p>代码实例:</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;encoding/json&quot;
	&quot;fmt&quot;
)

type ColorGroup struct {
	ID     int
	Name   string
	Colors []string
}

func main() {
	dst := new(bytes.Buffer)
	src := []byte(`{&quot;ID&quot;:1,&quot;Name&quot;:&quot;Reds&quot;,&quot;Colors&quot;:[&quot;Crimson&quot;,&quot;Red&quot;,&quot;Ruby&quot;,&quot;Maroon&quot;]}`)
	json.Indent(dst, src, &quot;##&quot;, &quot;**&quot;) //实际应用中，可能更多的是使用空格来作为prefix和indent，这里主要为了方便观察
	json.Indent(dst, src, &quot;##&quot;, &quot;**&quot;) //实际应用中，可能更多的是使用空格来作为prefix和indent，这里主要为了方便观察
	fmt.Println(dst)
}
</code></pre>
<p>显示结果:</p>
<pre><code>{
##**&quot;ID&quot;: 1,
##**&quot;Name&quot;: &quot;Reds&quot;,
##**&quot;Colors&quot;: [
##****&quot;Crimson&quot;,
##****&quot;Red&quot;,
##****&quot;Ruby&quot;,
##****&quot;Maroon&quot;
##**]
##}{
##**&quot;ID&quot;: 1,
##**&quot;Name&quot;: &quot;Reds&quot;,
##**&quot;Colors&quot;: [
##****&quot;Crimson&quot;,
##****&quot;Red&quot;,
##****&quot;Ruby&quot;,
##****&quot;Maroon&quot;
##**]
##}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>func Marshal(v interface{}) ([]byte, error)</p>
<p>参数列表:</p>
<ul>
<li>v 序列化对象</li>
</ul>
<p>返回值:</p>
<ul>
<li>[]byte 序列化的结果</li>
<li>error 错误</li>
</ul>
<p>功能说明:</p>
<p>这个函数主要是用于将对象v序列化为json格式[]byte,</p>
<p>代码实例:</p>
<pre><code>package main

import (
	&quot;encoding/json&quot;
	&quot;fmt&quot;
	&quot;os&quot;
)

type ColorGroup struct {
	ID     int
	Name   string
	Colors []string
}

func main() {
	group := ColorGroup{
		ID:     1,
		Name:   &quot;Reds&quot;,
		Colors: []string{&quot;Crimson&quot;, &quot;Red&quot;, &quot;Ruby&quot;, &quot;Maroon&quot;},
	}
	b, err := json.Marshal(group)
	if err != nil {
		fmt.Println(&quot;error:&quot;, err)
	}
	os.Stdout.Write(b)
}
</code></pre>
<p>显示结果:</p>
<pre><code>{&quot;ID&quot;:1,&quot;Name&quot;:&quot;Reds&quot;,&quot;Colors&quot;:[&quot;Crimson&quot;,&quot;Red&quot;,&quot;Ruby&quot;,&quot;Maroon&quot;]}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>func MarshalIndent(v interface{}, prefix, indent string) ([]byte, error)</p>
<p>参数列表:</p>
<ul>
<li>v 序列化对象</li>
<li>prefix 字首</li>
<li>indent 缩减的字段</li>
</ul>
<p>返回值:</p>
<ul>
<li>[]byte 序列化的结果</li>
<li>error 错误</li>
</ul>
<p>功能说明:</p>
<p>这个函数主要是用于将对象v序列化为缩进格式json，[]byte,</p>
<p>代码实例:</p>
<pre><code>package main

import (
	&quot;encoding/json&quot;
	&quot;fmt&quot;
	&quot;os&quot;
)

type ColorGroup struct {
	ID     int
	Name   string
	Colors []string
}

func main() {
	group := ColorGroup{
		ID:     1,
		Name:   &quot;Reds&quot;,
		Colors: []string{&quot;Crimson&quot;, &quot;Red&quot;, &quot;Ruby&quot;, &quot;Maroon&quot;},
	}
	b, err := json.MarshalIndent(group, &quot;##&quot;, &quot;**&quot;) //实际应用中更多的可能为 空格，这里为了便于观察
	if err != nil {
		fmt.Println(&quot;error:&quot;, err)
	}
	os.Stdout.Write(b)
}
</code></pre>
<p>显示结果:</p>
<pre><code>{
##**&quot;ID&quot;: 1,
##**&quot;Name&quot;: &quot;Reds&quot;,
##**&quot;Colors&quot;: [
##****&quot;Crimson&quot;,
##****&quot;Red&quot;,
##****&quot;Ruby&quot;,
##****&quot;Maroon&quot;
##**]
##}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>func NewDecoder(r io.Reader) *Decoder</p>
<p>参数列表:</p>
<ul>
<li>r Reader对象</li>
</ul>
<p>返回值:</p>
<ul>
<li>*Decoder 指向Decoder的指针</li>
</ul>
<p>功能说明:</p>
<p>这个函数主要是给r创建一个decoder实例</p>
<p>代码实例:</p>
<pre><code>package main

import (
	&quot;encoding/json&quot;
	&quot;fmt&quot;
	&quot;io&quot;
	&quot;log&quot;
	&quot;strings&quot;
)

func main() {
	const jsonStream = `
		{&quot;Name&quot;: &quot;Ed&quot;, &quot;Text&quot;: &quot;Knock knock.&quot;}
		{&quot;Name&quot;: &quot;Sam&quot;, &quot;Text&quot;: &quot;Who's there?&quot;}
		{&quot;Name&quot;: &quot;Ed&quot;, &quot;Text&quot;: &quot;Go fmt.&quot;}
		{&quot;Name&quot;: &quot;Sam&quot;, &quot;Text&quot;: &quot;Go fmt who?&quot;}
		{&quot;Name&quot;: &quot;Ed&quot;, &quot;Text&quot;: &quot;Go fmt yourself!&quot;}
	`
	type Message struct {
		Name, Text string
	}
	dec := json.NewDecoder(strings.NewReader(jsonStream))
	for {
		var m Message
		if err := dec.Decode(&amp;m); err == io.EOF {
			break
		} else if err != nil {
			log.Fatal(err)
		}
		fmt.Printf(&quot;%s: %s\n&quot;, m.Name, m.Text)
	}
}
</code></pre>
<p>显示结果:</p>
<pre><code>Ed: Knock knock.
Sam: Who's there?
Ed: Go fmt.
Sam: Go fmt who?
Ed: Go fmt yourself!</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>func NewEncoder(w io.Writer) *Encoder</p>
<p>参数列表:</p>
<ul>
<li>r Writer对象</li>
</ul>
<p>返回值:</p>
<ul>
<li>*Encoderr 指向Encoder的指针</li>
</ul>
<p>功能说明:</p>
<p>这个函数主要是给w创建一个encoder实例</p>
<p>代码实例:</p>
<pre><code>package main

import (
	&quot;encoding/json&quot;
	&quot;fmt&quot;
	&quot;os&quot;
)

type ColorGroup struct {
	ID     int
	Name   string
	Colors []string
}

func main() {
	group := ColorGroup{
		ID:     1,
		Name:   &quot;Reds&quot;,
		Colors: []string{&quot;Crimson&quot;, &quot;Red&quot;, &quot;Ruby&quot;, &quot;Maroon&quot;},
	}
	encoder := json.NewEncoder(os.Stdout)
	if err := encoder.Encode(group); err != nil {
		fmt.Printf(&quot;failed encoding to writer: %s&quot;, err)
	}
}
</code></pre>
<p>显示结果:</p>
<pre><code>{&quot;ID&quot;:1,&quot;Name&quot;:&quot;Reds&quot;,&quot;Colors&quot;:[&quot;Crimson&quot;,&quot;Red&quot;,&quot;Ruby&quot;,&quot;Maroon&quot;]}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>func Unmarshal(data []byte, v interface{}) error</p>
<p>参数列表:</p>
<ul>
<li>data json数据</li>
<li>v 反序列化JSON对象</li>
</ul>
<p>返回值:</p>
<ul>
<li>error 错误</li>
</ul>
<p>功能说明:</p>
<p>这个函数主要是用于反序列化JSON编码的data，并将结果存储到指向v的指针</p>
<p>代码实例:</p>
<pre><code>package main

import (
	&quot;encoding/json&quot;
	&quot;fmt&quot;
)

func main() {
	var jsonBlob = []byte(`[
		{&quot;Name&quot;: &quot;Platypus&quot;, &quot;Order&quot;: &quot;Monotremata&quot;},
		{&quot;Name&quot;: &quot;Quoll&quot;,    &quot;Order&quot;: &quot;Dasyuromorphia&quot;}
	]`)
	type Animal struct {
		Name  string
		Order string
	}
	var animals []Animal
	err := json.Unmarshal(jsonBlob, &amp;animals)
	if err != nil {
		fmt.Println(&quot;error:&quot;, err)
	}
	fmt.Printf(&quot;%+v&quot;, animals)
}
</code></pre>
<p>显示结果:</p>
<pre><code>[{Name:Platypus Order:Monotremata} {Name:Quoll Order:Dasyuromorphia}]</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名-21"><a class="header" href="#包名-21">包名</a></h1>
<p>函数列表</p>
<ul>
<li>xxx1</li>
<li>xxx2</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="xml"><a class="header" href="#xml">xml</a></h1>
<p>函数列表</p>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/encoding/xml/Escape.html">func Escape(w io.Writer, s []byte)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/encoding/xml/Marshal.html">func Marshal(v interface{}) ([]byte, error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/encoding/xml/MarshalIndent.html">func MarshalIndent(v interface{}, prefix, indent string) ([]byte, error)</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>##func Escape(w io.Writer, s []byte)</p>
<p>参数列表:</p>
<ul>
<li>w 输出接口，打印结果</li>
<li>s 表示待转换的数据</li>
</ul>
<p>返回值:</p>
<ul>
<li>无</li>
</ul>
<p>功能说明:</p>
<p>将s中的文本数据中的xml保留字符转换成预定义的实体引用，并输出到w。转换对照:</p>
<pre><code>&quot;   &amp;#34;
'   &amp;#39;
&amp;   &amp;amp;
&lt;   &amp;lt;
&gt;   &amp;gt;
</code></pre>
<p>代码实例:</p>
<pre><code>package main

import (
	&quot;encoding/xml&quot;
	&quot;os&quot;
)

func main() {
	str := &quot;\&quot;'&amp;&lt;&gt;&quot;
	xml.Escape(os.Stdout, []byte(str))
}
</code></pre>
<p>输出结果:</p>
<pre><code>&amp;#34;&amp;#39;&amp;amp;&amp;lt;&amp;gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>##func Marshal(v interface{}) ([]byte, error)</p>
<p>参数列表:</p>
<ul>
<li>v 空接口，用于传入生产xml的数据</li>
</ul>
<p>返回值:</p>
<ul>
<li>生成的xml</li>
<li>是否有错误</li>
</ul>
<p>功能说明:</p>
<p>当传入一个数组或者切片时，Marshal通过编组每一个元素来处理.当传入一个指针时，Marshal通过编组指针指向的值来处理，指针为空时，返回空.当传入一个接口值时，Marshal通过编组接口包含的值来处理接口，接口值为空，返回空.当传入其他数据时，返回一个或多个包含的数据。
xml元素名称的获取规则，按优先顺序排列:</p>
<pre><code>名称为XMLName字段的tag值 
名称为XMLName并且类型为xml.Name的字段的值
结构体名称
</code></pre>
<p>每一个struct包含的字段都会被作为输出的xml的元素，除了以下情况：</p>
<pre><code>名称为XMLName的字段将被忽略。
tag为&quot;-&quot;的字段将被忽略。
tag为&quot;name,attr&quot;的字段将变成xml元素中name命名的属性。
tag为&quot;,chardata&quot;的字段作为字符数据被写入，不是作为xml元素。
tag为&quot;,innerxml&quot;的字段逐字写入
tag为&quot;,comment&quot;的字段作为xml的注释，里面的数据必须不包括“--”.
tag包含&quot;omitempty&quot;的字段，如果值为空值将会被忽略。空值包括：false,0,空接口，空指针，长度为零的数组、切片、map。
值为外部结构体的字段，处理成非指针匿名结构字段
</code></pre>
<p>如果字段用了标签（tag）“a&gt;b&gt;c”，元素c将嵌套在他的父元素a和b中。父元素相同的字段，将封装在同一个元素内。
如果传入一个channel、function、map,Marshal将返回一个错误。</p>
<p>代码实例:</p>
<pre><code>package main

import (
	&quot;encoding/xml&quot;
	&quot;fmt&quot;
	&quot;os&quot;
)

type Address struct {
	City, State string
}
type Person struct {
	XMLName   xml.Name `xml:&quot;person&quot;`
	Id        int      `xml:&quot;id,attr&quot;`
	FirstName string   `xml:&quot;name&gt;first&quot;`
	LastName  string   `xml:&quot;name&gt;last&quot;`
	Age       int      `xml:&quot;age&quot;`
	Height    float32  `xml:&quot;height,omitempty&quot;`
	Married   bool
	Address
	Comment string `xml:&quot;,comment&quot;`
}

func main() {
	v := &amp;Person{Id: 13, FirstName: &quot;John&quot;, LastName: &quot;Doe&quot;, Age: 42}
	v.Comment = &quot; Need more details. &quot;
	v.Address = Address{&quot;Hanga Roa&quot;, &quot;Easter Island&quot;}

	output, err := xml.Marshal(v)
	if err != nil {
		fmt.Printf(&quot;error: %v\n&quot;, err)
	}

	os.Stdout.Write(output)
}
</code></pre>
<p>输出结果:</p>
<pre><code>&lt;person id=&quot;13&quot;&gt;&lt;name&gt;&lt;first&gt;John&lt;/first&gt;&lt;last&gt;Doe&lt;/last&gt;&lt;/name&gt;&lt;age&gt;42&lt;/age&gt;&lt;Married&gt;false&lt;/Married&gt;&lt;City&gt;Hanga Roa&lt;/City&gt;&lt;State&gt;Easter Island&lt;/State&gt;&lt;!-- Need more details. --&gt;&lt;/person&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>##func MarshalIndent(v interface{}, prefix, indent string) ([]byte, error)</p>
<p>参数列表:</p>
<ul>
<li>v 空接口，用于传入生产xml的数据</li>
<li>prefix 字符串，xml根元素缩进</li>
<li>indent 字符串，xml元素缩进</li>
</ul>
<p>返回值:</p>
<ul>
<li>生成的xml</li>
<li>是否有错误</li>
</ul>
<p>功能说明:</p>
<p>生产原理同Marshal，根元素缩进prefix，其他元素缩进indent。</p>
<p>代码实例:</p>
<pre><code>package main

import (
	&quot;encoding/xml&quot;
	&quot;fmt&quot;
	&quot;os&quot;
)

type Address struct {
	City, State string
}

type Person struct {
	XMLName   xml.Name `xml:&quot;person&quot;`
	Id        int      `xml:&quot;id,attr&quot;`
	FirstName string   `xml:&quot;name&gt;first&quot;`
	LastName  string   `xml:&quot;name&gt;last&quot;`
	Age       int      `xml:&quot;age&quot;`
	Height    float32  `xml:&quot;height,omitempty&quot;`
	Married   bool
	Address
	Comment string `xml:&quot;,comment&quot;`
}

func main() {
	v := &amp;Person{Id: 13, FirstName: &quot;John&quot;, LastName: &quot;Doe&quot;, Age: 42}
	v.Comment = &quot; Need more details. &quot;
	v.Address = Address{&quot;Hanga Roa&quot;, &quot;Easter Island&quot;}

	output, err := xml.MarshalIndent(v, &quot;  &quot;, &quot;    &quot;)
	if err != nil {
		fmt.Printf(&quot;error: %v\n&quot;, err)
	}

	os.Stdout.Write(output)
}
</code></pre>
<p>输出结果:</p>
<pre><code>  &lt;person id=&quot;13&quot;&gt;
      &lt;name&gt;
          &lt;first&gt;John&lt;/first&gt;
          &lt;last&gt;Doe&lt;/last&gt;
      &lt;/name&gt;
      &lt;age&gt;42&lt;/age&gt;
      &lt;Married&gt;false&lt;/Married&gt;
      &lt;City&gt;Hanga Roa&lt;/City&gt;
      &lt;State&gt;Easter Island&lt;/State&gt;
      &lt;!-- Need more details. --&gt;
  &lt;/person&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="errors-包函数列表"><a class="header" href="#errors-包函数列表">errors 包函数列表</a></h1>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/errors/New.html">func New(text string) error</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-newtext-string-error"><a class="header" href="#func-newtext-string-error">func New(text string) error</a></h1>
<p>参数列表</p>
<ul>
<li>text 错误字符串</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回error</li>
</ul>
<p>功能说明：</p>
<p>New returns an error that formats as the given text.
按给定的文本返回一个新的 error.</p>
<p>代码实例：</p>
<pre><code>    package main

    import  &quot;fmt&quot;
    import  &quot;errors&quot;

    func main(){
            fmt.Println(errors.New(&quot;Err&quot;))
    }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="expvar包"><a class="header" href="#expvar包">expvar包</a></h1>
<p>expvar包提供了一组标准接口，将服务器内部的公共变量，通过HTTP协议，及json格式，暴露出来，可访问 /debug/vars 获取。</p>
<p>默认提供两个变量：</p>
<ul>
<li>cmdline <a href="http://golang.org/pkg/os/#pkg-variables">os.Args</a></li>
<li>memstats <a href="http://golang.org/pkg/runtime/#MemStats">runtime.Memstats</a></li>
</ul>
<p>“公共变量”即Var，是一个实现了String()函数的接口，定义如下：</p>
<pre><code>type Var interface {
    String() string
}
</code></pre>
<p>实际类型的Var包括：Int，Float，String和Map，每个具体的类型都包括几个函数：</p>
<ul>
<li><strong>New*()</strong>      // 新建一个变量</li>
<li><strong>Set(*)</strong>      // 设置这个变量</li>
<li><strong>Add(*)</strong>      // 在原有变量上加上另一个变量</li>
<li><strong>String()</strong>    // 实现Var接口</li>
</ul>
<p>除此之外，Map还有几个特有的函数：</p>
<ul>
<li><strong>Init()</strong>                  // 初始化Map</li>
<li><strong>Get(key string)</strong>         // 根据key获取value</li>
<li><strong>Do(f func(KeyValue))</strong>    // 对Map中的每对key/value执行函数f</li>
</ul>
<p>所有对Var的设置和修改都是原子操作，所有操作的实例在<a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/expvar/testExpvar.go">testExpvar.go</a>, 运行后可访问 127.0.0.1/debug/vars, 一般会得到如<a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/expvar/vars.json">vars.json</a>的结果。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="flag包使用详解"><a class="header" href="#flag包使用详解">flag包使用详解</a></h1>
<p>##概述
flag包提供了一系列解析命令行参数的功能接口</p>
<p>###Variables</p>
<pre><code>var (
  CommandLine = NewFlagSet(os.Args[0], ExitOnError)
  ErrHelp     = errors.New(&quot;flag: help requested&quot;)
  Usage       = func() {
    fmt.Fprintf(os.Stderr, &quot;Usage of %s:\n&quot;, os.Args[0])
    PrintDefaults()
  }
)
</code></pre>
<p>##包函数列表</p>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/flag/Arg.html">func Arg(i int) string</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/flag/Args.html">func Args() []string</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/flag/Bool.html">func Bool(name string, value bool, usage string) *bool</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/flag/BoolVar.html">func BoolVar(p *bool, name string, value bool, usage string)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/flag/Duration.html">func Duration(name string, value time.Duration, usage string) *time.Duration</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/flag/DurationVar.html">func DurationVar(p *time.Duration, name string, value time.Duration, usage string)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/flag/Float64.html">func Float64(name string, value float64, usage string) *float64</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/flag/Float64Var.html">func Float64Var(p *float64, name string, value float64, usage string)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/flag/Int.html">func Int(name string, value int, usage string) *int</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/flag/Int64.html">func Int64(name string, value int64, usage string) *int64</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/flag/Int64Var.html">func Int64Var(p *int64, name string, value int64, usage string)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/flag/IntVar.html">func IntVar(p *int, name string, value int, usage string)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/flag/NArg.html">func NArg() int</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/flag/NFlag.html">func NFlag() int</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/flag/Parse.html">func Parse()</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/flag/Parsed.html">func Parsed() bool</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/flag/PrintDefaults.html">func PrintDefaults()</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/flag/Set.html">func Set(name, value string) error</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/flag/String.html">func String(name string, value string, usage string) *string</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/flag/StringVar.html">func StringVar(p *string, name string, value string, usage string)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/flag/Uint.html">func Uint(name string, value uint, usage string) *uint</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/flag/Uint64.html">func Uint64(name string, value uint64, usage string) *uint64</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/flag/Uint64Var.html">func Uint64Var(p *uint64, name string, value uint64, usage string)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/flag/UintVar.html">func UintVar(p *uint, name string, value uint, usage string)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/flag/Var.html">func Var(value Value, name string, usage string)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/flag/Visit.html">func Visit(fn func(*Flag))</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/flag/VisitAll.html">func VisitAll(fn func(*Flag))</a></li>
</ul>
<h3 id="type-flag"><a class="header" href="#type-flag">type Flag</a></h3>
<pre><code>type Flag struct {
        Name     string // name as it appears on command line
        Usage    string // help message
        Value    Value  // value as set
        DefValue string // default value (as text); for usage message
}
</code></pre>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/flag/Lookup.html">func Lookup(name string) *Flag</a></li>
</ul>
<h3 id="type-flagset"><a class="header" href="#type-flagset">type FlagSet</a></h3>
<pre><code>type FlagSet struct {
        Usage func()
}
</code></pre>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/flag/NewFlagSet.html">func NewFlagSet(name string, errorHandling ErrorHandling) *FlagSet</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/flag/FlagSetArg.html">func (f *FlagSet) Arg(i int) string</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/flag/FlagSetArgs.html">func (f *FlagSet) Args() []string</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/flag/FlagSetBool.html">func (f *FlagSet) Bool(name string, value bool, usage string) *bool</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/flag/FlagSetBoolVar.html">func (f *FlagSet) BoolVar(p *bool, name string, value bool, usage string)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/flag/FlagSetDuration.html">func (f *FlagSet) Duration(name string, value time.Duration, usage string) *time.Duration</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/flag/FlagSetDurationVar.html">func (f *FlagSet) DurationVar(p *time.Duration, name string, value time.Duration, usage string)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/flag/FlagSetFloat64.html">func (f *FlagSet) Float64(name string, value float64, usage string) *float64</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/flag/FlagSetFloat64Var">func (f *FlagSet) Float64Var(p *float64, name string, value float64, usage string)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/flag/FlagSetInit.html">func (f *FlagSet) Init(name string, errorHandling ErrorHandling)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/flag/FlagSetInt.html">func (f *FlagSet) Int(name string, value int, usage string) *int</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/flag/FlagSetInt64.html">func (f *FlagSet) Int64(name string, value int64, usage string) *int64</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/flag/FlagSetInt64Var.html">func (f *FlagSet) Int64Var(p *int64, name string, value int64, usage string)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/flag/FlagSetIntVar.html">func (f *FlagSet) IntVar(p *int, name string, value int, usage string)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/flag/FlagSetLookup.html">func (f *FlagSet) Lookup(name string) *Flag</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/flag/FlagSetNArg.html">func (f *FlagSet) NArg() int</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/flag/FlagSetNFlag.html">func (f *FlagSet) NFlag() int</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/flag/FlagSetParse.html">func (f *FlagSet) Parse(arguments []string) error</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/flag/FlagSetParsed.html">func (f *FlagSet) Parsed() bool</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/flag/FlagSetPrintDefaults.html">func (f *FlagSet) PrintDefaults()</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/flag/FlagSetSet.html">func (f *FlagSet) Set(name, value string) error</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/flag/FlagSetSetOutput.html">func (f *FlagSet) SetOutput(output io.Writer)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/flag/FlagSetString.html">func (f *FlagSet) String(name string, value string, usage string) *string</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/flag/FlagSetStringVar.html">func (f *FlagSet) StringVar(p *string, name string, value string, usage string)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/flag/FlagSetUint.html">func (f *FlagSet) Uint(name string, value uint, usage string) *uint</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/flag/FlagSetUint64.html">func (f *FlagSet) Uint64(name string, value uint64, usage string) *uint64</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/flag/FlagSetUint64Var.html">func (f *FlagSet) Uint64Var(p *uint64, name string, value uint64, usage string)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/flag/FlagSetUintVar.html">func (f *FlagSet) UintVar(p *uint, name string, value uint, usage string)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/flag/FlagSetVar.html">func (f *FlagSet) Var(value Value, name string, usage string)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/flag/FlagSetVisit.html">func (f *FlagSet) Visit(fn func(*Flag))</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/flag/FlagSetVisitAll.html">func (f *FlagSet) VisitAll(fn func(*Flag))</a></li>
</ul>
<h3 id="type-getter"><a class="header" href="#type-getter">type Getter</a></h3>
<pre><code>type Getter interface {
        Value
        Get() interface{}
}
</code></pre>
<h3 id="type-value"><a class="header" href="#type-value">type Value</a></h3>
<pre><code>type Value interface {
        String() string
        Set(string) error
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-argi-int-string"><a class="header" href="#func-argi-int-string">func Arg(i int) string</a></h2>
<p>参数列表</p>
<ul>
<li>i int 非flag命令行参数集合的索引</li>
</ul>
<p>返回值</p>
<ul>
<li>string 第i＋1个非flag命令行参数的值</li>
</ul>
<p>功能说明</p>
<ul>
<li>获取第i＋1个非flag命令行参数的值，使用前需要先调用<code>flag.Parse()</code>解析flag,底层实际调用了全局变量CommandLine的Arg函数</li>
</ul>
<p>代码示例1</p>
<pre><code>package main

import (
    &quot;flag&quot;
    &quot;fmt&quot;
)

func main() {
    flag.Parse()
    fmt.Println(flag.Arg(0))
}
</code></pre>
<p>执行结果</p>
<pre><code>//  ./test_arg abc
abc
</code></pre>
<p>代码示例2</p>
<pre><code>package main

import (
    &quot;flag&quot;
    &quot;fmt&quot;
)

var ip = flag.String(&quot;flag&quot;, &quot;1234&quot;, &quot;test for flags&quot;)

func main() {
    flag.Parse()
    fmt.Println(flag.Arg(0))
}
</code></pre>
<p>执行结果</p>
<pre><code>//  ./test_arg abc
abc

//  ./test_arg -flag abc def
def
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-args-string"><a class="header" href="#func-args-string">func Args() []string</a></h2>
<p>参数列表</p>
<p>返回值</p>
<ul>
<li>[]string 非flag命令行参数集合</li>
</ul>
<p>功能说明</p>
<ul>
<li>获取非flag命令行参数集合，使用前需要先调用<code>flag.Parse</code>解析flag，底层实际调用了全局变量CommandLine的Args函数</li>
</ul>
<p>代码示例1</p>
<pre><code>package main

import (
    &quot;flag&quot;
    &quot;fmt&quot;
)

func main() {
    flag.Parse()
    fmt.Println(flag.Args())
}
</code></pre>
<p>执行结果</p>
<pre><code>//  ./test_args abc
[abc]
</code></pre>
<p>代码示例2</p>
<pre><code>package main

import (
    &quot;flag&quot;
    &quot;fmt&quot;
)

var ip = flag.String(&quot;flag&quot;, &quot;1234&quot;, &quot;test for flags&quot;)

func main() {
    flag.Parse()
    fmt.Println(flag.Args())
}
</code></pre>
<p>执行结果</p>
<pre><code>//  ./test_args abc def
[abc def]

//  ./test_args -flag abc def ghi
[def ghi]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-boolname-string-value-bool-usage-string-bool"><a class="header" href="#func-boolname-string-value-bool-usage-string-bool">func Bool(name string, value bool, usage string) *bool</a></h2>
<p>参数列表</p>
<ul>
<li>name string 命令行flag名称</li>
<li>value bool 默认值</li>
<li>usage string 帮助信息</li>
</ul>
<p>返回值</p>
<ul>
<li>*bool 返回一个bool类型的flag值的地址</li>
</ul>
<p>功能说明</p>
<ul>
<li>定义一个带默认值和提示语句的bool类型flag，返回flag对应值的地址，底层实际调用了全局变量CommandLine的Bool方法</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;flag&quot;
	&quot;fmt&quot;
)

var boolFlag = flag.Bool(&quot;flag&quot;, false, &quot;help message for flag&quot;)

func main() {
	flag.Parse()
	fmt.Println(&quot;boolFlag: &quot;, *boolFlag)
}
</code></pre>
<p>执行结果</p>
<pre><code>//  ./test_bool
boolFlag:  false

//  ./test_bool -flag
boolFlag:  true

//  ./test_bool -flag=false
boolFlag:  false
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-boolvarp-bool-name-string-value-bool-usage-string"><a class="header" href="#func-boolvarp-bool-name-string-value-bool-usage-string">func BoolVar(p *bool, name string, value bool, usage string)</a></h2>
<p>参数列表</p>
<ul>
<li>p *bool bool型变量指针</li>
<li>name string flag名称</li>
<li>value bool 默认值</li>
<li>usage string 提示信息</li>
</ul>
<p>返回值</p>
<p>功能说明
－ 将指定flag值绑定到一个bool变量，底层实际调用了全局变量CommandLine的BoolVar函数</p>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;flag&quot;
	&quot;fmt&quot;
)

var boolFlag bool

func init() {
	flag.BoolVar(&amp;boolFlag, &quot;flag&quot;, false, &quot;help message for flag&quot;)
}

func main() {
	flag.Parse()
	fmt.Println(&quot;boolFlag: &quot;, boolFlag)
}
</code></pre>
<p>执行结果</p>
<pre><code>//  ./test_boolval
boolFlag:  false

//  ./test_boolval -flag
boolFlag:  true

//  ./test_boolval -flag=true
boolFlag:  true</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-durationname-string-value-timeduration-usage-string-timeduration"><a class="header" href="#func-durationname-string-value-timeduration-usage-string-timeduration">func Duration(name string, value time.Duration, usage string) *time.Duration</a></h2>
<p>参数列表</p>
<ul>
<li>name string flag名称</li>
<li>value time.Duration 默认值</li>
<li>usage string 提示信息 </li>
</ul>
<p>返回值</p>
<ul>
<li>*time.Duration 返回一个Duration类型的flag值的地址</li>
</ul>
<p>功能说明</p>
<ul>
<li>定义一个带默认值和提示语句的Duration类型flag，返回flag对应值的地址</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
    &quot;flag&quot;
    &quot;fmt&quot;
)

var durationFlag = flag.Duration(&quot;duraT&quot;, 12, &quot;help message for duraT&quot;)

func main() {
    flag.Parse()
    fmt.Println(*durationFlag)
}
</code></pre>
<p>代码输出</p>
<pre><code>//  ./testduration
12ns

//  ./testduration -duraT
flag needs an argument: -duraT
Usage of ./testduration:
  -duraT=12ns: help message for duraT
  
//  ./testduration -duraT=200ms
200ms

//  ./testduration -duraT 3000h
3000h0m0s
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-durationvarp-timeduration-name-string-value-timeduration-usage-string"><a class="header" href="#func-durationvarp-timeduration-name-string-value-timeduration-usage-string">func DurationVar(p *time.Duration, name string, value time.Duration, usage string)</a></h2>
<p>参数列表</p>
<ul>
<li>p *time.Duration  需要与flag值绑定的变量的指针</li>
<li>name string   flag名称</li>
<li>value time.Duration   默认值</li>
<li>usage string  提示信息</li>
</ul>
<p>返回值</p>
<p>功能说明</p>
<ul>
<li>将一个time.Duration类型的flag值绑定到一个time.Duration的变量 </li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;flag&quot;
	&quot;fmt&quot;
	&quot;time&quot;
)

var durationFlag time.Duration

func init() {
	flag.DurationVar(&amp;durationFlag, &quot;duraT&quot;, 120, &quot;help message for duraT&quot;)
}

func main() {
	flag.Parse()
	fmt.Println(durationFlag)
}
</code></pre>
<p>代码输出</p>
<pre><code>//  ./testdurationvar
120ns

//  ./testdurationvar -duraT
flag needs an argument: -duraT
Usage of ./testdurationvar:
  -duraT=120ns: help message for duraT
  
//  ./testdurationvar -duraT=200ms
200ms

//  ./testdurationvar -duraT 3000h
3000h0m0s</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-f-flagset-argi-int-string"><a class="header" href="#func-f-flagset-argi-int-string">func (f *FlagSet) Arg(i int) string</a></h2>
<p>参数列表</p>
<ul>
<li>i int 非flag参数集合的索引</li>
</ul>
<p>返回值</p>
<ul>
<li>string 第i＋1个非flag参数的值</li>
</ul>
<p>功能说明</p>
<ul>
<li>获取Flag集合f中第i＋1个非flag参数的值</li>
</ul>
<p>代码示例1</p>
<pre><code>package main

import (
	&quot;flag&quot;
	&quot;fmt&quot;
)

var myFlagSet = flag.NewFlagSet(&quot;myflagset&quot;, flag.ExitOnError)
var stringFlag = myFlagSet.String(&quot;abc&quot;, &quot;default value&quot;, &quot;help mesage&quot;)

func main() {
	myFlagSet.Parse([]string{&quot;-abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;123&quot;})
	args := myFlagSet.Args()
	for i := range args {
		fmt.Println(i, myFlagSet.Arg(i))
	}
}
</code></pre>
<p>执行结果</p>
<pre><code>//  ./testflagsetarg
0 ghi
1 123
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-f-flagset-args-string"><a class="header" href="#func-f-flagset-args-string">func (f *FlagSet) Args() []string</a></h2>
<p>参数列表</p>
<p>返回值</p>
<ul>
<li>[]string 所有非flag参数的集合</li>
</ul>
<p>功能说明</p>
<ul>
<li>获取Flag集合f中所有非flag参数的集合</li>
</ul>
<p>代码示例1</p>
<pre><code>package main

import (
    &quot;flag&quot;
    &quot;fmt&quot;
)

var myFlagSet = flag.NewFlagSet(&quot;myflagset&quot;, flag.ExitOnError)
var stringFlag = myFlagSet.String(&quot;abc&quot;, &quot;default value&quot;, &quot;help mesage&quot;)

func main() {
    myFlagSet.Parse([]string{&quot;-abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;123&quot;})
    args := myFlagSet.Args()
    for i := range args {
        fmt.Println(i, myFlagSet.Arg(i))
    }
}
</code></pre>
<p>执行结果</p>
<pre><code>//  ./testflagsetarg
0 ghi
1 123
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-f-flagset-boolname-string-value-bool-usage-string-bool"><a class="header" href="#func-f-flagset-boolname-string-value-bool-usage-string-bool">func (f *FlagSet) Bool(name string, value bool, usage string) *bool</a></h2>
<p>参数列表</p>
<ul>
<li>name string flag名称</li>
<li>value bool 默认值</li>
<li>usage string 提示信息</li>
</ul>
<p>返回值</p>
<p>功能说明
将f中指定flag的值绑定到一个bool变量</p>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;flag&quot;
	&quot;fmt&quot;
)

const (
	defaultUsage = &quot;help message&quot;
)

var (
	myFlagSet = flag.NewFlagSet(&quot;newflagset&quot;, flag.ExitOnError)
	boolFlag  = myFlagSet.Bool(&quot;boolFlag&quot;, false, defaultUsage)
	boolVar   bool
)

func init() {
	myFlagSet.BoolVar(&amp;boolVar, &quot;boolVar&quot;, false, defaultUsage)
}

func main() {
	args := []string{
		&quot;-boolFlag&quot;,
		&quot;-boolVar=true&quot;,
		&quot;arg2&quot;,
	}
	myFlagSet.Parse(args)
	fmt.Println(&quot;boolFlag&quot;, *boolFlag)
	fmt.Println(&quot;boolVar&quot;, boolVar)
}
</code></pre>
<p>执行结果</p>
<pre><code>//  ./testflagsetbool                         
boolFlag true
boolVar true
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-f-flagset-boolvarp-bool-name-string-value-bool-usage-string"><a class="header" href="#func-f-flagset-boolvarp-bool-name-string-value-bool-usage-string">func (f *FlagSet) BoolVar(p *bool, name string, value bool, usage string)</a></h2>
<p>参数列表</p>
<ul>
<li>p *time.Duration  需要与flag值绑定的变量的指针</li>
<li>name string   flag名称</li>
<li>value time.Duration   默认值</li>
<li>usage string  提示信息</li>
</ul>
<p>返回值</p>
<p>功能说明</p>
<ul>
<li>将一个time.Duration类型的flag值绑定到一个time.Duration的变量 </li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;flag&quot;
	&quot;fmt&quot;
	&quot;time&quot;
)

const (
	defaultUsage = &quot;help message&quot;
)

var (
	myFlagSet = flag.NewFlagSet(&quot;newflagset&quot;, flag.ExitOnError)
	duratFlag = myFlagSet.Duration(&quot;duratFlag&quot;, 20, defaultUsage)
	duratVar  time.Duration
)

func init() {
	myFlagSet.DurationVar(&amp;duratVar, &quot;duratVar&quot;, 100, defaultUsage)
}

func main() {
	args := []string{
		&quot;-duratVar&quot;, &quot;2m&quot;,
		&quot;-duratFlag&quot;, &quot;12h&quot;,
		&quot;arg2&quot;,
	}
	myFlagSet.Parse(args)
	fmt.Println(&quot;duratFlag&quot;, *duratFlag)
	fmt.Println(&quot;duratVar&quot;, duratVar)
}
</code></pre>
<p>代码输出</p>
<pre><code>//  ./testflagsetduration 
duratFlag 12h0m0s
duratVar 2m0s
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-f-flagset-durationname-string-value-timeduration-usage-string-timeduration"><a class="header" href="#func-f-flagset-durationname-string-value-timeduration-usage-string-timeduration">func (f *FlagSet) Duration(name string, value time.Duration, usage string) *time.Duration</a></h2>
<p>参数列表</p>
<ul>
<li>name string flag名称</li>
<li>value time.Duration 默认值</li>
<li>usage string 提示信息 </li>
</ul>
<p>返回值</p>
<ul>
<li>*time.Duration 返回一个Duration类型的flag值的地址</li>
</ul>
<p>功能说明</p>
<ul>
<li>为Flag集合f增加一个带默认值和提示语句的Duration类型flag，返回flag对应值的地址</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;flag&quot;
	&quot;fmt&quot;
	&quot;time&quot;
)

const (
	defaultUsage = &quot;help message&quot;
)

var (
	myFlagSet = flag.NewFlagSet(&quot;newflagset&quot;, flag.ExitOnError)
	duratFlag = myFlagSet.Duration(&quot;duratFlag&quot;, 20, defaultUsage)
	duratVar  time.Duration
)

func init() {
	myFlagSet.DurationVar(&amp;duratVar, &quot;duratVar&quot;, 100, defaultUsage)
}

func main() {
	args := []string{
		&quot;-duratVar&quot;, &quot;2m&quot;,
		&quot;-duratFlag&quot;, &quot;12h&quot;,
		&quot;arg2&quot;,
	}
	myFlagSet.Parse(args)
	fmt.Println(&quot;duratFlag&quot;, *duratFlag)
	fmt.Println(&quot;duratVar&quot;, duratVar)
}
</code></pre>
<p>代码输出</p>
<pre><code>//  ./testflagsetduration 
duratFlag 12h0m0s
duratVar 2m0s
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-f-flagset-float64name-string-value-float64-usage-string-float64"><a class="header" href="#func-f-flagset-float64name-string-value-float64-usage-string-float64">func (f *FlagSet) Float64(name string, value float64, usage string) *float64</a></h2>
<p>参数列表</p>
<ul>
<li>name string flag名称</li>
<li>value float64 默认值</li>
<li>usage string 提示信息</li>
</ul>
<p>返回值</p>
<ul>
<li>*float64 返回一个float64类型的flag值的地址</li>
</ul>
<p>功能说明</p>
<ul>
<li>为flag集合f增加一个带默认值和语句的float64类型的flag，返回flag对应值的地址</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;flag&quot;
	&quot;fmt&quot;
)

const (
	defaultUsage = &quot;help message&quot;
)

var (
	myFlagSet   = flag.NewFlagSet(&quot;newflagset&quot;, flag.ExitOnError)
	float64Flag = myFlagSet.Float64(&quot;float64Flag&quot;, 0.9917, defaultUsage)
	float64Var  float64
)

func init() {
	myFlagSet.Float64Var(&amp;float64Var, &quot;float64Var&quot;, 0.102, defaultUsage)
}

func main() {
	args := []string{
		&quot;-float64Flag&quot;, &quot;2718e28&quot;,
		&quot;-float64Var&quot;, &quot;-12.78&quot;,
		&quot;arg2&quot;,
	}
	myFlagSet.Parse(args)
	fmt.Println(&quot;float64Flag&quot;, *float64Flag)
	fmt.Println(&quot;float64Var&quot;, float64Var)
}
</code></pre>
<p>代码输出</p>
<p>./testflagsetfloat64 
float64Flag 2.718e+31
float64Var -12.78</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-f-flagset-float64varp-float64-name-string-value-float64-usage-string"><a class="header" href="#func-f-flagset-float64varp-float64-name-string-value-float64-usage-string">func (f *FlagSet) Float64Var(p *float64, name string, value float64, usage string)</a></h2>
<p>参数列表</p>
<ul>
<li>p *float64 需要与flag参数值绑定的变量地址</li>
<li>name string   flag名称</li>
<li>value float64 变量默认值</li>
<li>usage string 提示信息</li>
</ul>
<p>返回值</p>
<p>功能说明</p>
<ul>
<li>将f中指定flag参数值绑定到float64变量</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;flag&quot;
	&quot;fmt&quot;
)

const (
	defaultUsage = &quot;help message&quot;
)

var (
	myFlagSet   = flag.NewFlagSet(&quot;newflagset&quot;, flag.ExitOnError)
	float64Flag = myFlagSet.Float64(&quot;float64Flag&quot;, 0.9917, defaultUsage)
	float64Var  float64
)

func init() {
	myFlagSet.Float64Var(&amp;float64Var, &quot;float64Var&quot;, 0.102, defaultUsage)
}

func main() {
	args := []string{
		&quot;-float64Flag&quot;, &quot;2718e28&quot;,
		&quot;-float64Var&quot;, &quot;-12.78&quot;,
		&quot;arg2&quot;,
	}
	myFlagSet.Parse(args)
	fmt.Println(&quot;float64Flag&quot;, *float64Flag)
	fmt.Println(&quot;float64Var&quot;, float64Var)
}
</code></pre>
<p>代码输出</p>
<pre><code>//  ./testflagsetfloat64 
float64Flag 2.718e+31
float64Var -12.78
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-f-flagset-initname-string-errorhandling-errorhandling"><a class="header" href="#func-f-flagset-initname-string-errorhandling-errorhandling">func (f *FlagSet) Init(name string, errorHandling ErrorHandling)</a></h2>
<p>参数列表</p>
<ul>
<li>name string 名称</li>
<li>errorHandling ErrorHandling 错误处理方式，包括<code>ContinueOnError</code>:出错仍继续, <code>ExitOnError</code>:出错后退出程序,<code>PanicOnError</code>:出错后panic三种错误处理方式</li>
</ul>
<p>返回值</p>
<p>功能说明</p>
<ul>
<li>设置flag集合的名称和错误处理方式</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;flag&quot;
	&quot;fmt&quot;
)

var myFlagSet = flag.NewFlagSet(&quot;testFlagSet&quot;, flag.ExitOnError)

func main() {
	fmt.Println(&quot;Before Set:&quot;, myFlagSet)
	myFlagSet.Init(&quot;myFlagSet&quot;, flag.ContinueOnError)
	fmt.Println(&quot;After Set:&quot;, myFlagSet)
}
</code></pre>
<p>代码输出</p>
<pre><code>//  ./testflagsetinit 
Before Set: &amp;{&lt;nil&gt; testFlagSet false map[] map[] [] 1 ?reflect.Value?}
After Set: &amp;{&lt;nil&gt; myFlagSet false map[] map[] [] 0 ?reflect.Value?}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-f-flagset-intname-string-value-int-usage-string-int"><a class="header" href="#func-f-flagset-intname-string-value-int-usage-string-int">func (f *FlagSet) Int(name string, value int, usage string) *int</a></h2>
<p>参数列表</p>
<ul>
<li>name string   flag名称</li>
<li>value int 变量默认值</li>
<li>usage string 提示信息</li>
</ul>
<p>返回值</p>
<ul>
<li>*int 返回一个int类型的flag值的地址</li>
</ul>
<p>功能说明</p>
<ul>
<li>为flag集合f增加一个带默认值和提示语句的int类型flag，返回对应值的地址</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;flag&quot;
	&quot;fmt&quot;
)

const (
	defaultUsage = &quot;help message&quot;
)

var (
	myFlagSet = flag.NewFlagSet(&quot;newflagset&quot;, flag.ExitOnError)
	intFlag   = myFlagSet.Int(&quot;intFlag&quot;, 100, defaultUsage)
	intVar    int
)

func init() {
	myFlagSet.IntVar(&amp;intVar, &quot;intVar&quot;, 20, defaultUsage)
}

func main() {
	args := []string{
		&quot;--intFlag&quot;, &quot;22&quot;,
		&quot;-intVar&quot;, &quot;-10&quot;,
		&quot;arg2&quot;,
	}
	myFlagSet.Parse(args)
	fmt.Println(&quot;intFlag&quot;, *intFlag)
	fmt.Println(&quot;intVar&quot;, intVar)
}
</code></pre>
<p>代码输出</p>
<pre><code>//  ./testflagsetint
intFlag 22
intVar -10
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-f-flagset-int64name-string-value-int64-usage-string-int64"><a class="header" href="#func-f-flagset-int64name-string-value-int64-usage-string-int64">func (f *FlagSet) Int64(name string, value int64, usage string) *int64</a></h2>
<p>参数列表</p>
<ul>
<li>name string   flag名称</li>
<li>value int64 变量默认值</li>
<li>usage string 提示信息</li>
</ul>
<p>返回值</p>
<ul>
<li>*int64 返回一个int64类型的变量的地址</li>
</ul>
<p>功能说明</p>
<ul>
<li>为flag集合f增加爱一个带默认值和提示语句的int64类型flag，返回flag对应变量值的地址</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;flag&quot;
	&quot;fmt&quot;
)

const (
	defaultUsage = &quot;help message&quot;
)

var (
	myFlagSet = flag.NewFlagSet(&quot;newflagset&quot;, flag.ExitOnError)
	int64Flag = myFlagSet.Int64(&quot;int64Flag&quot;, 100, defaultUsage)
	int64Var  int64
)

func init() {
	myFlagSet.Int64Var(&amp;int64Var, &quot;int64Var&quot;, 20, defaultUsage)
}

func main() {
	args := []string{
		&quot;--int64Flag&quot;, &quot;22&quot;,
		&quot;-int64Var&quot;, &quot;-10&quot;,
		&quot;arg2&quot;,
	}
	myFlagSet.Parse(args)
	fmt.Println(&quot;int64Flag&quot;, *int64Flag)
	fmt.Println(&quot;int64Var&quot;, int64Var)
}
</code></pre>
<p>代码输出</p>
<pre><code>//  ./testflagsetint64 
int64Flag 22
int64Var -10
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-f-flagset-int64varp-int64-name-string-value-int64-usage-string"><a class="header" href="#func-f-flagset-int64varp-int64-name-string-value-int64-usage-string">func (f *FlagSet) Int64Var(p *int64, name string, value int64, usage string)</a></h2>
<p>参数列表</p>
<ul>
<li>p *int64 需要与flag参数值绑定的变量地址</li>
<li>name string  flag名称</li>
<li>value int 变量默认值</li>
<li>usage string 提示信息</li>
</ul>
<p>返回值</p>
<p>功能说明</p>
<ul>
<li>将f中指定flag参数值绑定到int64变量</li>
</ul>
<p>功能说明</p>
<ul>
<li>为flag集合f增加爱一个带默认值和提示语句的int64类型flag，返回flag对应变量值的地址</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;flag&quot;
	&quot;fmt&quot;
)

const (
	defaultUsage = &quot;help message&quot;
)

var (
	myFlagSet = flag.NewFlagSet(&quot;newflagset&quot;, flag.ExitOnError)
	int64Flag = myFlagSet.Int64(&quot;int64Flag&quot;, 100, defaultUsage)
	int64Var  int64
)

func init() {
	myFlagSet.Int64Var(&amp;int64Var, &quot;int64Var&quot;, 20, defaultUsage)
}

func main() {
	args := []string{
		&quot;--int64Flag&quot;, &quot;22&quot;,
		&quot;-int64Var&quot;, &quot;-10&quot;,
		&quot;arg2&quot;,
	}
	myFlagSet.Parse(args)
	fmt.Println(&quot;int64Flag&quot;, *int64Flag)
	fmt.Println(&quot;int64Var&quot;, int64Var)
}
</code></pre>
<p>代码输出</p>
<pre><code>//  ./testflagsetint64 
int64Flag 22
int64Var -10
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-f-flagset-intvarp-int-name-string-value-int-usage-string"><a class="header" href="#func-f-flagset-intvarp-int-name-string-value-int-usage-string">func (f *FlagSet) IntVar(p *int, name string, value int, usage string)</a></h2>
<p>参数列表</p>
<ul>
<li>p *int 需要与flag参数值绑定的变量地址</li>
<li>name string  flag名称</li>
<li>value int 变量默认值</li>
<li>usage string 提示信息</li>
</ul>
<p>返回值</p>
<p>功能说明</p>
<ul>
<li>将f中指定flag参数值绑定到int64变量</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;flag&quot;
	&quot;fmt&quot;
)

const (
	defaultUsage = &quot;help message&quot;
)

var (
	myFlagSet = flag.NewFlagSet(&quot;newflagset&quot;, flag.ExitOnError)
	intFlag   = myFlagSet.Int(&quot;intFlag&quot;, 100, defaultUsage)
	intVar    int
)

func init() {
	myFlagSet.IntVar(&amp;intVar, &quot;intVar&quot;, 20, defaultUsage)
}

func main() {
	args := []string{
		&quot;--intFlag&quot;, &quot;22&quot;,
		&quot;-intVar&quot;, &quot;-10&quot;,
		&quot;arg2&quot;,
	}
	myFlagSet.Parse(args)
	fmt.Println(&quot;intFlag&quot;, *intFlag)
	fmt.Println(&quot;intVar&quot;, intVar)
}
</code></pre>
<p>代码输出</p>
<pre><code>//  ./testflagsetint
intFlag 22
intVar -10
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-f-flagset-lookupname-string-flag"><a class="header" href="#func-f-flagset-lookupname-string-flag">func (f *FlagSet) Lookup(name string) *Flag</a></h2>
<p>参数列表</p>
<ul>
<li>name string  flag名称</li>
</ul>
<p>返回值</p>
<ul>
<li>*Flag Flag指针</li>
</ul>
<p>功能说明</p>
<ul>
<li>获取flag集合f中名称为name值的flag指针，如果对应的flag不存在，返回nil</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;flag&quot;
	&quot;fmt&quot;
)

var myFlagSet = flag.NewFlagSet(&quot;testFlagSet&quot;, flag.ExitOnError)
var testFlag = myFlagSet.String(&quot;test&quot;, &quot;default value&quot;, &quot;help message.&quot;)

func print(f *flag.Flag) {
	if f != nil {
		fmt.Println(f.Value)
	} else {
		fmt.Println(nil)
	}
}

func main() {
	fmt.Print(&quot;test:&quot;)
	print(myFlagSet.Lookup(&quot;test&quot;))
	fmt.Print(&quot;test1:&quot;)
	print(myFlagSet.Lookup(&quot;test1&quot;))
	myFlagSet.Parse([]string{&quot;-test=12345&quot;})
	fmt.Print(&quot;test:&quot;)
	print(myFlagSet.Lookup(&quot;test&quot;))
	fmt.Print(&quot;test1:&quot;)
	print(myFlagSet.Lookup(&quot;test1&quot;))
}
</code></pre>
<p>运行结果</p>
<pre><code>//  ./testflagsetlookup -test &quot;12345&quot;      
test:default value
test1:&lt;nil&gt;
test:12345
test1:&lt;nil&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-f-flagset-narg-int"><a class="header" href="#func-f-flagset-narg-int">func (f *FlagSet) NArg() int</a></h2>
<p>参数列表</p>
<p>返回值</p>
<ul>
<li>int 返回解析后剩余的参数的数量</li>
</ul>
<p>功能说明</p>
<ul>
<li>获取输入参数解析后剩余的参数的数量，即f.Args()返回的值的元素个数</li>
</ul>
<p>示例</p>
<pre><code>package main

import (
	&quot;flag&quot;
	&quot;fmt&quot;
)

const (
	defaultUsage = &quot;help message&quot;
)

var (
	myFlagSet = flag.NewFlagSet(&quot;newflagset&quot;, flag.ExitOnError)
	uintFlag  = myFlagSet.Uint(&quot;uintFlag&quot;, 1000, defaultUsage)
	uintVar   uint
)

func init() {
	myFlagSet.UintVar(&amp;uintVar, &quot;uintVar&quot;, 30, defaultUsage)
}

func main() {
	args := []string{
		&quot;-uintFlag&quot;, &quot;24&quot;,
		&quot;--uintVar&quot;, &quot;25&quot;,
		&quot;arg1&quot;,
		&quot;arg2&quot;,
		&quot;arg3&quot;,
	}
	myFlagSet.Parse(args)
	length := myFlagSet.NArg()
	for i := 0; i &lt; length; i++ {
		fmt.Println(i, myFlagSet.Arg(i))
	}
}
</code></pre>
<p>代码输出</p>
<pre><code>//  ./testflagsetnarg 
0 arg1
1 arg2
2 arg3
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-f-flagset-nflag-int"><a class="header" href="#func-f-flagset-nflag-int">func (f *FlagSet) NFlag() int</a></h2>
<p>参数列表</p>
<p>返回值</p>
<ul>
<li>int 返回解析成功的flag个数</li>
</ul>
<p>功能说明</p>
<ul>
<li>获取解析成功的flag个数</li>
</ul>
<p>示例</p>
<pre><code>package main

import (
	&quot;flag&quot;
	&quot;fmt&quot;
)

const (
	defaultUsage = &quot;help message&quot;
)

var (
	myFlagSet = flag.NewFlagSet(&quot;newflagset&quot;, flag.ExitOnError)
	uintFlag  = myFlagSet.Uint(&quot;uintFlag&quot;, 1000, defaultUsage)
	testFlag  = myFlagSet.String(&quot;testFlag&quot;, &quot;default value&quot;, defaultUsage)
	uintVar   uint
)

func init() {
	myFlagSet.UintVar(&amp;uintVar, &quot;uintVar&quot;, 30, defaultUsage)
}

func main() {
	args := []string{
		&quot;-uintFlag&quot;, &quot;24&quot;,
		&quot;arg1&quot;,
	}
	fmt.Println(&quot;before:&quot;, myFlagSet.NFlag())
	myFlagSet.Parse(args)
	fmt.Println(&quot;after:&quot;, myFlagSet.NFlag())
}
</code></pre>
<p>代码输出</p>
<pre><code>//  ./testflagsetnflag                          
before: 0
after: 1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-f-flagset-parsearguments-string-error"><a class="header" href="#func-f-flagset-parsearguments-string-error">func (f *FlagSet) Parse(arguments []string) error</a></h2>
<p>参数列表
－ arguments []string 要解析的字符串列表</p>
<p>返回值</p>
<p>功能说明</p>
<ul>
<li>从argumets中依次解析flag.在定义flag之后，必须调用用本函数才能成功获取arguments中设置的flag的值 </li>
</ul>
<p>示例</p>
<pre><code>package main

import (
	&quot;flag&quot;
	&quot;fmt&quot;
)

const (
	defaultUsage = &quot;help message&quot;
)

var (
	myFlagSet = flag.NewFlagSet(&quot;newflagset&quot;, flag.ExitOnError)
	uintFlag  = myFlagSet.Uint(&quot;uintFlag&quot;, 1000, defaultUsage)
	testFlag  = myFlagSet.String(&quot;testFlag&quot;, &quot;default value&quot;, defaultUsage)
	uintVar   uint
)

func init() {
	myFlagSet.UintVar(&amp;uintVar, &quot;uintVar&quot;, 30, defaultUsage)
}

func main() {
	args := []string{
		&quot;-uintFlag&quot;, &quot;24&quot;,
		&quot;-testFlag&quot;, &quot;test&quot;,
		&quot;arg1&quot;,
	}
	myFlagSet.Parse(args)
	if myFlagSet.Parsed() {
		fmt.Println(&quot;uintFlag:&quot;, *uintFlag)
		fmt.Println(&quot;testFlag:&quot;, *testFlag)
	}
}
</code></pre>
<p>代码输出</p>
<pre><code>//  ./testflagsetparse                          
uintFlag: 24
testFlag: test
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-f-flagset-parsed-bool"><a class="header" href="#func-f-flagset-parsed-bool">func (f *FlagSet) Parsed() bool</a></h2>
<p>参数列表</p>
<p>返回值</p>
<ul>
<li>bool 若flag设置参数已解析(已调用f.Parse()方法)，返回true</li>
</ul>
<p>功能说明</p>
<ul>
<li>判断flag设置参数是否已经解析(是否已调用f.Parse()方法)，若已解析返回true</li>
</ul>
<p>示例</p>
<pre><code>package main

import (
	&quot;flag&quot;
	&quot;fmt&quot;
)

const (
	defaultUsage = &quot;help message&quot;
)

var (
	myFlagSet = flag.NewFlagSet(&quot;newflagset&quot;, flag.ExitOnError)
	uintFlag  = myFlagSet.Uint(&quot;uintFlag&quot;, 1000, defaultUsage)
	testFlag  = myFlagSet.String(&quot;testFlag&quot;, &quot;default value&quot;, defaultUsage)
	uintVar   uint
)

func init() {
	myFlagSet.UintVar(&amp;uintVar, &quot;uintVar&quot;, 30, defaultUsage)
}

func main() {
	args := []string{
		&quot;-uintFlag&quot;, &quot;24&quot;,
		&quot;-testFlag&quot;, &quot;test&quot;,
		&quot;arg1&quot;,
	}
	myFlagSet.Parse(args)
	if myFlagSet.Parsed() {
		fmt.Println(&quot;uintFlag:&quot;, *uintFlag)
		fmt.Println(&quot;testFlag:&quot;, *testFlag)
	}
}
</code></pre>
<p>代码输出</p>
<pre><code>//  ./testflagsetparsed                          
uintFlag: 24
testFlag: test
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-f-flagset-printdefaults"><a class="header" href="#func-f-flagset-printdefaults">func (f *FlagSet) PrintDefaults()</a></h2>
<p>参数列表</p>
<p>返回值</p>
<p>功能说明</p>
<ul>
<li>将所有已设置flag的默认值输出，默认为输出到标准出错，可通过SetOutput接口修改，默认值包括默认值，默认错误提示等。</li>
</ul>
<p>示例</p>
<pre><code>package main

import (
	&quot;flag&quot;
	&quot;fmt&quot;
	&quot;os&quot;
)

const (
	defaultUsage = &quot;help message&quot;
)

var (
	myFlagSet = flag.NewFlagSet(&quot;newflagset&quot;, flag.ExitOnError)
	uintFlag  = myFlagSet.Uint(&quot;uintFlag&quot;, 1000, defaultUsage)
	testFlag  = myFlagSet.String(&quot;testFlag&quot;, &quot;default value&quot;, defaultUsage)
	uintVar   uint
)

func init() {
	myFlagSet.UintVar(&amp;uintVar, &quot;uintVar&quot;, 30, defaultUsage)
}

func main() {
	args := []string{
		&quot;-uintFlag&quot;, &quot;24&quot;,
		&quot;-testFlag&quot;, &quot;test&quot;,
		&quot;arg1&quot;,
	}
	myFlagSet.Parse(args)
	if myFlagSet.Parsed() {
		myFlagSet.SetOutput(os.Stderr)
		fmt.Println(&quot;PrintDefaults:&quot;)
		myFlagSet.PrintDefaults()
	}
}
</code></pre>
<p>代码输出</p>
<pre><code>//  ./testflagsetprintdefaults
PrintDefaults:
  -testFlag=&quot;default value&quot;: help message
  -uintFlag=1000: help message
  -uintVar=30: help message
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-f-flagset-setname-value-string-error"><a class="header" href="#func-f-flagset-setname-value-string-error">func (f *FlagSet) Set(name, value string) error</a></h2>
<p>参数列表</p>
<ul>
<li>name string flag名称</li>
<li>value string flag值</li>
</ul>
<p>功能说明</p>
<ul>
<li>修改指定flag的值</li>
</ul>
<p>返回值</p>
<ul>
<li>error 设置成功返回nil</li>
</ul>
<p>功能说明</p>
<ul>
<li>修改指定flag的值，成功返回nil</li>
</ul>
<p>示例</p>
<pre><code>package main

import (
	&quot;flag&quot;
	&quot;fmt&quot;
)

const (
	defaultUsage = &quot;help message&quot;
)

var (
	myFlagSet = flag.NewFlagSet(&quot;newflagset&quot;, flag.ExitOnError)
	uintFlag  = myFlagSet.Uint(&quot;uintFlag&quot;, 1000, defaultUsage)
	testFlag  = myFlagSet.String(&quot;testFlag&quot;, &quot;default value&quot;, defaultUsage)
	uintVar   uint
)

func init() {
	myFlagSet.UintVar(&amp;uintVar, &quot;uintVar&quot;, 30, defaultUsage)
}

func main() {
	args := []string{
		&quot;-uintFlag&quot;, &quot;24&quot;,
		&quot;-testFlag&quot;, &quot;test&quot;,
		&quot;arg1&quot;,
	}
	myFlagSet.Parse(args)
	if myFlagSet.Parsed() {
		fmt.Println(&quot;before set:&quot;, *testFlag)
		myFlagSet.Set(&quot;testFlag&quot;, &quot;12345&quot;)
		fmt.Println(&quot;after set&quot;, *testFlag)
	}
}
</code></pre>
<p>代码输出</p>
<pre><code>// ./testflagsetset                        
before set: test
after set 12345
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-f-flagset-setoutputoutput-iowriter"><a class="header" href="#func-f-flagset-setoutputoutput-iowriter">func (f *FlagSet) SetOutput(output io.Writer)</a></h2>
<p>参数列表</p>
<ul>
<li>output io.Writer 设置错误信息和帮助信息的输出，默认为输出到标准错误</li>
</ul>
<p>返回值</p>
<p>功能说明</p>
<ul>
<li>设置错误信息和帮助信息的输出方式，默认输出到标准错误</li>
</ul>
<p>示例</p>
<pre><code>package main

import (
	&quot;flag&quot;
	&quot;fmt&quot;
	&quot;os&quot;
)

const (
	defaultUsage = &quot;help message&quot;
)

var (
	myFlagSet = flag.NewFlagSet(&quot;newflagset&quot;, flag.ExitOnError)
	uintFlag  = myFlagSet.Uint(&quot;uintFlag&quot;, 1000, defaultUsage)
	testFlag  = myFlagSet.String(&quot;testFlag&quot;, &quot;default value&quot;, defaultUsage)
	uintVar   uint
)

func init() {
	myFlagSet.UintVar(&amp;uintVar, &quot;uintVar&quot;, 30, defaultUsage)
}

func main() {
	args := []string{
		&quot;-uintFlag&quot;, &quot;24&quot;,
		&quot;-testFlag&quot;, &quot;test&quot;,
		&quot;arg1&quot;,
	}
	myFlagSet.Parse(args)
	if myFlagSet.Parsed() {
		myFlagSet.SetOutput(os.Stderr)
		fmt.Println(&quot;PrintDefaults:&quot;)
		myFlagSet.PrintDefaults()
	}
}
</code></pre>
<p>代码输出</p>
<pre><code>//  ./testflagsetprintdefaults
PrintDefaults:
  -testFlag=&quot;default value&quot;: help message
  -uintFlag=1000: help message
  -uintVar=30: help message
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-f-flagset-stringname-string-value-string-usage-string-string"><a class="header" href="#func-f-flagset-stringname-string-value-string-usage-string-string">func (f *FlagSet) String(name string, value string, usage string) *string</a></h2>
<p>参数列表</p>
<ul>
<li>name string   flag名称</li>
<li>value string 变量默认值</li>
<li>usage string 提示信息</li>
</ul>
<p>返回值</p>
<ul>
<li>*string 返回一个string类型的flag值的地址</li>
</ul>
<p>功能说明</p>
<ul>
<li>为f增加一个带默认值和提示语句的string类型flag，返回对应值的地址</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;flag&quot;
	&quot;fmt&quot;
)

const (
	defaultUsage = &quot;help message&quot;
)

var (
	myFlagSet  = flag.NewFlagSet(&quot;newflagset&quot;, flag.ExitOnError)
	stringFlag = myFlagSet.String(&quot;stringFlag&quot;, &quot;defaultValue&quot;, defaultUsage)
	stringVar  string
)

func init() {
	myFlagSet.StringVar(&amp;stringVar, &quot;stringVar&quot;, &quot;defaultValue&quot;, defaultUsage)
}

func main() {
	args := []string{
		&quot;--stringFlag&quot;, &quot;test string flag&quot;,
		&quot;-stringVar&quot;, &quot;test string&quot;,
		&quot;arg2&quot;,
	}
	myFlagSet.Parse(args)
	fmt.Println(&quot;stringFlag&quot;, *stringFlag)
	fmt.Println(&quot;stringVar&quot;, stringVar)
}
</code></pre>
<p>代码输出</p>
<pre><code>//  ./testflagsetstring 
stringFlag test string flag
stringVar test string
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-f-flagset-stringvarp-string-name-string-value-string-usage-string"><a class="header" href="#func-f-flagset-stringvarp-string-name-string-value-string-usage-string">func (f *FlagSet) StringVar(p *string, name string, value string, usage string)</a></h2>
<p>参数列表</p>
<ul>
<li>p *string 需要与flag参数值绑定的变量地址</li>
<li>name string   flag名称</li>
<li>value string 变量默认值</li>
<li>usage string 提示信息</li>
</ul>
<p>返回值</p>
<p>功能说明</p>
<ul>
<li>将命令行指定flag参数值绑定到string变量</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;flag&quot;
	&quot;fmt&quot;
)

const (
	defaultUsage = &quot;help message&quot;
)

var (
	myFlagSet  = flag.NewFlagSet(&quot;newflagset&quot;, flag.ExitOnError)
	stringFlag = myFlagSet.String(&quot;stringFlag&quot;, &quot;defaultValue&quot;, defaultUsage)
	stringVar  string
)

func init() {
	myFlagSet.StringVar(&amp;stringVar, &quot;stringVar&quot;, &quot;defaultValue&quot;, defaultUsage)
}

func main() {
	args := []string{
		&quot;--stringFlag&quot;, &quot;test string flag&quot;,
		&quot;-stringVar&quot;, &quot;test string&quot;,
		&quot;arg2&quot;,
	}
	myFlagSet.Parse(args)
	fmt.Println(&quot;stringFlag&quot;, *stringFlag)
	fmt.Println(&quot;stringVar&quot;, stringVar)
}
</code></pre>
<p>代码输出</p>
<pre><code>//  ./testflagsetstring 
stringFlag test string flag
stringVar test string
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-f-flagset-uintname-string-value-uint-usage-string-uint"><a class="header" href="#func-f-flagset-uintname-string-value-uint-usage-string-uint">func (f *FlagSet) Uint(name string, value uint, usage string) *uint</a></h2>
<p>参数列表</p>
<ul>
<li>name string   flag名称</li>
<li>value uint 变量默认值</li>
<li>usage string 提示信息</li>
</ul>
<p>返回值</p>
<ul>
<li>*uint 返回一个uint类型的flag值的地址</li>
</ul>
<p>功能说明</p>
<ul>
<li>为flag集合新增一个带默认值和提示语句的uint类型flag，返回对应值的地址</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;flag&quot;
	&quot;fmt&quot;
)

const (
	defaultUsage = &quot;help message&quot;
)

var (
	myFlagSet = flag.NewFlagSet(&quot;newflagset&quot;, flag.ExitOnError)
	uintFlag  = myFlagSet.Uint(&quot;uintFlag&quot;, 1000, defaultUsage)
	uintVar   uint
)

func init() {
	myFlagSet.UintVar(&amp;uintVar, &quot;uintVar&quot;, 30, defaultUsage)
}

func main() {
	args := []string{
		&quot;-uintFlag&quot;, &quot;24&quot;,
		&quot;--uintVar&quot;, &quot;25&quot;,
		&quot;arg2&quot;,
	}
	myFlagSet.Parse(args)
	fmt.Println(&quot;uintFlag&quot;, *uintFlag)
	fmt.Println(&quot;uintVar&quot;, uintVar)
}
</code></pre>
<p>代码输出</p>
<pre><code>//  ./testflagsetuint                         
uintFlag 24
uintVar 25
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-f-flagset-uint64name-string-value-uint64-usage-string-uint64"><a class="header" href="#func-f-flagset-uint64name-string-value-uint64-usage-string-uint64">func (f *FlagSet) Uint64(name string, value uint64, usage string) *uint64</a></h2>
<p>参数列表</p>
<ul>
<li>name string   flag名称</li>
<li>value uint64 变量默认值</li>
<li>usage string 提示信息</li>
</ul>
<p>返回值</p>
<ul>
<li>*uint64 返回一个uint64类型的变量的地址</li>
</ul>
<p>功能说明</p>
<ul>
<li>为flag集合f增加爱一个带默认值和提示语句的uint64类型flag，返回flag对应变量值的地址</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
     &quot;flag&quot;
     &quot;fmt&quot;
)

const (
     defaultUsage = &quot;help message&quot;
)

var (
     myFlagSet  = flag.NewFlagSet(&quot;newflagset&quot;, flag.ExitOnError)
     uint64Flag = myFlagSet.Uint64(&quot;uint64Flag&quot;, 3310000, defaultUsage)
     uint64Var  uint64
)

func init() {
     myFlagSet.Uint64Var(&amp;uint64Var, &quot;uint64Var&quot;, 719200, defaultUsage)
}

func main() {
     args := []string{
          &quot;--uint64Var&quot;, &quot;25&quot;,
          &quot;-uint64Flag&quot;, &quot;1231&quot;,
          &quot;arg2&quot;,
     }
     myFlagSet.Parse(args)
     fmt.Println(&quot;uint64Flag&quot;, *uint64Flag)
     fmt.Println(&quot;uint64Var&quot;, uint64Var)
}
</code></pre>
<p>代码输出</p>
<pre><code> //  ./testflagsetuint64
 uint64Flag 1231
 uint64Var 25</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-f-flagset-uint64varp-uint64-name-string-value-uint64-usage-string"><a class="header" href="#func-f-flagset-uint64varp-uint64-name-string-value-uint64-usage-string">func (f *FlagSet) Uint64Var(p *uint64, name string, value uint64, usage string)</a></h2>
<p>参数列表</p>
<ul>
<li>p *uint64 需要与flag参数值绑定的变量地址</li>
<li>name string  flag名称</li>
<li>value uint64 变量默认值</li>
<li>usage string 提示信息</li>
</ul>
<p>返回值</p>
<p>功能说明</p>
<ul>
<li>将f中指定flag参数值绑定到uint64变量</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
     &quot;flag&quot;
     &quot;fmt&quot;
)

const (
     defaultUsage = &quot;help message&quot;
)

var (
     myFlagSet  = flag.NewFlagSet(&quot;newflagset&quot;, flag.ExitOnError)
     uint64Flag = myFlagSet.Uint64(&quot;uint64Flag&quot;, 3310000, defaultUsage)
     uint64Var  uint64
)

func init() {
     myFlagSet.Uint64Var(&amp;uint64Var, &quot;uint64Var&quot;, 719200, defaultUsage)
}

func main() {
     args := []string{
          &quot;--uint64Var&quot;, &quot;25&quot;,
          &quot;-uint64Flag&quot;, &quot;1231&quot;,
          &quot;arg2&quot;,
     }
     myFlagSet.Parse(args)
     fmt.Println(&quot;uint64Flag&quot;, *uint64Flag)
     fmt.Println(&quot;uint64Var&quot;, uint64Var)
}
</code></pre>
<p>代码输出</p>
<pre><code> //  ./testflagsetuint64
 uint64Flag 1231
 uint64Var 25</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-f-flagset-uintvarp-uint-name-string-value-uint-usage-string"><a class="header" href="#func-f-flagset-uintvarp-uint-name-string-value-uint-usage-string">func (f *FlagSet) UintVar(p *uint, name string, value uint, usage string)</a></h2>
<p>参数列表</p>
<ul>
<li>p *uint 需要与flag参数值绑定的变量地址</li>
<li>name string  flag名称</li>
<li>value uint 变量默认值</li>
<li>usage string 提示信息</li>
</ul>
<p>返回值</p>
<p>功能说明</p>
<ul>
<li>将f中指定flag参数值绑定到uint变量</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;flag&quot;
	&quot;fmt&quot;
)

const (
	defaultUsage = &quot;help message&quot;
)

var (
	myFlagSet = flag.NewFlagSet(&quot;newflagset&quot;, flag.ExitOnError)
	uintFlag  = myFlagSet.Uint(&quot;uintFlag&quot;, 1000, defaultUsage)
	uintVar   uint
)

func init() {
	myFlagSet.UintVar(&amp;uintVar, &quot;uintVar&quot;, 30, defaultUsage)
}

func main() {
	args := []string{
		&quot;-uintFlag&quot;, &quot;24&quot;,
		&quot;--uintVar&quot;, &quot;25&quot;,
		&quot;arg2&quot;,
	}
	myFlagSet.Parse(args)
	fmt.Println(&quot;uintFlag&quot;, *uintFlag)
	fmt.Println(&quot;uintVar&quot;, uintVar)
}
</code></pre>
<p>代码输出</p>
<pre><code>//  ./testflagsetuint                         
uintFlag 24
uintVar 25
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-f-flagset-varvalue-value-name-string-usage-string"><a class="header" href="#func-f-flagset-varvalue-value-name-string-usage-string">func (f *FlagSet) Var(value Value, name string, usage string)</a></h2>
<p>参数列表</p>
<ul>
<li>value Value   需要绑定的变量的名称</li>
<li>name string 变量默认值</li>
<li>usage string 提示信息</li>
</ul>
<p>返回值</p>
<p>功能说明</p>
<ul>
<li>将flag绑定到自定义变量上，自定义变量需要实现Value接口</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;errors&quot;
	&quot;flag&quot;
	&quot;fmt&quot;
	&quot;strings&quot;
	&quot;time&quot;
)

const (
	defaultUsage = &quot;help message&quot;
)

type interval []time.Duration

//实现String接口
func (i *interval) String() string {
	return fmt.Sprintf(&quot;%v&quot;, *i)
}

//实现Set接口,Set接口决定了如何解析flag的值
func (i *interval) Set(value string) error {
	//此处决定命令行是否可以设置多次-deltaT
	if len(*i) &gt; 0 {
		return errors.New(&quot;interval flag already set&quot;)
	}
	for _, dt := range strings.Split(value, &quot;,&quot;) {
		duration, err := time.ParseDuration(dt)
		if err != nil {
			return err
		}
		*i = append(*i, duration)
	}
	return nil
}

var (
	intervalFlag interval
	myFlagSet    = flag.NewFlagSet(&quot;newflagset&quot;, flag.ExitOnError)
)

func init() {
	myFlagSet.Var(&amp;intervalFlag, &quot;deltaT&quot;, &quot;comma-separated list of intervals to use between events&quot;)
}

func main() {
	myFlagSet.Parse([]string{&quot;-deltaT&quot;, &quot;61m,72h,80s&quot;})
	fmt.Println(intervalFlag)
}
</code></pre>
<p>运行结果</p>
<pre><code>//  ./testflagsetvar                        
[1h1m0s 72h0m0s 1m20s]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-f-flagset-visitfn-funcflag"><a class="header" href="#func-f-flagset-visitfn-funcflag">func (f *FlagSet) Visit(fn func(*Flag))</a></h2>
<p>参数列表</p>
<ul>
<li>fn func(*Flag)  函数</li>
</ul>
<p>返回值</p>
<p>功能说明</p>
<ul>
<li>按照字典顺序遍历所有已设置的flag参数，对每个参数调用fn方法</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;flag&quot;
	&quot;fmt&quot;
)

const (
	defaultUsage = &quot;help message&quot;
)

var (
	myFlagSet   = flag.NewFlagSet(&quot;newflagset&quot;, flag.ExitOnError)
	uintFlag    = myFlagSet.Uint(&quot;uintFlag&quot;, 1000, defaultUsage)
	testFlag    = myFlagSet.String(&quot;testFlag&quot;, &quot;default value&quot;, defaultUsage)
	float64Flag = myFlagSet.Float64(&quot;float64Flag&quot;, 0.9917, defaultUsage)
	uintVar     uint
)

func print(f *flag.Flag) {
	fmt.Println(&quot;	&quot;, f.Name, f.Value)
}

func main() {
	args := []string{
		&quot;-uintFlag&quot;, &quot;24&quot;,
		&quot;-float64Flag&quot;, &quot;2718e28&quot;,
		&quot;arg1&quot;,
	}
	myFlagSet.Parse(args)
	fmt.Println(&quot;Visit:&quot;)
	myFlagSet.Visit(print)
	fmt.Println(&quot;VisitAll:&quot;)
	myFlagSet.VisitAll(print)
}
</code></pre>
<p>运行结果</p>
<pre><code>//  ./testflagsetvisit 
Visit:
	 float64Flag 2.718e+31
	 uintFlag 24
VisitAll:
	 float64Flag 2.718e+31
	 testFlag default value
	 uintFlag 24
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-f-flagset-visitallfn-funcflag"><a class="header" href="#func-f-flagset-visitallfn-funcflag">func (f *FlagSet) VisitAll(fn func(*Flag))</a></h2>
<p>参数列表</p>
<ul>
<li>fn func(*Flag)  函数</li>
</ul>
<p>返回值</p>
<p>功能说明</p>
<ul>
<li>按照字典顺序遍历所有已定义的flag参数(不管是否已设置)，对每个参数调用fn方法</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;flag&quot;
	&quot;fmt&quot;
)

const (
	defaultUsage = &quot;help message&quot;
)

var (
	myFlagSet   = flag.NewFlagSet(&quot;newflagset&quot;, flag.ExitOnError)
	uintFlag    = myFlagSet.Uint(&quot;uintFlag&quot;, 1000, defaultUsage)
	testFlag    = myFlagSet.String(&quot;testFlag&quot;, &quot;default value&quot;, defaultUsage)
	float64Flag = myFlagSet.Float64(&quot;float64Flag&quot;, 0.9917, defaultUsage)
	uintVar     uint
)

func print(f *flag.Flag) {
	fmt.Println(&quot;	&quot;, f.Name, f.Value)
}

func main() {
	args := []string{
		&quot;-uintFlag&quot;, &quot;24&quot;,
		&quot;-float64Flag&quot;, &quot;2718e28&quot;,
		&quot;arg1&quot;,
	}
	myFlagSet.Parse(args)
	fmt.Println(&quot;Visit:&quot;)
	myFlagSet.Visit(print)
	fmt.Println(&quot;VisitAll:&quot;)
	myFlagSet.VisitAll(print)
}
</code></pre>
<p>运行结果</p>
<pre><code>//  ./testflagsetvisit 
Visit:
	 float64Flag 2.718e+31
	 uintFlag 24
VisitAll:
	 float64Flag 2.718e+31
	 testFlag default value
	 uintFlag 24
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-float64name-string-value-float64-usage-string-float64"><a class="header" href="#func-float64name-string-value-float64-usage-string-float64">func Float64(name string, value float64, usage string) *float64</a></h2>
<p>参数列表</p>
<ul>
<li>name string flag名称</li>
<li>value float64 默认值</li>
<li>usage string 提示信息</li>
</ul>
<p>返回值</p>
<ul>
<li>*float64 返回一个float64类型的flag值的地址</li>
</ul>
<p>功能说明</p>
<ul>
<li>定义一个带默认值和语句的float64类型的flag，返回flag对应值的地址</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;flag&quot;
	&quot;fmt&quot;
)

var float64Flag = flag.Float64(&quot;float64&quot;, 123.4, &quot;help message for float64&quot;)

func main() {
	flag.Parse()
	fmt.Println(&quot;float64Flag: &quot;, *float64Flag)
}
</code></pre>
<p>代码输出</p>
<pre><code>//  ./testfloat64 
float64Flag:  123.4

//  ./testfloat64 -float64 1230.6
float64Flag:  1230.6

//  ./testfloat64 -float64=0.123
float64Flag:  0.123
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-float64varp-float64-name-string-value-float64-usage-string"><a class="header" href="#func-float64varp-float64-name-string-value-float64-usage-string">func Float64Var(p *float64, name string, value float64, usage string)</a></h2>
<p>参数列表</p>
<ul>
<li>p *float64 需要与flag参数值绑定的变量地址</li>
<li>name string   flag名称</li>
<li>value float64 变量默认值</li>
<li>usage string 提示信息</li>
</ul>
<p>返回值</p>
<p>功能说明</p>
<ul>
<li>将命令行指定flag参数值绑定到float64变量</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
    &quot;flag&quot;
    &quot;fmt&quot;
)

var float64Var float64

func init() {
    flag.Float64Var(&amp;float64Var, &quot;float64&quot;, 123.4, &quot;help message for float64&quot;)
}

func main() {
    flag.Parse()
    fmt.Println(&quot;float64Flag:&quot;, float64Var)
}
</code></pre>
<p>代码输出</p>
<pre><code>//  ./testfloat64var 
float64Flag: 123.4

//  ./testfloat64var -float64 12345
float64Flag: 12345

//  ./testfloat64var -float64=1231.1
float64Flag: 1231.1

//  ./testfloat64 -float64
flag needs an argument: -float64
Usage of ./testfloat64:
  -float64=123.4: help message for float64</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-intname-string-value-int-usage-string-int"><a class="header" href="#func-intname-string-value-int-usage-string-int">func Int(name string, value int, usage string) *int</a></h2>
<p>参数列表</p>
<ul>
<li>name string   flag名称</li>
<li>value int 变量默认值</li>
<li>usage string 提示信息</li>
</ul>
<p>返回值</p>
<ul>
<li>*int 返回一个int类型的flag值的地址</li>
</ul>
<p>功能说明</p>
<ul>
<li>定义一个带默认值和提示语句的int类型flag，返回对应值的地址</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;flag&quot;
	&quot;fmt&quot;
)

var intFlag = flag.Int(&quot;int&quot;, 100, &quot;help message for int&quot;)

func main() {
	flag.Parse()
	fmt.Println(&quot;intFlag: &quot;, *intFlag)
}
</code></pre>
<p>代码输出</p>
<pre><code>./testint 
intFlag:  100

./testint -int
flag needs an argument: -int
Usage of ./testint:
  -int=100: help message for int
  
./testint -int=1000
intFlag:  1000

./testint -int -10000
intFlag:  -10000
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-int64name-string-value-int64-usage-string-int64"><a class="header" href="#func-int64name-string-value-int64-usage-string-int64">func Int64(name string, value int64, usage string) *int64</a></h2>
<p>参数列表</p>
<ul>
<li>name string   flag名称</li>
<li>value int64 变量默认值</li>
<li>usage string 提示信息</li>
</ul>
<p>返回值</p>
<ul>
<li>*int64 返回一个int64类型的flag值的地址</li>
</ul>
<p>功能说明</p>
<ul>
<li>定义一个带默认值和提示语句的int64类型flag，返回对应值的地址</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
    &quot;flag&quot;
    &quot;fmt&quot;
)

var int64Flag = flag.Int64(&quot;int64&quot;, int64(100), &quot;help message for int64&quot;)

func main() {
    flag.Parse()
    fmt.Println(&quot;intFlag: &quot;, *int64Flag)
}
</code></pre>
<p>代码输出</p>
<pre><code> ./testint64
intFlag:  100

//  ./testint64 -int64 111111111111
intFlag:  111111111111

//  ./testint64 -int64=-123123121231
intFlag:  -123123121231

//  ./testint64 -int64              
flag needs an argument: -int64
Usage of ./testint64:
  -int64=100: help message for int64
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-int64varp-int64-name-string-value-int64-usage-string"><a class="header" href="#func-int64varp-int64-name-string-value-int64-usage-string">func Int64Var(p *int64, name string, value int64, usage string)</a></h2>
<p>参数列表</p>
<ul>
<li>p *int64 需要与flag参数值绑定的变量地址</li>
<li>name string  flag名称</li>
<li>value int64 变量默认值</li>
<li>usage string 提示信息</li>
</ul>
<p>返回值</p>
<p>功能说明</p>
<ul>
<li>将指定flag参数值绑定到int64变量</li>
</ul>
<p>示例</p>
<pre><code>package main

import (
	&quot;flag&quot;
	&quot;fmt&quot;
)

var int64Flag int64

func init() {
	flag.Int64Var(&amp;int64Flag, &quot;int64&quot;, 123, &quot;help message for int64&quot;)
}

func main() {
	flag.Parse()
	fmt.Println(&quot;int64Flag:&quot;, int64Flag)
}
</code></pre>
<p>代码输出</p>
<pre><code>//  ./testint64var 
int64Flag: 123

//  ./testint64var -int64
flag needs an argument: -int64
Usage of ./testint64var:
  -int64=123: help message for int64

//  ./testint64var -int64=12312312
int64Flag: 12312312

//  ./testint64var -int64 12312312
int64Flag: 12312312
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-intvarp-int-name-string-value-int-usage-string"><a class="header" href="#func-intvarp-int-name-string-value-int-usage-string">func IntVar(p *int, name string, value int, usage string)</a></h2>
<p>参数列表</p>
<ul>
<li>p *int 需要与flag参数值绑定的变量地址</li>
<li>name string  flag名称</li>
<li>value int 变量默认值</li>
<li>usage string 提示信息</li>
</ul>
<p>返回值</p>
<p>功能说明</p>
<ul>
<li>将命令行指定flag参数值绑定到int变量</li>
</ul>
<p>示例</p>
<pre><code>package main

import (
	&quot;flag&quot;
	&quot;fmt&quot;
)

var intFlag int

func init() {
	flag.IntVar(&amp;intFlag, &quot;int&quot;, 123, &quot;help message for int&quot;)
}

func main() {
	flag.Parse()
	fmt.Println(&quot;intFlag:&quot;, intFlag)
}
</code></pre>
<p>代码输出</p>
<pre><code>//  ./testintvar 
intFlag: 123

// ./testintvar -int 456
intFlag: 456

// ./testintvar -int=456
intFlag: 456

// ./testintvar -int    
flag needs an argument: -int
Usage of ./testintvar:
  -int=123: help message for int
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-lookupname-string-flag"><a class="header" href="#func-lookupname-string-flag">func Lookup(name string) *Flag</a></h2>
<p>参数列表</p>
<ul>
<li>name string  flag名称</li>
</ul>
<p>返回值</p>
<ul>
<li>*Flag Flag指针</li>
</ul>
<p>功能说明</p>
<ul>
<li>获取flag集合中名称为name值的flag指针，如果对应的flag不存在，返回nil</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;flag&quot;
	&quot;fmt&quot;
)

var testFlag = flag.String(&quot;test&quot;, &quot;default value&quot;, &quot;help message.&quot;)

func print(f *flag.Flag) {
	if f != nil {
		fmt.Println(f.Value)
	} else {
		fmt.Println(nil)
	}
}

func main() {
	fmt.Print(&quot;test:&quot;)
	print(flag.Lookup(&quot;test&quot;))
	fmt.Print(&quot;test1:&quot;)
	print(flag.Lookup(&quot;test1&quot;))
	flag.Parse()
	fmt.Print(&quot;test:&quot;)
	print(flag.Lookup(&quot;test&quot;))
	fmt.Print(&quot;test1:&quot;)
	print(flag.Lookup(&quot;test1&quot;))
}
</code></pre>
<p>运行结果</p>
<pre><code>//  ./testlookup -test &quot;12345&quot;      
test:default value
test1:&lt;nil&gt;
test:12345
test1:&lt;nil&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-narg-int"><a class="header" href="#func-narg-int">func NArg() int</a></h2>
<p>参数列表</p>
<p>返回值</p>
<ul>
<li>int 返回解析后剩余的参数的数量</li>
</ul>
<p>功能说明</p>
<ul>
<li>获取命令行参数解析后剩余的参数的数量，即flag.Args()返回的值的元素个数</li>
</ul>
<p>示例</p>
<pre><code>package main

import (
    &quot;flag&quot;
    &quot;fmt&quot;
)

var test_flag = flag.String(&quot;flag&quot;, &quot;test&quot;, &quot;help message for flag&quot;)

func main() {
    flag.Parse()
    fmt.Println(&quot;test_flag:&quot;, *test_flag)
    fmt.Println(&quot;Args:&quot;, flag.Args())
    fmt.Println(&quot;Narg&quot;, flag.NArg())
}
</code></pre>
<p>代码输出</p>
<pre><code>./testnarg
test_flag: test
Args: []
Narg 0

//  ./testnarg asd
test_flag: test
Args: [asd]
Narg 1

//  ./testnarg -flag 123
test_flag: 123
Args: []
Narg 0

//  ./testnarg -flag 123 456 678 111
test_flag: 123
Args: [456 678 111]
Narg 3
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-newflagsetname-string-errorhandling-errorhandling-flagset"><a class="header" href="#func-newflagsetname-string-errorhandling-errorhandling-flagset">func NewFlagSet(name string, errorHandling ErrorHandling) *FlagSet</a></h2>
<p>参数列表</p>
<ul>
<li>name string   flagset的名称</li>
<li>errorHandling ErrorHandling flagset的错误处理方式，包括<code>ContinueOnError</code>:出错仍继续, <code>ExitOnError</code>:出错后退出程序,<code>PanicOnError</code>:出错后panic三种错误处理方式</li>
</ul>
<p>返回值</p>
<ul>
<li>*FlagSet Flagset指针</li>
</ul>
<p>功能说明</p>
<ul>
<li>获取一个指定名称和错误处理方式的空FlagSet</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
    &quot;flag&quot;
    &quot;fmt&quot;
)

func main() {
    var myFlagSet = flag.NewFlagSet(&quot;myFlagSet&quot;, flag.ExitOnError)
    fmt.Println(myFlagSet)
}
</code></pre>
<p>执行结果</p>
<pre><code>//  ./testnewflagset 
&amp;{&lt;nil&gt; myFlagSet false map[] map[] [] 1 ?reflect.Value?}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-nflag-int"><a class="header" href="#func-nflag-int">func NFlag() int</a></h2>
<p>参数列表</p>
<p>返回值</p>
<ul>
<li>int 返回命令行参数里已解析到的flag个数</li>
</ul>
<p>功能说明</p>
<ul>
<li>获取命令行参数里解析成功的flag个数</li>
</ul>
<p>示例</p>
<pre><code>package main

import (
	&quot;flag&quot;
	&quot;fmt&quot;
)

var stringFlag = flag.String(&quot;abc&quot;, &quot;default&quot;, &quot;help message&quot;)
var intFlag = flag.Int(&quot;int&quot;, 123, &quot;help message&quot;)

var m float64

func init() {
	flag.Float64Var(&amp;m, &quot;float&quot;, 12.3, &quot;help message&quot;)
}

func main() {
	fmt.Println(&quot;before parse:&quot;, flag.NFlag())
	flag.Parse()
	fmt.Println(&quot;after parse&quot;, flag.NFlag())
}
</code></pre>
<p>代码输出</p>
<pre><code>//  ./testnflag -abc 123 -int 0
before parse: 0
after parse 2
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-parse"><a class="header" href="#func-parse">func Parse()</a></h2>
<p>参数列表</p>
<p>返回值</p>
<p>功能说明</p>
<ul>
<li>从os.Args[1:]中依次解析flag.在定义flag之后，必须调用用本函数才能成功获取命令行flag的值 </li>
</ul>
<p>示例</p>
<pre><code>package main

import (
    &quot;flag&quot;
    &quot;fmt&quot;
)

var stringFlag = flag.String(&quot;test&quot;, &quot;test&quot;, &quot;help message.&quot;)
var intFlag = flag.Int(&quot;int&quot;, 10, &quot;help message&quot;)

func main() {
    fmt.Println(&quot;before parse:&quot;, *stringFlag)
    fmt.Println(&quot;before parse:&quot;, *intFlag)
    flag.Parse()
    fmt.Println(&quot;after parse:&quot;, *stringFlag)
    fmt.Println(&quot;after parse:&quot;, *intFlag)
}
</code></pre>
<p>代码输出</p>
<pre><code>//  ./testparse -test &quot;good&quot; -int 100
before parse: test
before parse: 10
after parse: good
after parse: 100
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-parsed-bool"><a class="header" href="#func-parsed-bool">func Parsed() bool</a></h2>
<p>参数列表</p>
<p>返回值</p>
<ul>
<li>若命令行flag参数已解析(已调用flag.Parse()方法)，返回true</li>
</ul>
<p>功能说明</p>
<ul>
<li>判断命令行flag参数是否已经解析(即调用flag.Parse()方法)，若已解析返回true</li>
</ul>
<p>示例</p>
<pre><code>package main

import (
	&quot;flag&quot;
	&quot;fmt&quot;
)

var stringFlag = flag.String(&quot;test&quot;, &quot;test&quot;, &quot;help message.&quot;)
var intFlag = flag.Int(&quot;int&quot;, 10, &quot;help message&quot;)

func main() {
	if flag.Parsed() {
		fmt.Println(&quot;before parse:&quot;, *stringFlag)
		fmt.Println(&quot;before parse:&quot;, *intFlag)

	}
	flag.Parse()
	if flag.Parsed() {
		fmt.Println(&quot;after parse:&quot;, *stringFlag)
		fmt.Println(&quot;after parse:&quot;, *intFlag)
	}
}
</code></pre>
<p>代码输出</p>
<pre><code>./testparsed -test abc
after parse: abc
after parse: 10
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-printdefaults"><a class="header" href="#func-printdefaults">func PrintDefaults()</a></h2>
<p>参数列表</p>
<p>返回值</p>
<p>功能说明</p>
<ul>
<li>将所有已定义flag的默认值输出到标准错误，默认值包括默认值，默认错误提示等。</li>
</ul>
<p>示例</p>
<pre><code>package main

import (
	&quot;flag&quot;
)

var stringFlag = flag.String(&quot;test&quot;, &quot;test&quot;, &quot;help message.&quot;)
var intFlag = flag.Int(&quot;int&quot;, 10, &quot;help message&quot;)

func main() {
	flag.PrintDefaults()
}
</code></pre>
<p>代码输出</p>
<pre><code>//  ./testprintdefaults        
-int=10: help message
-test=&quot;test&quot;: help message.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-setname-value-string-error"><a class="header" href="#func-setname-value-string-error">func Set(name, value string) error</a></h2>
<p>参数列表</p>
<ul>
<li>name string flag 名称</li>
<li>value string flag 值</li>
</ul>
<p>返回值</p>
<ul>
<li>error 设置成功返回nil</li>
</ul>
<p>功能说明</p>
<ul>
<li>将名称为name的flag的值设置为value, 成功返回nil</li>
</ul>
<p>示例</p>
<pre><code>package main

import (
	&quot;flag&quot;
	&quot;fmt&quot;
)

var stringFlag = flag.String(&quot;test&quot;, &quot;test&quot;, &quot;help message.&quot;)
var intFlag = flag.Int(&quot;int&quot;, 10, &quot;help message&quot;)

func main() {
	flag.Parse()
	fmt.Println(&quot;stringFlag:&quot;, *stringFlag)
	fmt.Println(&quot;inFlag&quot;, *intFlag)
	fmt.Println(&quot;After Set.&quot;)
	flag.Set(&quot;test&quot;, &quot;set_test&quot;)
	flag.Set(&quot;int&quot;, &quot;9999&quot;)
	fmt.Println(&quot;stringFlag:&quot;, *stringFlag)
	fmt.Println(&quot;inFlag:&quot;, *intFlag)
}
</code></pre>
<p>代码输出</p>
<pre><code>//  ./testset -test &quot;before set&quot; -int 1
stringFlag: before set
inFlag: 1
After Set.
stringFlag: set_test
inFlag: 9999
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-stringname-string-value-string-usage-string-string"><a class="header" href="#func-stringname-string-value-string-usage-string-string">func String(name string, value string, usage string) *string</a></h2>
<p>参数列表</p>
<ul>
<li>name string   flag名称</li>
<li>value string 变量默认值</li>
<li>usage string 提示信息</li>
</ul>
<p>返回值</p>
<ul>
<li>*string 返回一个string类型的flag值的地址</li>
</ul>
<p>功能说明</p>
<ul>
<li>定义一个带默认值和提示语句的string类型flag，返回对应值的地址</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;flag&quot;
	&quot;fmt&quot;
)

var stringFlag = flag.String(&quot;string&quot;, &quot;default value&quot;, &quot;help message for int&quot;)

func main() {
	flag.Parse()
	fmt.Println(&quot;stringFlag: &quot;, *stringFlag)
}
</code></pre>
<p>代码输出</p>
<pre><code>//  ./teststring 
stringFlag:  default value

//  ./teststring -string
flag needs an argument: -string
Usage of ./teststring:
  -string=&quot;default value&quot;: help message for int

//  ./teststring -string=123
stringFlag:  123

//  ./teststring -string 123
stringFlag:  123
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-stringvarp-string-name-string-value-string-usage-string"><a class="header" href="#func-stringvarp-string-name-string-value-string-usage-string">func StringVar(p *string, name string, value string, usage string)</a></h2>
<p>参数列表</p>
<ul>
<li>p *string 需要与flag参数值绑定的变量地址</li>
<li>name string   flag名称</li>
<li>value string 变量默认值</li>
<li>usage string 提示信息</li>
</ul>
<p>返回值</p>
<p>功能说明</p>
<ul>
<li>将命令行指定flag参数值绑定到string变量</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;flag&quot;
	&quot;fmt&quot;
)

var stringFlag string

func init() {
	flag.StringVar(&amp;stringFlag, &quot;flag&quot;, &quot;default value&quot;, &quot;help message for flag&quot;)
}

func main() {
	flag.Parse()
	fmt.Println(&quot;flag: &quot;, stringFlag)
}
</code></pre>
<p>代码输出</p>
<pre><code>//  ./teststringvar 
flag:  default value

//  ./teststringvar -flag    
flag needs an argument: -flag
Usage of ./teststringvar:
  -flag=&quot;default value&quot;: help message for flag

// ./teststringvar -flag=12
flag:  12

// ./teststringvar -flag 22
flag:  22
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-uintname-string-value-uint-usage-string-uint"><a class="header" href="#func-uintname-string-value-uint-usage-string-uint">func Uint(name string, value uint, usage string) *uint</a></h2>
<p>参数列表</p>
<ul>
<li>name string   flag名称</li>
<li>value uint 变量默认值</li>
<li>usage string 提示信息</li>
</ul>
<p>返回值</p>
<ul>
<li>*uint 返回一个uint类型的flag值的地址</li>
</ul>
<p>功能说明</p>
<ul>
<li>定义一个带默认值和提示语句的uint类型flag，返回对应值的地址</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;flag&quot;
	&quot;fmt&quot;
)

var uintFlag = flag.Uint(&quot;uint&quot;, 100, &quot;help message for uint&quot;)

func main() {
	flag.Parse()
	fmt.Println(&quot;uintFlag: &quot;, *uintFlag)
}
</code></pre>
<p>代码输出</p>
<p>//  ./testuint
uintFlag:  100</p>
<p>// ./testuint -uint 100
uintFlag:  100</p>
<p>// ./testuint -uint=100
uintFlag:  100</p>
<p>// ./testuint -uint<br />
flag needs an argument: -uint
Usage of ./testuint:
-uint=100: help message for uint</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-uint64name-string-value-uint64-usage-string-uint64"><a class="header" href="#func-uint64name-string-value-uint64-usage-string-uint64">func Uint64(name string, value uint64, usage string) *uint64</a></h2>
<p>参数列表</p>
<ul>
<li>name string   flag名称</li>
<li>value uint64 变量默认值</li>
<li>usage string 提示信息</li>
</ul>
<p>返回值</p>
<ul>
<li>*uint64 返回一个uint64类型的flag值的地址</li>
</ul>
<p>功能说明</p>
<ul>
<li>定义一个带默认值和提示语句的uint64类型flag，返回对应值的地址</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;flag&quot;
	&quot;fmt&quot;
)

var uint64Flag = flag.Uint64(&quot;uint64&quot;, 100, &quot;help message for uint&quot;)

func main() {
	flag.Parse()
	fmt.Println(&quot;uint64Flag: &quot;, *uint64Flag)
}
</code></pre>
<p>代码输出</p>
<p>//  ./testuint64<br />
uint64Flag:  100</p>
<p>//  ./testuint64 -uint64<br />
flag needs an argument: -uint64
Usage of ./testuint64:
-uint64=100: help message for uint</p>
<p>//  ./testuint64 -uint64 1231312<br />
uint64Flag:  1231312</p>
<p>//  ./testuint64 -uint64=1231312<br />
uint64Flag:  1231312</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-uint64varp-uint64-name-string-value-uint64-usage-string"><a class="header" href="#func-uint64varp-uint64-name-string-value-uint64-usage-string">func Uint64Var(p *uint64, name string, value uint64, usage string)</a></h2>
<p>参数列表</p>
<ul>
<li>p *uint64 需要与flag参数值绑定的变量地址</li>
<li>name string  flag名称</li>
<li>value uint64 变量默认值</li>
<li>usage string 提示信息</li>
</ul>
<p>返回值</p>
<p>功能说明</p>
<ul>
<li>将命令行指定flag参数值绑定到uint64变量</li>
</ul>
<p>示例</p>
<pre><code>package main

import (
	&quot;flag&quot;
	&quot;fmt&quot;
)

var uint64varFlag uint64

func init() {
	flag.Uint64Var(&amp;uint64varFlag, &quot;flag&quot;, 123, &quot;help message for uint64var&quot;)
}

func main() {
	flag.Parse()
	fmt.Println(&quot;uint64varFlag:&quot;, uint64varFlag)
}
</code></pre>
<p>代码输出</p>
<pre><code>//./testuint64var 
uint64varFlag: 123

//  ./testuint64var -flag 
flag needs an argument: -flag
Usage of ./testuint64var:
  -flag=123: help message for uint64var

//  ./testuint64var -flag 1234
uint64varFlag: 1234

//  ./testuint64var -flag=11234  
uint64varFlag: 11234
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-uintvarp-uint-name-string-value-uint-usage-string"><a class="header" href="#func-uintvarp-uint-name-string-value-uint-usage-string">func UintVar(p *uint, name string, value uint, usage string)</a></h2>
<p>参数列表</p>
<ul>
<li>p *uint 需要与flag参数值绑定的变量地址</li>
<li>name string  flag名称</li>
<li>value uint 变量默认值</li>
<li>usage string 提示信息</li>
</ul>
<p>返回值</p>
<p>功能说明</p>
<ul>
<li>将命令行指定flag参数值绑定到uint变量</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;flag&quot;
	&quot;fmt&quot;
)

var uintvarFlag uint

func init() {
	flag.UintVar(&amp;uintvarFlag, &quot;flag&quot;, 123, &quot;help message for uintvar&quot;)
}

func main() {
	flag.Parse()
	fmt.Println(&quot;uintvarFlag:&quot;, uintvarFlag)
}
</code></pre>
<p>代码输出</p>
<pre><code>//./testuintvar 
uintvarFlag: 123

// ./testuintvar -flag  
flag needs an argument: -flag
Usage of ./testuintvar:
  -flag=123: help message for uintvar

// ./testuintvar -flag 456
uintvarFlag: 456

// ./testuintvar -flag=456
uintvarFlag: 456
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-varvalue-value-name-string-usage-string"><a class="header" href="#func-varvalue-value-name-string-usage-string">func Var(value Value, name string, usage string)</a></h2>
<p>参数列表</p>
<ul>
<li>value Value   需要绑定的变量的名称</li>
<li>name string 变量默认值</li>
<li>usage string 提示信息</li>
</ul>
<p>返回值</p>
<p>功能说明</p>
<ul>
<li>将flag绑定到自定义变量上，自定义变量需要实现Value接口</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;errors&quot;
	&quot;flag&quot;
	&quot;fmt&quot;
	&quot;strings&quot;
	&quot;time&quot;
)

type interval []time.Duration

//实现String接口
func (i *interval) String() string {
	return fmt.Sprintf(&quot;%v&quot;, *i)
}

//实现Set接口,Set接口决定了如何解析flag的值
func (i *interval) Set(value string) error {
	//此处决定命令行是否可以设置多次-deltaT
	if len(*i) &gt; 0 {
		return errors.New(&quot;interval flag already set&quot;)
	}
	for _, dt := range strings.Split(value, &quot;,&quot;) {
		duration, err := time.ParseDuration(dt)
		if err != nil {
			return err
		}
		*i = append(*i, duration)
	}
	return nil
}

var intervalFlag interval

func init() {
	flag.Var(&amp;intervalFlag, &quot;deltaT&quot;, &quot;comma-separated list of intervals to use between events&quot;)
}

func main() {
	flag.Parse()
	fmt.Println(intervalFlag)
}
</code></pre>
<p>运行结果</p>
<pre><code>//./testvar -deltaT 61m,72h,80s
[1h1m0s 72h0m0s 1m20s]</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-visitfn-funcflag"><a class="header" href="#func-visitfn-funcflag">func Visit(fn func(*Flag))</a></h2>
<p>参数列表</p>
<ul>
<li>fn func(*Flag)  函数</li>
</ul>
<p>返回值</p>
<p>功能说明</p>
<ul>
<li>按照字典顺序遍历所有命令行已设置的flag参数(只定义了但未在命令行被设置的flag不会被遍历)，对每个参数调用fn方法</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;flag&quot;
	&quot;fmt&quot;
)

var stringFlag = flag.String(&quot;string&quot;, &quot;string&quot;, &quot;help message for string&quot;)
var intFlag = flag.Int(&quot;int&quot;, 100, &quot;help message for int&quot;)
var boolFlag = flag.Bool(&quot;bool&quot;, false, &quot;help message for bool&quot;)
var testFlag = flag.String(&quot;test&quot;, &quot;test&quot;, &quot;help message for test&quot;)

func print(f *flag.Flag) {
	fmt.Println(f.Name, f.Value)
}

func main() {
	flag.Parse()
	flag.Visit(print)
}
</code></pre>
<p>运行结果</p>
<pre><code>//  ./testvisit -string &quot;teststring&quot; -int -90 
int -90
string teststring
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-visitallfn-funcflag"><a class="header" href="#func-visitallfn-funcflag">func VisitAll(fn func(*Flag))</a></h2>
<p>参数列表</p>
<ul>
<li>fn func(*Flag)  函数</li>
</ul>
<p>返回值</p>
<p>功能说明</p>
<ul>
<li>按照字典顺序遍历所有已定义的flag参数(不管是否在命令行中设置)，对每个参数调用fn方法</li>
</ul>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;flag&quot;
	&quot;fmt&quot;
)

var stringFlag = flag.String(&quot;string&quot;, &quot;string&quot;, &quot;help message for string&quot;)
var intFlag = flag.Int(&quot;int&quot;, 100, &quot;help message for int&quot;)
var boolFlag = flag.Bool(&quot;bool&quot;, false, &quot;help message for bool&quot;)
var testFlag = flag.String(&quot;test&quot;, &quot;test&quot;, &quot;help message for test&quot;)

func print(f *flag.Flag) {
	fmt.Println(f.Name, f.Value)
}

func main() {
	flag.Parse()
	flag.VisitAll(print)
}
</code></pre>
<p>运行结果</p>
<pre><code>//  ./testvisitall -string &quot;teststring&quot; -int 999
bool false
int 999
string teststring
test test
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fmt-包函数列表"><a class="header" href="#fmt-包函数列表">fmt 包函数列表</a></h1>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/fmt/Printf.html">func Printf(format string, a ...interface{}) (n int, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/fmt/Print.html">func Print(a ...interface{}) (n int, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/fmt/Println.html">func Println(a ...interface{}) (n int, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/fmt/Sprintf.html">func Sprintf(format string, a ...interface{}) string</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/fmt/Sprint.html">func Sprint(a ...interface{}) string</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/fmt/Sprintln.html">func Sprintln(a ...interface{}) string</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/fmt/Fprintf.html">func Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/fmt/Fprint.html">func Fprint(w io.Writer, a ...interface{}) (n int, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/fmt/Fprintln.html">func Fprintln(w io.Writer, a ...interface{}) (n int, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/fmt/Scanf.html">func Scanf(format string, a ...interface{}) (n int, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/fmt/Scan.html">func Scan(a ...interface{}) (n int, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/fmt/Scanln.html">func Scanln(a ...interface{}) (n int, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/fmt/Sscanf.html">func Sscanf(str string, format string, a ...interface{}) (n int, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/fmt/Sscan.html">func Sscan(str string, a ...interface{}) (n int, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/fmt/Sscanln.html">func Sscanln(str string, a ...interface{}) (n int, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/fmt/Fscanf.html">func Fscanf(r io.Reader, format string, a ...interface{}) (n int, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/fmt/Fscan.html">func Fscan(r io.Reader, a ...interface{}) (n int, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/fmt/Fscanln.html">func Fscanln(r io.Reader, a ...interface{}) (n int, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/fmt/Errorf.html">func Errorf(format string, a ...interface{}) error</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/fmt/FormatDoc.html">FormatDoc</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-errorfformat-string-a-interface-error"><a class="header" href="#func-errorfformat-string-a-interface-error">func Errorf(format string, a ...interface{}) error</a></h1>
<p>参数列表</p>
<ul>
<li>format 打印的格式说明 </li>
<li>a... 值变量列表</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回error</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是用来根据格式字符串和参数表生成一个字符串，该字符串满足error接口</p>
<p>代码实例：</p>
<pre><code>package main

import &quot;fmt&quot;

func main() {
	fmt.Errorf(&quot;Error:%s\n&quot;,&quot;Test error!&quot;)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="package-fmt"><a class="header" href="#package-fmt">package fmt</a></h1>
<h2 id="package-中的-format-说明"><a class="header" href="#package-中的-format-说明">package 中的 format 说明</a></h2>
<p><code>import &quot;fmt&quot;</code></p>
<p>Go 语言中的fmt包含有格式化输入输出的函数，类似于C语言的printf和scanf。格式字符串的规则来源于C但更简单更好用。</p>
<p>在 fmt 包中，有三种标准输出的打印语句：</p>
<blockquote>
<p>Printf 可以给定输出格式的打印语句</p>
<ul>
<li>
<p>Printf(&quot;格式化串定义&quot;,变量列表)</p>
</li>
<li>
<p>格式化串定义：即format字符串</p>
</li>
<li>
<p>变量列表: 可以是任意类型的值变量列表，系统实现的是一通用接口函数</p>
</li>
</ul>
<p>Print 这个函数不需要format字符串，等价于对每一个参数设置为%v</p>
<p>Println 等价于Print语句，但输出时会在参数之间加上空格并在输出结束后换行</p>
</blockquote>
<h3 id="1例子-exfmt01go"><a class="header" href="#1例子-exfmt01go">1.例子 Exfmt01.go：</a></h3>
<pre><code>	// Exfmt01.go
	// %v  基本格式的值
	// %+v 当输出结构体时，扩展标志添加成员的名字。
	// %#v 值的Go语法表示。
	package main
	
	import &quot;fmt&quot;
	
	var timeZone = map[string]int{
	        &quot;UTC&quot;: 0 * 60 * 60,
	        &quot;EST&quot;: -5 * 60 * 60,
	        &quot;CST&quot;: -6 * 60 * 60,
	        &quot;MST&quot;: -7 * 60 * 60,
	        &quot;PST&quot;: -8 * 60 * 60,
	}
	
	type T struct {
	        a int
	        b float32
	        c string
	}
	
	func main() {
	        t := &amp;T{7, -2.35, &quot;abc\tdef&quot;}
	        fmt.Printf(&quot;No01:%v\n&quot;, t)
	        fmt.Printf(&quot;No02:%+v\n&quot;, t)
	        fmt.Printf(&quot;No03:%#v\n&quot;, t)
	        fmt.Printf(&quot;No04:%#v\n&quot;, timeZone)
	}
</code></pre>
<p>输出格式：</p>
<pre><code>	No01:&amp;{7 -2.35 abc   def}
    No02:&amp;{a:7 b:-2.35 c:abc     def}
    No03:&amp;main.T{a:7, b:-2.35, c:&quot;abc\tdef&quot;}
    No04:map[string]int{&quot;MST&quot;:-25200, &quot;UTC&quot;:0, &quot;CST&quot;:-21600, &quot;PST&quot;:-28800, &quot;EST&quot;:-18000}
</code></pre>
<blockquote>
<p>重点说明：</p>
<p>在go语言中，一般可以不考虑需打印数据的具体类型，直接利用格式中的 v 就可以了，方便啊！</p>
<p>%v  基本格式的值</p>
<p>%+v 当输出结构体时，扩展标志添加成员的名字。</p>
<p>%#v 值的Go语法表示。</p>
</blockquote>
<h3 id="2例子-exfmt02go"><a class="header" href="#2例子-exfmt02go">2.例子 Exfmt02.go：</a></h3>
<pre><code>    // Exfmt02.go
    // 测试和说明：
    // %t 值的true和false
    // %T 值的类型在Go语言中的表示
    // %% 打印一个 %
    // %q 给打印的字串自动加引号
    package main

    import &quot;fmt&quot;

    func main() {
            var Yes bool //bool 变量自动初始化为 false
            fmt.Printf(&quot;No01:%t\n&quot;, Yes)
            fmt.Printf(&quot;No02:%T\n&quot;, Yes)
            fmt.Printf(&quot;No03:%%\n&quot;)
            fmt.Printf(&quot;No04:%q\n&quot;,&quot;自动加引号&quot;)
    }
    // 输出：
    //No01:false
    //No02:bool
    //No03:%
    //No04:&quot;自动加引号&quot;
</code></pre>
<blockquote>
<p>重点说明：</p>
<p>%t 用于打印bool类型的值，一般为true和false</p>
<p>%T 值的类型在Go语言中的表示</p>
<p>%% 打印一个 %</p>
</blockquote>
<h3 id="3例子-exfmt03go"><a class="header" href="#3例子-exfmt03go">3.例子 Exfmt03.go：</a></h3>
<pre><code>    // Exfmt03.go
    // 测试和说明：
    // 整数部分
    // %b 二进制表示
    // %c 数值对应的Unicode编码字符
    // %d 十进制表示
    // %o 八进制表示
    // %x 十六进制表示，使用a-f
    // %X 十六进制表示，使用A-F
    // %U Unicode格式： U+1234，等价于&quot;U+%04X&quot;
    // %q 单引号
    package main

    import &quot;fmt&quot;

    func main() {
            fmt.Printf(&quot;No01:%b\n&quot;, 888)
            fmt.Printf(&quot;No02:%c\n&quot;, '太')
            fmt.Printf(&quot;No03:%d\n&quot;, 888)
            fmt.Printf(&quot;No04:%o\n&quot;, 888)
            fmt.Printf(&quot;No05:%x\n&quot;, 888)
            fmt.Printf(&quot;No06:%X\n&quot;, 888)
            fmt.Printf(&quot;No07:%U\n&quot;, 888)
            fmt.Printf(&quot;No08:%q\n&quot;, 88)
    }
    // 输出：
    //No01:1101111000
    //No02:太
    //No03:888
    //No04:1570
    //No05:378
    //No06:378
    //No07:U+0378
    //No08:'X'
</code></pre>
<blockquote>
<p>重点说明：</p>
<p>整数部分</p>
<p>%b 二进制表示</p>
<p>%c 数值对应的Unicode编码字符</p>
<p>%d 十进制表示</p>
<p>%o 八进制表示</p>
<p>%x 十六进制表示，使用a-f</p>
<p>%X 十六进制表示，使用A-F</p>
<p>%U Unicode格式： U+1234，等价于&quot;U+%04X&quot;</p>
<p>%q 单引号</p>
</blockquote>
<h3 id="4例子-exfmt04go"><a class="header" href="#4例子-exfmt04go">4.例子 Exfmt04.go：</a></h3>
<pre><code>    // Exfmt04.go
    // 测试和说明：
    // 浮点数：
    // %b 无小数部分、两位指数的科学计数法，和strconv.FormatFloat的'b'转换格式一致。
    // %e 科学计数法，举例：-1234.456e+78
    // %E 科学计数法，举例：-1234.456E+78
    // %f 有小数部分，但无指数部分，举例：123.456
    // %g 根据实际情况采用%e或%f格式（以获得更简洁的输出）
    // %G 根据实际情况采用%E或%f格式（以获得更简洁的输出）
    package main

    import &quot;fmt&quot;

    func main() {
            fmt.Printf(&quot;No01:%b\n&quot;, 888.66)
            fmt.Printf(&quot;No02:%e\n&quot;, 888.66)
            fmt.Printf(&quot;No03:%E\n&quot;, 888.66)
            fmt.Printf(&quot;No04:%f\n&quot;, 888.66)
            fmt.Printf(&quot;No05:%g\n&quot;, 888.33)
            fmt.Printf(&quot;No06:%g\n&quot;, 99999999.33)
            fmt.Printf(&quot;No07:%G\n&quot;, 888.33)
            fmt.Printf(&quot;No08:%G\n&quot;, 99999999.33)
    }
    // 输出：
    //No01:7816736025115361p-43
    //No02:8.886600e+02
    //No03:8.886600E+02
    //No04:888.660000
    //No05:888.33
    //No06:9.999999933e+07
    //No07:888.33
    //No08:9.999999933E+07
</code></pre>
<blockquote>
<p>重点说明：</p>
<p>浮点数：</p>
<p>%b 无小数部分、两位指数的科学计数法，和strconv.FormatFloat的'b'转换格式一致。</p>
<p>%e 科学计数法，举例：-1234.456e+78</p>
<p>%E 科学计数法，举例：-1234.456E+78</p>
<p>%f 有小数部分，但无指数部分，举例：123.456</p>
<p>%g 根据实际情况采用%e或%f格式（以获得更简洁的输出）</p>
<p>%G 根据实际情况采用%E或%f格式（以获得更简洁的输出）</p>
</blockquote>
<h3 id="5例子-exfmt05go"><a class="header" href="#5例子-exfmt05go">5.例子 Exfmt05.go：</a></h3>
<pre><code>    // Exfmt05.go
    // 测试和说明：
    // &quot;No01:%.*d&quot;,10,123: 打印整数，并保证10为长度，关键是长度运行时动态传入
    // &quot;No02:%6.*f&quot;,2,888.666: 打印浮点数，并保证两位小数，关键是小数位运行时动态传入
    package main

    import &quot;fmt&quot;

    func main() {
            fmt.Printf(&quot;No01:%.*d\n&quot;,10,123)
            fmt.Printf(&quot;No02:%6.*f\n&quot;,2,888.666)
    }
    // 输出：
    //No01:0000000123
    //No02:888.67
</code></pre>
<blockquote>
<p>重点说明：</p>
<p>&quot;No01:%.*d&quot;,10,123: 打印整数，并保证10为长度，关键是长度运行时动态传入</p>
<p>&quot;No02:%6.*f&quot;,2,888.666: 打印浮点数，并保证两位小数，关键是小数位运行时动态传入</p>
</blockquote>
<hr />
<h2 id="字符串和byte切片类型说明"><a class="header" href="#字符串和byte切片类型说明">字符串和byte切片类型说明：</a></h2>
<pre><code>%s 直接输出字符串或者[]byte
%q 双引号括起来的字符串
%x 每个字节用两字符十六进制数表示（使用小写a-f）
%X 每个字节用两字符十六进制数表示（使用大写A-F）
</code></pre>
<h2 id="指针类型说明"><a class="header" href="#指针类型说明">指针类型说明：</a></h2>
<pre><code>%p 0x开头的十六进制数表示
木有'u'标志。如果是无类型整数，自然会打印无类型格式。类似的，没有必要去区分操作数的大小(int8, int64)。
宽度和精度格式化控制是指的Unicode编码字符的数量（不同于C的printf，它的这两个因子指的是字节的数量。）两者均可以使用'*'号取代（任一个或两个都），此时它们的值将被紧接着的参数控制，这个操作数必须是整型。
对于数字，宽度设置总长度，精度设置小数部分长度。例如，格式%6.2f 输出123.45。
对于字符串，宽度是输出字符数目的最低数量，如果不足会用空格填充。精度是输出字符数目的最大数量，超过则会截断。
</code></pre>
<h2 id="其他符号说明"><a class="header" href="#其他符号说明">其他符号说明：	</a></h2>
<pre><code>+ 总是输出数值的正负号；对%q(%+q)将保证纯ASCII码输出
- 用空格在右侧填充空缺而不是默认的左侧。
# 切换格式：在八进制前加0(%#o)，十六进制前加0x(%#x)或0X(%#X)；废除指针的0x(%#p)；
对%q (%#q)如果可能的话输出一个无修饰的字符串；
对%U(%#U)如果对应数值是可打印字符输出该字符。
' ' 对数字(% d)空格会留一个空格在数字前并忽略数字的正负号；
对切片和字符串(% x, % X)会以16进制输出。
0 用前置0代替空格填补空缺。
</code></pre>
<h2 id="补充说明"><a class="header" href="#补充说明">补充说明：</a></h2>
<pre><code>每一个类似Printf的函数，都会有一个同样的Print函数，此函数不需要format字符串，等价于对每一个参数设置为%v。另一个变体Println会在参数之间加上空格并在输出结束后换行。
如果参数是一个接口值，将使用内在的具体实现的值，而不是接口本身，%v参数不会被使用。如下：
var i interface{} = 23
fmt.Printf(&quot;%v\n&quot;, i)
将输出23。
如果参数实现了Formatter接口，该接口可用来更好的控制格式化。
如果格式（标志对Println等是隐含的%v）是专用于字符串的(%s %q %v %x %X)，还提供了如下两个规则：
1. 如果一个参数实现了error接口，Error方法会用来将目标转化为字符串，随后将被按给出的要求格式化。
2. 如果参数提供了String方法，这个方法将被用来将目标转换为字符串，然后将按给出的格式标志格式化。
为了避免有可能的递归循环，例如：
type X string
func (x X) String() string { return Sprintf(&quot;&lt;%s&gt;&quot;, x) }
会在递归循环前转换值：
func (x X) String() string { return Sprintf(&quot;&lt;%s&gt;&quot;, string(x)) }
错误的格式：
如果提供了一个错误的格式标志，例如给一个字符串提供了%d标志，生成的字符串将包含对该问题的描述，如下面的例子：
错误或未知的格式标志: %!verb(type=value)
Printf(&quot;%d&quot;, hi): %!d(string=hi)
太多参数: %!(EXTRA type=value)
Printf(&quot;hi&quot;, &quot;guys&quot;): hi%!(EXTRA string=guys)
缺少参数: %!verb(MISSING)
Printf(&quot;hi%d&quot;): hi %!d(MISSING)
使用非整数提供宽度和精度: %!(BADWIDTH) or %!(BADPREC)
Printf(&quot;%*s&quot;, 4.5, &quot;hi&quot;): %!(BADWIDTH)hi
Printf(&quot;%.*s&quot;, 4.5, &quot;hi&quot;): %!(BADPREC)hi
所有的错误都使用&quot;%!&quot;起始，（紧随单字符的格式标志）以括号包围的错误描述结束。
输入
一系列类似的函数读取格式化的文本，生成值。Scan，Scanf和Scanln从os.Stdin读取；Fscan，Fscanf和Fscanln 从特定的io.Reader读取；Sscan，Sscanf和Sscanln 从字符串读取；Scanln，Fscanln和Sscanln在换行时结束读取，并要求数据连续出现；Scanf，Fscanf和Sscanf会读取一整行以匹配格式字符串；其他的函数将换行看着空格。
Scanf, Fscanf, and Sscanf根据格式字符串解析数据，类似于Printf。例如，%x将读取一个十六进制数，%v将读取值的默认表示。
格式行为类似于Printf，但有如下例外：
%p没有提供
%T没有提供
%e %E %f %F %g %G是等价的，都可以读取任何浮点数或者复合数（非复数，指科学计数法表示的带指数的数）
%s 和 %v字符串使用这两个格式读取时会因为空格而结束
不设格式或者使用%v读取整数时，如果前缀为0(八进制)或0x(十六进制)，将按对应进制读取。
宽度在输入中被解释（%5s意思是最多从输入读取5个字符赋值给一个字符串），但输入系列函数没有解释精度的语法(木有%5.2f，只有%5f)。
输入系列函数中的格式字符串，所有非空的空白字符（除了换行符之外），无论在输入里还是格式字符串里，都等价于1个空白字符。格式字符串必须匹配输入的文本，如果不匹配将停止读取数据并返回函数已经赋值的参数的数量。
所有的scan系列函数，如果参数包含Scan方法（或者说实现了Scanner接口），该参数将使用该方法读取文本。另外，如果被填写的参数的数量少于提供的参数的数量，将返回一个错误。
所有要被输入的参数都应该是基础类型或者实现了Scanner接口的数据类型的指针。
注意：Fscan等函数可以从输入略过一些字符读取需要的字符并返回，这就意味着一个循环的读取程序可能会跳过输入的部分数据。当数据间没有空白时就会导致出现问题。如果读取这提供给Fscan系列函数ReadRune 方法，这个方法可以用来读取字符。如果读取者还提供了UnreadRune 方法，该方法将被用来保存字符以使成功的调用不会丢失数据。为了给一个没有这些功能的读取者添加这俩方法，使用bufio.NewReader。
</code></pre>
<h1 id="函数及相关类型的简介"><a class="header" href="#函数及相关类型的简介">函数及相关类型的简介</a></h1>
<h2 id="函数说明"><a class="header" href="#函数说明">函数说明</a></h2>
<pre><code>func Errorf
func Errorf(format string, a ...interface{}) error
Errorf根据格式字符串和参数表生成一个字符串，该字符串满足error接口。
func Fprint
func Fprint(w io.Writer, a ...interface{}) (n int, err error)
Fprint将所有参数都使用默认的格式写入w。如果相邻两个参数都不是字符串时，会在参数间添加空白。函数返回写入的字节数和任何遇到的错误。
func Fprintf
func Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error)
Fprintf根据格式字符串将参数写入w。函数返回写入的字节数和任何遇到的错误。
func Fprintln
func Fprintln(w io.Writer, a ...interface{}) (n int, err error)
Fprintln将所有参数都使用默认的格式写入w并在最后添加换行。如果相邻两个参数都不是字符串时，会在参数间添加空白。函数返回写入的字节数和任何遇到的错误。
func Fscan
func Fscan(r io.Reader, a ...interface{}) (n int, err error)
Fscan从r读取文本，将连续的空白分割的数据存入连续的参数里。换行视同空白。它返回成功读取的参数的数量。如果少于提供的参数的数量，返回值err将报告原因。
func Fscanf
func Fscanf(r io.Reader, format string, a ...interface{}) (n int, err error)
Fscanf从r读取文本，根据格式字符串顺序将数据存入参数中。它返回成功解析并存入的参数的数量。
func Fscanln
func Fscanln(r io.Reader, a ...interface{}) (n int, err error)
Fscanln类似Fscanf，但会在换行符中止，并且存入最后一条后时读取位置必须有换行或者结束符。
func Print
func Print(a ...interface{}) (n int, err error)
Print将所有参数都使用默认的格式写入标准输出。如果相邻两个参数都不是字符串时，会在参数间添加空白。函数返回写入的字节数和任何遇到的错误。
func Printf
func Printf(format string, a ...interface{}) (n int, err error)
Printf根据格式字符串将参数写入标准输出。函数返回写入的字节数和任何遇到的错误。
func Println
func Println(a ...interface{}) (n int, err error)
Println将所有参数都使用默认的格式写入标准输出并在最后添加换行。如果相邻两个参数均非字符串时，会在参数间添加空白。函数返回写入的字节数和任何遇到的错误。
func Scan
func Scan(a ...interface{}) (n int, err error)
Scan从标准输入读取文本，将空白分割的连续数据顺序存入参数里。换行视同空白。它返回成功读取的参数的数量。如果少于提供的参数的数量，返回值err将报告原因。
func Scanf
func Scanf(format string, a ...interface{}) (n int, err error)
Scanf从标准输入读取文本，根据格式字符串顺序将数据存入参数中。它返回成功解析并存入的参数的数量。
func Scanln
func Scanln(a ...interface{}) (n int, err error)
Scanln类似Scan，但会在换行符中止，并且存入最后一条后时读取位置必须有换行或者结束符。
func Sprint
func Sprint(a ...interface{}) string
Sprint将所有参数都使用默认的格式写入并生成一个字符串。如果相邻两个参数都不是字符串时，会在参数间添加空白。
func Sprintf
func Sprintf(format string, a ...interface{}) string
Sprintf根据格式字符串将参数写入并返回生成的字符串。
func Sprintln
func Sprintln(a ...interface{}) string
Sprintln将所有参数都使用默认的格式写入并生成一个字符串。如果相邻两个参数都不是字符串时，会在参数间添加空白。字符串最后会添加换行符。
func Sscan
func Sscan(str string, a ...interface{}) (n int, err error)
Sscan从字符串读取文本，将空白分割的连续数据顺序存入参数里。换行视同空白。它返回成功读取的参数的数量。如果少于提供的参数的数量，返回值err将报告原因。
func Sscanf
func Sscanf(str string, format string, a ...interface{}) (n int, err error)
Scanf从字符串读取文本，根据格式字符串顺序将数据存入参数中。它返回成功解析并存入的参数的数量。
func Sscanln
func Sscanln(str string, a ...interface{}) (n int, err error)
Sscanln类似Sscan，但会在换行符中止，并且存入最后一条后时读取位置必须有换行或者结束符。
</code></pre>
<h2 id="类型说明"><a class="header" href="#类型说明">类型说明</a></h2>
<pre><code>type Formatter
type Formatter interface {
Format(f State, c rune)
}
Formatter是一个供用户定制的格式化接口。Format方法的实现可能需要调用Sprintf 或Fprintf(f)等函数来生成输出。
type GoStringer
type GoStringer interface {
GoString() string
}
GoStringer接口由任意包含GoString方法的数据实现，这个方法定义了数据的Go语法格式。GoString方法用来在使用%#v格式标志时输出值。
type ScanState
type ScanState interface {
// ReadRune函数从输入读取下一个Unicode符号。如果在Scanln，Fscanln或Sscanln中调用，本函数会在读取到第一个'\n'或达到最大宽度时返回EOF。
ReadRune() (r rune, size int, err error)
// UnreadRune会让ReadRune的下一次调用返回同一个字符。
UnreadRune() error
// SkipSpace跳过输入的空白。换行被视为空白（Scanln，Fscanln和Sscanln例外，这三个函数里换行符视为EOF）。
SkipSpace()
// Token方法会在skipSpace为真时跳过输入中的空白，并返回一个满足f(c)的Unicode字符。如果f是nil，则使用!unicode.IsSpace(c)（即返回第一个非空格Unicode字符）；
// 即是说，本函数只对非空字符起效。换行符视为空白字符（Scanln，Fscanln和Sscanln例外，这三个函数里换行符视为EOF）。
// 返回的切片类型指向共享的数据，该数据可以被下一次Token的调用（使用ScanState接口作为输入调用Scan函数）中或者调用返回的Scan方法时重写。
Token(skipSpace bool, f func(rune) bool) (token []byte, err error)
// Width返回width选项的值以及其是否被设定。
Width() (wid int, ok bool)
// 因为ReadRune用接口实现，Read方法应该永远不被scan程序调用，一个好使的ScanState实现应该保证总是从Read返回错误。
Read(buf []byte) (n int, err error)
}
ScanState是一个交给用户定制的Scanner接口的参数的接口。Scanner接口可能会进行一次一个字符的扫描或者要求ScanState去探测下一个空白分隔的token。
type Scanner
type Scanner interface {
Scan(state ScanState, verb rune) error
}
任何实现了Scan方法的对象都实现了Scanner接口，Scan方法会从输入读取数据并将处理结果存入接受端，接收端必须是有效的指针。Scan方法会被任何Scan、Scanf、Scanln等函数调用，只要对应的参数实现了该方法。
type State
type State interface {
// Write可被调用以发出格式化的输出。
Write(b []byte) (ret int, err error)
// Width返回宽度的值及其是否被设定。
Width() (wid int, ok bool)
// Precision返回精度的值及其是否被设定。
Precision() (prec int, ok bool)
// Flag返回符号（正负号……）的值是否被设定。
Flag(c int) bool
}
State是一个提供给Formatter接口的输出参数的接口。它提供对io.Writer接口的、使用提供的数据对参数格式化后的访问。
type Stringer
type Stringer interface {
String() string
}
Stringer接口被任何实现了String方法的类型自动实现，该方法定义了该类型的“原生”格式。String方法用来输出参数，当使用%s或%v格式时，或者被Print等不使用格式字符串的函数输出时。 
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-fprintw-iowriter-a-interface-n-int-err-error"><a class="header" href="#func-fprintw-iowriter-a-interface-n-int-err-error">func Fprint(w io.Writer, a ...interface{}) (n int, err error)</a></h1>
<p>参数列表</p>
<ul>
<li>w 写入文件指针</li>
<li>a... 值变量列表</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回打印字符数 n</li>
<li>返回error</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是用来根据默认格式字符串和参数表生成一个打印字符串并写入指定文件</p>
<p>代码实例：</p>
<pre><code>package main

import 	&quot;fmt&quot;
import  &quot;os&quot;
	
func main() {
	fmt.Fprint(os.Stdout,&quot;默认格式打印!&quot;)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-fprintfw-iowriter-format-string-a-interface-n-int-err-error"><a class="header" href="#func-fprintfw-iowriter-format-string-a-interface-n-int-err-error">func Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error)</a></h1>
<p>参数列表</p>
<ul>
<li>w 写入文件指针</li>
<li>format 打印的格式说明 </li>
<li>a... 值变量列表</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回打印字符数 n</li>
<li>返回error</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是用来根据说明格式字符串和参数表生成一个打印字符串</p>
<p>代码实例：</p>
<pre><code>package main

import 	&quot;fmt&quot;
import  &quot;os&quot;
	
func main() {
	fmt.Fprintf(os.Stdout,&quot;Format:%s\n&quot;,&quot;格式打印!&quot;)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-fprintlnw-iowritera-interface-n-int-err-error"><a class="header" href="#func-fprintlnw-iowritera-interface-n-int-err-error">func Fprintln(w io.Writer,a ...interface{}) (n int, err error)</a></h1>
<p>参数列表</p>
<ul>
<li>w 写入文件指针</li>
<li>a... 值变量列表</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回打印字符数 n</li>
<li>返回error</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是用来根据默认格式字符串和参数表生成一个打印字符串并加换行写入指定文件</p>
<p>代码实例：</p>
<pre><code>package main

import 	&quot;fmt&quot;
import  &quot;os&quot;
	
func main() {
	fmt.Fprintln(os.Stdout,&quot;默认格式加换行打印!&quot;)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-fscanr-ioreader-a-interface-n-int-err-error"><a class="header" href="#func-fscanr-ioreader-a-interface-n-int-err-error">func Fscan(r io.Reader, a ...interface{}) (n int, err error)</a></h1>
<p>参数列表</p>
<ul>
<li>r 输入文件指针</li>
<li>a... 值变量列表</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回成功读取的参数的数量 n</li>
<li>返回error</li>
</ul>
<p>功能说明：</p>
<blockquote>
<p>这个函数主要是从指定文件读取文本，将空白分割的连续数据顺序存入参数里。</p>
<p>换行视同空白。它返回成功读取的参数的数量。</p>
<p>如果少于提供的参数的数量，返回值err将报告原因。</p>
</blockquote>
<p>代码实例：</p>
<pre><code>    package main

    import &quot;fmt&quot;
    import &quot;os&quot;

    var (
        n, a, b, c int
    err        error
    )

    func main() {

    n, err = fmt.Fscan(os.Stdin, &amp;a, &amp;b, &amp;c)
    fmt.Println(a, b, c)
    fmt.Printf(&quot;输入正确参数%v个，错误参数原因:%v&quot;, n, err)
    }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-fscanfr-ioreader-format-string-a-interface-n-int-err-error"><a class="header" href="#func-fscanfr-ioreader-format-string-a-interface-n-int-err-error">func Fscanf(r io.Reader, format string, a ...interface{}) (n int, err error)</a></h1>
<p>参数列表</p>
<ul>
<li>r 输入文件指针</li>
<li>format 输入格式说明 </li>
<li>a... 值变量列表</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回输入字符数 n</li>
<li>返回error</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是从指定文件中按说明的格式读取文本，根据格式字符串顺序将数据存入参数中，
它返回成功解析并存入的参数的数量</p>
<p>代码实例：</p>
<pre><code>    package main

    import  &quot;fmt&quot;
    import  &quot;os&quot;

    func main(){
           	var a,b,c int
            fmt.Fscanf(os.Stdin,&quot;%d,%d,%d&quot;,&amp;a,&amp;b,&amp;c)
            fmt.Println(a,b,c)
    }
</code></pre>
<p>注意上面的Fscanf(&quot;%d,%d,%d&quot;,&amp;a,&amp;b,&amp;c)中%d,%d,%d之间有逗号，
在输入数据时也要加逗号，如果去掉逗号，输入时就不用逗号，
而用空格，tab键或回车键将各个数据隔开</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-fscanlnr-ioreader-a-interface-n-int-err-error"><a class="header" href="#func-fscanlnr-ioreader-a-interface-n-int-err-error">func Fscanln(r io.Reader, a ...interface{}) (n int, err error)</a></h1>
<p>参数列表</p>
<ul>
<li>r 输入文件指针</li>
<li>a... 值变量列表</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回成功读取的参数的数量 n</li>
<li>返回error</li>
</ul>
<p>功能说明：</p>
<blockquote>
<p>这个函数主要是从指定文件中读取文本，将空白分割的连续数据顺序存入参数里。</p>
<p>换行视同空白。它返回成功读取的参数的数量。</p>
<p>如果少于提供的参数的数量，返回值err将报告原因。</p>
<p>类似Scan，但会在换行符中止，并且存入最后一条后时读取位置必须有换行或者结束符。</p>
</blockquote>
<p>代码实例：</p>
<pre><code>    package main

    import  (
    &quot;fmt&quot;
    &quot;os&quot;
    )

    func main(){
            var a,b,c int
            fmt.Fscanln(os.Stdin,&amp;a,&amp;b,&amp;c)
            fmt.Println(a,b,c)
    }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-printa-interface-n-int-err-error"><a class="header" href="#func-printa-interface-n-int-err-error">func Print(a ...interface{}) (n int, err error)</a></h1>
<p>参数列表</p>
<ul>
<li>a... 值变量列表</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回打印字符数 n</li>
<li>返回error</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是用来根据系统默认格式字符串和参数表生成一个打印字符串</p>
<p>代码实例：</p>
<pre><code>package main

import 	&quot;fmt&quot;
	
func main() {
	fmt.Print(&quot;默认格式打印!&quot;)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-printfformat-string-a-interface-n-int-err-error"><a class="header" href="#func-printfformat-string-a-interface-n-int-err-error">func Printf(format string, a ...interface{}) (n int, err error)</a></h1>
<p>参数列表</p>
<ul>
<li>format 打印的格式说明 </li>
<li>a... 值变量列表</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回打印字符数 n</li>
<li>返回error</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是用来根据说明格式字符串和参数表生成一个打印字符串</p>
<p>代码实例：</p>
<pre><code>package main

import 	&quot;fmt&quot;
	
func main() {
	fmt.Printf(&quot;Format:%s\n&quot;,&quot;格式打印!&quot;)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-printlna-interface-n-int-err-error"><a class="header" href="#func-printlna-interface-n-int-err-error">func Println(a ...interface{}) (n int, err error)</a></h1>
<p>参数列表</p>
<ul>
<li>a... 值变量列表</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回打印字符数 n</li>
<li>返回error</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是用来根据系统默认格式字符串和参数表生成一个打印字符串并加换行</p>
<p>代码实例：</p>
<pre><code>package main

import 	&quot;fmt&quot;
	
func main() {
	fmt.Println(&quot;默认格式打印，有换行啊!&quot;)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-scana-interface-n-int-err-error"><a class="header" href="#func-scana-interface-n-int-err-error">func Scan(a ...interface{}) (n int, err error)</a></h1>
<p>参数列表</p>
<ul>
<li>a... 值变量列表</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回成功读取的参数的数量 n</li>
<li>返回error</li>
</ul>
<p>功能说明：</p>
<blockquote>
<p>这个函数主要是从标准输入读取文本，将空白分割的连续数据顺序存入参数里。</p>
<p>换行视同空白。它返回成功读取的参数的数量。</p>
<p>如果少于提供的参数的数量，返回值err将报告原因。</p>
</blockquote>
<p>代码实例：</p>
<pre><code>    package main

    import  &quot;fmt&quot;

    func main(){
            var a,b,c int
            fmt.Scan(&amp;a,&amp;b,&amp;c)
            fmt.Println(a,b,c)
    }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-scanfformat-string-a-interface-n-int-err-error"><a class="header" href="#func-scanfformat-string-a-interface-n-int-err-error">func Scanf(format string, a ...interface{}) (n int, err error)</a></h1>
<p>参数列表</p>
<ul>
<li>format 输入格式说明 </li>
<li>a... 值变量列表</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回输入字符数 n</li>
<li>返回error</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是从标准输入读取文本，根据格式字符串顺序将数据存入参数中，
它返回成功解析并存入的参数的数量</p>
<p>代码实例：</p>
<pre><code>    package main

    import  &quot;fmt&quot;

    func main(){
            var a,b,c int
            fmt.Scanf(&quot;%d,%d,%d&quot;,&amp;a,&amp;b,&amp;c)
            fmt.Println(a,b,c)
    }
</code></pre>
<p>注意上面的Scanf(&quot;%d,%d,%d&quot;,&amp;a,&amp;b,&amp;c)中%d,%d,%d之间有逗号，
在输入数据时也要加逗号，如果去掉逗号，输入时就不用逗号，
而用空格，tab键或回车键将各个数据隔开</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-scanlna-interface-n-int-err-error"><a class="header" href="#func-scanlna-interface-n-int-err-error">func Scanln(a ...interface{}) (n int, err error)</a></h1>
<p>参数列表</p>
<ul>
<li>a... 值变量列表</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回成功读取的参数的数量 n</li>
<li>返回error</li>
</ul>
<p>功能说明：</p>
<blockquote>
<p>这个函数主要是从标准输入读取文本，将空白分割的连续数据顺序存入参数里。</p>
<p>换行视同空白。它返回成功读取的参数的数量。</p>
<p>如果少于提供的参数的数量，返回值err将报告原因。</p>
<p>类似Scan，但会在换行符中止，并且存入最后一条后时读取位置必须有换行或者结束符。</p>
</blockquote>
<p>代码实例：</p>
<pre><code>    package main

    import  &quot;fmt&quot;

    func main(){
            var a,b,c int
            fmt.Scanln(&amp;a,&amp;b,&amp;c)
            fmt.Println(a,b,c)
    }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-sprinta-interface-string"><a class="header" href="#func-sprinta-interface-string">func Sprint(a ...interface{}) string</a></h1>
<p>参数列表</p>
<ul>
<li>a... 值变量列表</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回打印字符串</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是用来根据默认格式字符串和参数表生成一个打印字符串</p>
<p>代码实例：</p>
<pre><code>package main

import 	&quot;fmt&quot;
	
func main() {
	fmt.Sprint(&quot;默认格式打印出字符串!&quot;)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-sprintfformat-string-a-interface-string"><a class="header" href="#func-sprintfformat-string-a-interface-string">func Sprintf(format string, a ...interface{}) string</a></h1>
<p>参数列表</p>
<ul>
<li>format 打印的格式说明 </li>
<li>a... 值变量列表</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回打印字符串</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是用来根据说明格式字符串和参数表生成一个打印字符串</p>
<p>代码实例：</p>
<pre><code>package main

import 	&quot;fmt&quot;
	
func main() {
	str := fmt.Sprintf(&quot;Format:%s\n&quot;,&quot;格式打印出字符串!&quot;)
	fmt.Println(str)  // Format:格式打印出字符串!
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-sprintlna-interface-string"><a class="header" href="#func-sprintlna-interface-string">func Sprintln(a ...interface{}) string</a></h1>
<p>参数列表</p>
<ul>
<li>a... 值变量列表</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回打印字符串</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是用来根据默认格式字符串和参数表生成一个打印字符串并带换行</p>
<p>代码实例：</p>
<pre><code>package main

import 	&quot;fmt&quot;
	
func main() {
	fmt.Sprintln(&quot;默认格式打印出字符串并带换行!&quot;)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-sscanstr-string-a-interface-n-int-err-error"><a class="header" href="#func-sscanstr-string-a-interface-n-int-err-error">func Sscan(str string, a ...interface{}) (n int, err error)</a></h1>
<p>参数列表</p>
<ul>
<li>str 指定源字符串</li>
<li>a... 值变量列表</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回成功读取的参数的数量 n</li>
<li>返回error</li>
</ul>
<p>功能说明：</p>
<blockquote>
<p>这个函数主要是从指定源字符串str中读取文本，将空白分割的连续数据顺序存入参数里。</p>
<p>换行视同空白。它返回成功读取的参数的数量。</p>
<p>如果少于提供的参数的数量，返回值err将报告原因。</p>
</blockquote>
<p>代码实例：</p>
<pre><code>    package main

    import  &quot;fmt&quot;

    func main(){
            str := &quot;34  343  245&quot;
            var a,b,c int
            fmt.Sscan(str,&amp;a,&amp;b,&amp;c)
            fmt.Println(a,b,c)
    }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-sscanfstr-string-format-string-a-interface-n-int-err-error"><a class="header" href="#func-sscanfstr-string-format-string-a-interface-n-int-err-error">func Sscanf(str string, format string, a ...interface{}) (n int, err error)</a></h1>
<p>参数列表</p>
<ul>
<li>str 指定的源字符串</li>
<li>format 输入格式说明 </li>
<li>a... 值变量列表</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回输入字符数 n</li>
<li>返回error</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是从指定字符串str中按说明的格式读取文本，根据格式字符串顺序将数据存入参数中，
它返回成功解析并存入的参数的数量</p>
<p>代码实例：</p>
<pre><code>    package main

    import  &quot;fmt&quot;

    func main(){
    	str := &quot;13 23 45&quot;
            var a,b,c int
            fmt.Sscanf(str,&quot;%d,%d,%d&quot;,&amp;a,&amp;b,&amp;c)
            fmt.Println(a,b,c)
    }
</code></pre>
<p>注意上面的Sscanf(&quot;%d,%d,%d&quot;,&amp;a,&amp;b,&amp;c)中%d,%d,%d之间有逗号，
在输入数据时也要加逗号，如果去掉逗号，输入时就不用逗号，
而用空格，tab键或回车键将各个数据隔开</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-sscanlnstr-string-a-interface-n-int-err-error"><a class="header" href="#func-sscanlnstr-string-a-interface-n-int-err-error">func Sscanln(str string, a ...interface{}) (n int, err error)</a></h1>
<p>参数列表</p>
<ul>
<li>str 指定源字符串</li>
<li>a... 值变量列表</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回成功读取的参数的数量 n</li>
<li>返回error</li>
</ul>
<p>功能说明：</p>
<blockquote>
<p>这个函数主要是从指定源字符串str中读取文本，将空白分割的连续数据顺序存入参数里。</p>
<p>换行视同空白。它返回成功读取的参数的数量。</p>
<p>如果少于提供的参数的数量，返回值err将报告原因。</p>
<p>类似Scan，但会在换行符中止，并且存入最后一条后时读取位置必须有换行或者结束符。</p>
</blockquote>
<p>代码实例：</p>
<pre><code>    package main

    import  &quot;fmt&quot;

    func main(){
    	str := &quot;34  343  245&quot;
            var a,b,c int
            fmt.Sscanln(str,&amp;a,&amp;b,&amp;c)
            fmt.Println(a,b,c)
    }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名-22"><a class="header" href="#包名-22">包名</a></h1>
<p>函数列表</p>
<ul>
<li>xxx1</li>
<li>xxx2</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名-23"><a class="header" href="#包名-23">包名</a></h1>
<p>函数列表</p>
<ul>
<li>xxx1</li>
<li>xxx2</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名-24"><a class="header" href="#包名-24">包名</a></h1>
<p>函数列表</p>
<ul>
<li>xxx1</li>
<li>xxx2</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名-25"><a class="header" href="#包名-25">包名</a></h1>
<p>函数列表</p>
<ul>
<li>xxx1</li>
<li>xxx2</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名-26"><a class="header" href="#包名-26">包名</a></h1>
<p>函数列表</p>
<ul>
<li>xxx1</li>
<li>xxx2</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名-27"><a class="header" href="#包名-27">包名</a></h1>
<p>函数列表</p>
<ul>
<li>xxx1</li>
<li>xxx2</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名-28"><a class="header" href="#包名-28">包名</a></h1>
<p>函数列表</p>
<ul>
<li>xxx1</li>
<li>xxx2</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名-29"><a class="header" href="#包名-29">包名</a></h1>
<p>函数列表</p>
<ul>
<li>xxx1</li>
<li>xxx2</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名-30"><a class="header" href="#包名-30">包名</a></h1>
<p>函数列表</p>
<ul>
<li>xxx1</li>
<li>xxx2</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名-31"><a class="header" href="#包名-31">包名</a></h1>
<p>函数列表</p>
<ul>
<li>xxx1</li>
<li>xxx2</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名-32"><a class="header" href="#包名-32">包名</a></h1>
<p>函数列表</p>
<ul>
<li>xxx1</li>
<li>xxx2</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名-33"><a class="header" href="#包名-33">包名</a></h1>
<p>函数列表</p>
<ul>
<li>xxx1</li>
<li>xxx2</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名-34"><a class="header" href="#包名-34">包名</a></h1>
<p>函数列表</p>
<ul>
<li>xxx1</li>
<li>xxx2</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>#html包</p>
<p>##概述
提供了HTML文本转义与反转义的函数</p>
<p>##函数列表</p>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/html/EscapeString.html">func EscapeString(s string) string</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/html/UnescapeString.html">func UnescapeString(s string) string</a></li>
</ul>
<p>##子包</p>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/html/template">template</a> (html/template) 实现了数据驱动的模板引擎,生成HTML输出并可防止代码注入</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>#html/template包</p>
<p>##概述
html/template包实现了数据驱动的模板引擎,生成HTML输出并可防止代码注入. 虽然它提供了与text/template相同的接口,但如果你要输出的内容是HTML时应该使用html/template包而不是text/template包.	</p>
<p>这里着重介绍html/template包中的安全性功能. 有关如何编写自己的模板，请参阅text/template包。</p>
<p>##详细介绍
html/template包含了text/template,你可以使用template API来安全的解析和执行HTML模板.</p>
<pre><code>tmpl, err := template.New(&quot;name&quot;).Parse(...)
// 这里省略了err的判断
err = tmpl.Execute(out, data)
</code></pre>
<p>如果成功的话，tmpl已经过滤掉注入代码了,可以放心的使用.如果失败，err将返回一个ErrorCode.</p>
<p>在HTML模板中那些需要被转义或被编码的数据(值)会被当做纯文本进行处理,这样你就可以安全的把这些值嵌入到HTML中了.而且转义是语境关联的,JavaScript,CSS和URI中都会被转义.</p>
<p>template包使用的安全模型会假设模板的作者是可信的,而执行的数据和参数不是.更多细节请看下面的例子.</p>
<p>使用text/template包,结果不会被自动转义:	</p>
<pre><code>import &quot;text/template&quot;
//这里省略一万字
t, err := template.New(&quot;foo&quot;).Parse(`{{define &quot;T&quot;}}Hello, {{.}}!{{end}}`)
err = t.ExecuteTemplate(out, &quot;T&quot;, &quot;&lt;script&gt;alert('you have been pwned')&lt;/script&gt;&quot;)
</code></pre>
<p>输出的HTML没有经过转义:<br />
<code>Hello, &lt;script&gt;alert('you have been pwned')&lt;/script&gt;!</code></p>
<p>而使用html/template包,输出会进行语境自动转义:</p>
<pre><code>import &quot;html/template&quot;
//这里省略一万字
t, err := template.New(&quot;foo&quot;).Parse(`{{define &quot;T&quot;}}Hello, {{.}}!{{end}}`)
err = t.ExecuteTemplate(out, &quot;T&quot;, &quot;&lt;script&gt;alert('you have been pwned')&lt;/script&gt;&quot;)
</code></pre>
<p>输出的HTML是经过转义的:<br />
<code>Hello, &amp;lt;script&amp;gt;alert(&amp;#39;you have been pwned&amp;#39;)&amp;lt;/script&amp;gt;!</code></p>
<p>##语境转义
html/template包会转义的部分包含HTML, CSS, JavaScript, 和 URI	
它会为每一个管道添加消毒功能,下面是一个代码片段:	
<code>&lt;a href=&quot;/search?q={{.}}&quot;&gt;{{.}}&lt;/a&gt;</code>	
在解析时,每一个<code>{{.}}</code>将会被覆盖,以增加必要的转义功能.在这种情况下，它将会变为:	
<code>&lt;a href=&quot;/search?q={{. | urlquery}}&quot;&gt;{{. | html}}&lt;/a&gt;</code>	</p>
<p>##错误返回
详见文档中的ErrorCode部分</p>
<p>##更全面的了解
这个包其余的注释可以在第一次阅读时跳过,它包括了语境转义和错误异常返回的详细信息.大多数用户可能并不需要了解这些细节.</p>
<p>##语境转义详解</p>
<p>假设 <code>{{.}}</code> 为 <code>O'Reilly: How are &lt;i&gt;you&lt;/i&gt;?</code>, 下面列出了转义之后<code>{{.}}</code>中的内容会变为什么</p>
<pre><code>语境                             {{.}} 之后

{{.}}                            O'Reilly: How are &amp;lt;i&amp;gt;you&amp;lt;/i&amp;gt;?
&lt;a title='{{.}}'&gt;                O&amp;#39;Reilly: How are you?
&lt;a href=&quot;/{{.}}&quot;&gt;                O&amp;#39;Reilly: How are %3ci%3eyou%3c/i%3e?
&lt;a href=&quot;?q={{.}}&quot;&gt;              O&amp;#39;Reilly%3a%20How%20are%3ci%3e...%3f
&lt;a onx='f(&quot;{{.}}&quot;)'&gt;             O\x27Reilly: How are \x3ci\x3eyou...?
&lt;a onx='f({{.}})'&gt;               &quot;O\x27Reilly: How are \x3ci\x3eyou...?&quot;
&lt;a onx='pattern = /{{.}}/;'&gt;     O\x27Reilly: How are \x3ci\x3eyou...\x3f
</code></pre>
<p>如果使用了一个不安全的内容,这个值将会被过滤掉:</p>
<pre><code>原内容                            {{.}} 之后

&lt;a href=&quot;{{.}}&quot;&gt;                 #ZgotmplZ
</code></pre>
<p>例如&quot;O'Reilly:&quot; 是一个不安全的协议,如&quot;http:&quot;.</p>
<p>如果 <code>{{.}}</code> 的内容是安全的, 例如<code>你好</code>, 他将不会被转义而是直接输出到模板中去</p>
<pre><code>语境                                 {{.}} 之后

{{.}}                                你好
&lt;a title='{{.}}'&gt;                    你好
&lt;a href='{{.}}'&gt;                     你好
&lt;a href='/{{.}}'&gt;                    你好
&lt;a href='?dir={{.}}'&gt;                你好
&lt;a style=&quot;border-{{.}}: 4px&quot;&gt;        你好
&lt;a style=&quot;align: {{.}}&quot;&gt;             你好
&lt;a style=&quot;background: '{{.}}'&gt;       你好
&lt;a style=&quot;background: url('{{.}}')&gt;  你好
&lt;style&gt;p.{{.}} {color:red}&lt;/style&gt;   你好
</code></pre>
<p>非字符串的值是可以出现在JavaScript的语境中的. 例如 <code>{{.}}</code> 是:</p>
<pre><code>[]struct{A,B string}{ &quot;foo&quot;, &quot;bar&quot; }
</code></pre>
<p>在模板转义过之后:</p>
<pre><code>&lt;script&gt;var pair = {{.}};&lt;/script&gt;
</code></pre>
<p>模板的输出结果:</p>
<pre><code>&lt;script&gt;var pair = {&quot;A&quot;: &quot;foo&quot;, &quot;B&quot;: &quot;bar&quot;};&lt;/script&gt;
</code></pre>
<p>请参阅json包来了解如何在JavaScript语境中格式化的嵌入非字符串内容.</p>
<p>##字符串的类型
默认情况下,tmplate包假设所有的管道产生纯文本字符串.它增加了转义管道的阶段以确保在适当的情况下正确和安全地嵌入纯文本字符串.
当数据的值不是纯文本时,你可以确保它的标记不被转义.	
HTML, JS, URL等类型,并且内容是安全的,go语言可以使他们避免被转义.<br />
下面是模板的一个例子:	</p>
<pre><code>Hello, {{.}}!
</code></pre>
<p>可以被这样调用:	</p>
<pre><code>tmpl.Execute(out, HTML(`&lt;b&gt;World&lt;/b&gt;`))
</code></pre>
<p>输出结果是:</p>
<pre><code>Hello, &lt;b&gt;World&lt;/b&gt;!
</code></pre>
<p>而不是:</p>
<pre><code>Hello, &amp;lt;b&amp;gt;World&amp;lt;b&amp;gt;!
</code></pre>
<p>如果<code>{{.}}</code>是一个普通的字符串将会被直接输出而不是被转义</p>
<p>##安全模型
template包使用的安全模型:<br />
<a href="http://js-quasis-libraries-and-repl.googlecode.com/svn/trunk/safetemplate.html#problem_definition">http://js-quasis-libraries-and-repl.googlecode.com/svn/trunk/safetemplate.html#problem_definition</a>	</p>
<p>template包使用的安全模型会假设模板的作者是可信的,而执行的数据和参数不是,并能在面对不受信任的数据时寻找并维持下面的这些特性：</p>
<ul>
<li>
<p>结构保持性： 当使用安全的模板语言写一个HTML标签时,浏览器会解释并输出相应的部分,无论作为标记的值是否是不受信任的数据.同样,对于其他结构如属性界限,JS和CSS字符串的界限也是如此.</p>
</li>
<li>
<p>效果一致性： 注入模板的结果输出到一个页面,所有模板的使用者的运行应执行相同的结果.</p>
</li>
<li>
<p>最小惊讶性： 熟悉HTML,CSS和JavaScript的开发人员（或代码评审人员）,看到<code>{{.}}</code>时都应该知道自动语境转义发生了,并应该能正确推断出转义了什么.</p>
</li>
</ul>
<p>##函数/类型列表</p>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/html/template/HTMLEscape.html">func HTMLEscape(w io.Writer, b []byte)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/html/template/HTMLEscapeString.html">func HTMLEscapeString(s string) string</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/html/template/HTMLEscaper.html">func HTMLEscaper(args ...interface{}) string</a></li>
<li>func JSEscape(w io.Writer, b []byte)</li>
<li>func JSEscapeString(s string) string</li>
<li>func JSEscaper(args ...interface{}) string</li>
<li>func URLQueryEscaper(args ...interface{}) string</li>
<li>type CSS</li>
<li>type Error
<ul>
<li>func (e *Error) Error() string</li>
</ul>
</li>
<li>type ErrorCode</li>
<li>type FuncMap</li>
<li>type HTML</li>
<li>type HTMLAttr</li>
<li>type JS</li>
<li>type JSStr</li>
<li>type Template
<ul>
<li>func Must(t *Template, err error) *Template</li>
<li>func New(name string) *Template</li>
<li>func ParseFiles(filenames ...string) (*Template, error)</li>
<li>func ParseGlob(pattern string) (*Template, error)</li>
<li>func (t *Template) AddParseTree(name string, tree *parse.Tree) (*Template, error)</li>
<li>func (t *Template) Clone() (*Template, error)</li>
<li>func (t *Template) Delims(left, right string) *Template</li>
<li>func (t *Template) Execute(wr io.Writer, data interface{}) (err error)</li>
<li>func (t *Template) ExecuteTemplate(wr io.Writer, name string, data interface{}) error</li>
<li>func (t *Template) Funcs(funcMap FuncMap) *Template</li>
<li>func (t *Template) Lookup(name string) *Template</li>
<li>func (t *Template) Name() string</li>
<li>func (t *Template) New(name string) *Template</li>
<li>func (t *Template) Parse(src string) (*Template, error)</li>
<li>func (t *Template) ParseFiles(filenames ...string) (*Template, error)</li>
<li>func (t *Template) ParseGlob(pattern string) (*Template, error)</li>
<li>func (t *Template) Templates() []*Template</li>
</ul>
</li>
<li>type URL</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>#func HTMLEscape(w io.Writer, b []byte)</p>
<p>##参数</p>
<ul>
<li>w io.Writer 	写入的Writer</li>
<li>b []byte 		需要进行转义的内容</li>
</ul>
<p>##功能说明
HTMLEscape用于将b转义后的HTML文本写入到w中.</p>
<p>##代码示例</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
	&quot;html/template&quot;
)

func main() {

	w := bytes.NewBufferString(&quot;&quot;)

	b := []byte(&quot;&lt;script&gt;alert('xss!')&lt;/script&gt;&quot;)

	template.HTMLEscape(w, b)

	fmt.Println(w)

}
</code></pre>
<p>输出:	
<code>&amp;lt;script&amp;gt;alert(&amp;#39;xss!&amp;#39;)&amp;lt;/script&amp;gt;</code></p>
<div style="break-before: page; page-break-before: always;"></div><p>#func HTMLEscaper(args ...interface{}) string</p>
<p>##参数</p>
<ul>
<li>args 多个输入参数</li>
</ul>
<p>##返回</p>
<ul>
<li>string 转义后的字符串</li>
</ul>
<p>##功能说明
HTMLEscaper 返回多个参数一起转义后的字符串</p>
<p>##代码示例</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;html/template&quot;
)

func main() {

	a := &quot;&lt;script&gt;alert('xss!')&lt;/script&gt;&quot;

	b := &quot;&lt;h1&gt;Raymond&lt;/h1&gt;&quot;

	c := &quot;&lt;h2&gt;Chou&lt;/h2&gt;&quot;

	fmt.Println(template.HTMLEscaper(a, b, c))

}
</code></pre>
<p>输出:	
<code>&amp;lt;script&amp;gt;alert(&amp;#39;xss!&amp;#39;)&amp;lt;/script&amp;gt;&amp;lt;h1&amp;gt;Raymond&amp;lt;/h1&amp;gt;&amp;lt;h2&amp;gt;Chou&amp;lt;/h2&amp;gt;</code></p>
<div style="break-before: page; page-break-before: always;"></div><p>#func HTMLEscapeString(s string) string</p>
<p>##参数</p>
<ul>
<li>s string 需要进行转义的字符串</li>
</ul>
<p>##返回</p>
<ul>
<li>string 转义后的字符串</li>
</ul>
<p>##功能说明
HTMLEscapeString返回s转义后的HTML文本.</p>
<p>##代码示例</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;html/template&quot;
)

func main() {

	s := &quot;&lt;script&gt;alert('xss!')&lt;/script&gt;&quot;

	fmt.Println(template.HTMLEscapeString(s))

}
</code></pre>
<p>输出:	
<code>&amp;lt;script&amp;gt;alert(&amp;#39;xss!&amp;#39;)&amp;lt;/script&amp;gt;</code></p>
<div style="break-before: page; page-break-before: always;"></div><p>#func EscapeString(s string) string</p>
<p>##参数</p>
<ul>
<li>s string 需要转义的字符串</li>
</ul>
<p>##返回</p>
<ul>
<li>string 转义后的字符串</li>
</ul>
<p>##功能说明
EscapeString用于将特殊字符转移为html实体,如把<code>&lt;</code>转义成<code>&amp;lt;</code><br />
它只会转义下列五种字符: <code>&lt;</code> <code>&gt;</code> <code>&amp;</code> <code>'</code>  <code>&quot;</code><br />
需要注意的是 <code>UnescapeString(EscapeString(s)) == s</code> 返回结果一定是true,但是反过来就不一定是true了</p>
<p>##代码示例</p>
<pre><code>package main

import &quot;fmt&quot;
import &quot;html&quot;

func main() {
    var s string = &quot;&lt;script&gt;alert('xss')&lt;/script&gt;&quot;
    fmt.Println(html.EscapeString(s))
}
</code></pre>
<p>输出结果:
<code>&amp;lt;script&amp;gt;alert(&amp;#39;xss&amp;#39;)&amp;lt;/script&amp;gt;</code></p>
<div style="break-before: page; page-break-before: always;"></div><p>#func UnescapeString(s string) string</p>
<p>##参数</p>
<ul>
<li>s string 需要反转义的字符串</li>
</ul>
<p>##返回</p>
<ul>
<li>string 反转义后的字符串</li>
</ul>
<p>##功能说明
UnescapeString用于将html实体转义回特殊字符,如把<code>&amp;lt;</code>转义成<code>&lt;</code><br />
此函数可以反转义的html实体比EscapeString可转义的更多,EscapeString只会转义下列五种字符: <code>&lt;</code> <code>&gt;</code> <code>&amp;</code> <code>'</code>  <code>&quot;</code><br />
例如,<code>&amp;aacute;</code> <code>&amp;#225;</code> <code>&amp;nbsp;</code> 这些都可以被反转义为特殊字符	
需要注意的是 <code>UnescapeString(EscapeString(s)) == s</code> 返回结果一定是true,但是反过来就不一定是true了</p>
<p>##代码示例</p>
<pre><code>package main

import &quot;fmt&quot;
import &quot;html&quot;

func main() {
	var s string = &quot;&amp;#225;&amp;nbsp;&amp;#225;&amp;nbsp;&amp;#225;&quot;
	fmt.Println(html.UnescapeString(s))
}
</code></pre>
<p>输出结果:<br />
<code>á á á</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名-35"><a class="header" href="#包名-35">包名</a></h1>
<p>函数列表</p>
<ul>
<li>xxx1</li>
<li>xxx2</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名-36"><a class="header" href="#包名-36">包名</a></h1>
<p>函数列表</p>
<ul>
<li>xxx1</li>
<li>xxx2</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名-37"><a class="header" href="#包名-37">包名</a></h1>
<p>函数列表</p>
<ul>
<li>xxx1</li>
<li>xxx2</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名-38"><a class="header" href="#包名-38">包名</a></h1>
<p>函数列表</p>
<ul>
<li>xxx1</li>
<li>xxx2</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名-39"><a class="header" href="#包名-39">包名</a></h1>
<p>函数列表</p>
<ul>
<li>xxx1</li>
<li>xxx2</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名-40"><a class="header" href="#包名-40">包名</a></h1>
<p>函数列表</p>
<ul>
<li>xxx1</li>
<li>xxx2</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名-41"><a class="header" href="#包名-41">包名</a></h1>
<p>函数列表</p>
<ul>
<li>xxx1</li>
<li>xxx2</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="suffixarray函数包列表"><a class="header" href="#suffixarray函数包列表">suffixarray函数包列表</a></h1>
<p>函数列表</p>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/index/suffixarray/New.html">func New(data []byte) *Index</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/index/suffixarray/Bytes.html">func (x *Index) Bytes() []byte</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/index/suffixarray/FindAllIndex.html">func (x *Index) FindAllIndex(r *regexp.Regexp, n int) (result [][]int)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/index/suffixarray/Lookup.html">func (x *Index) Lookup(s []byte, n int) (result []int)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/index/suffixarray/Read.html">func (x *Index) Read(r io.Reader) error</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/index/suffixarray/Write.html">func (x *Index) Write(w io.Writer) error</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-x-index-bytes-byte"><a class="header" href="#func-x-index-bytes-byte">func (x *Index) Bytes() []byte</a></h2>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值</p>
<ul>
<li>返回[]byte类型</li>
</ul>
<p>功能说明： 获取Index的数据</p>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;index/suffixarray&quot;
)

func main() {
	data := []byte(&quot;aaaa&quot;)
	index := suffixarray.New(data) 
	fmt.Println(index.Bytes()) //[97,97,97,97]
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-x-index-findallindexr-regexpregexp-n-int-result-int"><a class="header" href="#func-x-index-findallindexr-regexpregexp-n-int-result-int">func (x *Index) FindAllIndex(r *regexp.Regexp, n int) (result [][]int)</a></h2>
<p>参数列表</p>
<ul>
<li>r 正则表达式</li>
<li>n 查找返回结果的个数</li>
</ul>
<p>返回值</p>
<ul>
<li>返回int二维数组类型</li>
</ul>
<p>功能说明： 根据正则表达式查找所有的索引，并返回匹配结果在数据中的位置（结果已排序）</p>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;index/suffixarray&quot;
	&quot;regexp&quot;
)

func main() {
	data := []byte(&quot;aaaaaaa&quot;)
	index := suffixarray.New(data)
	str := &quot;[a+]&quot;
	r, _ := regexp.Compile(str)
	res := index.FindAllIndex(r, 1)
	fmt.Println(res) //[[0 1]]
	res = index.FindAllIndex(r, 3)
	fmt.Println(res) //[[0 1][1 2][2 3]]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-x-index-lookups-byte-n-int-result-int"><a class="header" href="#func-x-index-lookups-byte-n-int-result-int">func (x *Index) Lookup(s []byte, n int) (result []int)</a></h2>
<p>参数列表</p>
<ul>
<li>s 需要查找的byte类型数组</li>
<li>n 返回结果的个数，n&lt;0 则返回全部</li>
</ul>
<p>返回值</p>
<ul>
<li>返回int数组类型</li>
</ul>
<p>功能说明：根据输入byte数组查找索引，并返回匹配结果在数据中的位置（结果未排序）</p>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;index/suffixarray&quot;
)

func main() {
	data := []byte(&quot;aaaaaaa&quot;)
	index := suffixarray.New(data)
	str := []byte(&quot;a&quot;)
	res := index.Lookup(str, 1)
	fmt.Println(res) //[6]
	res = index.Lookup(str, 3)
	fmt.Println(res) //[6 5 4]
	res = index.Lookup(str, -1)
	fmt.Println(res) //[6 5 4 3 2 1 0]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-newdata-byte-index"><a class="header" href="#func-newdata-byte-index">func New(data []byte) *Index</a></h2>
<p>参数列表</p>
<ul>
<li>data 需要创建Index的数据</li>
</ul>
<p>返回值</p>
<ul>
<li>返回Index类型</li>
</ul>
<p>功能说明： 创建一个索引</p>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;index/suffixarray&quot;
)

func main() {
	data := []byte(&quot;aaaa&quot;)
	index := suffixarray.New(data) 
	
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-x-index-readr-ioreader-error"><a class="header" href="#func-x-index-readr-ioreader-error">func (x *Index) Read(r io.Reader) error</a></h2>
<p>参数列表</p>
<ul>
<li>r 字符流</li>
</ul>
<p>返回值</p>
<ul>
<li>返回错误类型</li>
</ul>
<p>功能说明： 从一个字符流中读取数据到索引</p>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
	&quot;index/suffixarray&quot;
)

func main() {
	data := []byte(&quot;aa&quot;)
	x := suffixarray.New(data)
	var buf bytes.Buffer
	if err := x.Write(&amp;buf); err != nil {
		fmt.Println(&quot;failed writing index %s&quot;, err)
	}
	size := buf.Len()
	var y suffixarray.Index
	if err := y.Read(&amp;buf); err != nil {
		fmt.Println(&quot;failed reading index %s &quot;, err)
	}
	fmt.Println(y.Bytes()) //[97 97]
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-x-index-writew-iowriter-error"><a class="header" href="#func-x-index-writew-iowriter-error">func (x *Index) Write(w io.Writer) error</a></h2>
<p>参数列表</p>
<ul>
<li>r 字符流</li>
</ul>
<p>返回值</p>
<ul>
<li>返回错误类型</li>
</ul>
<p>功能说明： 把字符流写入到索引中</p>
<p>代码示例</p>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
	&quot;index/suffixarray&quot;
)

func main() {
	data := []byte(&quot;aa&quot;)
	x := suffixarray.New(data)
	var buf bytes.Buffer //0
	fmt.Println(buf.Len())
	if err := x.Write(&amp;buf); err != nil {
		fmt.Println(&quot;failed writing index %s&quot;, err)
	}
	fmt.Println(buf.Len()) //24
	
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名--io"><a class="header" href="#包名--io">包名  io</a></h1>
<p>函数列表</p>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/io/Copy.html">func Copy(dst Writer, src Reader) (written int64, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/io/CopyN.html">func CopyN(dst Writer, src Reader, n int64) (written int64, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/io/LimitReader.html">func LimitReader(r Reader, n int64) Reader</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/io/LimitReader.Read.html">func (l *LimitedReader) Read(p []byte) (n int, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/io/MultiReader.html">func MultiReader(readers ...Reader) Reader</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/io/MultiWriter.html">func MultiWriter(writers ...Writer) Writer</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/io/NewSectionReade.html">func NewSectionReader(r ReaderAt, off int64, n int64) *SectionReader</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/io/Pipe.html">func Pipe() (*PipeReader, *PipeWriter)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/io/ReadAtLeast.html">func ReadAtLeast(r Reader, buf []byte, min int) (n int, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/io/ReadFull.html">func ReadFull(r Reader, buf []byte) (n int, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/io/PipeReader.Close.html">func (r *PipeReader) Close() error</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/io/PipeReader.CloseWithError.html">func (r *PipeReader) CloseWithError(err error) error</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/io/PipeReader.Read.html">func (r *PipeReader) Read(data []byte) (n int, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/io/SectionReader.ReadAt.html">func (s *SectionReader) ReadAt(p []byte, off int64) (n int, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/io/SectionReader.Read.html">func (s *SectionReader) Read(p []byte) (n int, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/io/SectionReader.Seek.html">func (s *SectionReader) Seek(offset int64, whence int) (ret int64, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/io/SectionReader.Size.html">func (s *SectionReader) Size() int64</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/io/TeeReader.Read.html">func TeeReader(r Reader, w Writer) Reader</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/io/PipeWriter.Close.html">func (w *PipeWriter) Close() error</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/io/PipeWriter.CloseWithError.html">func (w *PipeWriter) CloseWithError(err error) error</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/io/PipeWriter.Write.html">func (w *PipeWriter) Write(data []byte) (n int, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/io/WriteString.html">func WriteString(w Writer, s string) (n int, err error)</a></li>
<li></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名-ioutil"><a class="header" href="#包名-ioutil">包名 ioutil</a></h1>
<p>函数列表</p>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/io/ioutil/NopCloser.html">func NopCloser(r io.Reader) io.ReadCloser</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/io/ioutil/ReadAll.html">func ReadAll(r io.Reader) ([]byte, error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/io/ioutil/ReadDir.html">func ReadDir(dirname string) ([]os.FileInfo, error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/io/ioutil/ReadFile.html">func ReadFile(filename string) ([]byte, error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/io/ioutil/TempDir.html">func TempDir(dir, prefix string) (name string, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/io/ioutil/TempFile.html">func TempFile(dir, prefix string) (f *os.File, err error)</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-nopcloserr-ioreader-ioreadcloser"><a class="header" href="#func-nopcloserr-ioreader-ioreadcloser">func NopCloser(r io.Reader) io.ReadCloser</a></h1>
<p>参数列表</p>
<ul>
<li>r 读取对象 </li>
</ul>
<p>返回值：</p>
<ul>
<li>返回一个读取对象ReadCloser接口，该接口仅提供Close方法。</li>
</ul>
<p>功能说明：</p>
<p>本函数主要是用来返回一个读取对象的ReadCloser接口，该接口仅提供Close方法</p>
<p>代码实例：</p>
<pre><code>package main

import &quot;io/ioutil&quot;
import &quot;strings&quot;

func main() {
	s := strings.NewReader(&quot;hello world!&quot;)
	r := ioutil.NopCloser(s)
	defer r.Close()
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-readallr-ioreader-byte-error"><a class="header" href="#func-readallr-ioreader-byte-error">func ReadAll(r io.Reader) ([]byte, error)</a></h1>
<p>参数列表</p>
<ul>
<li>r 读取对象 </li>
</ul>
<p>返回值：</p>
<ul>
<li>[]byte 返回读取对象的内容</li>
<li>error 返回读取是否成功</li>
</ul>
<p>功能说明：</p>
<p>本函数主要是用来从r读取直到遇到error或EOF并返回读取的数据；成功的读取返回的err为nil，而不是EOF。因为ReadAll定义为从资源读取数据直到EOF，它不会将从r读取的EOF视为应该报告的错误</p>
<p>代码实例：</p>
<pre><code>package main

import &quot;fmt&quot;
import &quot;io/ioutil&quot;
import &quot;strings&quot;

func main() {
	s := strings.NewReader(&quot;hello world!&quot;)
	b, e := ioutil.ReadAll(s)
	if e != nil {
		fmt.Printf(&quot;%v\n&quot;, e)
		return
	}
	fmt.Println(string(b))
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-readdirdirname-string-osfileinfo-error"><a class="header" href="#func-readdirdirname-string-osfileinfo-error">func ReadDir(dirname string) ([]os.FileInfo, error)</a></h1>
<p>参数列表</p>
<ul>
<li>dirname 读取目录的目录路径 </li>
</ul>
<p>返回值：</p>
<ul>
<li>[]os.FileInfo 返回指定dirname目录下的一个有序的子目录信息列表</li>
<li>error 返回读取是否成功</li>
</ul>
<p>功能说明：</p>
<p>本函数主要是用来读取指定dirname目录，并返回一个有序的子目录信息列表</p>
<p>代码实例：</p>
<pre><code>package main

import &quot;fmt&quot;
import &quot;io/ioutil&quot;

func main() {
	dir_list, e := ioutil.ReadDir(&quot;d:/goTest&quot;)
	if e != nil {
		fmt.Println(&quot;read dir error&quot;)
		return
	}
	for i, v := range dir_list {
		fmt.Println(i, &quot;=&quot;, v.Name())
	}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-readfilefilename-string-byte-error"><a class="header" href="#func-readfilefilename-string-byte-error">func ReadFile(filename string) ([]byte, error)</a></h1>
<p>参数列表</p>
<ul>
<li>filename 读取文件的名称(包括文件目录及名称) </li>
</ul>
<p>返回值：</p>
<ul>
<li>[]byte 返回读取指定文件的内容</li>
<li>error 返回读取文件是否成功</li>
</ul>
<p>功能说明：</p>
<p>本函数主要是用来从指定的filename文件中读取数据并返回文件的内容；成功的调用返回的err为nil，而不是EOF。因为ReadFile定义为从资源读取数据直到EOF，它不会将从r读取的EOF视为应该报告的错误</p>
<p>代码实例：</p>
<pre><code>package main

import &quot;fmt&quot;
import &quot;io/ioutil&quot;

func main() {
	b, e := ioutil.ReadFile(&quot;d:/goTest/123.txt&quot;)
	if e != nil {
		fmt.Println(&quot;read file error&quot;)
		return
	}
	fmt.Println(string(b))
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-tempdirdir-prefix-string-name-string-err-error"><a class="header" href="#func-tempdirdir-prefix-string-name-string-err-error">func TempDir(dir, prefix string) (name string, err error)</a></h1>
<p>参数列表</p>
<ul>
<li>dir 创建临时目录的父目录</li>
<li>prefix 创建临时目录的前缀</li>
</ul>
<p>返回值：</p>
<ul>
<li>name 返回创建的临时目录名称(名称的组成为前缀+随机数)</li>
<li>error 返回创建临时目录是否成功</li>
</ul>
<p>功能说明：</p>
<p>本函数主要是用来在指定的dir目录里创建一个新的、使用prfix作为前缀的临时文件夹，并返回文件夹的路径。 如果dir是空字符串，TempDir使用默认用于临时文件的目录（参见os.TempDir函数）。 如果多个程序调用该函数的话，将会创建不同的临时目录（因此是线程安全的）。调用本函数的程序有责任在不需要临时文件夹时摧毁它。</p>
<p>代码实例：</p>
<pre><code>package main

import &quot;fmt&quot;
import &quot;io/ioutil&quot;

func main() {
	f, e := ioutil.TempDir(&quot;d:/goTest&quot;, &quot;temp&quot;)
	if e != nil {
		fmt.Println(&quot;create tempDir error&quot;)
		return
	}
	fmt.Println(f)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-tempfiledir-prefix-string-f-osfile-err-error"><a class="header" href="#func-tempfiledir-prefix-string-f-osfile-err-error">func TempFile(dir, prefix string) (f *os.File, err error)</a></h1>
<p>参数列表</p>
<ul>
<li>dir 创建临时文件的目录</li>
<li>prefix 创建临时文件名称的前缀(文件名称组成为前缀+随机数)</li>
</ul>
<p>返回值：</p>
<ul>
<li>f 返回创建的临时文件的指针</li>
<li>error 返回创建临时文件是否成功</li>
</ul>
<p>功能说明：</p>
<p>本函数主要是用来在指定的dir目录下创建一个新的、使用prefix为前缀的临时文件，并以读写模式打开该文件并返回os.File指针。 如果dir是空字符串，TempFile使用默认用于临时文件的目录（参见os.TempDir函数）。 如果多个程序调用该函数的话，将会创建不同的临时文件（因此是线程安全的）。调用本函数的程序有责任在不需要临时文件时摧毁它.</p>
<p>代码实例：</p>
<pre><code>package main

import &quot;fmt&quot;
import &quot;io/ioutil&quot;

func main() {
	f, e := ioutil.TempFile(&quot;d:/goTest&quot;, &quot;temp&quot;)
	defer f.Close()
	fmt.Println(f.Name())
	if e != nil {
		fmt.Println(&quot;create tempFile error&quot;)
		return
	}
	f.WriteString(&quot;hello world!&quot;)
	b, e1 := ioutil.ReadFile(f.Name())
	if e1 != nil {
		fmt.Println(&quot;read error&quot;)
		return
	}
	fmt.Println(string(b))
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-copydst-writer-src-reader-written-int64-err-error"><a class="header" href="#func-copydst-writer-src-reader-written-int64-err-error">func Copy(dst Writer, src Reader) (written int64, err error)</a></h1>
<p>参数：</p>
<ul>
<li>dst 拷贝目标写入器</li>
<li>src 拷贝源读取器</li>
</ul>
<p>返回值：</p>
<ul>
<li>written 拷贝字节数</li>
<li>err 拷贝是否成功；nil代表拷贝成功</li>
</ul>
<p>功能说明：
向dst拷贝src的全部数据；读取src中数据直到EOF，故不会返回io.EOF</p>
<p>可能的异常：
io.ErrShortWrite:写入数据不等于读取数据</p>
<p>示例：
package main</p>
<pre><code>import (
	&quot;io&quot;
	&quot;fmt&quot;
	&quot;os&quot;
)

func main() {
	srcFile, _ := os.Open(&quot;copySrc.txt&quot;)
	destFile, _ := os.Create(&quot;copyDest.txt&quot;)
	written, err := io.Copy(destFile, srcFile)
	if err == nil {
		fmt.Println(&quot;Copy Success! total&quot;, written, &quot;bytes&quot;)
	}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-copyndst-writer-src-reader-n-int64-written-int64-err-error"><a class="header" href="#func-copyndst-writer-src-reader-n-int64-written-int64-err-error">func CopyN(dst Writer, src Reader, n int64) (written int64, err error)</a></h1>
<p>参数：</p>
<ul>
<li>dst 拷贝目标写入器</li>
<li>src 拷贝源读取器</li>
<li>n 拷贝的字节数</li>
</ul>
<p>返回值：</p>
<ul>
<li>written 拷贝字节数</li>
<li>err 拷贝是否成功；nil代表拷贝成功</li>
</ul>
<p>功能说明：</p>
<ul>
<li>向dst拷贝src的n比特数据</li>
</ul>
<p>可能的异常：</p>
<ul>
<li>io.EOF：当n&gt;src字节数时，拷贝src全部数据并返回src字节数</li>
<li>io.ErrShortWrite:写入数据不等于读取数据</li>
</ul>
<p>示例：
package main</p>
<pre><code>import (
	&quot;io&quot;
	&quot;fmt&quot;
	&quot;os&quot;
)

func main() {
	srcFile, _ := os.Open(&quot;copySrc.txt&quot;)
	destFile, _ := os.Create(&quot;copyDest.txt&quot;)
	written, err := io.CopyN(destFile, srcFile, 15)
	if err == nil {
		fmt.Println(&quot;Copy Success! total&quot;, written, &quot;bytes&quot;)
	}
	if err == io.EOF {
		fmt.Println(&quot;Copy all total&quot;, written, &quot;bytes&quot;)
	}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-limitreaderr-reader-n-int64-reader"><a class="header" href="#func-limitreaderr-reader-n-int64-reader">func LimitReader(r Reader, n int64) Reader</a></h1>
<p>参数：</p>
<ul>
<li>r 读取器</li>
<li>n 限定字节数</li>
</ul>
<p>返回值：LimitReader对象</p>
<p>LimitReader对象说明：</p>
<ul>
<li>是对Reader对象的一种封装，限定Reader数据的读取数量</li>
</ul>
<p>功能说明：</p>
<ul>
<li>获得一个只能从r读取n比特数据的Reader</li>
</ul>
<p>示例：
package main</p>
<pre><code>import (
	&quot;io&quot;
	&quot;fmt&quot;
	&quot;os&quot;
	&quot;reflect&quot;
)

func main() {
	reader, _ := os.Open(&quot;readFile.txt&quot;)
	limitReader := io.LimitReader(reader, 20)
	fmt.Println(reflect.TypeOf(limitReader))
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-l-limitedreader-readp-byte-n-int-err-error"><a class="header" href="#func-l-limitedreader-readp-byte-n-int-err-error">func (l *LimitedReader) Read(p []byte) (n int, err error)</a></h1>
<p>参数：</p>
<ul>
<li>p 存放读取结果的比特数组</li>
</ul>
<p>返回值：</p>
<ul>
<li>n 读取的字节数</li>
<li>err 读取是否成功；nil代表成功</li>
</ul>
<p>功能说明：</p>
<ul>
<li>在LimitedReader中读取数据，并存入p中；每次读取后，限定字节数=限定字节数-len(p)；若len(p)&gt;限定字节数，len(p):=限定字节数；若限定字节数&lt;=0,返回io.EOF，所以io.EOF代表读取完毕</li>
</ul>
<p>示例：
package main;</p>
<pre><code>import (
	&quot;io&quot;
	&quot;fmt&quot;
	&quot;os&quot;
)

func main() {
	reader, _ := os.Open(&quot;readFile.txt&quot;)
	limitReader := io.LimitReader(reader, 20)
	var n, total int
	var err error
	p := make([]byte, 15)
	for {
		n, err = limitReader.Read(p)
		if err == io.EOF {
			fmt.Println(&quot;Read end total&quot;, total)
			break
		}
		total = total + n
		fmt.Println(&quot;Read value:&quot;, string(p[0:n]))
		fmt.Println(&quot;Read count:&quot;, n)
	}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-multireaderreaders-reader-reader"><a class="header" href="#func-multireaderreaders-reader-reader">func MultiReader(readers ...Reader) Reader</a></h1>
<p>参数：</p>
<ul>
<li>readers 不定参数，为若干读取器</li>
</ul>
<p>返回值：MultiReader</p>
<p>MultiReader说明：</p>
<ul>
<li>封装多个Reader，可实现多个Reader连续读取，就想在读取一个Reader一样</li>
</ul>
<p>功能说明：</p>
<ul>
<li>获得一个可以对参数中的多个Reader进行连续读取的Reader</li>
</ul>
<p>示例：
package main</p>
<pre><code>import (
	&quot;io&quot;
	&quot;fmt&quot;
	&quot;os&quot;
	&quot;reflect&quot;
)

func main() {
	reader1, _ := os.Open(&quot;src1.txt&quot;)
	reader2, _ := os.Open(&quot;src2.txt&quot;)
	multiReader := io.MultiReader(reader1, reader2)
	fmt.Println(reflect.TypeOf(multiReader))
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-mr-multireader-readp-byte-n-int-err-error"><a class="header" href="#func-mr-multireader-readp-byte-n-int-err-error">func (mr *multiReader) Read(p []byte) (n int, err error)</a></h1>
<p>参数：</p>
<ul>
<li>p 存放读取结果的比特数组</li>
</ul>
<p>返回值：</p>
<ul>
<li>n 读取字节数</li>
<li>err 读取是否成功，nil代表成功</li>
</ul>
<p>功能说明：</p>
<ul>
<li>在MultiReader中读取数据（连续从多个封装的Reader中读取），并存入p中；读完最后一个封装的Reader后返回io.EOF，所以io.EOF代表读取完毕</li>
</ul>
<p>示例：
package main;</p>
<pre><code>import (
	&quot;io&quot;
	&quot;fmt&quot;
	&quot;os&quot;
)

func main() {
	reader1, _ := os.Open(&quot;src1.txt&quot;)
	reader2, _ := os.Open(&quot;src2.txt&quot;)
	multiReader := io.MultiReader(reader1, reader2)
	var n, total int
	var err error
	p := make([]byte, 15)
	for {
		n, err = multiReader.Read(p)
		if err == io.EOF {
			fmt.Println(&quot;Read end total&quot;, total)
			break
		}
		total = total + n
		fmt.Println(&quot;Read value:&quot;, string(p[0:n]))
		fmt.Println(&quot;Read count:&quot;, n)
	}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-multiwriterwriters-writer-writer"><a class="header" href="#func-multiwriterwriters-writer-writer">func MultiWriter(writers ...Writer) Writer</a></h1>
<p>参数：</p>
<ul>
<li>writers 不定参数，为若干写入器</li>
</ul>
<p>返回值：MultiWriter</p>
<p>MultiWriter说明：</p>
<ul>
<li>封装多个Writer，统一的Write操作可以将数据同时写入多目标</li>
</ul>
<p>功能说明：</p>
<ul>
<li>获得一个可以对多Writer同时写入的Writer</li>
</ul>
<p>示例：
package main</p>
<pre><code>import (
	&quot;io&quot;
	&quot;fmt&quot;
	&quot;os&quot;
	&quot;reflect&quot;
)

func main() {
	writer1, _ := os.Create(&quot;dst1.txt&quot;)
	writer2, _ := os.Create(&quot;dst2.txt&quot;)
	multiWriter := io.MultiWriter(writer1, writer2)
	fmt.Println(reflect.TypeOf(multiWriter))
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-t-multiwriter-writep-byte-n-int-err-error"><a class="header" href="#func-t-multiwriter-writep-byte-n-int-err-error">func (t *multiWriter) Write(p []byte) (n int, err error)</a></h1>
<p>参数：</p>
<ul>
<li>p 写入的数据</li>
</ul>
<p>返回值：</p>
<ul>
<li>n 写入字节数</li>
<li>err 写入是否成功，nil代表成功</li>
</ul>
<p>功能说明：</p>
<ul>
<li>将p中的数据同时写入MultiWriter的多个Writer中</li>
</ul>
<p>示例：
package main</p>
<pre><code>import (
	&quot;io&quot;
	&quot;fmt&quot;
	&quot;os&quot;
)

func main() {
	writer1, _ := os.Create(&quot;dst1.txt&quot;)
	writer2, _ := os.Create(&quot;dst2.txt&quot;)
	multiWriter := io.MultiWriter(writer1, writer2)
	p := []byte(&quot;Write to multi dest&quot;)
	n, err := multiWriter.Write(p)
	if err == nil {
		fmt.Println(&quot;Write success total&quot;, n)
	}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-newsectionreaderr-readerat-off-int64-n-int64-sectionreader"><a class="header" href="#func-newsectionreaderr-readerat-off-int64-n-int64-sectionreader">func NewSectionReader(r ReaderAt, off int64, n int64) *SectionReader</a></h1>
<p>参数：</p>
<ul>
<li>r 源读取器</li>
<li>off 偏移量（从r的第off+1个字节开始读）</li>
<li>n 可读取字节数量</li>
</ul>
<p>返回值：SectionReader对象</p>
<p>功能说明：</p>
<ul>
<li>创建一个SectionReader</li>
</ul>
<p>SectionReader说明：</p>
<ul>
<li>实现对Reader的部分读取</li>
</ul>
<p>示例：
package main</p>
<pre><code>import (
	&quot;io&quot;
	&quot;os&quot;
	&quot;fmt&quot;
	&quot;reflect&quot;
)

func main() {
	reader, _ := os.Open(&quot;src.txt&quot;)
	sectionReader := io.NewSectionReader(reader, 5, 10)
	fmt.Println(reflect.TypeOf(sectionReader))
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-pipe-pipereader-pipewriter"><a class="header" href="#func-pipe-pipereader-pipewriter">func Pipe() (*PipeReader, *PipeWriter)</a></h1>
<p>返回值：</p>
<ul>
<li>PipeReader：管道读取器</li>
<li>PipeWriter：管道写入器</li>
</ul>
<p>功能说明：</p>
<ul>
<li>创建一个管道，并返回它的读取器和写入器</li>
</ul>
<p>示例：
package main</p>
<pre><code>import (
	&quot;io&quot;
	&quot;fmt&quot;
	&quot;reflect&quot;
)

func main() {
	reader, writer := io.Pipe()
	fmt.Println(reflect.TypeOf(reader))
	fmt.Println(reflect.TypeOf(writer))
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-r-pipereader-close-error"><a class="header" href="#func-r-pipereader-close-error">func (r *PipeReader) Close() error</a></h1>
<p>返回值：关闭是否成功，nil代表成功</p>
<p>功能说明：</p>
<ul>
<li>关闭管道，关闭后管道将不能写入</li>
</ul>
<p>可能的异常：</p>
<ul>
<li>管道关闭后，正在进行或后续的写入Write操作返回ErrClosedPipe</li>
</ul>
<p>示例：
package main;</p>
<pre><code>import (
	&quot;io&quot;
	&quot;fmt&quot;
)

func main() {
	reader, writer := io.Pipe()
	inputData := []byte(&quot;1234567890&quot;)
	reader.Close()
	c := make(chan error)
	go func() {
		_, err := writer.Write(inputData)
		c &lt;- err
	}()
	if io.ErrClosedPipe == &lt;-c {
		fmt.Println(&quot;return ErrClosedPipe&quot;)
	}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-r-pipereader-closewitherrorerr-error-error"><a class="header" href="#func-r-pipereader-closewitherrorerr-error-error">func (r *PipeReader) CloseWithError(err error) error</a></h1>
<p>参数：</p>
<ul>
<li>err 任何实现err接口的对象</li>
</ul>
<p>返回值：关闭是否成功，nil代表成功</p>
<p>功能说明：</p>
<ul>
<li>关闭管道，关闭后管道将不能写入；管道关闭后，正在进行或后续的写入Write操作返回参数传入的异常</li>
</ul>
<p>示例：
package main;</p>
<pre><code>import (
	&quot;io&quot;
	&quot;fmt&quot;
	&quot;errors&quot;
)

func main() {
	reader, writer := io.Pipe()
	inputData := []byte(&quot;1234567890&quot;)
	var customErr = errors.New(&quot;Custom Error For CloseWithError&quot;)
	reader.CloseWithError(customErr)
	c := make(chan error)
	go func() {
		_, err := writer.Write(inputData)
		c &lt;- err
	}()
	fmt.Println(&lt;-c)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-r-pipereader-readdata-byte-n-int-err-error"><a class="header" href="#func-r-pipereader-readdata-byte-n-int-err-error">func (r *PipeReader) Read(data []byte) (n int, err error)</a></h1>
<p>参数：</p>
<ul>
<li>data 存放读取结果的比特数组</li>
</ul>
<p>返回值：</p>
<ul>
<li>n 读取比特数</li>
<li>err 读取是否成功，nil代表成功</li>
</ul>
<p>功能说明：</p>
<ul>
<li>从管道中读取数据，并存放到data中</li>
</ul>
<p>示例：
package main;</p>
<pre><code>import (
	&quot;io&quot;
	&quot;fmt&quot;
)

func main() {
	reader, writer := io.Pipe()
	inputData := []byte(&quot;1234567890&quot;)
	go writer.Write(inputData)
	outputData := make([]byte, 10)
	n, _ := reader.Read(outputData)
	fmt.Println(string(outputData))
	fmt.Println(&quot;read number&quot;, n)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-w-pipewriter-close-error"><a class="header" href="#func-w-pipewriter-close-error">func (w *PipeWriter) Close() error</a></h1>
<p>返回值：关闭是否成功，nil代表成功</p>
<p>功能说明：</p>
<ul>
<li>关闭管道，关闭时正在进行的Read操作将返回EOF，若管道内仍有未读取的数据，后续仍可正常读取</li>
</ul>
<p>示例：
package main;</p>
<pre><code>import (
	&quot;io&quot;
	&quot;fmt&quot;
)

func main() {
	reader, writer := io.Pipe()
	inputData := []byte(&quot;1234567890&quot;)
	go writer.Write(inputData)
	writer.Close()
	outputData := make([]byte, 10)
	n, err := reader.Read(outputData)
	if err == io.EOF {
		fmt.Println(&quot;executing read return EOF&quot;)
		fmt.Println(&quot;executing read reads number&quot;, n)
	}
	n, _ = reader.Read(outputData)
	fmt.Println(string(outputData))
	fmt.Println(&quot;next read number&quot;, n)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-w-pipewriter-closewitherrorerr-error-error"><a class="header" href="#func-w-pipewriter-closewitherrorerr-error-error">func (w PipeWriter) CloseWithError(err error) error</a></h1>
<p>返回值：关闭是否成功，nil代表成功</p>
<p>功能说明：</p>
<ul>
<li>关闭管道，关闭时正在进行的Read操作将返回参数传入的异常，若管道内仍有未读取的数据，后续仍可正常读取</li>
</ul>
<p>示例：
package main;</p>
<pre><code>import (
	&quot;io&quot;
	&quot;fmt&quot;
	&quot;errors&quot;
)

func main() {
	reader, writer := io.Pipe()
	inputData := []byte(&quot;1234567890&quot;)
	go writer.Write(inputData)
	var customErr = errors.New(&quot;Custom Error For CloseWithError&quot;)
	writer.CloseWithError(customErr)
	outputData := make([]byte, 10)
	n, err := reader.Read(outputData)
	fmt.Println(&quot;executing read return&quot;, err)
	fmt.Println(&quot;executing read reads number&quot;, n)
	n, _ = reader.Read(outputData)
	fmt.Println(string(outputData))
	fmt.Println(&quot;next read number&quot;, n)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-w-pipewriter-writedata-byte-n-int-err-error"><a class="header" href="#func-w-pipewriter-writedata-byte-n-int-err-error">func (w *PipeWriter) Write(data []byte) (n int, err error)</a></h1>
<p>参数：</p>
<ul>
<li>data 写入管道的比特数据</li>
</ul>
<p>返回值：</p>
<ul>
<li>n 写入比特数</li>
<li>err 写入是否成功，nil代表成功</li>
</ul>
<p>功能说明：</p>
<ul>
<li>将data比特数组的数据写入管道</li>
</ul>
<p>示例：
package main;</p>
<pre><code>import (
	&quot;io&quot;
	&quot;fmt&quot;
)

func main() {
	reader, writer := io.Pipe()
	inputData := []byte(&quot;1234567890&quot;)
	go writer.Write(inputData)
	outputData := make([]byte, 10)
	n, _ := reader.Read(outputData)
	fmt.Println(string(outputData))
	fmt.Println(&quot;read number&quot;, n)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-readatleastr-reader-buf-byte-min-int-n-int-err-error"><a class="header" href="#func-readatleastr-reader-buf-byte-min-int-n-int-err-error">func ReadAtLeast(r Reader, buf []byte, min int) (n int, err error)</a></h1>
<p>参数：</p>
<ul>
<li>r 源读取器</li>
<li>buf 存放读取结果的比特数组</li>
<li>min 读取的最小字节数</li>
</ul>
<p>返回值：</p>
<ul>
<li>n 读取的字节数</li>
<li>err 读取是否成功；nil代表成功</li>
</ul>
<p>功能说明：</p>
<ul>
<li>在r中读取l数据，并存放在buf中</li>
</ul>
<p>可能的异常：</p>
<ul>
<li>io.ErrUnexpectedEOF：读取的数据少于min字节</li>
<li>io.EOF：读取完毕</li>
</ul>
<p>示例：
package main</p>
<pre><code>import (
	&quot;io&quot;
	&quot;os&quot;
	&quot;fmt&quot;
)

func main() {
	reader, _ := os.Open(&quot;src.txt&quot;)
	var n, total int
	var err error
	p := make([]byte, 20)
	fmt.Println(&quot;Full count is:&quot;, 15)
	for {
		n, err = io.ReadAtLeast(reader, p, 15)
		if err == nil {
			fmt.Println(&quot;Read enough value:&quot;, string(p))
		}
		if err == io.ErrUnexpectedEOF {
			fmt.Println(&quot;Read fewer value:&quot;, string(p[0:n]))
		}
		if err == io.EOF {
			fmt.Println(&quot;Read end total&quot;, total)
			break
		}
		total = total + n
	}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-readfullr-reader-buf-byte-n-int-err-error"><a class="header" href="#func-readfullr-reader-buf-byte-n-int-err-error">func ReadFull(r Reader, buf []byte) (n int, err error)</a></h1>
<p>参数：</p>
<ul>
<li>r 源读取器</li>
<li>buf 存放读取结果的比特数组</li>
</ul>
<p>返回值：</p>
<ul>
<li>n 读取的字节数</li>
<li>err 读取是否成功；nil代表成功</li>
</ul>
<p>功能说明：</p>
<ul>
<li>在r中读取len(buf)字节数据，并存放在buf中</li>
</ul>
<p>可能的异常：</p>
<ul>
<li>io.ErrUnexpectedEOF：读取的数据不足len(buf)字节</li>
<li>io.EOF：读取完毕</li>
</ul>
<p>示例：
package main</p>
<pre><code>import (
	&quot;io&quot;
	&quot;os&quot;
	&quot;fmt&quot;
)

func main() {
	reader, _ := os.Open(&quot;src.txt&quot;)
	var n, total int
	var err error
	p := make([]byte, 20)
	fmt.Println(&quot;Full count is:&quot;, len(p))
	for {
		n, err = io.ReadFull(reader, p)
		if err == nil {
			fmt.Println(&quot;Read enough value:&quot;, string(p))
		}
		if err == io.ErrUnexpectedEOF {
			fmt.Println(&quot;Read fewer value:&quot;, string(p[0:n]))
		}
		if err == io.EOF {
			fmt.Println(&quot;Read end total&quot;, total)
			break
		}
		total = total + n
	}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-s-sectionreader-readp-byte-n-int-err-error"><a class="header" href="#func-s-sectionreader-readp-byte-n-int-err-error">func (s *SectionReader) Read(p []byte) (n int, err error)</a></h1>
<p>参数：</p>
<ul>
<li>p 存放读取结果的比特数组</li>
</ul>
<p>返回值：</p>
<ul>
<li>n 读取的字节数</li>
<li>err 读取是否成功；nil代表成功</li>
</ul>
<p>功能说明：</p>
<ul>
<li>在SectionReader中读取数据，并存入p中；若未读到数据返回io.EOF，所以io.EOF代表读取完毕</li>
</ul>
<p>示例：
package main</p>
<pre><code>import (
	&quot;io&quot;
	&quot;os&quot;
	&quot;fmt&quot;
)

func main() {
	reader, _ := os.Open(&quot;src.txt&quot;)
	sectionReader := io.NewSectionReader(reader, 5, 10)
	var n, total int
	var err error
	p := make([]byte, 15)
	for {
		n, err = sectionReader.Read(p)
		if err == io.EOF {
			fmt.Println(&quot;Find EOF so end total&quot;, total)
			break
		}
		total = total + n
		fmt.Println(&quot;Read value:&quot;, string(p[0:n]))
		fmt.Println(&quot;Read count:&quot;, n)
	}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-s-sectionreader-readatp-byte-off-int64-n-int-err-error"><a class="header" href="#func-s-sectionreader-readatp-byte-off-int64-n-int-err-error">func (s *SectionReader) ReadAt(p []byte, off int64) (n int, err error)</a></h1>
<p>参数：</p>
<ul>
<li>p 存放读取结果的比特数组</li>
<li>off 偏移量</li>
</ul>
<p>返回值：</p>
<ul>
<li>n 读取的字节数</li>
<li>err 读取是否成功；nil代表成功</li>
</ul>
<p>功能说明：</p>
<ul>
<li>从SectionReader中第off+1个字节开始读取数据，并存入p中；若未读到数据返回io.EOF，所以io.EOF代表读取完毕</li>
<li>注意：用该方法去取数据时，读取后读取点并不会移动，故多次读取会读取同样结果，无法使用循环读取并用EOF判断结束</li>
</ul>
<p>示例：
package main</p>
<pre><code>import (
	&quot;io&quot;
	&quot;os&quot;
	&quot;fmt&quot;
)

func main() {
	reader, _ := os.Open(&quot;src.txt&quot;)
	sectionReader := io.NewSectionReader(reader, 5, 10)
	p := make([]byte, 15)
	n, _ := sectionReader.ReadAt(p, 4)
	fmt.Println(&quot;Read value:&quot;, string(p[0:n]))
	fmt.Println(&quot;Read count:&quot;, n)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-s-sectionreader-seekoffset-int64-whence-int-ret-int64-err-error"><a class="header" href="#func-s-sectionreader-seekoffset-int64-whence-int-ret-int64-err-error">func (s *SectionReader) Seek(offset int64, whence int) (ret int64, err error)</a></h1>
<p>参数：</p>
<ul>
<li>offset 偏移量</li>
<li>whence 设定选项 0:读取起始点，1:当前读取点，2:结束点(不好用)，其他：将抛出Seek: invalid whence异常</li>
</ul>
<p>返回值：</p>
<ul>
<li>ret 当前读取点相对读取起始点的偏移量</li>
<li>err 便宜是否成功；nil代表成功</li>
</ul>
<p>功能说明：</p>
<ul>
<li>对SectionReader的读取起始点、当前读取点、结束点进行偏移</li>
</ul>
<p>示例：
package main</p>
<pre><code>import (
	&quot;io&quot;
	&quot;os&quot;
	&quot;fmt&quot;
)

func main() {
	reader, _ := os.Open(&quot;src.txt&quot;)
	sectionReader := io.NewSectionReader(reader, 2, 20)
	sectionReader.Seek(2, 0)
	p := make([]byte, 10)
	n, _ := sectionReader.Read(p)
	fmt.Println(&quot;First read value:&quot;, string(p[0:n]))
	fmt.Println(&quot;First read count:&quot;, n)
	a, _ := sectionReader.Seek(2, 1)
	fmt.Println(&quot;off - base is&quot;, a)
	n, _ = sectionReader.Read(p)
	fmt.Println(&quot;Second Read value:&quot;, string(p[0:n]))
	fmt.Println(&quot;Second Read count:&quot;, n)
	sectionReader.Seek(8, 2)
	n, _ = sectionReader.Read(p)
	fmt.Println(&quot;Third read value:&quot;, string(p[0:n]))
	fmt.Println(&quot;Third read count:&quot;, n)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-s-sectionreader-size-int64"><a class="header" href="#func-s-sectionreader-size-int64">func (s *SectionReader) Size() int64</a></h1>
<p>返回值：可读取字节数量</p>
<p>功能说明：</p>
<ul>
<li>获得SectionReader可读取字节数量，不受Read影响</li>
</ul>
<p>示例：
package main</p>
<pre><code>import (
	&quot;io&quot;
	&quot;os&quot;
	&quot;fmt&quot;
)

func main() {
	reader, _ := os.Open(&quot;src.txt&quot;)
	sectionReader := io.NewSectionReader(reader, 5, 20)
	fmt.Println(&quot;Can read count:&quot;, sectionReader.Size())
	p := make([]byte, 10)
	n, _ := sectionReader.Read(p)
	fmt.Println(&quot;Read count:&quot;, n)
	fmt.Println(&quot;Can read count:&quot;, sectionReader.Size())
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-teereaderr-reader-w-writer-reader"><a class="header" href="#func-teereaderr-reader-w-writer-reader">func TeeReader(r Reader, w Writer) Reader</a></h1>
<p>参数：</p>
<ul>
<li>r 源读取器</li>
<li>w 目标写入去</li>
</ul>
<p>返回值：TeeReader对象</p>
<p>TeeReader对象说明：</p>
<ul>
<li>是对Reader对象的一种封装，从r中读取写入并写入w中</li>
</ul>
<p>功能说明：</p>
<ul>
<li>创建一个TeeReader对象</li>
</ul>
<p>示例：
package main</p>
<pre><code>import (
	&quot;io&quot;
	&quot;os&quot;
	&quot;fmt&quot;
	&quot;reflect&quot;
)

func main() {
	reader, _ := os.Open(&quot;copySrc.txt&quot;)
	writer, _ := os.Create(&quot;copyDest.txt&quot;)
	teeReader := io.TeeReader(reader, writer)
	fmt.Println(reflect.TypeOf(teeReader))
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-t-teereader-readp-byte-n-int-err-error"><a class="header" href="#func-t-teereader-readp-byte-n-int-err-error">func (t *teeReader) Read(p []byte) (n int, err error)</a></h1>
<p>参数：</p>
<ul>
<li>p 在读取与写入之间缓存数据</li>
</ul>
<p>返回值：</p>
<ul>
<li>n 读取及写入的字节数</li>
<li>err 读取及写入是否成功；nil代表成功</li>
</ul>
<p>功能说明：</p>
<ul>
<li>从源读取数据并缓存在p中，并将p中缓存的数据写入目标</li>
</ul>
<p>示例：
package main</p>
<pre><code>import (
	&quot;io&quot;
	&quot;os&quot;
	&quot;fmt&quot;
)

func main() {
	reader, _ := os.Open(&quot;src.txt&quot;)
	writer, _ := os.Create(&quot;dst.txt&quot;)
	teeReader := io.TeeReader(reader, writer)
	var n, total int
	var err error
	p := make([]byte, 20)
	for {
		n, err = teeReader.Read(p)
		total = total + n
		if err == nil {
			fmt.Println(&quot;Read and write value&quot;, string(p[0:n]))
			fmt.Println(&quot;Read and write count&quot;, total)
		} 
		if err == io.EOF {
			fmt.Println(&quot;Read and write end total&quot;, total)
			break
		}
	}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-writestringw-writer-s-string-n-int-err-error"><a class="header" href="#func-writestringw-writer-s-string-n-int-err-error">func WriteString(w Writer, s string) (n int, err error)</a></h1>
<p>参数：</p>
<ul>
<li>w 目标写入器</li>
<li>s 写入的字符串</li>
</ul>
<p>返回值：</p>
<ul>
<li>n 写入字节数</li>
<li>err 写入是否成功，nil代表成功</li>
</ul>
<p>功能说明：</p>
<ul>
<li>将字符串s写入到w中</li>
</ul>
<p>示例：
package main</p>
<pre><code>import (
	&quot;io&quot;
	&quot;fmt&quot;
	&quot;os&quot;
)

func main() {
	writer, _ := os.Create(&quot;dst.txt&quot;)
	data := &quot;write data..&quot;
	n, err := io.WriteString(writer, data)
	if err == nil {
		fmt.Println(&quot;Success write&quot;, n, &quot;byte&quot;)
	}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="log包"><a class="header" href="#log包">log包</a></h1>
<p>常量</p>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/log/Constants.html">Constants</a></li>
</ul>
<p>函数列表</p>
<ul>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/log/Fatal.html">func Fatal(v ...interface{})</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/log/Fatalf.html">func Fatalf(format string, v ...interface{})</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/log/Fatalln.html">func Fatalln(v ...interface{})</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/log/Flags.html">func Flags() int</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/log/Panic.html">func Panic(v ...interface{})</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/log/Panicf.html">func Panicf(format string, v ...interface{})</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/log/Panicln.html">func Panicln(v ...interface{})</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/log/Prefix.html">func Prefix() string</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/log/Print.html">func Print(v ...interface{})</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/log/Printf.html">func Printf(format string, v ...interface{})</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/log/Println.html">func Println(v ...interface{})</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/log/SetFlags.html">func SetFlags(flag int)</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/log/SetOutput.html">func SetOutput(w io.Writer)</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/log/SetPrefix.html">func SetPrefix(prefix string)</a></p>
</li>
<li>
<p>type Logger</p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/log/New.html">func New(out io.Writer, prefix string, flag int) *Logger</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/log/lFatal.html">func (l *Logger) Fatal(v ...interface{})</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/log/lFatalf.html">func (l *Logger) Fatalf(format string, v ...interface{})</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/log/lFatalln.html">func (l *Logger) Fatalln(v ...interface{})</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/log/lFlags.html">func (l *Logger) Flags() int</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/log/Output.html">func (l *Logger) Output(calldepth int, s string) error</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/log/lPanic.html">func (l *Logger) Panic(v ...interface{})</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/log/lPanicf.html">func (l *Logger) Panicf(format string, v ...interface{})</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/log/lPanicln.html">func (l *Logger) Panicln(v ...interface{})</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/log/lPrefix.html">func (l *Logger) Prefix() string</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/log/lPrint.html">func (l *Logger) Print(v ...interface{})</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/log/lPrintf.html">func (l *Logger) Printf(format string, v ...interface{})</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/log/lPrintln.html">func (l *Logger) Println(v ...interface{})</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/log/lSetFlags.html">func (l *Logger) SetFlags(flag int)</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/log/lSetPrefix.html">func (l *Logger) SetPrefix(prefix string)</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名-42"><a class="header" href="#包名-42">包名</a></h1>
<p>函数列表</p>
<ul>
<li>xxx1</li>
<li>xxx2</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="常量"><a class="header" href="#常量">常量</a></h1>
<p>常量列表：</p>
<pre><code>- Ldate         日期 年/月/日
- Ltime         时间 时:分:秒
- Lmicroseconds 时间 .毫秒于Ltime之后
- Llongfile     完整文件名:行号
- Lshortfile    文件名，此标志位优先于 Llongfile
- LstdFlags     = Ldate 并且 Ltime
</code></pre>
<p>功能说明：</p>
<p>标志位常量控制日志格式。</p>
<p>代码实例：</p>
<pre><code class="language-go">package main

import &quot;log&quot;

func main() {
  log.SetFlags(log.Lshortfile | log.LstdFlags)
	log.Println(&quot;log:&quot;)
}
</code></pre>
<p>输出：</p>
<pre><code>2009/11/10 23:00:00 log.go:7: log:
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-fatalv-interface"><a class="header" href="#func-fatalv-interface">func Fatal(v ...interface{})</a></h2>
<p>参数列表：</p>
<ul>
<li>v 待输出参数列表</li>
</ul>
<p>返回值：</p>
<ul>
<li>无</li>
</ul>
<p>功能说明：</p>
<p>打印日志并退出。相当于调用Print()并os.Exit(1)</p>
<p>代码实例：</p>
<pre><code>package main

import(
	&quot;log&quot;
)

func main(){

	age := 25
	log.Fatal(&quot;Hi &amp; Bye ! Age = &quot;, age)// this will print &quot;Hi &amp; Bye ! Age = 25&quot;	

	log.Println(&quot;This will not be called.&quot;)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-fatalfformat-string-v-interface"><a class="header" href="#func-fatalfformat-string-v-interface">func Fatalf(format string, v ...interface{})</a></h2>
<p>参数列表：</p>
<ul>
<li>format 输出格式</li>
<li>v 带输出参数列表</li>
</ul>
<p>返回值：</p>
<ul>
<li>无</li>
</ul>
<p>功能说明：</p>
<p>按格式输出日志，并退出。相当于调用Printf()并调用os.Exit(1)</p>
<p>代码实例：</p>
<pre><code>package main

import(
	&quot;log&quot;
)

func main(){

	//log.Fatalf(&quot;%s&quot;, &quot;hello&quot;)

	name := &quot;golang&quot;
	log.Fatalf(&quot;%8d,%8s&quot;, 23, name) //2013/03/10 16:08:49       23,  golang
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-fatallnv-interface"><a class="header" href="#func-fatallnv-interface">func Fatalln(v ...interface{})</a></h2>
<p>参数列表：</p>
<ul>
<li>v</li>
</ul>
<p>返回值：</p>
<ul>
<li>无</li>
</ul>
<p>功能说明：</p>
<p>打印一行日志并退出。相当于调用Println()并os.Exit(1)</p>
<p>代码实例：</p>
<pre><code>package main

import(
	&quot;log&quot;
)

func main(){

	log.Fatalln(&quot;bye!&quot;)//2013/03/10 16:14:54 bye!\n
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-flags-int"><a class="header" href="#func-flags-int">func Flags() int</a></h2>
<p>参数列表：</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>默认logger的配置值</li>
</ul>
<p>功能说明：</p>
<p>返回默认logger配置值。</p>
<p>代码实例：</p>
<pre><code>package main

import(
	&quot;log&quot;
	&quot;fmt&quot;
)

func main(){

	fmt.Println(&quot;standard flags :&quot;, log.Flags())

	//the flags constants
	fmt.Println(log.Ldate)
	fmt.Println(log.Ltime)
	fmt.Println(log.Lmicroseconds)
	fmt.Println(log.Llongfile)
	fmt.Println(log.Lshortfile)
	fmt.Println(log.LstdFlags)	//LstdFlags     = Ldate | Ltime
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-l-logger-fatalv-interface"><a class="header" href="#func-l-logger-fatalv-interface">func (l *Logger) Fatal(v ...interface{})</a></h2>
<p>参数列表：</p>
<ul>
<li>v 待输出参数列表</li>
</ul>
<p>返回值：</p>
<ul>
<li>无</li>
</ul>
<p>功能说明：</p>
<p>打印日志并退出。相当于调用l.Print()并os.Exit(1)</p>
<p>代码实例：</p>
<pre><code>package main

import(
	&quot;log&quot;
	&quot;os&quot;
)

func main(){

	l := log.New(os.Stdout, &quot;&quot;, log.LstdFlags)
	age := 25
	l.Fatal(&quot;Hi &amp; Bye ! Age = &quot;, age)// this will print &quot;Hi &amp; Bye ! Age = 25&quot;

	l.Println(&quot;This will not be called.&quot;)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-fatalfformat-string-v-interface-1"><a class="header" href="#func-fatalfformat-string-v-interface-1">func Fatalf(format string, v ...interface{})</a></h2>
<p>参数列表：</p>
<ul>
<li>format 输出格式</li>
<li>v 带输出参数列表</li>
</ul>
<p>返回值：</p>
<ul>
<li>无</li>
</ul>
<p>功能说明：</p>
<p>按格式输出日志，并退出。相当于调用l.Printf()并调用os.Exit(1)</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;log&quot;
	&quot;os&quot;
)

func main() {

	l := log.New(os.Stdout, &quot;&quot;, log.LstdFlags)
	//l.Fatalf(&quot;%s&quot;, &quot;hello&quot;)

	name := &quot;golang&quot;
	l.Fatalf(&quot;%8d,%8s&quot;, 23, name) //2013/03/10 16:08:49       23,  golang
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-l-logger-fatallnv-interface"><a class="header" href="#func-l-logger-fatallnv-interface">func (l *Logger) Fatalln(v ...interface{})</a></h2>
<p>参数列表：</p>
<ul>
<li>v</li>
</ul>
<p>返回值：</p>
<ul>
<li>无</li>
</ul>
<p>功能说明：</p>
<p>打印一行日志并退出。相当于调用l.Println()并os.Exit(1)</p>
<p>代码实例：</p>
<pre><code>package main

import(
	&quot;log&quot;
	&quot;os&quot;
)

func main(){

	l := log.New(os.Stdout, &quot;&quot;, log.LstdFlags)
	l.Fatalln(&quot;bye!&quot;)//2013/03/10 16:14:54 bye!\n
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-l-logger-flags-int"><a class="header" href="#func-l-logger-flags-int">func (l *Logger) Flags() int</a></h2>
<p>参数列表：</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>当期logger的配置值</li>
</ul>
<p>功能说明：</p>
<p>返回当前logger配置值。</p>
<p>代码实例：</p>
<pre><code>package main

import(
	&quot;log&quot;
	&quot;fmt&quot;
	&quot;os&quot;
)

func main(){

	l := log.New(os.Stdout, &quot;&quot;, log.LstdFlags)
	fmt.Println(&quot;logger l's flags :&quot;, l.Flags())
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-l-logger-panicv-interface"><a class="header" href="#func-l-logger-panicv-interface">func (l *Logger) Panic(v ...interface{})</a></h2>
<p>参数列表：</p>
<ul>
<li>v 待输出参数列表</li>
</ul>
<p>返回值：</p>
<ul>
<li>无</li>
</ul>
<p>功能说明：</p>
<p>这个方法相当于调用l.Print()及panic()</p>
<p>代码实例：</p>
<pre><code>package main

import(
	&quot;log&quot;
	&quot;fmt&quot;
	&quot;os&quot;
)

func main(){


	l := log.New(os.Stdout, &quot;&quot;, log.LstdFlags)

	defer func(){
		if err := recover(); err !=nil{

			fmt.Println(err)	//output : &quot;call panic and stop&quot;
			handleException()
		}
	}()


	l.Panic(&quot;call panic and stop&quot;)

	log.Println(&quot;this will not be called.&quot;)
}

func handleException(){
	log.Println(&quot;recovering...&quot;)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-l-logger-panicfformat-string-v-interface"><a class="header" href="#func-l-logger-panicfformat-string-v-interface">func (l *Logger) Panicf(format string, v ...interface{})</a></h2>
<p>参数列表：</p>
<ul>
<li>format 	输出格式</li>
<li>v			待输出参数列表</li>
</ul>
<p>返回值：</p>
<ul>
<li>无</li>
</ul>
<p>功能说明：</p>
<p>相当于调用l.Printf()，之后调用panic()</p>
<p>代码实例：</p>
<pre><code>package main

import(
	&quot;log&quot;
	&quot;os&quot;
)

func main(){

	defer func(){

		if err := recover(); err != nil{
			if err == &quot;3q&quot;{
				log.Println(&quot;you are welcome&quot;)
			}
		}
	}()

	l := log.New(os.Stdout, &quot;&quot;, log.LstdFlags)
	l.Panicf(&quot;%d%s&quot;, 3, &quot;q&quot;)
}

//this will print like this:
//2013/03/10 16:48:06 3q
//2013/03/10 16:48:06 you are welcome
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-l-logger-paniclnv-interface"><a class="header" href="#func-l-logger-paniclnv-interface">func (l *Logger) Panicln(v ...interface{})</a></h2>
<p>参数列表：</p>
<ul>
<li>v 待输出参数列表</li>
</ul>
<p>返回值：</p>
<ul>
<li>无</li>
</ul>
<p>功能说明：</p>
<p>相当于调用l.Println()并调用panic()</p>
<p>代码实例：</p>
<pre><code>package main

import(
	&quot;log&quot;
	&quot;os&quot;
)

func main(){

	defer func(){

		if err := recover(); err != nil{
			if err == &quot;3q\n&quot;{
				log.Println(&quot;you are welcome&quot;)
			}
		}
	}()

	l := log.New(os.Stdout, &quot;&quot;, log.LstdFlags)
	l.Panicln(&quot;3q&quot;)
}

//this will print like this:
//2013/03/10 16:48:06 3q
//2013/03/10 16:48:06 you are welcome
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-l-logger-prefix-string"><a class="header" href="#func-l-logger-prefix-string">func (l *Logger) Prefix() string</a></h2>
<p>参数列表：</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>logger前缀，字符串类型</li>
</ul>
<p>功能说明：</p>
<p>返回当前logger的输出前缀</p>
<p>代码实例：</p>
<pre><code>package main

import(
	&quot;log&quot;
	&quot;fmt&quot;
	&quot;os&quot;
)

func main(){

	l := log.New(os.Stdout, &quot;&quot;, log.LstdFlags)
	fmt.Print(l.Prefix())	//this will print nothing

	l.Println(1)	//2013/03/10 17:02:05 1

	l.SetPrefix(&quot;log:&quot;)
	fmt.Println(l.Prefix())	//log:

	l.Println(2)	//log:2013/03/10 17:02:05 2
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-l-logger-printv-interface"><a class="header" href="#func-l-logger-printv-interface">func (l *Logger) Print(v ...interface{})</a></h2>
<p>参数列表：</p>
<ul>
<li>v 待输出参数列表</li>
</ul>
<p>返回值：</p>
<ul>
<li>无</li>
</ul>
<p>功能说明：</p>
<p>输出日志到logger。参数处理方式同fmt.Print</p>
<p>代码实例：</p>
<pre><code>package main

import(
	&quot;log&quot;
	&quot;os&quot;
)

func main(){
	l := log.New(os.Stdout, &quot;&quot;, log.LstdFlags)
	l.Print(&quot;string&quot;, 1, 2.3)//2013/03/10 17:26:06 string1 2.3
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-l-logger-printfformat-string-v-interface"><a class="header" href="#func-l-logger-printfformat-string-v-interface">func (l *Logger) Printf(format string, v ...interface{})</a></h2>
<p>参数列表：</p>
<ul>
<li>format 输出格式</li>
<li>v 待输出参数列表</li>
</ul>
<p>返回值：</p>
<ul>
<li>无</li>
</ul>
<p>功能说明：</p>
<p>调用l.Output输出日志到logger l。参数处理方式同fmt.Printf</p>
<p>代码实例：</p>
<pre><code>package main

import(
	&quot;log&quot;
	&quot;os&quot;
)

func main(){

	l := log.New(os.Stdout, &quot;&quot;, log.LstdFlags)
	l.Printf(&quot;%s&quot;, &quot;hello&quot;)	//hello

	name := &quot;golang&quot;
	l.Printf(&quot;%8d,%8s&quot;, 23, name) //2013/03/10 16:08:49       23,  golang
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-l-logger-printlnv-interface"><a class="header" href="#func-l-logger-printlnv-interface">func (l *Logger) Println(v ...interface{})</a></h2>
<p>参数列表：</p>
<ul>
<li>v 待输出参数列表</li>
</ul>
<p>返回值：</p>
<ul>
<li>无</li>
</ul>
<p>功能说明：</p>
<p>调用Output打印日志到当前logger，参数处理方式同fmt.Println</p>
<p>代码实例：</p>
<pre><code>package main

import(
	&quot;log&quot;
	&quot;os&quot;
)

func main(){

	l := log.New(os.Stdout, &quot;&quot;, log.LstdFlags)
	l.Println(&quot;hello&quot;)	//2013/03/10 17:35:28 hello\n
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-l-logger-setflagsflag-int"><a class="header" href="#func-l-logger-setflagsflag-int">func (l *Logger) SetFlags(flag int)</a></h2>
<p>参数列表：</p>
<ul>
<li>flag logger配置值</li>
</ul>
<p>返回值：</p>
<ul>
<li>无</li>
</ul>
<p>功能说明：</p>
<p>这个方法用来设置标准logger的配置，默认为3（logger.LstdFlags）</p>
<p>代码实例：</p>
<pre><code>package main

import(
	&quot;log&quot;
	&quot;os&quot;
)

func main(){

	l := log.New(os.Stdout, &quot;&quot;, log.LstdFlags)

	l.Println(l.Flags())	//2013/03/10 17:46:53 3

	l.SetFlags(log.Ldate)

	l.Println(l.Flags())	//2013/03/10 1

	l.SetFlags(log.LstdFlags | log.Lshortfile)

	l.Println(l.Flags())	//2013/03/10 17:46:53 setflags.go:17: 19
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-setprefixprefix-string"><a class="header" href="#func-setprefixprefix-string">func SetPrefix(prefix string)</a></h2>
<p>参数列表：</p>
<ul>
<li>prefix 前缀</li>
</ul>
<p>返回值：</p>
<ul>
<li>无</li>
</ul>
<p>功能说明：</p>
<p>设置logger的输出前缀</p>
<p>代码实例：</p>
<pre><code>package main

import(
	&quot;log&quot;
	&quot;fmt&quot;
	&quot;os&quot;
)

func main(){

	l := log.New(os.Stdout, &quot;&quot;, log.LstdFlags)
	fmt.Print(l.Prefix())	//this will print nothing

	l.Println(1)	//2013/03/10 17:02:05 1

	l.SetPrefix(&quot;log:&quot;)
	fmt.Println(l.Prefix())	//log:

	l.Println(2)	//log:2013/03/10 17:02:05 2
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-newout-iowriter-prefix-string-flag-int-logger"><a class="header" href="#func-newout-iowriter-prefix-string-flag-int-logger">func New(out io.Writer, prefix string, flag int) *Logger</a></h2>
<p>参数列表：</p>
<ul>
<li>out 输出目标</li>
<li>prefix 输出前缀</li>
<li>flag 格式配置标识值</li>
</ul>
<p>返回值：</p>
<ul>
<li>自定义的logger</li>
</ul>
<p>功能说明：</p>
<p>这个方法用来自定义logger，指定输出目标、格式等</p>
<p>代码实例：</p>
<p>package main</p>
<p>import(
&quot;log&quot;
&quot;os&quot;
)</p>
<p>func main(){</p>
<pre><code>file, err := os.OpenFile(&quot;sample.txt&quot;, os.O_WRONLY, 0666)
if err != nil{
	panic(err)
}

defer file.Close()

l := log.New(file, &quot;logger&quot;, log.Ldate)

l.Println(&quot;log to file sample&quot;)	//logger2013/03/10 log to file sample
</code></pre>
<p>}</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-l-logger-outputcalldepth-int-s-string-error"><a class="header" href="#func-l-logger-outputcalldepth-int-s-string-error">func (l *Logger) Output(calldepth int, s string) error</a></h2>
<p>参数列表：</p>
<ul>
<li>calldepth 深度 </li>
<li>s 字符串</li>
</ul>
<p>返回值：</p>
<ul>
<li>error 错误</li>
</ul>
<p>功能说明：</p>
<p>输出日志事件。字符串s包含待打印内容，跟在预定义的prefix后面，并且根据flags设置会有区分。如果s末尾没有换行符，这个方法会默认加上一个。calldepth目前预定义均为2,以后会用来支持通用场景，支持其他值配置。（本人注：日志输出不建议直接使用该方法）</p>
<p>代码实例：</p>
<pre><code>package main

import(
	&quot;log&quot;
	&quot;os&quot;
)

func main(){

	l := log.New(os.Stdout, &quot;log-&gt;&quot;, log.Ldate)

	l.Output(2, &quot;log output&quot;)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-panicv-interface-1"><a class="header" href="#func-panicv-interface-1">func Panic(v ...interface{})</a></h2>
<p>参数列表：</p>
<ul>
<li>v 待输出参数列表</li>
</ul>
<p>返回值：</p>
<ul>
<li>无</li>
</ul>
<p>功能说明：</p>
<p>这个方法相当于调用Print()及panic()</p>
<p>代码实例：</p>
<pre><code>package main

import(
	&quot;log&quot;
	&quot;fmt&quot;
)

func main(){

	defer func(){
		if err := recover(); err !=nil{

			fmt.Println(err)	//output : &quot;call panic and stop&quot;
			handleException()
		}
	}()


	log.Panic(&quot;call panic and stop&quot;)

	log.Println(&quot;this will not be called.&quot;)
}

func handleException(){
	log.Println(&quot;recovering...&quot;)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-panicfformat-string-v-interface"><a class="header" href="#func-panicfformat-string-v-interface">func Panicf(format string, v ...interface{})</a></h2>
<p>参数列表：</p>
<ul>
<li>format 	输出格式</li>
<li>v			待输出参数列表</li>
</ul>
<p>返回值：</p>
<ul>
<li>无</li>
</ul>
<p>功能说明：</p>
<p>相当于调用Printf()，之后调用panic()</p>
<p>代码实例：</p>
<pre><code>package main

import(
	&quot;log&quot;
)

func main(){

	defer func(){

		if err := recover(); err != nil{
			if err == &quot;3q&quot;{
				log.Println(&quot;you are welcome&quot;)
			}
		}
	}()

	log.Panicf(&quot;%d%s&quot;, 3, &quot;q&quot;)
</code></pre>
<p>}</p>
<p>//this will print like this:
//2013/03/10 16:48:06 3q
//2013/03/10 16:48:06 you are welcome</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-paniclnv-interface"><a class="header" href="#func-paniclnv-interface">func Panicln(v ...interface{})</a></h2>
<p>参数列表：</p>
<ul>
<li>v 待输出参数列表</li>
</ul>
<p>返回值：</p>
<ul>
<li>无</li>
</ul>
<p>功能说明：</p>
<p>相当于调用Println()并调用panic()</p>
<p>代码实例：</p>
<pre><code>package main

import(
	&quot;log&quot;
)

func main(){

	defer func(){

		if err := recover(); err != nil{
			if err == &quot;3q\n&quot;{
				log.Println(&quot;you are welcome&quot;)
			}
		}
	}()

	log.Panicln(&quot;3q&quot;)
}

//this will print like this:
//2013/03/10 16:48:06 3q
//2013/03/10 16:48:06 you are welcome
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-prefix-string"><a class="header" href="#func-prefix-string">func Prefix() string</a></h2>
<p>参数列表：</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>标准logger前缀，字符串类型</li>
</ul>
<p>功能说明：</p>
<p>返回标准logger的输出前缀</p>
<p>代码实例：</p>
<pre><code>package main

import(
	&quot;log&quot;
	&quot;fmt&quot;
)

func main(){

	fmt.Print(log.Prefix())	//this will print nothing

	log.Println(1)	//2013/03/10 17:02:05 1

	log.SetPrefix(&quot;log:&quot;)
	fmt.Println(log.Prefix())	//log:

	log.Println(2)	//log:2013/03/10 17:02:05 2
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-printv-interface"><a class="header" href="#func-printv-interface">func Print(v ...interface{})</a></h2>
<p>参数列表：</p>
<ul>
<li>v 待输出参数列表</li>
</ul>
<p>返回值：</p>
<ul>
<li>无</li>
</ul>
<p>功能说明：</p>
<p>输出日志到标准logger。参数处理方式同fmt.Print</p>
<p>代码实例：</p>
<pre><code>package main

import(
	&quot;log&quot;
)

func main(){
	log.Print(&quot;string&quot;, 1, 2.3)//2013/03/10 17:26:06 string1 2.3
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-printfformat-string-v-interface"><a class="header" href="#func-printfformat-string-v-interface">func Printf(format string, v ...interface{})</a></h2>
<p>参数列表：</p>
<ul>
<li>format 输出格式</li>
<li>v 待输出参数列表</li>
</ul>
<p>返回值：</p>
<ul>
<li>无</li>
</ul>
<p>功能说明：</p>
<p>调用Output输出日志到标准logger。参数处理方式同fmt.Printf</p>
<p>代码实例：</p>
<pre><code>package main

import(
	&quot;log&quot;
)

func main(){

	log.Printf(&quot;%s&quot;, &quot;hello&quot;)	//hello

	name := &quot;golang&quot;
	log.Printf(&quot;%8d,%8s&quot;, 23, name) //2013/03/10 16:08:49       23,  golang
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-printlnv-interface"><a class="header" href="#func-printlnv-interface">func Println(v ...interface{})</a></h2>
<p>参数列表：</p>
<ul>
<li>v</li>
</ul>
<p>返回值：</p>
<ul>
<li>无</li>
</ul>
<p>功能说明：</p>
<p>调用Output打印日志到标准logger，参数处理方式同fmt.Println</p>
<p>代码实例：</p>
<pre><code>package main

import(
	&quot;log&quot;
)

func main(){
	log.Println(&quot;hello&quot;)	//2013/03/10 17:35:28 hello\n
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-setflagsflag-int"><a class="header" href="#func-setflagsflag-int">func SetFlags(flag int)</a></h2>
<p>参数列表：</p>
<ul>
<li>flag logger配置值</li>
</ul>
<p>返回值：</p>
<ul>
<li>无</li>
</ul>
<p>功能说明：</p>
<p>这个方法用来设置标准logger的配置，默认为3（logger.LstdFlags）</p>
<p>代码实例：</p>
<pre><code>package main

import(
	&quot;log&quot;
)

func main(){

	log.Println(log.Flags())	//2013/03/10 17:46:53 3

	log.SetFlags(log.Ldate)

	log.Println(log.Flags())	//2013/03/10 1

	log.SetFlags(log.LstdFlags | log.Lshortfile)

	log.Println(log.Flags())	//2013/03/10 17:46:53 setflags.go:17: 19
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-setoutputw-iowriter"><a class="header" href="#func-setoutputw-iowriter">func SetOutput(w io.Writer)</a></h2>
<p>参数列表：</p>
<ul>
<li>w 目标流，io.Writer类型</li>
</ul>
<p>返回值：</p>
<ul>
<li>无</li>
</ul>
<p>功能说明：</p>
<p>设置标准logger的输出目标</p>
<p>代码实例：</p>
<pre><code>package main

import(
	&quot;log&quot;
	&quot;os&quot;
)

func main(){

	file, err := os.OpenFile(&quot;sample.txt&quot;, os.O_WRONLY, 0666)
	if err != nil{
		panic(err)
	}

	defer file.Close()

	log.SetOutput(file)

	log.Println(&quot;log to file&quot;)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-setprefixprefix-string-1"><a class="header" href="#func-setprefixprefix-string-1">func SetPrefix(prefix string)</a></h2>
<p>参数列表：</p>
<ul>
<li>prefix 前缀</li>
</ul>
<p>返回值：</p>
<ul>
<li>无</li>
</ul>
<p>功能说明：</p>
<p>设置logger的输出前缀</p>
<p>代码实例：</p>
<pre><code>package main

import(
	&quot;log&quot;
	&quot;fmt&quot;
)

func main(){

	fmt.Print(log.Prefix())	//this will print nothing

	log.Println(1)	//2013/03/10 17:02:05 1

	log.SetPrefix(&quot;log:&quot;)
	fmt.Println(log.Prefix())	//log:

	log.Println(2)	//log:2013/03/10 17:02:05 2
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名-43"><a class="header" href="#包名-43">包名</a></h1>
<p>函数列表</p>
<ul>
<li>xxx1</li>
<li>xxx2</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名-44"><a class="header" href="#包名-44">包名</a></h1>
<p>函数列表</p>
<ul>
<li>xxx1</li>
<li>xxx2</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名-45"><a class="header" href="#包名-45">包名</a></h1>
<p>函数列表</p>
<ul>
<li>xxx1</li>
<li>xxx2</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rand包函数列表"><a class="header" href="#rand包函数列表">rand包函数列表</a></h1>
<p>函数列表</p>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/math/rand/ExpFloat64.html">func ExpFloat64() float64</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/math/rand/Float32.html">func Float32() float32</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/math/rand/Float64.html">func Float64() float64</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/math/rand/Int.html">func Int() int</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/math/rand/Int31.html">func Int31() int32</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/math/rand/Int31n.html">func Int31n(n int32) int32</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/math/rand/Int63.html">func Int63() int64</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/math/rand/Int63n.html">func Int63n(n int64) int64</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/math/rand/Intn.html">func Intn(n int) int</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/math/rand/NormFloat64.html">func NormFloat64() float64</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/math/rand/Perm.html">func Perm(n int) []int</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/math/rand/Seed.html">func Seed(seed int64)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/math/rand/Uint32.html">func Uint32() uint32</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/math/rand/Rand.html">type Rand</a>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/math/rand/New.html">func New(src Source) *Rand</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/math/rand/Rand-ExpFloat64.html">func (r *Rand) ExpFloat64() float64</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/math/rand/Rand-Float32.html">func (r *Rand) Float32() float32</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/math/rand/Rand-Float64.html">func (r *Rand) Float64() float64</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/math/rand/Rand-Int.html">func (r *Rand) Int() int</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/math/rand/Rand-Int31.html">func (r *Rand) Int31() int32</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/math/rand/Rand-Int31n.html">func (r *Rand) Int31n(n int32) int32</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/math/rand/Rand-Int63.html">func (r *Rand) Int63() int64</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/math/rand/Rand-Int63n.html">func (r *Rand) Int63n(n int64) int64</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/math/rand/Rand-Intn.html">func (r *Rand) Intn(n int) int</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/math/rand/Rand-NormFloat64.html">func (r *Rand) NormFloat64() float64</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/math/rand/Rand-Perm.html">func (r *Rand) Perm(n int) []int</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/math/rand/Rand-Seed.html">func (r *Rand) Seed(seed int64)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/math/rand/Rand-Uint32.html">func (r *Rand) Uint32() uint32</a></li>
</ul>
</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/math/rand/Source.html">type Source</a>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/math/rand/NewSource.html">func NewSource(seed int64) Source</a></li>
</ul>
</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/math/rand/Zipf.html">type Zipf</a>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/math/rand/NewZipf.html">func NewZipf(r *Rand, s float64, v float64, imax uint64) *Zipf</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/math/rand/Zipf-Uint64.html">func (z *Zipf) Uint64() uint64</a></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-expfloat64-float64"><a class="header" href="#func-expfloat64-float64">func ExpFloat64() float64</a></h2>
<p>返回值：</p>
<ul>
<li>返回float64</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要实现了指数分布公式</p>
<p><img src="http://upload.wikimedia.org/math/7/c/1/7c1e7458e99f77f22c350aec59c67e9c.png" alt="" /></p>
<p>函数定义域在(0, +∞);在此,用math.MaxFloat64表示正无穷, 率参数λ归元为1,函数的期望是1/λ(λ=1).返回值计算如下:</p>
<pre><code>f(x,1)
</code></pre>
<p>如果想要λ是别的值怎么办呢?可以通过调整分母来达到目的.</p>
<pre><code>sample = ExpFloat64() / desiredRateParameter
</code></pre>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;math/rand&quot;
)

func main() {
	sum := 0.0
	n := 10000000
	i := 0
	for i &lt; n {
		x := rand.ExpFloat64()
		sum += x
		i += 1
	}
	expect := sum / (float64)(n)
	fmt.Println(expect)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-float32-float32"><a class="header" href="#func-float32-float32">func Float32() float32</a></h2>
<p>返回值：</p>
<ul>
<li>返回float32</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要实现返回一个[0.0.1.0)区间的Float32型的数.通常是一个精确到小数点后8位(8x4=32)的浮点数.</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;math/rand&quot;
)

func main() {
	n := 10
	i := 0
	for i &lt; n {
		x := rand.Float32()
		fmt.Println(x)
		i += 1
	}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-float64-float64"><a class="header" href="#func-float64-float64">func Float64() float64</a></h2>
<p>返回值：</p>
<ul>
<li>返回float64</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要实现返回一个[0.0.1.0)区间的Float64型的数.通常是一个精确到小数点后16位(16x4=64)的浮点数.</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;math/rand&quot;
)

func main() {
	n := 10
	i := 0
	for i &lt; n {
		x := rand.Float64()
		fmt.Println(x)
		i += 1
	}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-int-int"><a class="header" href="#func-int-int">func Int() int</a></h2>
<p>返回值：</p>
<ul>
<li>返回int</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要实现返回一个非负伪随机整数.</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;math/rand&quot;
)

func main() {
	n := 10
	i := 0
	for i &lt; n {
		x := rand.Int()
		fmt.Println(x)
		i += 1
	}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-int31-int32"><a class="header" href="#func-int31-int32">func Int31() int32</a></h2>
<p>返回值：</p>
<ul>
<li>返回int32</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要实现返回一个非负伪随机整数,该整数是一个有符号int32型,除去最高位,占31个比特位,范围在[0,2^31-1]之间.</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;math/rand&quot;
)

func main() {
	n := 10
	i := 0
	for i &lt; n {
		x := rand.Int31()
		fmt.Println(x)
		i += 1
	}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-int31nn-int32-int32"><a class="header" href="#func-int31nn-int32-int32">func Int31n(n int32) int32</a></h2>
<p>参数列表:</p>
<ul>
<li>n 期望输出随机值的最大限制值</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回int32</li>
</ul>
<p>功能说明：</p>
<p>返回一个[0,n)之间的非负伪随机整数.如果n&lt;=0会panic.</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;math/rand&quot;
)

func main() {
	n := 10
	i := 0
	for i &lt; n {
		x := rand.Int31n(5)
		fmt.Println(x)
		i += 1
	}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-int63-int64"><a class="header" href="#func-int63-int64">func Int63() int64</a></h2>
<p>返回值：</p>
<ul>
<li>返回int64</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要实现返回一个非负伪随机整数,该整数是一个有符号int64型,除去最高位,占63个比特位,范围在[0,2^63-1]之间.</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;math/rand&quot;
)

func main() {
	n := 10
	i := 0
	for i &lt; n {
		x := rand.Int63()
		fmt.Println(x)
		i += 1
	}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-int63nn-int64-int64"><a class="header" href="#func-int63nn-int64-int64">func Int63n(n int64) int64</a></h2>
<p>参数列表</p>
<ul>
<li>n 期望输出随机值的最大限制值</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回int64</li>
</ul>
<p>功能说明：</p>
<p>返回一个[0,n)之间的非负伪随机整数.如果n&lt;=0会panic.</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;math/rand&quot;
)

func main() {
	n := 10
	i := 0
	for i &lt; n {
		x := rand.Int63n(5)
		fmt.Println(x)
		i += 1
	}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-intnn-int-int"><a class="header" href="#func-intnn-int-int">func Intn(n int) int</a></h2>
<p>参数列表</p>
<ul>
<li>n 期望输出随机值的最大限制值</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回int</li>
</ul>
<p>功能说明：</p>
<p>返回一个[0,n)之间的非负伪随机整数.如果n&lt;=0会panic.</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;math/rand&quot;
)

func main() {
	n := 10
	i := 0
	for i &lt; n {
		x := rand.Intn(5)
		fmt.Println(x)
		i += 1
	}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-newsrc-source-rand"><a class="header" href="#func-newsrc-source-rand">func New(src Source) *Rand</a></h2>
<p>参数列表</p>
<ul>
<li>src Source</li>
</ul>
<p>返回值</p>
<ul>
<li>Rand指针</li>
</ul>
<p>该函数主要返回了一个新的Rand实例,并以src作为随机值产生器.</p>
<p>代码实例</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;math/rand&quot;
)

func main() {
	n := 10
	i := 0

	r := rand.New(rand.NewSource(64))
	for i &lt; n {
		fmt.Println(r.Int())
		i += 1
	}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-newsourceseed-int64-source"><a class="header" href="#func-newsourceseed-int64-source">func NewSource(seed int64) Source</a></h2>
<p>参数列表:</p>
<ul>
<li>int64类型的值作为种子值</li>
</ul>
<p>返回值:</p>
<ul>
<li>Source结构体</li>
</ul>
<p>功能说明：</p>
<p>该函数主要返回一个指定种子的随机数产生器.</p>
<p>代码实例:</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;math/rand&quot;
	&quot;time&quot;
)

func main() {
	n := 10
	i := 0

	r := rand.New(rand.NewSource(time.Now().UnixNano()))
	for i &lt; n {
		fmt.Println(r.Int())
		i += 1
	}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-newzipfr-rand-s-float64-v-float64-imax-uint64-zipf"><a class="header" href="#func-newzipfr-rand-s-float64-v-float64-imax-uint64-zipf">func NewZipf(r *Rand, s float64, v float64, imax uint64) *Zipf</a></h2>
<p>参数列表:</p>
<ul>
<li>r *Rand 随机值产生器结构体指针</li>
<li>s float64 Zipf公式的描述分布的指数</li>
<li>v float64 Zipf公式的v参数</li>
<li>imax uint64 分布区间的最大值</li>
</ul>
<p>返回值:</p>
<ul>
<li>Zipf对象的指针</li>
</ul>
<p>功能说明：</p>
<p>该函数实现取值是0到imax之间的随即变量p(k), 它与(v+k)**(-s)成比例, 其中s&gt;1, k&gt;=0, 且 v&gt;=1.</p>
<p><img src="http://upload.wikimedia.org/math/f/7/e/f7ea651d890ccb3249ecd1c8eded8869.png" alt="" /></p>
<p><img src="http://upload.wikimedia.org/math/3/4/4/344c5375a5cd6ea108c6823b7b167b02.png" alt="" /></p>
<p>更多关于Zipf分布的理论请参考<a href="http://en.wikipedia.org/wiki/Zipf&#x27;s_law">wikipedia</a></p>
<p>代码实例:</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;math/rand&quot;
	&quot;time&quot;
)

func main() {
	n := 10
	i := 0

	r := rand.New(rand.NewSource(time.Now().UnixNano()))
	zipf := rand.NewZipf(r, 3.14, 2.72, 5000)
	for i &lt; n {
		fmt.Println(zipf.Uint64())
		i += 1
	}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-normfloat64-float64"><a class="header" href="#func-normfloat64-float64">func NormFloat64() float64</a></h2>
<p>返回值：</p>
<ul>
<li>返回float64</li>
</ul>
<p>功能说明：</p>
<p>该函数返回一个区间为[-math.MaxFloat64, +math.MaxFloat64]的标准正态分布.</p>
<p>正太分布的密度函数是</p>
<p><img src="http://upload.wikimedia.org/math/7/9/a/79af499be9466b7dce2cf8ac19fa0a07.png" alt="" /></p>
<p>其中默认的位置参数(期望desiredMean)为0,尺度参数(标准差desiredStdDev)为1.
如果想改变不同的位置参数和尺度参数,可以通过下面方法变通:</p>
<pre><code>sample = NormFloat64() * desiredStdDev + desiredMean
</code></pre>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;math/rand&quot;
)

func main() {
	n := 10000
	i := 0
	sum := 0.0
	for i &lt; n {
		x := rand.NormFloat64()
		i += 1
		sum += x
	}
	expect := sum / float64(n)
	fmt.Println(expect)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-permn-int-int"><a class="header" href="#func-permn-int-int">func Perm(n int) []int</a></h2>
<p>参数列表</p>
<ul>
<li>n 期望输出随机值的最大限制值</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回[]int</li>
</ul>
<p>功能说明：</p>
<p>返回一个元素个数是n的slice,里面的元素是0到n-1的整数无重复的随机排列.</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;math/rand&quot;
)

func main() {
	n := 10
	i := 0
	for i &lt; n {
		x := rand.Perm(5)
		fmt.Println(x)
		i += 1
	}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-rand-expfloat64-float64"><a class="header" href="#func-rand-expfloat64-float64">func (*Rand) ExpFloat64() float64</a></h2>
<p>返回值：</p>
<ul>
<li>返回float64</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要实现了指数分布公式</p>
<p><img src="http://upload.wikimedia.org/math/7/c/1/7c1e7458e99f77f22c350aec59c67e9c.png" alt="" /></p>
<p>函数定义域在(0, +∞);在此,用math.MaxFloat64表示正无穷, 率参数λ归元为1,函数的期望是1/λ(λ=1).返回值计算如下:</p>
<pre><code>f(x,1)
</code></pre>
<p>如果想要λ是别的值怎么办呢?可以通过调整分母来达到目的.</p>
<pre><code>sample = ExpFloat64() / desiredRateParameter
</code></pre>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;math/rand&quot;
)

func main() {
	sum := 0.0
	n := 100
	i := 0
	r := rand.New(rand.NewSource(64))
	for i &lt; n {
		x := r.ExpFloat64()
		sum += x
		i += 1
		fmt.Println(x)
	}
	expect := sum / (float64)(n)
	fmt.Println(expect)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-rand-float32-float32"><a class="header" href="#func-rand-float32-float32">func (*Rand) Float32() float32</a></h2>
<p>返回值：</p>
<ul>
<li>返回float32</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要实现返回一个[0.0.1.0)区间的Float32型的数.通常是一个精确到小数点后8位(8x4=32)的浮点数.</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;math/rand&quot;
)

func main() {
	n := 10
	i := 0
	r := rand.New(rand.NewSource(64))
	for i &lt; n {
		x := r.Float32()
		fmt.Println(x)
		i += 1
	}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-rand-float64-float64"><a class="header" href="#func-rand-float64-float64">func (*Rand) Float64() float64</a></h2>
<p>返回值：</p>
<ul>
<li>返回float64</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要实现返回一个[0.0.1.0)区间的Float64型的数.通常是一个精确到小数点后16位(16x4=64)的浮点数.</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;math/rand&quot;
)

func main() {
	n := 10
	i := 0
	r := rand.New(rand.NewSource(64))
	for i &lt; n {
		x := r.Float64()
		fmt.Println(x)
		i += 1
	}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-rand-int-int"><a class="header" href="#func-rand-int-int">func (*Rand) Int() int</a></h2>
<p>返回值：</p>
<ul>
<li>返回int</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要实现返回一个非负伪随机整数.</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;math/rand&quot;
)

func main() {
	n := 10
	i := 0
		r := rand.New(rand.NewSource(64))
	for i &lt; n {
		x := r.Int()
		fmt.Println(x)
		i += 1
	}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-rand-int31-int32"><a class="header" href="#func-rand-int31-int32">func (*Rand) Int31() int32</a></h2>
<p>返回值：</p>
<ul>
<li>返回int32</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要实现返回一个非负伪随机整数,该整数是一个有符号int32型,除去最高位,占31个比特位,范围在[0,2^31-1]之间.</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;math/rand&quot;
)

func main() {
	n := 10
	i := 0
	r := rand.New(rand.NewSource(64))
	for i &lt; n {
		x := r.Int31()
		fmt.Println(x)
		i += 1
	}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-rand-int31nn-int32-int32"><a class="header" href="#func-rand-int31nn-int32-int32">func (*Rand) Int31n(n int32) int32</a></h2>
<p>参数列表</p>
<ul>
<li>n 期望输出随机值的最大限制值</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回int32</li>
</ul>
<p>功能说明：</p>
<p>返回一个[0,n)之间的非负伪随机整数.如果n&lt;=0会panic.</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;math/rand&quot;
)

func main() {
	n := 10
	i := 0
	r := rand.New(rand.NewSource(64))
	for i &lt; n {
		x := r.Int31n(5)
		fmt.Println(x)
		i += 1
	}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-rand-int63-int64"><a class="header" href="#func-rand-int63-int64">func (*Rand) Int63() int64</a></h2>
<p>返回值：</p>
<ul>
<li>返回int64</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要实现返回一个非负伪随机整数,该整数是一个有符号int64型,除去最高位,占63个比特位,范围在[0,2^63-1]之间.</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;math/rand&quot;
)

func main() {
	n := 10
	i := 0
		r := rand.New(rand.NewSource(64))
	for i &lt; n {
		x := r.Int63()
		fmt.Println(x)
		i += 1
	}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-rand-int63nn-int64-int64"><a class="header" href="#func-rand-int63nn-int64-int64">func (*Rand) Int63n(n int64) int64</a></h2>
<p>参数列表</p>
<ul>
<li>n 期望输出随机值的最大限制值</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回int64</li>
</ul>
<p>功能说明：</p>
<p>返回一个[0,n)之间的非负伪随机整数.如果n&lt;=0会panic.</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;math/rand&quot;
)

func main() {
	n := 10
	i := 0
		r := rand.New(rand.NewSource(64))
	for i &lt; n {
		x := r.Int63n(5)
		fmt.Println(x)
		i += 1
	}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-rand-intnn-int-int"><a class="header" href="#func-rand-intnn-int-int">func (*Rand) Intn(n int) int</a></h2>
<p>参数列表</p>
<ul>
<li>n 期望输出随机值的最大限制值</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回int</li>
</ul>
<p>功能说明：</p>
<p>返回一个[0,n)之间的非负伪随机整数.如果n&lt;=0会panic.</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;math/rand&quot;
)

func main() {
	n := 10
	i := 0
		r := rand.New(rand.NewSource(64))
	for i &lt; n {
		x := r.Intn(5)
		fmt.Println(x)
		i += 1
	}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-rand-normfloat64-float64"><a class="header" href="#func-rand-normfloat64-float64">func (*Rand) NormFloat64() float64</a></h2>
<p>返回值：</p>
<ul>
<li>返回float64</li>
</ul>
<p>功能说明：</p>
<p>该函数返回一个区间为[-math.MaxFloat64, +math.MaxFloat64]的标准正态分布.</p>
<p>正太分布的密度函数是</p>
<p><img src="http://upload.wikimedia.org/math/7/9/a/79af499be9466b7dce2cf8ac19fa0a07.png" alt="" /></p>
<p>其中默认的位置参数(期望desiredMean)为0,尺度参数(标准差desiredStdDev)为1.
如果想改变不同的位置参数和尺度参数,可以通过下面方法变通:</p>
<pre><code>sample = NormFloat64() * desiredStdDev + desiredMean
</code></pre>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;math/rand&quot;
)

func main() {
	n := 10000
	i := 0
	sum := 0.0
		r := rand.New(rand.NewSource(64))
	for i &lt; n {
		x := r.NormFloat64()
		i += 1
		sum += x
	}
	expect := sum / float64(n)
	fmt.Println(expect)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-rand-permn-int-int"><a class="header" href="#func-rand-permn-int-int">func (*Rand) Perm(n int) []int</a></h2>
<p>参数列表</p>
<ul>
<li>n 期望输出随机值的最大限制值</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回[]int</li>
</ul>
<p>功能说明：</p>
<p>返回一个元素个数是n的slice,里面的元素是0到n-1的整数无重复的随机排列.</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;math/rand&quot;
)

func main() {
	n := 10
	i := 0
	r := rand.New(rand.NewSource(64))
	for i &lt; n {
		x := r.Perm(10)
		fmt.Println(x)
		i += 1
	}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-rand-seedseed-int64"><a class="header" href="#func-rand-seedseed-int64">func (*Rand) Seed(seed int64)</a></h2>
<p>参数列表</p>
<ul>
<li>seed 提供随机种子值</li>
</ul>
<p>功能说明：</p>
<p>以提供的参数作为种子值,来初始化随机产生器.如果Seed没有被调用,那么随机数调用前默认调用Seed(1).</p>
<p>小贴士,一般用传入time.Now().UnixNano()给Seed函数来实现不同运行次数看到不同结果的目的.</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;math/rand&quot;
	&quot;time&quot;
)

func main() {
	n := 10
	i := 0
	r := rand.New(rand.NewSource(64))
	for i &lt; n {
		r.Seed(time.Now().UnixNano())
		fmt.Println(r.Int())
		i += 1
	}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-rand-uint32-uint32"><a class="header" href="#func-rand-uint32-uint32">func (*Rand) Uint32() uint32</a></h2>
<p>返回值：</p>
<ul>
<li>返回int32</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要实现返回一个0-2^32范围内的伪随机数.</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;math/rand&quot;
)

func main() {
	n := 10
	i := 0
	r := rand.New(rand.NewSource(64))
	for i &lt; n {
		x := r.Uint32()
		fmt.Println(x)
		i += 1
	}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="type-rand"><a class="header" href="#type-rand">type Rand</a></h2>
<p>这个是随机数的来源结构体.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-seedseed-int64"><a class="header" href="#func-seedseed-int64">func Seed(seed int64)</a></h2>
<p>参数列表</p>
<ul>
<li>seed 提供随机种子值</li>
</ul>
<p>功能说明：</p>
<p>以提供的参数作为种子值,来初始化随机产生器.如果Seed没有被调用,那么随机数调用前默认调用Seed(1).</p>
<p>小贴士,一般用传入time.Now().UnixNano()给Seed函数来实现不同运行次数看到不同结果的目的.</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;math/rand&quot;
	&quot;time&quot;
)

func main() {
	n := 10
	i := 0
	for i &lt; n {
		rand.Seed(time.Now().UnixNano())
		fmt.Println(rand.Int())
		i += 1
	}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="type-source-interface-"><a class="header" href="#type-source-interface-">type Source interface {</a></h2>
<h2 id="int63-int64"><a class="header" href="#int63-int64">Int63() int64</a></h2>
<h2 id="seedseed-int64"><a class="header" href="#seedseed-int64">Seed(seed int64)</a></h2>
<h2 id=""><a class="header" href="#">}</a></h2>
<p>Source 结构体是0到2^63-1之间的均匀分布的伪随机数的来源.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-uint32-uint32"><a class="header" href="#func-uint32-uint32">func Uint32() uint32</a></h2>
<p>返回值：</p>
<ul>
<li>返回int32</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要实现返回一个0-2^32范围内的伪随机数.</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;math/rand&quot;
)

func main() {
	n := 10
	i := 0
	for i &lt; n {
		x := rand.Uint32()
		fmt.Println(x)
		i += 1
	}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-zipf-uint64-uint64"><a class="header" href="#func-zipf-uint64-uint64">func (*Zipf) Uint64 uint64</a></h2>
<p>返回值:</p>
<ul>
<li>unit64</li>
</ul>
<p>功能说明：</p>
<p>该函数返回一个按照Zipf对象表述的Zipf分布的值.</p>
<p>代码实例:</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;math/rand&quot;
	&quot;time&quot;
)

func main() {
	n := 10
	i := 0

	r := rand.New(rand.NewSource(time.Now().UnixNano()))
	zipf := rand.NewZipf(r, 3.14, 2.72, 5000)
	for i &lt; n {
		fmt.Println(zipf.Uint64())
		i += 1
	}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="type-zipf-struct-"><a class="header" href="#type-zipf-struct-">type Zipf struct {</a></h2>
<h2 id="-contains-filtered-or-unexported-fields"><a class="header" href="#-contains-filtered-or-unexported-fields">// contains filtered or unexported fields</a></h2>
<h2 id="-1"><a class="header" href="#-1">}</a></h2>
<p>Zipf 是一个产生Zipf分布变量的结构体.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名-46"><a class="header" href="#包名-46">包名</a></h1>
<p>函数列表</p>
<ul>
<li>xxx1</li>
<li>xxx2</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名-47"><a class="header" href="#包名-47">包名</a></h1>
<p>函数列表</p>
<ul>
<li>xxx1</li>
<li>xxx2</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="net包"><a class="header" href="#net包">net包</a></h1>
<h2 id="概述-5"><a class="header" href="#概述-5">概述</a></h2>
<p>net 包是处理网络I/O的包</p>
<h2 id="常量-1"><a class="header" href="#常量-1">常量</a></h2>
<p>P地址长度</p>
<pre><code>const (
    IPv4len = 4
    IPv6len = 16
)
</code></pre>
<h2 id="变量-2"><a class="header" href="#变量-2">变量</a></h2>
<p>知名IPv4地址</p>
<pre><code>var (
	IPv4bcast     = IPv4(255, 255, 255, 255) // 广播
	IPv4allsys    = IPv4(224, 0, 0, 1)       // 所有主机的地址 （包括所有路由器地址）
    IPv4allrouter = IPv4(224, 0, 0, 2)       // 所有组播路由器的地址
    IPv4zero      = IPv4(0, 0, 0, 0)         // 不确定地址
)
</code></pre>
<p>知名IPv6地址</p>
<pre><code>var (
    IPv6zero                   = IP{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
    IPv6unspecified            = IP{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
    IPv6loopback               = IP{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1}
    IPv6interfacelocalallnodes = IP{0xff, 0x01, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x01}
    IPv6linklocalallnodes      = IP{0xff, 0x02, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x01}
    IPv6linklocalallrouters    = IP{0xff, 0x02, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x02}
)
</code></pre>
<p>错误</p>
<pre><code>var ErrWriteToConnected = errors.New(&quot;use of WriteTo with pre-connected UDP&quot;)
</code></pre>
<h2 id="函数-2"><a class="header" href="#函数-2">函数</a></h2>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/InterfaceAddrs.html">InterfaceAddrs</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/Interfaces.html">Interfaces</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/JoinHostPort.html">JoinHostPort</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/LookupAddr.html">LookupAddr</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/LookupCNAME.html">LookupCNAME</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/LookupHost.html">LookupHost</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/LookupIP.html">LookupIP</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/LookupPort.html">LookupPort</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/LookupSRV.html">LookupSRV</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/LookupTXT.html">LookupTXT</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/SplitHostPort.html">SplitHostPort</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/Dial.html">Dial</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/DialTimeout.html">DialTimeout</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/Pipe.html">Pipe</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/ParseMAC.html">ParseMAC</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/IPv4.html">IPv4</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/ParseCIDR.html">ParseCIDR</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/ParseIP.html">ParseIP</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/ResolveIPAddr.html">ResolveIPAddr</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/DialIP.html">DialIP</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/ListenIP.html">ListenIP</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/CIDRMask.html">CIDRMask</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/IPv4Mask.html">IPv4Mask</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/InterfaceByIndex.html">InterfaceByIndex</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/InterfaceByName.html">InterfaceByName</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/FileListener.html">FileListener</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/Listen.html">Listen</a></li>
</ul>
<h2 id="结构"><a class="header" href="#结构">结构</a></h2>
<ul>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/Addr.html">Addr</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/AddrError.html">AddrError</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/AddrError.html">Error</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/AddrError.html">Temporary</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/AddrError.html">Timeout</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/Conn.html">Conn</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/Conn.html">Read</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/Conn.html">Write</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/Conn.html">Close</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/Conn.html">LocalAddr</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/Conn.html">RemoteAddr</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/Conn.html">SetDeadline</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/Conn.html">SetReadDeadline</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/Conn.html">SetWriteDeadline</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/DNSConfigError.html">DNSConfigError</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/DNSConfigError.html">Error</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/DNSConfigError.html">Temporary</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/DNSConfigError.html">Timeout</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/DNSError.html">DNSError</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/DNSError.html">Error</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/DNSError.html">Temporary</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/DNSError.html">Timeout</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/Error.html">Error</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/Flags.html">Flags</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/Flags.html">String</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/HardwareAddr.html">HardwareAddr</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/HardwareAddr.html">String</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/IP.html">IP</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/IP.html">DefaultMask</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/IP.html">Equal</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/IP.html">IsGlobalUnicast</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/IP.html">IsInterfaceLocalMulticast</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/IP.html">IsLinkLocalMulticast</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/IP.html">IsLinkLocalUnicast</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/IP.html">IsLoopback</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/IP.html">IsMulticast</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/IP.html">IsUnspecified</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/IP.html">Mask</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/IP.html">String</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/IP.html">To16</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/IPAddr.html">IPAddr</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/IPAddr.html">Network</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/IPAddr.html">String</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/IPConn.html">IPConn</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/IPConn.html">Close</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/IPConn.html">File</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/IPConn.html">LocalAddr</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/IPConn.html">Read</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/IPConn.html">ReadFrom</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/IPConn.html">ReadFromIP</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/IPConn.html">RemoteAddr</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/IPConn.html">SetDeadline</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/IPConn.html">SetReadBuffer</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/IPConn.html">SetReadDeadline</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/IPConn.html">SetWriteBuffer</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/IPConn.html">SetWriteDeadline</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/IPConn.html">Write</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/IPConn.html">WriteTo</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/IPConn.html">WriteToIP</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/IPMask.html">IPMask</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/IPMask.html">Size</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/IPMask.html">String</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/IPNet.html">IPNet</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/IPNet.html">Contains</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/IPNet.html">Network</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/IPNet.html">String</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/Interface.html">Interface</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/Interface.html">Addrs</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/Interface.html">MulticastAddrs</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/InvalidAddrError.html">InvalidAddrError</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/InvalidAddrError.html">Error</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/InvalidAddrError.html">Temporary</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/InvalidAddrError.html">Timeout</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/Listener.html">Listener</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/MX.html">MX</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/OpError.html">OpError</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/UDPAddr.html">UDPAddr</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/UDPAddr.html">ResolveUDPAddr</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/UDPAddr.html">Network</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/UDPAddr.html">String</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="net-http"><a class="header" href="#net-http">net http</a></h1>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/CanonicalHeaderKey.html">func CanonicalHeaderKey(s string) string</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/DetectContentType.html">func DetectContentType(data []byte) string</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/Error.html">func Error(w ResponseWriter, error string, code int)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/Handle.html">func Handle(pattern string, handler Handler)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/Handle.html">func HandleFunc(pattern string, handler func(ResponseWriter, *Request)) </a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/ListenAndServe.html">func ListenAndServe(addr string, handler Handler) error</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/ListenAndServeTLS.html">func ListenAndServeTLS(addr string, certFile string, keyFile string, handler Handler) error</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/MaxBytesReader.html">func MaxBytesReader(w ResponseWriter, r io.ReadCloser, n int64) io.ReadCloser</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/NotFound.html">func NotFound(w ResponseWriter, r *Request)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/ParseHTTPVersion.html">func ParseHTTPVersion(vers string) (major, minor int, ok bool)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/ProxyFromEnvironment.html">func ProxyFromEnvironment(req *Request) (*url.URL, error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/ProxyURL.html">func ProxyURL(fixedURL *url.URL) func(*Request) (*url.URL, error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/Redirect.html">func Redirect(w ResponseWriter, r *Request, urlStr string, code int)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/Serve.html">func Serve(l net.Listener, handler Handler) error</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/ServeContent.html">func ServeContent(w ResponseWriter, req *Request, name string, modtime time.Time, content io.ReadSeeker)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/ServeFile.html">func ServeFile(w ResponseWriter, r *Request, name string)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/SetCookie.html">func SetCookie(w ResponseWriter, cookie *Cookie)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/StatusText.html">func StatusText(code int) string</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/typeClient.html">type Client</a>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/Client_Do.html">func (c *Client) Do(req *Request) (resp *Response, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/Client_Get.html">func (c *Client) Get(url string) (resp *Response, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/Client_Head.html">func (c *Client) Head(url string) (resp *Response, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/Client_Post.html">func (c *Client) Post(url string, bodyType string, body io.Reader) (resp *Response, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/Client_PostForm.html">func (c *Client) PostForm(url string, data url.Values) (resp *Response, err error)</a></li>
</ul>
</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/typeCookie.html">type Cookie</a>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/Cookie_String.html">func (c *Cookie) String() string</a></li>
</ul>
</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/typeCookieJar.html">type CookieJar</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/typeDir.html">type Dir</a>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/Dir_Open.html">func (d Dir) Open(name string) (File, error)</a></li>
</ul>
</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/typeFile.html">type File</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/typeFileSystem.html">type FileSystem</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/typeFlusher.html">type Flusher</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/typeHandler.html">type Handler</a>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/Handler_FileServer.html">func FileServer(root FileSystem) Handler</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/Handler_NotFoundHandler.html">func NotFoundHandler() Handler</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/Handler_RedirectHandler.html">func RedirectHandler(url string, code int) Handler</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/Handler_StripPrefix.html">func StripPrefix(prefix string, h Handler) Handler</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/Handler_TimeoutHandler.html">func TimeoutHandler(h Handler, dt time.Duration, msg string) Handler</a></li>
</ul>
</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/typeHandlerFunc.html">type HandlerFunc</a>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/HandlerFunc_ServeHTTP.html">func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request)</a></li>
</ul>
</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/typeHeader.html">type Header</a>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/Header_Add.html">func (h Header) Add(key, value string)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/Header_Del.html">func (h Header) Del(key string)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/Header_Get.html">func (h Header) Get(key string) string</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/Header_Set.html">func (h Header) Set(key, value string)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/Header_Write.html">func (h Header) Write(w io.Writer) error</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/Header_WriteSubset.html">func (h Header) WriteSubset(w io.Writer, exclude map[string]bool) error</a></li>
</ul>
</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/typeHijacker.html">type Hijacker</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/typeProtocolError.html">type ProtocolError</a>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/ProtocolError_Error.html">func (err *ProtocolError) Error() string</a></li>
</ul>
</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/typeRequest.html">type Request</a>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/Request_NewRequest.html">func NewRequest(method, urlStr string, body io.Reader) (*Request, error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/Request_ReadRequest.html">func ReadRequest(b *bufio.Reader) (req *Request, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/Request_AddCookie.html">func (r *Request) AddCookie(c *Cookie)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/Request_Cookie.html">func (r *Request) Cookie(name string) (*Cookie, error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/Cookie_Cookies.html">func (r *Request) Cookies() []*Cookie</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/Cookies_FormFile.html">func (r *Request) FormFile(key string) (multipart.File, *multipart.FileHeader, error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/Cookies_FormValue.html">func (r *Request) FormValue(key string) string</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/Cookies_MultipartReader.html">func (r *Request) MultipartReader() (*multipart.Reader, error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/Cookies_ParseForm.html">func (r *Request) ParseForm() (err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/Cookies_ParseMultipartForm.html">func (r *Request) ParseMultipartForm(maxMemory int64) error</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/Cookies_ProtoAtLeast.html">func (r *Request) ProtoAtLeast(major, minor int) bool</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/Cookies_Referer.html">func (r *Request) Referer() string</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/Cookies_SetBasicAuth.html">func (r *Request) SetBasicAuth(username, password string)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/Cookies_UserAgent.html">func (r *Request) UserAgent() string</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/Cookies_Write.html">func (r *Request) Write(w io.Writer) error</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/Cookies_WriteProxy.html">func (r *Request) WriteProxy(w io.Writer) error</a></li>
</ul>
</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/typeResponse.html">type Response</a>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/Response_Get.html">func Get(url string) (resp *Response, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/Response_Head.html">func Head(url string) (resp *Response, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/Response_Post.html">func Post(url string, bodyType string, body io.Reader) (resp *Response, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/Response_PostForm.html">func PostForm(url string, data url.Values) (resp *Response, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/Response_ReadResponse.html">func ReadResponse(r *bufio.Reader, req *Request) (resp *Response, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/Response_Cookies.html">func (r *Response) Cookies() []*Cookie</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/Response_Location.html">func (r *Response) Location() (*url.URL, error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/Response_ProtoAtLeast.html">func (r *Response) ProtoAtLeast(major, minor int) bool</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/Response_Write.html">func (r *Response) Write(w io.Writer) error</a></li>
</ul>
</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/typeResponseWriter.html">type ResponseWriter</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/typeRoundTripper.html">type RoundTripper</a>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/RoundTripper_NewFileTransport.html">func NewFileTransport(fs FileSystem) RoundTripper</a></li>
</ul>
</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/typeServeMux.html">type ServeMux</a>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/ServeMux_NewServeMux.html">func NewServeMux() *ServeMux</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/ServeMux_Handle.html">func (mux *ServeMux) Handle(pattern string, handler Handler)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/ServeMux_HandleFunc.html">func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request))</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/ServeMux_ServeHTTP.html">func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request)</a></li>
</ul>
</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/typeServer.html">type Server</a>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/Server_ListenAndServe.html">func (srv *Server) ListenAndServe() error</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/Server_ListenAndServeTLS.html">func (srv *Server) ListenAndServeTLS(certFile, keyFile string) error</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/Server_Serve.html">func (srv *Server) Serve(l net.Listener) error</a></li>
</ul>
</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/typeTransport.html">type Transport</a>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/Transport_CloseIdleConnections.html">func (t *Transport) CloseIdleConnections()</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/Transport_RegisterProtocol.html">func (t *Transport) RegisterProtocol(scheme string, rt RoundTripper)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/http/Transport_RoundTrip.html">func (t *Transport) RoundTrip(req *Request) (resp *Response, err error)</a></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名-48"><a class="header" href="#包名-48">包名</a></h1>
<p>函数列表</p>
<ul>
<li>xxx1</li>
<li>xxx2</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名-49"><a class="header" href="#包名-49">包名</a></h1>
<p>函数列表</p>
<ul>
<li>xxx1</li>
<li>xxx2</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名-50"><a class="header" href="#包名-50">包名</a></h1>
<p>函数列表</p>
<ul>
<li>xxx1</li>
<li>xxx2</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名-51"><a class="header" href="#包名-51">包名</a></h1>
<p>函数列表</p>
<ul>
<li>xxx1</li>
<li>xxx2</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名-52"><a class="header" href="#包名-52">包名</a></h1>
<p>函数列表</p>
<ul>
<li>xxx1</li>
<li>xxx2</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-canonicalheaderkeys-string-string"><a class="header" href="#func-canonicalheaderkeys-string-string">func CanonicalHeaderKey(s string) string</a></h2>
<p>参数列表</p>
<ul>
<li>s 需要做标准化的http header字符串 </li>
</ul>
<p>返回值：</p>
<ul>
<li>返回按照http协议定义的标准化字符串</li>
</ul>
<p>功能说明：
这个函数返回一个规范好的标准的http header字符串。
标准化的http header 字符串格式为：
第一个字母和跟着“-”字符后面的第一个字母大写，剩下的字符全部小写。
举个例子：
对于一个http头（header） &quot;accept-encoding&quot; 来说，
规范好的标准化格式就是
&quot;Accept-Encoding&quot;。</p>
<p>代码实例：</p>
<p>package main</p>
<p>import (
&quot;fmt&quot;
&quot;net/http&quot;
)</p>
<p>func main() {
fmt.Println(http.CanonicalHeaderKey(&quot;accept-encoding&quot;))
//Accept-Encoding
fmt.Println(http.CanonicalHeaderKey(&quot;accept-Language&quot;))
//Accept-Language
}</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-detectcontenttypedata-byte-string"><a class="header" href="#func-detectcontenttypedata-byte-string">func DetectContentType(data []byte) string</a></h2>
<p>参数列表</p>
<ul>
<li>data 需要检测类型的数据 </li>
</ul>
<p>返回值：</p>
<ul>
<li>返回检测好的MIME类型。如果不能检测到任何MIME类型，返回&quot;application/octet-stream&quot;。</li>
</ul>
<p>功能说明：</p>
<p>该函数实现了一个算法，用来检测指定的数据是否符合http://mimesniff.spec.whatwg.org/所定义的MIME类型。
该函数最多需要数据的前512个字节。
该函数总是会返回一个有效的MIME类型。
如果它不能够识别数据，将会返回&quot;application/octet-stream&quot;。</p>
<p>代码实例</p>
<p>package main
import (
&quot;fmt&quot;
&quot;net/http&quot;
)</p>
<pre><code>func main() {
	var notingData []byte = []byte{0x01, 0x02}
	var gifData []byte = []byte{0x01, 0x02}				
	fmt.Println(http.DetectContentType(notingData))
	fmt.Println(http.DetectContentType(gifData))
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>##func Error(w ResponseWriter, error string, code int) </p>
<p>参数</p>
<ul>
<li>w 响应的写入器</li>
<li>error 用户定义的错误信息</li>
<li>code  用户定义的http代码</li>
</ul>
<p>返回值</p>
<ul>
<li>无</li>
</ul>
<p>函数功能 </p>
<ul>
<li>该函数通过一个ResponseWriter对象输出指定的错误信息和HTTP代码。</li>
</ul>
<p>例子</p>
<p>package main</p>
<pre><code>import (
	_ &quot;io&quot;
	&quot;log&quot;
	&quot;net/http&quot;
)

// hello world, the web server
func HelloServer(w http.ResponseWriter, req *http.Request) {
	// 正常情况的输出,暂时注释掉了
	//io.WriteString(w, &quot;hello, world!\n&quot;)

	// 输出用户自定义错误
	http.Error(w, &quot;this is a error&quot;, 404)
}

func main() {
	// 指定当用户访问 http://www.xxx.com:mmmm/hello 的时候(注意，请不要在hello后面加上/变成hello/)
	// 调用HelloServer这个函数来处理
	http.HandleFunc(&quot;/hello&quot;, HelloServer)

	// 侦听本地的8888端口
	// 客户可以通过浏览器来访问
	// 可以输入 http://localhost:8888/hello来访问
	// 其中localhost会被转换为127.0.0.1,这是本地ip地址
	// 这里需要注意的问题有
	// 1. 360误报，可以删除360装qq管家
	// 2. 某些浏览器不识别这个端口，需要手动配置一下,或者你可以使用80端口，8080端口
	//    或者换成chrome浏览器尝试一下
	// 3. 本地防火墙阻止
	// 如果顺利的话，你的浏览器会输出 this is a error

	err := http.ListenAndServe(&quot;:8888&quot;, nil)
	if err != nil {
		log.Fatal(&quot;ListenAndServe: &quot;, err)
	}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>##func Handle(pattern string, handler Handler) </p>
<p>参数</p>
<ul>
<li>pattern 需要匹配的pattern，比如/hello, /index.php , /index.aspx等等</li>
<li>handler 实际响应该pattern的函数</li>
</ul>
<p>返回值</p>
<ul>
<li>无</li>
</ul>
<p>函数功能 </p>
<ul>
<li>该函数在缺省的服务器路由（DefaultServeMux）中注册一个函数。当一个请求request进来的时候，缺省的服务器路由会依次根据ServeMux.m中的string（路由表达式）来一个一个匹配。文档（服务器路由）ServeMux解释了路由表达式是如何被匹配的。</li>
</ul>
<p>例子</p>
<p>package main</p>
<pre><code>import (
	&quot;io&quot;
	&quot;log&quot;
	&quot;net/http&quot;
)

// hello world, the web server
func HelloServer(w http.ResponseWriter, req *http.Request) {
	io.WriteString(w, &quot;hello, world!\n&quot;)
}

func IndexPhpServer(w http.ResponseWriter, req *http.Request) {
	io.WriteString(w, &quot;&lt;html&gt;&lt;body&gt;hello,this is a go page for index.php&lt;/body&gt;&lt;/html&gt;\n&quot;)
}

func main() {
	// 指定当用户访问 http://www.xxx.com:mmmm/hello 的时候(注意，请不要在hello后面加上/变成hello/)
	// 调用HelloServer这个函数来处理
	http.HandleFunc(&quot;/hello&quot;, HelloServer)

	// 调用 http://localhost:8888/index.php 访问
	http.HandleFunc(&quot;/index.php&quot;, IndexPhpServer)

	// 侦听本地的8888端口
	// 客户可以通过浏览器来访问
	// 可以输入 http://localhost:8888/hello来访问
	// 其中localhost会被转换为127.0.0.1,这是本地ip地址
	// 这里需要注意的问题有
	// 1. 360误报，可以删除360装qq管家
	// 2. 某些浏览器不识别这个端口，需要手动配置一下,或者你可以使用80端口，8080端口
	//    或者换成chrome浏览器尝试一下
	// 3. 本地防火墙阻止
	// 如果顺利的话，你的浏览器会输出 this is a error

	err := http.ListenAndServe(&quot;:8888&quot;, nil)
	if err != nil {
		log.Fatal(&quot;ListenAndServe: &quot;, err)
	}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>##func ListenAndServe(addr string, handler Handler) error </p>
<p>参数</p>
<ul>
<li>addr http服务监听的地址(端口号)，一般网站默认为80端口</li>
<li>handler </li>
</ul>
<p>返回值</p>
<ul>
<li>error 返回错误。一般是端口被占用比较多</li>
</ul>
<p>函数功能 </p>
<ul>
<li>该函数监听addr指定的端口号，然后调用handler提供的服务处理连接的请求。
handler一般我们可以设置为nil，这样我们会使用缺省的服务路由器。</li>
</ul>
<p>例子</p>
<p>package main</p>
<pre><code>import (
	&quot;io&quot;
	&quot;log&quot;
	&quot;net/http&quot;
)

// hello world, the web server
func HelloServer(w http.ResponseWriter, req *http.Request) {
	io.WriteString(w, &quot;hello, world!\n&quot;)
}

func IndexPhpServer(w http.ResponseWriter, req *http.Request) {
	io.WriteString(w, &quot;&lt;html&gt;&lt;body&gt;hello,this is a go page for index.php&lt;/body&gt;&lt;/html&gt;\n&quot;)
}

func main() {
	// 指定当用户访问 http://www.xxx.com:mmmm/hello 的时候(注意，请不要在hello后面加上/变成hello/)
	// 调用HelloServer这个函数来处理
	http.HandleFunc(&quot;/hello&quot;, HelloServer)

	// 调用 http://localhost:8888/index.php 访问
	http.HandleFunc(&quot;/index.php&quot;, IndexPhpServer)

	// 侦听本地的8888端口
	// 客户可以通过浏览器来访问
	// 可以输入 http://localhost:8888/hello来访问
	// 其中localhost会被转换为127.0.0.1,这是本地ip地址
	// 这里需要注意的问题有
	// 1. 360误报，可以删除360装qq管家
	// 2. 某些浏览器不识别这个端口，需要手动配置一下,或者你可以使用80端口，8080端口
	//    或者换成chrome浏览器尝试一下
	// 3. 本地防火墙阻止
	// 如果顺利的话，你的浏览器会输出 this is a error

	err := http.ListenAndServe(&quot;:8888&quot;, nil)
	if err != nil {
		log.Fatal(&quot;ListenAndServe: &quot;, err)
	}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>##func ListenAndServeTLS(addr string, certFile string, keyFile string, handler Handler) error </p>
<p>参数</p>
<ul>
<li>addr http服务监听的地址(端口号)，一般网站默认为80端口</li>
<li>certFile https 证书文件</li>
<li>keyFile https key文件</li>
<li>handler 处理连接请求的函数</li>
</ul>
<p>返回值</p>
<ul>
<li>error 返回错误。一般是端口被占用比较多</li>
</ul>
<p>函数功能 </p>
<ul>
<li>这个函数基本上跟该函数ListenAndServe功能相同。不过它特别处理https连接。该函数监听addr指定的端口号，然后调用handler提供的服务处理连接的请求。
handler一般我们可以设置为nil，这样我们会使用缺省的服务路由器。特别的，我们必须指定一个证书文件和对应的key文件.单单作为测试，这两个文件我们可以通过Go\src\pkg\crypto\tls\generate_cert.go生成两个文件，放到.exe的目录所在即可。</li>
</ul>
<p>例子</p>
<p>package main</p>
<pre><code>import (
	&quot;io&quot;
	&quot;log&quot;
	&quot;net/http&quot;
)

// hello world, the web server
func HelloServer(w http.ResponseWriter, req *http.Request) {
	io.WriteString(w, &quot;hello, world!\n&quot;)
}

func IndexPhpServer(w http.ResponseWriter, req *http.Request) {
	io.WriteString(w, &quot;&lt;html&gt;&lt;body&gt;hello,this is a go page for index.php&lt;/body&gt;&lt;/html&gt;\n&quot;)
}

func main() {
	// 指定当用户访问 http://www.xxx.com:mmmm/hello 的时候(注意，请不要在hello后面加上/变成hello/)
	// 调用HelloServer这个函数来处理
	http.HandleFunc(&quot;/hello&quot;, HelloServer)

	// 调用 http://localhost:8888/index.php 访问
	http.HandleFunc(&quot;/index.php&quot;, IndexPhpServer)

	// 侦听本地的8888端口
	// 客户可以通过浏览器来访问
	// 可以输入 http://localhost:8888/hello来访问
	// 其中localhost会被转换为127.0.0.1,这是本地ip地址
	// 这里需要注意的问题有
	// 1. 360误报，可以删除360装qq管家
	// 2. 某些浏览器不识别这个端口，需要手动配置一下,或者你可以使用80端口，8080端口
	//    或者换成chrome浏览器尝试一下
	// 3. 本地防火墙阻止
	// 如果顺利的话，你的浏览器会输出 this is a error

	err := http.ListenAndServeTLS(&quot;:8888&quot;, &quot;cert.pem&quot;, &quot;key.pem&quot;, nil)
	if err != nil {
		log.Fatal(&quot;ListenAndServe: &quot;, err)
	}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>##func MaxBytesReader(w ResponseWriter, r io.ReadCloser, n int64) io.ReadCloser </p>
<p>参数</p>
<ul>
<li>w ResponseWriter</li>
<li>r io.ReadCloser，一般可以指向req.Body</li>
<li>n 限制的大小</li>
</ul>
<p>返回值</p>
<ul>
<li>io.ReadCloser </li>
</ul>
<p>函数功能 </p>
<ul>
<li>MaxBytesReader跟io.LimitReader函数很像。但是它被设计来设置接收的请求体的最大大小。
跟io.LimitReader不同MaxBytesReader的返回值是一个ReadCloser，当读取超过限制时会返回non-EOF错误。
并且当它调用关闭方法的时候会把潜在的读取者（函数/进程）也关闭掉。</li>
</ul>
<p>MaxBytesReader用来保护服务器端，以避免客户端偶然或者恶意发送的长数据请求导致的server资源的浪费。 </p>
<p>例子 服务器端
调用这个函数限制客户端上传数据为10个字节</p>
<p>package main</p>
<pre><code>import (
	&quot;fmt&quot;
	&quot;io&quot;
	&quot;io/ioutil&quot;
	&quot;log&quot;
	&quot;net/http&quot;
)

// hello world, the web server
func HelloServer(w http.ResponseWriter, req *http.Request) {
	fmt.Println(&quot;come on&quot;)

	req.Body = http.MaxBytesReader(w, req.Body, 10)
	n, err := io.Copy(ioutil.Discard, req.Body)
	if err == nil {
		fmt.Println(&quot;iocpy err&quot;)
	}
	if n != 20 {
		fmt.Println(&quot;io.Copy = &quot;, n, &quot;, want 20&quot;)
	}

	io.WriteString(w, &quot;hello, world!hello, world!hello, world!hello, world!hello, world!\n&quot;)

}

func main() {

	// 指定当用户访问 http://www.xxx.com:mmmm/hello 的时候(注意，请不要在hello后面加上/变成hello/)
	// 调用HelloServer这个函数来处理
	http.HandleFunc(&quot;/hello&quot;, HelloServer)

	err := http.ListenAndServe(&quot;:8888&quot;, nil)
	if err != nil {
		log.Fatal(&quot;ListenAndServe: &quot;, err)
	}

}
</code></pre>
<p>客户端发送JSON数据</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;net/http&quot;
	&quot;strings&quot;
)

func main() {
	json := `{&quot;content&quot;:&quot;hello,world&quot;}`
	b := strings.NewReader(json)

	http.Post(&quot;http://localhost:8888/hello&quot;, &quot;image/jpeg&quot;, b)
	fmt.Println(&quot;post ok&quot;)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-notfoundw-responsewriter-r-request"><a class="header" href="#func-notfoundw-responsewriter-r-request">func NotFound(w ResponseWriter, r *Request)</a></h2>
<p>参数</p>
<ul>
<li>w 响应的写入器</li>
<li>r 用户请求</li>
</ul>
<p>返回值</p>
<ul>
<li>无</li>
</ul>
<p>函数功能 </p>
<ul>
<li>该函数通过一个ResponseWriter对象输出404 page not found。</li>
</ul>
<p>例子
package main</p>
<pre><code>import (
	_ &quot;io&quot;
	&quot;log&quot;
	&quot;net/http&quot;
)

func HelloServer(w http.ResponseWriter, req *http.Request) {
	http.NotFound(w, req)
}

func main() {

	http.HandleFunc(&quot;/hello&quot;, HelloServer)
	err := http.ListenAndServe(&quot;:8888&quot;, nil)
	if err != nil {
		log.Fatal(&quot;ListenAndServe: &quot;, err)
	}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-parsehttpversionvers-string-major-minor-int-ok-bool"><a class="header" href="#func-parsehttpversionvers-string-major-minor-int-ok-bool">func ParseHTTPVersion(vers string) (major, minor int, ok bool)</a></h2>
<p>参数</p>
<ul>
<li>vers 响应的写入器</li>
<li>r 用户请求</li>
</ul>
<p>返回值</p>
<ul>
<li>major 主版本号</li>
<li>minor 从版本号</li>
<li>ok    true或者false</li>
</ul>
<p>函数功能 </p>
<ul>
<li>该函数解析一个HTTP 版本字符串. 比如输入&quot;HTTP/1.0&quot; 将会返回 (1, 0, true). </li>
</ul>
<p>例子
package main</p>
<pre><code>import (
	&quot;fmt&quot;
	&quot;net/http&quot;
)

func main() {
	major, minor, ok := http.ParseHTTPVersion(&quot;HTTP/1.0&quot;)
	fmt.Println(major, minor, ok)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-proxyfromenvironmentreq-request-urlurl-error"><a class="header" href="#func-proxyfromenvironmentreq-request-urlurl-error">func ProxyFromEnvironment(req *Request) (*url.URL, error)</a></h2>
<p>参数列表</p>
<ul>
<li>req 用户的请求</li>
</ul>
<p>返回值：</p>
<ul>
<li>*url.URL 代理的URL,如果没有使用代理或者代理全局变量没有定义则返回nil</li>
<li>error 错误，如果没有使用代理或者代理全局变量没有定义则返回nil</li>
</ul>
<p>功能说明：
ProxyFromEnvironment返回给定request的代理url.
一般该URL由用户的环境变量$HTTP_PROXY和$NO_PROXY (或$http_proxy和$no_proxy)指定。
如果用户的全局代理环境无效则返回一个错误。
如果用户没有使用代理或者全局环境变量没有定义则会返回一个nil的URL和一个nil的错误。</p>
<p>代码实例</p>
<p>package main</p>
<pre><code>import (
	&quot;io&quot;
	&quot;log&quot;
	&quot;net/http&quot;
)

func HelloServer(w http.ResponseWriter, req *http.Request) {
	io.WriteString(w, &quot;&lt;html&gt;\n&lt;body&gt;\n&quot;)
	io.WriteString(w, &quot;hello, world!&lt;br/&gt;\n&quot;)

	myurl, _ := http.ProxyFromEnvironment(req)
	if myurl != nil {
		io.WriteString(w, myurl.Scheme+&quot;&lt;br/&gt;\n&quot;)
		io.WriteString(w, myurl.Opaque+&quot;&lt;br/&gt;\n&quot;)
		io.WriteString(w, myurl.Host+&quot;&lt;br/&gt;\n&quot;)
		io.WriteString(w, myurl.Path+&quot;&lt;br/&gt;\n&quot;)
		io.WriteString(w, myurl.RawQuery+&quot;&lt;br/&gt;\n&quot;)
		io.WriteString(w, myurl.Fragment+&quot;&lt;br/&gt;\n&quot;)
	} else {
		io.WriteString(w, &quot;url is null &lt;br/&gt;\n&quot;)
	}
	io.WriteString(w, &quot;&lt;/body&gt;\n&lt;/html&gt;\n&quot;)

}

func main() {

	http.HandleFunc(&quot;/hello&quot;, HelloServer)

	err := http.ListenAndServe(&quot;:8888&quot;, nil)
	if err != nil {
		log.Fatal(&quot;ListenAndServe: &quot;, err)
	}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-proxyurlfixedurl-urlurl-funcrequest-urlurl-error"><a class="header" href="#func-proxyurlfixedurl-urlurl-funcrequest-urlurl-error">func ProxyURL(fixedURL *url.URL) func(*Request) (*url.URL, error)</a></h2>
<p>参数列表</p>
<ul>
<li>fixedURL 代理的URL</li>
</ul>
<p>返回值：</p>
<ul>
<li>func(*Request) (*url.URL, error) 返回一个代理函数</li>
</ul>
<p>功能说明：
ProxyURL返回一个代理函数，这个代理函数（一般在Transport中使用）接受请求，并总是返回一个（代理后的）地址。</p>
<p>代码实例</p>
<p>package main</p>
<pre><code>import (
	&quot;fmt&quot;
)

func main() {
	fmt.Println(&quot;这个函数暂时不知道用在什么地方&quot;)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-redirectw-responsewriter-r-request-urlstr-string-code-int"><a class="header" href="#func-redirectw-responsewriter-r-request-urlstr-string-code-int">func Redirect(w ResponseWriter, r *Request, urlStr string, code int)</a></h2>
<p>参数列表</p>
<ul>
<li>w 服务器响应</li>
<li>r 客户端请求</li>
<li>urlStr 要重定向的地址</li>
<li>code 定义在http里面，一般我们可以使用http.StatusFound</li>
</ul>
<p>返回值：</p>
<ul>
<li>无</li>
</ul>
<p>功能说明：
Redirect告诉request重定向到一个url,这个URL可以是请求路径的的相对路径。</p>
<p>代码实例</p>
<p>package main</p>
<pre><code>import (
	&quot;io&quot;
	&quot;log&quot;
	&quot;net/http&quot;
)

func HelloServer(w http.ResponseWriter, req *http.Request) {

	http.Redirect(w, req, &quot;world&quot;, http.StatusFound)

}

func WorldServer(w http.ResponseWriter, req *http.Request) {
	io.WriteString(w, &quot;world server&quot;)

}

func main() {

	http.HandleFunc(&quot;/hello&quot;, HelloServer)
	http.HandleFunc(&quot;/world&quot;, WorldServer)

	err := http.ListenAndServe(&quot;:9999&quot;, nil)
	if err != nil {
		log.Fatal(&quot;ListenAndServe: &quot;, err)
	}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-servel-netlistener-handler-handler-error"><a class="header" href="#func-servel-netlistener-handler-handler-error">func Serve(l net.Listener, handler Handler) error</a></h2>
<p>参数列表</p>
<ul>
<li>l 监听者</li>
<li>handler Handler参数一般是nil，此时使用DefaultServeMux。</li>
</ul>
<p>返回值：</p>
<ul>
<li>error 成功为nil</li>
</ul>
<p>功能说明：
Serve接受Listener l接收到的HTTP连接，并为每个连接创建一个新的线程。服务线程会读取每一个请求，调用handler做出回应。Handler参数一般是nil，此时使用DefaultServeMux。</p>
<p>代码实例</p>
<p>package main</p>
<pre><code>import (
	&quot;io&quot;
	&quot;log&quot;
	&quot;net&quot;
	&quot;net/http&quot;
)

func HelloServer(w http.ResponseWriter, req *http.Request) {

	io.WriteString(w, &quot;hellWorld server&quot;)

}

func main() {

	http.HandleFunc(&quot;/hello&quot;, HelloServer)

	// 首先，创建用tcp协议监听8888端口
	l, e := net.Listen(&quot;tcp&quot;, &quot;:8888&quot;)
	if e != nil {
		log.Fatal(&quot;Listen: &quot;, e)
	}

	// 然后在监听的这个端口上启用http服务进行http服务
	err := http.Serve(l, nil)
	if err != nil {
		log.Fatal(&quot;Serve: &quot;, err)
	}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-servecontentw-responsewriter-req-request-name-string-modtime-timetime-content-ioreadseeker"><a class="header" href="#func-servecontentw-responsewriter-req-request-name-string-modtime-timetime-content-ioreadseeker">func ServeContent(w ResponseWriter, req *Request, name string, modtime time.Time, content io.ReadSeeker)</a></h2>
<p>参数列表</p>
<ul>
<li>w 服务器响应</li>
<li>req 客户端请求</li>
<li>name 文件的名称</li>
<li>modtime 文件的修改时间 </li>
<li>content 文件的内容，必须实现io.ReadSeeker这个接口中的方法</li>
</ul>
<p>返回值：</p>
<ul>
<li>error 成功为nil</li>
</ul>
<p>功能说明：</p>
<p>ServeContent使用ReadSeeker所读取的内容回复给用户请求.
ServeContent比io.Copy更好的是，他能够合适的处理一批请求，设置MIME类型，并且能够处理文件是否修改的请求。
如果响应的内容类型头没有设置,该函数首先会尝试从文件的文件扩展名推断文件类型。
如果推断不出来，则会读取文件的第一个块并传送给DetectContentType来检测类型。
文件名称也可以不使用。
如果文字名称为空，则服务器不会传送给响应。
如果修改时间不为0，ServeContent会把它放在服务器响应的Last-Modified头里面。
如果客户端请求中包含了If-Modified-Since头，ServeContent会使用modtime来判断是否把内容传给客户端。</p>
<p>content的Seek方法必须能够工作。
ServeContent通过定位到文件结尾来确定文件大小。
*os.File中实现了io.ReadSeeker接口。</p>
<p>代码实例</p>
<p>package main</p>
<pre><code>import (
	&quot;fmt&quot;
	&quot;log&quot;
	&quot;net/http&quot;
	&quot;time&quot;
)

// 实现一个byte的ReadSeeker
type MySeeker []byte

// 仅仅是copy输出
func (d MySeeker) Read(p []byte) (n int, err error) {
	n = copy(p, d)
	fmt.Printf(&quot;read is&quot;, n)
	return n, nil
}
func (d MySeeker) Seek(offset int64, whence int) (ret int64, err error) {
	ret = int64(len(d))
	fmt.Printf(&quot;ret is&quot;, ret)
	return ret, nil
}

func Handler(w http.ResponseWriter, r *http.Request) {
	// 仅仅向客户端输出几个字节
	var seeker MySeeker = []byte{'H', 'E', 'L', 'L', 'O', 0}
	
	// 文件名称随便填写了1个
	http.ServeContent(w, r, &quot;1.txt&quot;, time.Now(), seeker)
}
func main() {
	http.HandleFunc(&quot;/hello&quot;, Handler)

	s := &amp;http.Server{
		Addr: &quot;:8888&quot;,
	}
	log.Fatal(s.ListenAndServe())
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-servefilew-responsewriter-r-request-name-string"><a class="header" href="#func-servefilew-responsewriter-r-request-name-string">func ServeFile(w ResponseWriter, r *Request, name string)</a></h2>
<p>参数列表</p>
<ul>
<li>w 响应</li>
<li>r 客户端请求</li>
<li>name 文件名或者文件目录名称</li>
</ul>
<p>返回值：</p>
<ul>
<li>无</li>
</ul>
<p>功能说明：
该函数实现了向客户请求输出目录或者文件内容。</p>
<p>代码实例</p>
<p>package main</p>
<pre><code>import (
	&quot;log&quot;
	&quot;net&quot;
	&quot;net/http&quot;
)

func HelloServer(w http.ResponseWriter, req *http.Request) {

	http.ServeFile(w, req, &quot;index.html&quot;)

}

func main() {

	http.HandleFunc(&quot;/hello&quot;, HelloServer)

	l, e := net.Listen(&quot;tcp&quot;, &quot;:8888&quot;)
	if e != nil {
		log.Fatal(&quot;Listen: &quot;, e)
	}

	err := http.Serve(l, nil)
	if err != nil {
		log.Fatal(&quot;Serve: &quot;, err)
	}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-setcookiew-responsewriter-cookie-cookie"><a class="header" href="#func-setcookiew-responsewriter-cookie-cookie">func SetCookie(w ResponseWriter, cookie *Cookie)</a></h2>
<p>参数列表</p>
<ul>
<li>w 对客户端的响应</li>
<li>cookie cookie的内容</li>
</ul>
<p>返回值：</p>
<ul>
<li>无</li>
</ul>
<p>功能说明：</p>
<p>该函数添加一个Set-Cookie头到客户端响应中</p>
<p>代码实例</p>
<p>package main</p>
<pre><code>import (
	&quot;log&quot;
	&quot;net&quot;
	&quot;net/http&quot;
	&quot;time&quot;
)

func HelloServer(w http.ResponseWriter, req *http.Request) {
	expire := time.Now().AddDate(0, 0, 1)
	mycookie := http.Cookie{&quot;test&quot;, &quot;testcookie&quot;, &quot;/&quot;, &quot;www.sanguohelp.com&quot;, expire, expire.Format(time.UnixDate),
		86400, true, true, &quot;test=testcookie&quot;, []string{&quot;test=tcookie&quot;}}

	http.SetCookie(w, &amp;mycookie)

}

func main() {

	http.HandleFunc(&quot;/hello&quot;, HelloServer)

	l, e := net.Listen(&quot;tcp&quot;, &quot;:8888&quot;)
	if e != nil {
		log.Fatal(&quot;Listen: &quot;, e)
	}

	err := http.Serve(l, nil)
	if err != nil {
		log.Fatal(&quot;Serve: &quot;, err)
	}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-statustextcode-int-string"><a class="header" href="#func-statustextcode-int-string">func StatusText(code int) string</a></h2>
<p>参数列表</p>
<ul>
<li>code 状态码</li>
</ul>
<p>返回值：</p>
<ul>
<li>string 对应状态码的字符串</li>
</ul>
<p>功能说明：
该函数为一个http状态码返回对应的文本。
如果状态码未知的话，则返回一个空的字符串。</p>
<p>代码实例</p>
<p>package main</p>
<pre><code>import (
	&quot;fmt&quot;
	&quot;net/http&quot;
)

func main() {
	fmt.Println(http.StatusText(404))
	fmt.Println(http.StatusText(202))
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="netmail"><a class="header" href="#netmail">net/mail</a></h1>
<p>函数列表</p>
<ul>
<li>函数列表暂时区分于类型吧</li>
</ul>
<p>类型列表</p>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/mail/Address.html">Address</a> - RFC 5322 地址</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/mail/Header.html">Header</a> - 邮件头的 Golang 表示</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/mail/Message.html">Message</a> - 邮件消息的 Golang 表示</li>
</ul>
<p>by: andelf</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="type-address"><a class="header" href="#type-address">type Address</a></h2>
<pre><code class="language-go">type Address struct {
    Name    string // 专有名称；可以为空。
    Address string // user@domain
}
</code></pre>
<p>Address 用于表示邮件中的一个 email 地址，具体格式请参考
RFC 5322，源代码中还包含一个 RFC 2047 的编码函数，
但是没有暴露出来。不过通过小技巧可以使用，请参考例子。</p>
<p>函数列表</p>
<ul>
<li>func (a *Address) String() string</li>
</ul>
<p>邮件地址转换</p>
<pre><code class="language-go">package main

import (
    &quot;net/mail&quot;
    &quot;fmt&quot;
)

func main() {
    addr := mail.Address{&quot;Jim Green&quot;, &quot;noreply@noreply.com&quot;}
    fmt.Println(addr.String())
    // Output: =?utf-8?q?Jim_Green?= &lt;noreply@noreply.com&gt;
    addr = mail.Address{&quot;中文&quot;, &quot;noreply@noreply.com&quot;}
    fmt.Println(addr.String())
    // Output: =?utf-8?q?=E4=B8=AD=E6=96=87?= &lt;noreply@noreply.com&gt;
}
</code></pre>
<p>RFC 2047 编码函数</p>
<pre><code class="language-go">// import net/mail, strings
func EncodeRFC2047(String string) string{
    // use mail's rfc2047 to encode any string
    addr := mail.Address{String, &quot;&quot;}
    return strings.Trim(addr.String(), &quot; &lt;&gt;&quot;)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="type-header"><a class="header" href="#type-header">type Header</a></h2>
<pre><code class="language-go">type Header map[string][]string
</code></pre>
<p>Header 用于表示邮件头中的键值对(Key-Value Pairs)。使用的时候尽量使用 Get() 和 AddressList() 方法操作，别作为 map 操作。</p>
<p>函数列表</p>
<ul>
<li>func (h Header) AddressList(key string) ([]*Address, error)</li>
<li>func (h Header) Date() (time.Time, error)</li>
<li>func (h Header) Get(key string) string</li>
</ul>
<p>该类型一般用于解析，构建消息时由于它缺乏对应的方法，不够方便。相关例子请参考 <a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/mail/Message.html">Message</a>。</p>
<p>如果你熟悉 Golang 其他库的话，那么你会发现 textproto.MIMEHeader 和
mail.Header 以及 http.Header 其实都是 <code>map[string][]string</code>。
所以部分缺失的方法可以用其他库代替，不过这不是好编程习惯。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="type-message"><a class="header" href="#type-message">type Message</a></h2>
<pre><code class="language-go">type Message struct {
    Header Header
    Body   io.Reader
}
</code></pre>
<p>Message 是邮件消息的 Golang 表示，代表一个已经解析了的邮件对象。</p>
<p>函数列表</p>
<ul>
<li>func ReadMessage(r io.Reader) (msg *Message, err error)</li>
</ul>
<pre><code class="language-go">package main

import (
	&quot;net/mail&quot;
	&quot;bytes&quot;
	&quot;io/ioutil&quot;
	&quot;fmt&quot;
)

func main() {
	rawMessage := `From: Feather &lt;dummy@dummy.com&gt;
To: noreply@noreply.com, noreply2@noreply.com
Subject: =?utf-8?B?5rWL6K+V5Y+R6YCB?=
Date: Fri, 21 May 2010 08:54:49 +0800
Message-ID: &lt;m3fx1mt6p2.fsf@dummy.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=utf-8
Content-Transfer-Encoding: plain

Hello Golang Mail`

	buf := bytes.NewBuffer([]byte(rawMessage))
	// parse mail message, buf may from net or somewhere.
	msg, err := mail.ReadMessage(buf)
	if err != nil {
		panic(err)
	}
	// mail body
	body, _ := ioutil.ReadAll(msg.Body)
	fmt.Printf(&quot;Mail Body:\n%s\n&quot;, body)

	fmt.Println(&quot;To Addresses:&quot;)
	printAddrs(msg, &quot;to&quot;)

	fmt.Println(&quot;From Address:&quot;)
	printAddrs(msg, &quot;From&quot;)

	// auto convert to golang time.Time
	date, _ := msg.Header.Date()
	fmt.Println(&quot;Date:&quot;, date)

	// mime header will ignore case
	fmt.Println(&quot;mime version:&quot;, msg.Header.Get(&quot;mime-version&quot;))
}

func printAddrs(msg *mail.Message, filedName string) {
	addrs, err := msg.Header.AddressList(filedName)
	if err != nil {
		panic(err)
	}
	for _, addr := range addrs {
		fmt.Println(&quot;Addr:&quot;, addr)
	}
}
</code></pre>
<p>示例中有几个需要注意的地方</p>
<ul>
<li>邮件头的 mime 域不区分大小写，适用于 Get()、 AddressList() 。</li>
<li>RFC 2047 编码的字符串不一定会被解码，所以 Subject 不能被还原。
（希望未来版本能完善）</li>
<li>由于邮件服务比较混乱，客户端对标准的实现参差不齐，所以 AddressList()
的解析不一定成功</li>
<li>如果无法信任 net/mail， 建议自己解析</li>
</ul>
<p>发送邮件内容请参考 net/smtp。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="netrpc"><a class="header" href="#netrpc">net/rpc</a></h1>
<h3 id="constants-1"><a class="header" href="#constants-1">CONSTANTS</a></h3>
<pre><code>const (
    // Defaults used by HandleHTTP
    DefaultRPCPath   = &quot;/_goRPC_&quot;
    DefaultDebugPath = &quot;/debug/rpc&quot;
)
</code></pre>
<h3 id="variables-2"><a class="header" href="#variables-2">VARIABLES</a></h3>
<pre><code>var DefaultServer = NewServer()
    DefaultServer is the default instance of *Server.
var ErrShutdown = errors.New(&quot;connection is shut down&quot;)
</code></pre>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/rpc/Accept.html">func Accept(lis net.Listener)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/rpc/HandleHTTP.html">func HandleHTTP()</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/rpc/Register.html">func Register(rcvr interface{}) error</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/rpc/RegisterName.html">func RegisterName(name string, rcvr interface{}) error</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/rpc/ServeCodec.html">func ServeCodec(codec ServerCodec)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/rpc/ServeConn.html">func ServeConn(conn io.ReadWriteCloser)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/rpc/ServeRequest.html">func ServeRequest(codec ServerCodec) error</a></li>
</ul>
<h3 id="type-call"><a class="header" href="#type-call">type Call</a></h3>
<pre><code>type Call struct {
    ServiceMethod string      // The name of the service and method to call.
    Args          interface{} // The argument to the function (*struct).
    Reply         interface{} // The reply from the function (*struct).
    Error         error       // After completion, the error status.
    Done          chan *Call  // Strobes when call is complete.
}
</code></pre>
<h3 id="type-client"><a class="header" href="#type-client">type Client</a></h3>
<pre><code>type Client struct {
    // contains filtered or unexported fields
}
</code></pre>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/rpc/Dial.html">func Dial(network, address string) (*Client, error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/rpc/DialHTTP.html">func DialHTTP(network, address string) (*Client, error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/rpc/DialHTTPPath.html">func DialHTTPPath(network, address, path string) (*Client, error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/rpc/NewClient.html">func NewClient(conn io.ReadWriteCloser) *Client</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/rpc/NewClientWithCodec.html">func NewClientWithCodec(codec ClientCodec) *Client</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/rpc/Client_Call.html">func (client *Client) Call(serviceMethod string, args interface{}, reply interface{}) error</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/rpc/Client_Go.html">func (client *Client) Go(serviceMethod string, args interface{}, reply interface{}, done chan *Call) *Call</a></li>
</ul>
<h3 id="type-clientcodec"><a class="header" href="#type-clientcodec">type ClientCodec</a></h3>
<pre><code>type ClientCodec interface {
    WriteRequest(*Request, interface{}) error
    ReadResponseHeader(*Response) error
    ReadResponseBody(interface{}) error

    Close() error
}
</code></pre>
<h3 id="type-request"><a class="header" href="#type-request">type Request</a></h3>
<pre><code>type Request struct {
    ServiceMethod string // format: &quot;Service.Method&quot;
    Seq           uint64 // sequence number chosen by client
    // contains filtered or unexported fields
}
</code></pre>
<h3 id="type-response"><a class="header" href="#type-response">type Response</a></h3>
<pre><code>type Response struct {
    ServiceMethod string // echoes that of the Request
    Seq           uint64 // echoes that of the request
    Error         string // error, if any.
    // contains filtered or unexported fields
}
</code></pre>
<h3 id="type-server"><a class="header" href="#type-server">type Server</a></h3>
<pre><code>type Server struct {
    // contains filtered or unexported fields
}
</code></pre>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/rpc/NewServer.html">func NewServer() *Server</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/rpc/Server_Accept.html">func (server *Server) Accept(lis net.Listener)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/rpc/Server_HandleHTTP.html">func (server *Server) HandleHTTP(rpcPath, debugPath string)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/rpc/Server_Register.html">func (server *Server) Register(rcvr interface{}) error</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/rpc/Server_RegisterName.html">func (server *Server) RegisterName(name string, rcvr interface{}) errorr</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/rpc/Server_ServeCodec.html">func (server *Server) ServeCodec(codec ServerCodec)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/rpc/Server_ServeConn.html">func (server *Server) ServeConn(conn io.ReadWriteCloser)</a></li>
<li>[func (server *Server) ServeHTTP(w http.ResponseWriter, req *http.Request)]</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/rpc/Server_ServeRequest.html">func (server *Server) ServeRequest(codec ServerCodec) error</a></li>
</ul>
<h3 id="type-servercodec"><a class="header" href="#type-servercodec">type ServerCodec</a></h3>
<pre><code>type ServerCodec interface {
    ReadRequestHeader(*Request) error
    ReadRequestBody(interface{}) error
    WriteResponse(*Response, interface{}) error
    Close() error
}
</code></pre>
<h3 id="type-servererror"><a class="header" href="#type-servererror">type ServerError</a></h3>
<pre><code>type ServerError string
</code></pre>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/rpc/ServerError_Error.html">func (e ServerError) Error() string</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名-53"><a class="header" href="#包名-53">包名</a></h1>
<p>函数列表</p>
<ul>
<li>xxx1</li>
<li>xxx2</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-acceptlis-netlistener"><a class="header" href="#func-acceptlis-netlistener">func Accept(lis net.Listener)</a></h2>
<p>参数列表</p>
<p>-lis 要设置的网络监听对象</p>
<p>返回值：</p>
<p>功能说明：</p>
<p>这个函数主要来设置网络连接监听，以响应每次的网络连接请求。如果看源码就会发现，这个方法实际上是调用DefaultServer.Accept(lis)这个方法。这个方法一般用go rpc.Accept(l)进行调用。 </p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;log&quot;
    &quot;net&quot;
    &quot;net/rpc&quot;
    &quot;time&quot;
)

type Args struct {
    A, B int
}
type Quotient struct {
    Quo, Rem int
}
type Arith int

func (t *Arith) Multiply(args *Args, reply *int) error {
    *reply = args.A * args.B
    return nil
}

func main() {
    //设置服务端
    arith := new(Arith)
    //注册服务
    rpc.Register(arith)
    //创建连接监听
    l, e := net.Listen(&quot;tcp&quot;, &quot;:1234&quot;)
    if e != nil {
        log.Fatal(&quot;listen error:&quot;, e)
    }
    //设置连接监听
    go rpc.Accept(l)

    //暂停2秒，让服务器有足够的时间开启
    time.Sleep(2 * time.Second)

    //使用TCP的方式进行网络请求
    client, _ := rpc.Dial(&quot;tcp&quot;, &quot;127.0.0.1:1234&quot;)
    defer client.Close()

    args := &amp;Args{7, 8}
    var reply int
    //呼叫请求
    err := client.Call(&quot;Arith.Multiply&quot;, args, &amp;reply)
    if err != nil {
        log.Fatal(&quot;arith error:&quot;, err)
    }
    log.Println(reply)

}
</code></pre>
<p>结果:2013/03/19 20:35:05 56</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-client-client-callservicemethod-string-args-interface-reply-interface-error"><a class="header" href="#func-client-client-callservicemethod-string-args-interface-reply-interface-error">func (client *Client) Call(serviceMethod string, args interface{}, reply interface{}) error</a></h2>
<p>参数列表
-serviceMethod 服务名称
-args 发送的参数
-reply 回复
返回值：
-error 错误信息</p>
<p>功能说明：</p>
<p>这个函数是用来调用rpc服务。</p>
<p>代码实例：</p>
<pre><code> package main

import (
    &quot;log&quot;
    &quot;net&quot;
    &quot;net/rpc&quot;
    &quot;time&quot;
)

type Args struct {
    A, B int
}
type Quotient struct {
    Quo, Rem int
}
type Arith int

func (t *Arith) Multiply(args *Args, reply *int) error {
    *reply = args.A * args.B
    return nil
}

func main() {
    //设置服务端
    arith := new(Arith)
    //注册服务
    rpc.Register(arith)
    //将服务注册到了HTTP协议
    rpc.HandleHTTP()
    //创建连接监听
    l, e := net.Listen(&quot;tcp&quot;, &quot;:1234&quot;)
    if e != nil {
        log.Fatal(&quot;listen error:&quot;, e)
    }
    //设置连接监听
    go rpc.Accept(l)
    //设置自定义的serverCodec

    //暂停2秒，让服务器有足够的时间开启
    time.Sleep(2 * time.Second)

    //设置客户端
    client, _ := rpc.Dial(&quot;tcp&quot;, &quot;127.0.0.1:1234&quot;)

    args := &amp;Args{7, 8}
    var reply int
    err := client.Call(&quot;Arith.Multiply&quot;, args, &amp;reply)
    if err != nil {
        log.Fatal(&quot;arith error:&quot;, err)
    }
    log.Println(reply)

}
</code></pre>
<p>结果:2013/03/21 20:29:45 56</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-client-client-goservicemethod-string-args-interface-reply-interface-done-chan-call-call"><a class="header" href="#func-client-client-goservicemethod-string-args-interface-reply-interface-done-chan-call-call">func (client *Client) Go(serviceMethod string, args interface{}, reply interface{}, done chan *Call) *Call</a></h2>
<p>参数列表
-serviceMethod 服务名称
-args 发送的参数
-reply 回复
-done 一个Call类型的channel
返回值：
-Call 返回一个Call</p>
<p>功能说明：</p>
<p>这个函数是用来异步调用rpc服务</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;errors&quot;
    &quot;log&quot;
    &quot;net&quot;
    &quot;net/rpc&quot;
    &quot;time&quot;
)

type Args struct {
    A, B int
}
type Quotient struct {
    Quo, Rem int
}
type Arith int

func (t *Arith) Multiply(args *Args, reply *int) error {
    *reply = args.A * args.B
    return nil
}
func (t *Arith) Divide(args *Args, quo *Quotient) error {
    if args.B == 0 {
        return errors.New(&quot;divide by zero&quot;)
    }
    quo.Quo = args.A / args.B
    quo.Rem = args.A % args.B
    return nil
}

func main() {
    //设置服务端
    arith := new(Arith)
    //注册服务
    rpc.Register(arith)
    //将服务注册到了HTTP协议
    rpc.HandleHTTP()
    //创建连接监听
    l, e := net.Listen(&quot;tcp&quot;, &quot;:1234&quot;)
    if e != nil {
        log.Fatal(&quot;listen error:&quot;, e)
    }
    //设置连接监听
    go rpc.Accept(l)
    //设置自定义的serverCodec

    //暂停2秒，让服务器有足够的时间开启
    time.Sleep(2 * time.Second)

    //使用TCP的方式进行网络请求
    client, _ := rpc.Dial(&quot;tcp&quot;, &quot;127.0.0.1:1234&quot;)

    defer client.Close()

    args := &amp;Args{7, 8}
    var reply int
    call := client.Go(&quot;Arith.Multiply&quot;, args, &amp;reply, make(chan *rpc.Call, 1))
    call = &lt;-call.Done
    if call.Error != nil {
        log.Println(&quot;error:&quot;, call.Error)
    }
    log.Println(reply)

}
</code></pre>
<p>结果:2013/03/21 20:56:39 56</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-dialnetwork-address-string-client-error"><a class="header" href="#func-dialnetwork-address-string-client-error">func Dial(network, address string) (*Client, error)</a></h2>
<p>参数列表
-network 要连接网络协议,例如tcp
-address 要连接的网络地址，例如192.168.1.1:8080</p>
<p>返回值：
-Client 客户端，返回一个连接到rpc服务的客户端对象
-error 错误对象，当连接服务出现错误时，就会返回一个错误对象。</p>
<p>功能说明：</p>
<p>这个函数是用来连接rpc服务，并返回一个客户端对象。 </p>
<p>代码实例：</p>
<pre><code>   package main

import (
    &quot;errors&quot;
    &quot;log&quot;
    &quot;net&quot;
    &quot;net/rpc&quot;
    &quot;time&quot;
)

type Args struct {
    A, B int
}
type Quotient struct {
    Quo, Rem int
}
type Arith int

func (t *Arith) Multiply(args *Args, reply *int) error {
    *reply = args.A * args.B
    return nil
}
func (t *Arith) Divide(args *Args, quo *Quotient) error {
    if args.B == 0 {
        return errors.New(&quot;divide by zero&quot;)
    }
    quo.Quo = args.A / args.B
    quo.Rem = args.A % args.B
    return nil
}

func main() {
    //设置服务端
    arith := new(Arith)
    //注册服务
    rpc.Register(arith)
    //将服务注册到了HTTP协议
    rpc.HandleHTTP()
    //创建连接监听
    l, e := net.Listen(&quot;tcp&quot;, &quot;:1234&quot;)
    if e != nil {
        log.Fatal(&quot;listen error:&quot;, e)
    }
    //设置连接监听
    go rpc.Accept(l)

    //暂停2秒，让服务器有足够的时间开启
    time.Sleep(2 * time.Second)

    //设置客户端
    //使用TCP的方式进行网络请求
    client, _ := rpc.Dial(&quot;tcp&quot;, &quot;127.0.0.1:1234&quot;)
    defer client.Close()

    args := &amp;Args{7, 8}
    var reply int
    //呼叫请求
    err := client.Call(&quot;Arith.Multiply&quot;, args, &amp;reply)
    if err != nil {
        log.Fatal(&quot;arith error:&quot;, err)
    }
    log.Println(reply)

}
</code></pre>
<p>结果:2013/03/21 19:45:25 56</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-dialhttpnetwork-address-string-client-error"><a class="header" href="#func-dialhttpnetwork-address-string-client-error">func DialHTTP(network, address string) (*Client, error)</a></h2>
<p>参数列表
-network 要连接网络协议,例如tcp
-address 要连接的网络地址，例如192.168.1.1:8080</p>
<p>返回值：
-Client 客户端，返回一个连接到rpc服务的客户端对象
-error 错误对象，当连接服务出现错误时，就会返回一个错误对象。</p>
<p>功能说明：</p>
<p>这个函数是用来连接Http的rpc服务，并返回一个客户端对象。 </p>
<p>代码实例：</p>
<pre><code>  package main

import (
    &quot;errors&quot;
    &quot;log&quot;
    &quot;net&quot;
    &quot;net/http&quot;
    &quot;net/rpc&quot;
    &quot;time&quot;
)

type Args struct {
    A, B int
}
type Quotient struct {
    Quo, Rem int
}
type Arith int

func (t *Arith) Multiply(args *Args, reply *int) error {
    *reply = args.A * args.B
    return nil
}
func (t *Arith) Divide(args *Args, quo *Quotient) error {
    if args.B == 0 {
        return errors.New(&quot;divide by zero&quot;)
    }
    quo.Quo = args.A / args.B
    quo.Rem = args.A % args.B
    return nil
}

func main() {
    //设置服务端
    arith := new(Arith)
    //注册服务
    rpc.Register(arith)
    //将服务注册到了HTTP协议
    rpc.HandleHTTP()
    //创建连接监听
    l, e := net.Listen(&quot;tcp&quot;, &quot;:1234&quot;)
    if e != nil {
        log.Fatal(&quot;listen error:&quot;, e)
    }
    //设置连接监听
    go http.Serve(l, nil)

    //暂停2秒，让服务器有足够的时间开启
    time.Sleep(2 * time.Second)

    //设置客户端
    //使用TCP的方式进行网络请求
    client, err := rpc.DialHTTP(&quot;tcp&quot;, &quot;127.0.0.1:1234&quot;)
    if err != nil {
        log.Fatal(&quot;dialHttp:&quot;, err)
    }
    defer client.Close()

    args := &amp;Args{7, 8}
    var reply int
    //呼叫请求
    err = client.Call(&quot;Arith.Multiply&quot;, args, &amp;reply)
    if err != nil {
        log.Fatal(&quot;arith error:&quot;, err)
    }
    log.Println(reply)

}
</code></pre>
<p>结果: 2013/03/21 20:07:35 56</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-dialhttppathnetwork-address-path-string-client-error"><a class="header" href="#func-dialhttppathnetwork-address-path-string-client-error">func DialHTTPPath(network, address, path string) (*Client, error)</a></h2>
<p>参数列表
-network 要连接网络协议,例如tcp
-address 要连接的网络地址，例如192.168.1.1:8080
-path rpc地址</p>
<p>返回值：
-Client 客户端，返回一个连接到rpc服务的客户端对象
-error 错误对象，当连接服务出现错误时，就会返回一个错误对象。</p>
<p>功能说明：</p>
<p>这个函数是用来连接rpc服务，并返回一个客户端对象。 </p>
<p>代码实例：</p>
<pre><code>  package main

import (
    &quot;errors&quot;
    &quot;log&quot;
    &quot;net&quot;
    &quot;net/http&quot;
    &quot;net/rpc&quot;
    &quot;time&quot;
)

type Args struct {
    A, B int
}
type Quotient struct {
    Quo, Rem int
}
type Arith int

func (t *Arith) Multiply(args *Args, reply *int) error {
    *reply = args.A * args.B
    return nil
}
func (t *Arith) Divide(args *Args, quo *Quotient) error {
    if args.B == 0 {
        return errors.New(&quot;divide by zero&quot;)
    }
    quo.Quo = args.A / args.B
    quo.Rem = args.A % args.B
    return nil
}

func main() {
    //设置服务端
    arith := new(Arith)
    //注册服务
    rpc.Register(arith)
    //将服务注册到了HTTP协议
    rpc.HandleHTTP()
    //创建连接监听
    l, e := net.Listen(&quot;tcp&quot;, &quot;:1234&quot;)
    if e != nil {
        log.Fatal(&quot;listen error:&quot;, e)
    }
    //设置连接监听
    go http.Serve(l, nil)

    //暂停2秒，让服务器有足够的时间开启
    time.Sleep(2 * time.Second)

    //设置客户端
    //使用TCP的方式进行网络请求
    client, err := rpc.DialHTTPPath(&quot;tcp&quot;, &quot;127.0.0.1:1234&quot;, rpc.DefaultRPCPath)
    if err != nil {
        log.Fatal(&quot;dialHttp:&quot;, err)
    }
    defer client.Close()

    args := &amp;Args{7, 8}
    var reply int
    //呼叫请求
    err = client.Call(&quot;Arith.Multiply&quot;, args, &amp;reply)
    if err != nil {
        log.Fatal(&quot;arith error:&quot;, err)
    }
    log.Println(reply)

}
</code></pre>
<p>结果:2013/03/21 20:15:27 56</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-handlehttp"><a class="header" href="#func-handlehttp">func HandleHTTP()</a></h2>
<p>参数列表</p>
<p>返回值：</p>
<p>功能说明：</p>
<p>这个函数是将rpc的服务注册到http协议上，使用http的方式进行接受数据和传送数据。看源码也会发现，这个方法实际上是调用DefaultServer.HandleHTTP(DefaultRPCPath, DefaultDebugPath)这个方法。 </p>
<p>代码实例：</p>
<pre><code>   package main

import (
    &quot;log&quot;
    &quot;net&quot;
    &quot;net/rpc&quot;
    &quot;time&quot;
)

type Args struct {
    A, B int
}
type Quotient struct {
    Quo, Rem int
}
type Arith int

func (t *Arith) Multiply(args *Args, reply *int) error {
    *reply = args.A * args.B
    return nil
}

func main() {
    //设置服务端
    arith := new(Arith)
    //注册服务
    rpc.Register(arith)
    //将服务注册到了HTTP协议
    rpc.HandleHTTP()
    //创建连接监听
    l, e := net.Listen(&quot;tcp&quot;, &quot;:1234&quot;)
    if e != nil {
        log.Fatal(&quot;listen error:&quot;, e)
    }
    //设置连接监听
    go rpc.Accept(l)

    //暂停2秒，让服务器有足够的时间开启
    time.Sleep(2 * time.Second)

    //设置客户端
    client, _ := rpc.Dial(&quot;tcp&quot;, &quot;127.0.0.1:1234&quot;)
    defer client.Close()

    args := &amp;Args{7, 8}
    var reply int
    //呼叫请求
    err := client.Call(&quot;Arith.Multiply&quot;, args, &amp;reply)
    if err != nil {
        log.Fatal(&quot;arith error:&quot;, err)
    }
    log.Println(reply)

}
</code></pre>
<p>结果:2013/03/19 20:35:05 56</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-newclientconn-ioreadwritecloser-client"><a class="header" href="#func-newclientconn-ioreadwritecloser-client">func NewClient(conn io.ReadWriteCloser) *Client</a></h2>
<p>参数列表
-conn 网络连接对象</p>
<p>返回值：
-Client 客户端，返回一个连接到rpc服务的客户端对象</p>
<p>功能说明：</p>
<p>这个函数是用来连接rpc服务，并创建一个客户端对象。 </p>
<p>代码实例：</p>
<pre><code> package main

import (
    &quot;errors&quot;
    &quot;log&quot;
    &quot;net&quot;
    &quot;net/rpc&quot;
    &quot;time&quot;
)

type Args struct {
    A, B int
}
type Quotient struct {
    Quo, Rem int
}
type Arith int

func (t *Arith) Multiply(args *Args, reply *int) error {
    *reply = args.A * args.B
    return nil
}
func (t *Arith) Divide(args *Args, quo *Quotient) error {
    if args.B == 0 {
        return errors.New(&quot;divide by zero&quot;)
    }
    quo.Quo = args.A / args.B
    quo.Rem = args.A % args.B
    return nil
}

func main() {
    //设置服务端
    arith := new(Arith)
    //注册服务
    rpc.Register(arith)
    //将服务注册到了HTTP协议
    rpc.HandleHTTP()
    //创建连接监听
    l, e := net.Listen(&quot;tcp&quot;, &quot;:1234&quot;)
    if e != nil {
        log.Fatal(&quot;listen error:&quot;, e)
    }
    //设置连接监听
    go rpc.Accept(l)

    //暂停2秒，让服务器有足够的时间开启
    time.Sleep(2 * time.Second)

    //设置客户端
    //使用TCP的方式创建一个连接
    conn, err := net.Dial(&quot;tcp&quot;, &quot;127.0.0.1:1234&quot;)
    if err != nil {
        log.Fatal(&quot;dial error&quot;, err)
    }
    //创建一个客户端对象
    client := rpc.NewClient(conn)
    defer client.Close()

    args := &amp;Args{7, 8}
    var reply int
    //呼叫请求
    err = client.Call(&quot;Arith.Multiply&quot;, args, &amp;reply)
    if err != nil {
        log.Fatal(&quot;arith error:&quot;, err)
    }
    log.Println(reply)

}
</code></pre>
<p>结果: 2013/03/21 20:19:30 56</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-newclientwithcodeccodec-clientcodec-client"><a class="header" href="#func-newclientwithcodeccodec-clientcodec-client">func NewClientWithCodec(codec ClientCodec) *Client</a></h2>
<p>参数列表
-codec ClientCodec,用户处理客户端网络连接的请求和回复。</p>
<p>返回值：
-Client 客户端，返回一个连接到rpc服务的客户端对象</p>
<p>功能说明：</p>
<p>这个函数是用来连接rpc服务，并返回一个客户端对象，可以设置一个 ClientCodec，来处理请求和回复。</p>
<p>代码实例：</p>
<pre><code>  package main

import (
    &quot;bufio&quot;
    &quot;encoding/gob&quot;
    &quot;errors&quot;
    &quot;io&quot;
    &quot;log&quot;
    &quot;net&quot;
    &quot;net/rpc&quot;
    &quot;time&quot;
)

type Args struct {
    A, B int
}
type Quotient struct {
    Quo, Rem int
}
type Arith int

func (t *Arith) Multiply(args *Args, reply *int) error {
    *reply = args.A * args.B
    return nil
}

type myClientCodec struct {
    rwc    io.ReadWriteCloser
    dec    *gob.Decoder
    enc    *gob.Encoder
    encBuf *bufio.Writer
}

func (c *myClientCodec) ReadResponseHeader(r *rpc.Response) error {
    log.Println(&quot;调用:ReadResponseHeader&quot;)
    return c.dec.Decode(r)
}

func (c *myClientCodec) ReadResponseBody(body interface{}) error {
    log.Println(&quot;调用:ReadResponseBody&quot;)
    return c.dec.Decode(body)
}

func (c *myClientCodec) WriteRequest(r *rpc.Request, body interface{}) (err error) {
    log.Println(&quot;调用:WriteRequest&quot;)
    if err = c.enc.Encode(r); err != nil {
        return
    }
    if err = c.enc.Encode(body); err != nil {
        return
    }
    return c.encBuf.Flush()
}

func (c *myClientCodec) Close() error {
    log.Println(&quot;调用:Close&quot;)
    return c.rwc.Close()
}

func main() {
    //设置服务端
    arith := new(Arith)
    //注册服务
    rpc.Register(arith)
    //将服务注册到了HTTP协议
    rpc.HandleHTTP()
    //创建连接监听
    l, e := net.Listen(&quot;tcp&quot;, &quot;:1234&quot;)
    if e != nil {
        log.Fatal(&quot;listen error:&quot;, e)
    }
    //设置连接监听
    go rpc.Accept(l)
    //设置自定义的serverCodec

    //暂停2秒，让服务器有足够的时间开启
    time.Sleep(2 * time.Second)

    //设置客户端
    address, err := net.ResolveTCPAddr(&quot;tcp&quot;, &quot;127.0.0.1:1234&quot;)
    if err != nil {
        panic(err)
    }
    //使用TCP的方式进行网络请求
    conn, _ := net.DialTCP(&quot;tcp&quot;, nil, address)
    defer conn.Close()
    //创建一个客户端
    buf := bufio.NewWriter(conn)
    codec := &amp;myClientCodec{conn, gob.NewDecoder(conn), gob.NewEncoder(buf), buf}
    client := rpc.NewClientWithCodec(codec)
    defer client.Close()

    args := &amp;Args{7, 8}
    var reply int
    err = client.Call(&quot;Arith.Multiply&quot;, args, &amp;reply)
    if err != nil {
        log.Fatal(&quot;arith error:&quot;, err)
    }
    log.Println(reply)

}
</code></pre>
<p>结果:
2013/03/22 20:56:35 调用:WriteRequest
2013/03/22 20:56:35 调用:ReadResponseHeader
2013/03/22 20:56:35 调用:ReadResponseBody
2013/03/22 20:56:35 调用:ReadResponseHeader
2013/03/22 20:56:35 56
2013/03/22 20:56:35 调用:Close</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-newserver-server"><a class="header" href="#func-newserver-server">func NewServer() *Server</a></h2>
<p>参数列表</p>
<p>返回值：</p>
<p>-Server 新的服务对象</p>
<p>功能说明：</p>
<p>这个函数是用来创建一个新的服务对象。 </p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;errors&quot;
    &quot;log&quot;
    &quot;net&quot;
    &quot;net/rpc&quot;
    &quot;time&quot;
)

type Args struct {
    A, B int
}
type Quotient struct {
    Quo, Rem int
}
type Arith int

func (t *Arith) Multiply(args *Args, reply *int) error {
    *reply = args.A * args.B
    return nil
}
func (t *Arith) Divide(args *Args, quo *Quotient) error {
    if args.B == 0 {
        return errors.New(&quot;divide by zero&quot;)
    }
    quo.Quo = args.A / args.B
    quo.Rem = args.A % args.B
    return nil
}

func main() {
    //设置服务端
    arith := new(Arith)
    //注册服务
    server := rpc.NewServer()
    server.Register(arith)
    //创建连接监听
    l, e := net.Listen(&quot;tcp&quot;, &quot;:1234&quot;)
    if e != nil {
        log.Fatal(&quot;listen error:&quot;, e)
    }
    //设置连接监听
    go server.Accept(l)

    //暂停2秒，让服务器有足够的时间开启
    time.Sleep(2 * time.Second)

    //使用TCP的方式进行网络请求
    client, _ := rpc.Dial(&quot;tcp&quot;, &quot;127.0.0.1:1234&quot;)
    defer client.Close()

    args := &amp;Args{7, 8}
    var reply int
    //呼叫请求
    err := client.Call(&quot;Arith.Multiply&quot;, args, &amp;reply)
    if err != nil {
        log.Fatal(&quot;arith error:&quot;, err)
    }
    log.Println(reply)

}
</code></pre>
<p>结果:2013/03/21 20:53:24 56</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-registerrcvr-interface-error"><a class="header" href="#func-registerrcvr-interface-error">func Register(rcvr interface{}) error</a></h2>
<p>参数列表
-rcvr 要注册的服务对象</p>
<p>返回值：</p>
<p>-error 错误对象，当注册服务出现错误时，就会返回一个错误对象。</p>
<p>功能说明：</p>
<p>这个函数是用来注册服务的，看源码也会发现这个方式实际上是调用DefaultServer.Register(rcvr)这个方法。 </p>
<p>代码实例：</p>
<pre><code>    package main

import (
    &quot;log&quot;
    &quot;net&quot;
    &quot;net/rpc&quot;
    &quot;time&quot;
)

type Args struct {
    A, B int
}
type Quotient struct {
    Quo, Rem int
}
type Arith int

func (t *Arith) Multiply(args *Args, reply *int) error {
    *reply = args.A * args.B
    return nil
}

func main() {
    //设置服务端
    arith := new(Arith)
    //注册服务
    rpc.Register(arith)
    //将服务注册到了HTTP协议
    rpc.HandleHTTP()
    //创建连接监听
    l, e := net.Listen(&quot;tcp&quot;, &quot;:1234&quot;)
    if e != nil {
        log.Fatal(&quot;listen error:&quot;, e)
    }
    //设置连接监听
    go rpc.Accept(l)

    //暂停2秒，让服务器有足够的时间开启
    time.Sleep(2 * time.Second)

    //设置客户端
    client, _ := rpc.Dial(&quot;tcp&quot;, &quot;127.0.0.1:1234&quot;)
    defer client.Close()

    args := &amp;Args{7, 8}
    var reply int
    //呼叫请求
    err := client.Call(&quot;Arith.Multiply&quot;, args, &amp;reply)
    if err != nil {
        log.Fatal(&quot;arith error:&quot;, err)
    }
    log.Println(reply)

}
</code></pre>
<p>结果:2013/03/19 20:35:05 56</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-registernamename-string-rcvr-interface-error"><a class="header" href="#func-registernamename-string-rcvr-interface-error">func RegisterName(name string, rcvr interface{}) error</a></h2>
<p>参数列表
-name 要使用的服务别名
-rcvr 要注册的服务对象</p>
<p>返回值：</p>
<p>-error 错误对象，当注册服务出现错误时，就会返回一个错误对象。</p>
<p>功能说明：</p>
<p>这个函数是用来注册服务的，但是提供一个名称用来代替具体的服务类型，例如原本的类型为Arith,可以使用其他名称来代替这个名称，看源码也会发现这个方式实际上是调用DefaultServer.RegisterName(name, rcvr)这个方法。 </p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;log&quot;
    &quot;net&quot;
    &quot;net/rpc&quot;
    &quot;time&quot;
)

type Args struct {
    A, B int
}
type Quotient struct {
    Quo, Rem int
}
type Arith int

func (t *Arith) Multiply(args *Args, reply *int) error {
    *reply = args.A * args.B
    return nil
}

func main() {
    //设置服务端
    arith := new(Arith)
    //注册服务
    rpc.RegisterName(&quot;Server&quot;, arith)
    //将服务注册到了HTTP协议
    rpc.HandleHTTP()
    //创建连接监听
    l, e := net.Listen(&quot;tcp&quot;, &quot;:1234&quot;)
    if e != nil {
        log.Fatal(&quot;listen error:&quot;, e)
    }
    //设置连接监听
    go rpc.Accept(l)

    //暂停2秒，让服务器有足够的时间开启
    time.Sleep(2 * time.Second)

    //设置客户端
    client, _ := rpc.Dial(&quot;tcp&quot;, &quot;127.0.0.1:1234&quot;)
    defer client.Close()

    args := &amp;Args{7, 8}
    var reply int
    //呼叫请求
    err := client.Call(&quot;Server.Multiply&quot;, args, &amp;reply)
    if err != nil {
        log.Fatal(&quot;arith error:&quot;, err)
    }
    log.Println(reply)

}
</code></pre>
<p>结果:2013/03/19 20:35:05 56</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-server-server-acceptlis-netlistener"><a class="header" href="#func-server-server-acceptlis-netlistener">func (server *Server) Accept(lis net.Listener)</a></h2>
<p>参数列表</p>
<p>-lis 要设置的网络监听对象</p>
<p>返回值：</p>
<p>功能说明：</p>
<p>这个函数主要来设置网络连接监听，以响应每次的网络连接请求。这个方法一般用go rpc.Accept(l)进行调用。 </p>
<p>代码实例：</p>
<pre><code>    package main

import (
    &quot;errors&quot;
    &quot;log&quot;
    &quot;net&quot;
    &quot;net/rpc&quot;
    &quot;time&quot;
)

type Args struct {
    A, B int
}
type Quotient struct {
    Quo, Rem int
}
type Arith int

func (t *Arith) Multiply(args *Args, reply *int) error {
    *reply = args.A * args.B
    return nil
}
func (t *Arith) Divide(args *Args, quo *Quotient) error {
    if args.B == 0 {
        return errors.New(&quot;divide by zero&quot;)
    }
    quo.Quo = args.A / args.B
    quo.Rem = args.A % args.B
    return nil
}

func main() {
    //设置服务端
    arith := new(Arith)
    //注册服务
    server := rpc.NewServer()
    server.Register(arith)
    //创建连接监听
    l, e := net.Listen(&quot;tcp&quot;, &quot;:1234&quot;)
    if e != nil {
        log.Fatal(&quot;listen error:&quot;, e)
    }
    //设置连接监听
    go server.Accept(l)

    //暂停2秒，让服务器有足够的时间开启
    time.Sleep(2 * time.Second)

    //使用TCP的方式进行网络请求
    client, _ := rpc.Dial(&quot;tcp&quot;, &quot;127.0.0.1:1234&quot;)
    defer client.Close()

    args := &amp;Args{7, 8}
    var reply int
    //呼叫请求
    err := client.Call(&quot;Arith.Multiply&quot;, args, &amp;reply)
    if err != nil {
        log.Fatal(&quot;arith error:&quot;, err)
    }
    log.Println(reply)

}
</code></pre>
<p>结果:2013/03/21 20:56:39 56</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-server-server-handlehttprpcpath-debugpath-string"><a class="header" href="#func-server-server-handlehttprpcpath-debugpath-string">func (server *Server) HandleHTTP(rpcPath, debugPath string)</a></h2>
<p>参数列表
-rpcPath rpc路径
-debugPath debug路径</p>
<p>返回值：</p>
<p>功能说明：</p>
<p>这个函数是将rpc的服务注册到http协议上，使用http的方式进行接受数据和传送数据，并可以设置 rpcPath和debugPath。</p>
<p>代码实例：</p>
<pre><code>    package main

import (
    &quot;errors&quot;
    &quot;log&quot;
    &quot;net&quot;
    &quot;net/rpc&quot;
    &quot;time&quot;
)

type Args struct {
    A, B int
}
type Quotient struct {
    Quo, Rem int
}
type Arith int

func (t *Arith) Multiply(args *Args, reply *int) error {
    *reply = args.A * args.B
    return nil
}
func (t *Arith) Divide(args *Args, quo *Quotient) error {
    if args.B == 0 {
        return errors.New(&quot;divide by zero&quot;)
    }
    quo.Quo = args.A / args.B
    quo.Rem = args.A % args.B
    return nil
}

func main() {
    //设置服务端
    arith := new(Arith)
    //注册服务
    server := rpc.NewServer()
    server.Register(arith)
    server.HandleHTTP(rpc.DefaultRPCPath, rpc.DefaultDebugPath)
    //创建连接监听
    l, e := net.Listen(&quot;tcp&quot;, &quot;:1234&quot;)
    if e != nil {
        log.Fatal(&quot;listen error:&quot;, e)
    }
    //设置连接监听
    go server.Accept(l)

    //暂停2秒，让服务器有足够的时间开启
    time.Sleep(2 * time.Second)

    //使用TCP的方式进行网络请求
    client, _ := rpc.Dial(&quot;tcp&quot;, &quot;127.0.0.1:1234&quot;)
    defer client.Close()

    args := &amp;Args{7, 8}
    var reply int
    //呼叫请求
    err := client.Call(&quot;Arith.Multiply&quot;, args, &amp;reply)
    if err != nil {
        log.Fatal(&quot;arith error:&quot;, err)
    }
    log.Println(reply)

}
</code></pre>
<p>结果:2013/03/21 21:01:02 56</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-server-server-registerrcvr-interface-error"><a class="header" href="#func-server-server-registerrcvr-interface-error">func (server *Server) Register(rcvr interface{}) error</a></h2>
<p>参数列表
-rcvr 要注册的服务对象</p>
<p>返回值：</p>
<p>-error 错误对象，当注册服务出现错误时，就会返回一个错误对象。</p>
<p>功能说明：</p>
<p>这个函数是用来注册服务的，看源码也会发现这个方式实际上是调用DefaultServer.Register(rcvr)这个方法。</p>
<p>代码实例：</p>
<pre><code>    package main

import (
    &quot;errors&quot;
    &quot;log&quot;
    &quot;net&quot;
    &quot;net/rpc&quot;
    &quot;time&quot;
)

type Args struct {
    A, B int
}
type Quotient struct {
    Quo, Rem int
}
type Arith int

func (t *Arith) Multiply(args *Args, reply *int) error {
    *reply = args.A * args.B
    return nil
}
func (t *Arith) Divide(args *Args, quo *Quotient) error {
    if args.B == 0 {
        return errors.New(&quot;divide by zero&quot;)
    }
    quo.Quo = args.A / args.B
    quo.Rem = args.A % args.B
    return nil
}

func main() {
    //设置服务端
    arith := new(Arith)
    //注册服务
    server := rpc.NewServer()
    server.Register(arith)
    server.HandleHTTP(rpc.DefaultRPCPath, rpc.DefaultDebugPath)
    //创建连接监听
    l, e := net.Listen(&quot;tcp&quot;, &quot;:1234&quot;)
    if e != nil {
        log.Fatal(&quot;listen error:&quot;, e)
    }
    //设置连接监听
    go server.Accept(l)

    //暂停2秒，让服务器有足够的时间开启
    time.Sleep(2 * time.Second)

    //使用TCP的方式进行网络请求
    client, _ := rpc.Dial(&quot;tcp&quot;, &quot;127.0.0.1:1234&quot;)
    defer client.Close()

    args := &amp;Args{7, 8}
    var reply int
    //呼叫请求
    err := client.Call(&quot;Arith.Multiply&quot;, args, &amp;reply)
    if err != nil {
        log.Fatal(&quot;arith error:&quot;, err)
    }
    log.Println(reply)

}
</code></pre>
<p>结果:2013/03/21 21:01:02 56</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-server-server-registernamename-string-rcvr-interface-errorr"><a class="header" href="#func-server-server-registernamename-string-rcvr-interface-errorr">func (server *Server) RegisterName(name string, rcvr interface{}) errorr</a></h2>
<p>参数列表
-name 要使用的服务别名
-rcvr 要注册的服务对象</p>
<p>返回值：</p>
<p>-error 错误对象，当注册服务出现错误时，就会返回一个错误对象。</p>
<p>功能说明：</p>
<p>这个函数是用来注册服务的，但是提供一个名称用来代替具体的服务类型，例如原本的类型为Arith,可以使用其他名称来代替这个名称。</p>
<p>代码实例：</p>
<pre><code>   package main

import (
    &quot;errors&quot;
    &quot;log&quot;
    &quot;net&quot;
    &quot;net/rpc&quot;
    &quot;time&quot;
)

type Args struct {
    A, B int
}
type Quotient struct {
    Quo, Rem int
}
type Arith int

func (t *Arith) Multiply(args *Args, reply *int) error {
    *reply = args.A * args.B
    return nil
}
func (t *Arith) Divide(args *Args, quo *Quotient) error {
    if args.B == 0 {
        return errors.New(&quot;divide by zero&quot;)
    }
    quo.Quo = args.A / args.B
    quo.Rem = args.A % args.B
    return nil
}

func main() {
    //设置服务端
    arith := new(Arith)
    //注册服务
    server := rpc.NewServer()
    server.RegisterName(&quot;Serve&quot;, arith)
    server.HandleHTTP(rpc.DefaultRPCPath, rpc.DefaultDebugPath)
    //创建连接监听
    l, e := net.Listen(&quot;tcp&quot;, &quot;:1234&quot;)
    if e != nil {
        log.Fatal(&quot;listen error:&quot;, e)
    }
    //设置连接监听
    go server.Accept(l)

    //暂停2秒，让服务器有足够的时间开启
    time.Sleep(2 * time.Second)

    //使用TCP的方式进行网络请求
    client, _ := rpc.Dial(&quot;tcp&quot;, &quot;127.0.0.1:1234&quot;)
    defer client.Close()

    args := &amp;Args{7, 8}
    var reply int
    //呼叫请求
    err := client.Call(&quot;Serve.Multiply&quot;, args, &amp;reply)
    if err != nil {
        log.Fatal(&quot;arith error:&quot;, err)
    }
    log.Println(reply)

}
</code></pre>
<p>结果:2013/03/21 21:03:40 56</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-server-server-servecodeccodec-servercodec"><a class="header" href="#func-server-server-servecodeccodec-servercodec">func (server *Server) ServeCodec(codec ServerCodec)</a></h2>
<p>参数列表
-codec 用使用的ServerCodec</p>
<p>返回值：</p>
<p>功能说明：</p>
<p>这个函数是运行一个单连接的DefaultServer，服务一直开启，直到客户端断开连接，并且可以设置ServeCodec，用于处理请求和回复。</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;bufio&quot;
    &quot;encoding/gob&quot;
    &quot;errors&quot;
    &quot;io&quot;
    &quot;log&quot;
    &quot;net&quot;
    &quot;net/rpc&quot;
    &quot;time&quot;
)

type Args struct {
    A, B int
}
type Quotient struct {
    Quo, Rem int
}
type Arith int

func (t *Arith) Multiply(args *Args, reply *int) error {
    *reply = args.A * args.B
    return nil
}
func (t *Arith) Divide(args *Args, quo *Quotient) error {
    if args.B == 0 {
        return errors.New(&quot;divide by zero&quot;)
    }
    quo.Quo = args.A / args.B
    quo.Rem = args.A % args.B
    return nil
}

type myServerCodec struct {
    rwc    io.ReadWriteCloser
    dec    *gob.Decoder
    enc    *gob.Encoder
    encBuf *bufio.Writer
}

func (c *myServerCodec) ReadRequestHeader(r *rpc.Request) error {
    log.Println(&quot;调用:ReadRequestHeader&quot;)
    return c.dec.Decode(r)
}

func (c *myServerCodec) ReadRequestBody(body interface{}) error {
    log.Println(&quot;调用:ReadRequestBody&quot;)
    return c.dec.Decode(body)
}

func (c *myServerCodec) WriteResponse(r *rpc.Response, body interface{}) (err error) {
    log.Println(&quot;调用:WriteResponse&quot;)
    if err = c.enc.Encode(r); err != nil {
        return
    }
    if err = c.enc.Encode(body); err != nil {
        return
    }
    return c.encBuf.Flush()
}

func (c *myServerCodec) Close() error {
    log.Println(&quot;调用:Close&quot;)
    return c.rwc.Close()
}

func myAccept(l net.Listener) {
    //设置服务端
    arith := new(Arith)
    //注册服务
    server := rpc.NewServer()
    server.RegisterName(&quot;Serve&quot;, arith)
    server.HandleHTTP(rpc.DefaultRPCPath, rpc.DefaultDebugPath)
    conn, e := l.Accept()
    if e != nil {
        log.Fatal(&quot;Accept error:&quot;, e)
    }
    //创建一个自定义的ServerCode，实际上这些代码就从go源码中获取出来的
    buf := bufio.NewWriter(conn)
    codec := &amp;myServerCodec{conn, gob.NewDecoder(conn), gob.NewEncoder(buf), buf}
    //运行连接
    go server.ServeCodec(codec)
}
func main() {

    //创建连接监听
    l, e := net.Listen(&quot;tcp&quot;, &quot;:1234&quot;)
    if e != nil {
        log.Fatal(&quot;listen error:&quot;, e)
    }
    //运行服务监听
    go myAccept(l)

    //暂停2秒，让服务器有足够的时间开启
    time.Sleep(2 * time.Second)

    //设置客户端
    address, err := net.ResolveTCPAddr(&quot;tcp&quot;, &quot;127.0.0.1:1234&quot;)
    if err != nil {
        panic(err)
    }
    //使用TCP的方式进行网络请求
    conn, _ := net.DialTCP(&quot;tcp&quot;, nil, address)
    defer conn.Close()
    //创建一个客户端
    client := rpc.NewClient(conn)
    defer client.Close()

    args := &amp;Args{7, 8}
    var reply int
    err = client.Call(&quot;Arith.Multiply&quot;, args, &amp;reply)
    if err != nil {
        log.Fatal(&quot;arith error:&quot;, err)
    }
    log.Println(reply)

}
</code></pre>
<p>结果:
2013/03/21 21:07:59 56</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-server-server-serveconnconn-ioreadwritecloser"><a class="header" href="#func-server-server-serveconnconn-ioreadwritecloser">func (server *Server) ServeConn(conn io.ReadWriteCloser)</a></h2>
<p>参数列表
-conn 网络连接对象</p>
<p>返回值：</p>
<p>功能说明：</p>
<p>这个函数是运行一个单连接的DefaultServer，服务一直连接，直到客户端断开连接。</p>
<p>代码实例：</p>
<p>package main</p>
<p>import (
&quot;errors&quot;
&quot;log&quot;
&quot;net&quot;
&quot;net/rpc&quot;
&quot;time&quot;
)</p>
<p>type Args struct {
A, B int
}
type Quotient struct {
Quo, Rem int
}
type Arith int</p>
<p>func (t *Arith) Multiply(args *Args, reply *int) error {
*reply = args.A * args.B
return nil
}
func (t *Arith) Divide(args *Args, quo *Quotient) error {
if args.B == 0 {
return errors.New(&quot;divide by zero&quot;)
}
quo.Quo = args.A / args.B
quo.Rem = args.A % args.B
return nil
}</p>
<p>func myAccept(l net.Listener) {
arith := new(Arith)
//注册服务
server := rpc.NewServer()
server.Register(arith)
server.HandleHTTP(rpc.DefaultRPCPath, rpc.DefaultDebugPath)
conn, e := l.Accept()
if e != nil {
log.Fatal(&quot;Accept error:&quot;, e)
}
go server.ServeConn(conn)
}
func main() {
//创建连接监听
l, e := net.Listen(&quot;tcp&quot;, &quot;:1234&quot;)
if e != nil {
log.Fatal(&quot;listen error:&quot;, e)
}
//设置连接监听
go myAccept(l)
//设置自定义的serverCodec</p>
<pre><code>//暂停2秒，让服务器有足够的时间开启
time.Sleep(2 * time.Second)

//设置客户端
address, err := net.ResolveTCPAddr(&quot;tcp&quot;, &quot;127.0.0.1:1234&quot;)
if err != nil {
    panic(err)
}
//使用TCP的方式进行网络请求
conn, _ := net.DialTCP(&quot;tcp&quot;, nil, address)
defer conn.Close()
//创建一个客户端
client := rpc.NewClient(conn)
defer client.Close()

args := &amp;Args{7, 8}
var reply int
err = client.Call(&quot;Arith.Multiply&quot;, args, &amp;reply)
if err != nil {
    log.Fatal(&quot;arith error:&quot;, err)
}
log.Println(reply)
</code></pre>
<p>}</p>
<p>结果:
2013/03/21 21:38:43 56</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-server-server-servehttpw-httpresponsewriter-req-httprequest"><a class="header" href="#func-server-server-servehttpw-httpresponsewriter-req-httprequest">func (server *Server) ServeHTTP(w http.ResponseWriter, req *http.Request)</a></h2>
<p>参数列表
-w ResponseWriter对象
-req Request对象</p>
<p>返回值：</p>
<p>功能说明：</p>
<p>这个函数是实现回复和请求的处理。</p>
<p>代码实例：</p>
<pre><code>   package main

import (
    &quot;errors&quot;
    &quot;log&quot;
    &quot;net&quot;
    &quot;net/rpc&quot;
    &quot;time&quot;
)

type Args struct {
    A, B int
}
type Quotient struct {
    Quo, Rem int
}
type Arith int

func (t *Arith) Multiply(args *Args, reply *int) error {
    *reply = args.A * args.B
    return nil
}
func (t *Arith) Divide(args *Args, quo *Quotient) error {
    if args.B == 0 {
        return errors.New(&quot;divide by zero&quot;)
    }
    quo.Quo = args.A / args.B
    quo.Rem = args.A % args.B
    return nil
}

func main() {
    //设置服务端
    arith := new(Arith)
    //注册服务
    server := rpc.NewServer()
    server.RegisterName(&quot;Serve&quot;, arith)
    server.HandleHTTP(rpc.DefaultRPCPath, rpc.DefaultDebugPath)
    //创建连接监听
    l, e := net.Listen(&quot;tcp&quot;, &quot;:1234&quot;)
    if e != nil {
        log.Fatal(&quot;listen error:&quot;, e)
    }
    //设置连接监听
    go server.Accept(l)

    //暂停2秒，让服务器有足够的时间开启
    time.Sleep(2 * time.Second)

    //使用TCP的方式进行网络请求
    client, _ := rpc.Dial(&quot;tcp&quot;, &quot;127.0.0.1:1234&quot;)
    defer client.Close()

    args := &amp;Args{7, 8}
    var reply int
    //呼叫请求
    err := client.Call(&quot;Serve.Multiply&quot;, args, &amp;reply)
    if err != nil {
        log.Fatal(&quot;arith error:&quot;, err)
    }
    log.Println(reply)

}
</code></pre>
<p>结果:2013/03/21 21:03:40 56</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-server-server-serverequestcodec-servercodec-error"><a class="header" href="#func-server-server-serverequestcodec-servercodec-error">func (server *Server) ServeRequest(codec ServerCodec) error</a></h2>
<p>参数列表
-codec 用使用的ServerCodec</p>
<p>返回值：
-error 返回错误信息</p>
<p>功能说明：</p>
<p>这个函数类似ServeCodec,不过这个是同步的。</p>
<p>代码实例：</p>
<p>package main</p>
<pre><code>import (
    &quot;bufio&quot;
    &quot;encoding/gob&quot;
    &quot;errors&quot;
    &quot;io&quot;
    &quot;log&quot;
    &quot;net&quot;
    &quot;net/rpc&quot;
    &quot;time&quot;
)

type Args struct {
    A, B int
}
type Quotient struct {
    Quo, Rem int
}
type Arith int

func (t *Arith) Multiply(args *Args, reply *int) error {
    *reply = args.A * args.B
    return nil
}
func (t *Arith) Divide(args *Args, quo *Quotient) error {
    if args.B == 0 {
        return errors.New(&quot;divide by zero&quot;)
    }
    quo.Quo = args.A / args.B
    quo.Rem = args.A % args.B
    return nil
}

type myServerCodec struct {
    rwc    io.ReadWriteCloser
    dec    *gob.Decoder
    enc    *gob.Encoder
    encBuf *bufio.Writer
}

func (c *myServerCodec) ReadRequestHeader(r *rpc.Request) error {
    log.Println(&quot;调用:ReadRequestHeader&quot;)
    return c.dec.Decode(r)
}

func (c *myServerCodec) ReadRequestBody(body interface{}) error {
    log.Println(&quot;调用:ReadRequestBody&quot;)
    return c.dec.Decode(body)
}

func (c *myServerCodec) WriteResponse(r *rpc.Response, body interface{}) (err error) {
    log.Println(&quot;调用:WriteResponse&quot;)
    if err = c.enc.Encode(r); err != nil {
        return
    }
    if err = c.enc.Encode(body); err != nil {
        return
    }
    return c.encBuf.Flush()
}

func (c *myServerCodec) Close() error {
    log.Println(&quot;调用:Close&quot;)
    return c.rwc.Close()
}

func myAccept(l net.Listener) {
    // for {
    arith := new(Arith)
    //注册服务
    server := rpc.NewServer()
    server.Register(arith)
    server.HandleHTTP(rpc.DefaultRPCPath, rpc.DefaultDebugPath)
    conn, e := l.Accept()
    if e != nil {
        log.Fatal(&quot;Accept error:&quot;, e)
    }
    buf := bufio.NewWriter(conn)
    codec := &amp;myServerCodec{conn, gob.NewDecoder(conn), gob.NewEncoder(buf), buf}
    e = server.ServeRequest(codec)
    if e != nil {
        log.Fatal(&quot;ServeRequst Error&quot;, e)
    }
    // }
}
func main() {
    //设置服务端
    //创建连接监听
    l, e := net.Listen(&quot;tcp&quot;, &quot;:1234&quot;)
    if e != nil {
        log.Fatal(&quot;listen error:&quot;, e)
    }
    //设置连接监听
    go myAccept(l)
    //设置自定义的serverCodec

    //暂停2秒，让服务器有足够的时间开启
    time.Sleep(2 * time.Second)

    //设置客户端
    address, err := net.ResolveTCPAddr(&quot;tcp&quot;, &quot;127.0.0.1:1234&quot;)
    if err != nil {
        panic(err)
    }
    //使用TCP的方式进行网络请求
    conn, _ := net.DialTCP(&quot;tcp&quot;, nil, address)
    defer conn.Close()
    //创建一个客户端
    client := rpc.NewClient(conn)
    defer client.Close()

    args := &amp;Args{7, 8}
    var reply int
    err = client.Call(&quot;Arith.Multiply&quot;, args, &amp;reply)
    if err != nil {
        log.Fatal(&quot;arith error:&quot;, err)
    }
    log.Println(reply)

}
</code></pre>
<p>结果:
2013/03/21 21:41:51 调用:ReadRequestHeader
2013/03/21 21:41:51 调用:ReadRequestBody
2013/03/21 21:41:51 调用:WriteResponse
2013/03/21 21:41:51 56</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-servecodeccodec-servercodec"><a class="header" href="#func-servecodeccodec-servercodec">func ServeCodec(codec ServerCodec)</a></h2>
<p>参数列表
-codec 用使用的ServerCodec</p>
<p>返回值：</p>
<p>功能说明：</p>
<p>这个函数是运行一个单连接的DefaultServer，服务一直开启，直到客户端断开连接，并且可以设置ServeCodec，用于处理请求和回复。实际上就是调用DefaultServer.ServeCodec(codec)这个方法。</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;bufio&quot;
    &quot;encoding/gob&quot;
    &quot;errors&quot;
    &quot;io&quot;
    &quot;log&quot;
    &quot;net&quot;
    &quot;net/rpc&quot;
    &quot;time&quot;
)

type Args struct {
    A, B int
}
type Quotient struct {
    Quo, Rem int
}
type Arith int

func (t *Arith) Multiply(args *Args, reply *int) error {
    *reply = args.A * args.B
    return nil
}
func (t *Arith) Divide(args *Args, quo *Quotient) error {
    if args.B == 0 {
        return errors.New(&quot;divide by zero&quot;)
    }
    quo.Quo = args.A / args.B
    quo.Rem = args.A % args.B
    return nil
}

type myServerCodec struct {
    rwc    io.ReadWriteCloser
    dec    *gob.Decoder
    enc    *gob.Encoder
    encBuf *bufio.Writer
}

func (c *myServerCodec) ReadRequestHeader(r *rpc.Request) error {
    log.Println(&quot;调用:ReadRequestHeader&quot;)
    return c.dec.Decode(r)
}

func (c *myServerCodec) ReadRequestBody(body interface{}) error {
    log.Println(&quot;调用:ReadRequestBody&quot;)
    return c.dec.Decode(body)
}

func (c *myServerCodec) WriteResponse(r *rpc.Response, body interface{}) (err error) {
    log.Println(&quot;调用:WriteResponse&quot;)
    if err = c.enc.Encode(r); err != nil {
        return
    }
    if err = c.enc.Encode(body); err != nil {
        return
    }
    return c.encBuf.Flush()
}

func (c *myServerCodec) Close() error {
    log.Println(&quot;调用:Close&quot;)
    return c.rwc.Close()
}

func myAccept(l net.Listener) {
        conn, e := l.Accept()
        if e != nil {
            log.Fatal(&quot;Accept error:&quot;, e)
        }
        //创建一个自定义的ServerCode，实际上这些代码就从go源码中获取出来的
        buf := bufio.NewWriter(conn)
        codec := &amp;myServerCodec{conn, gob.NewDecoder(conn), gob.NewEncoder(buf), buf}
        //运行连接
        go rpc.ServeCodec(codec)
}
func main() {
    //设置服务端
    arith := new(Arith)
    //注册服务
    rpc.Register(arith)
    //将服务注册到了HTTP协议
    rpc.HandleHTTP()
    //创建连接监听
    l, e := net.Listen(&quot;tcp&quot;, &quot;:1234&quot;)
    if e != nil {
        log.Fatal(&quot;listen error:&quot;, e)
    }
    //运行服务监听
    go myAccept(l)

    //暂停2秒，让服务器有足够的时间开启
    time.Sleep(2 * time.Second)

    //设置客户端
    address, err := net.ResolveTCPAddr(&quot;tcp&quot;, &quot;127.0.0.1:1234&quot;)
    if err != nil {
        panic(err)
    }
    //使用TCP的方式进行网络请求
    conn, _ := net.DialTCP(&quot;tcp&quot;, nil, address)
    defer conn.Close()
    //创建一个客户端
    client := rpc.NewClient(conn)
    defer client.Close()

    args := &amp;Args{7, 8}
    var reply int
    err = client.Call(&quot;Arith.Multiply&quot;, args, &amp;reply)
    if err != nil {
        log.Fatal(&quot;arith error:&quot;, err)
    }
    log.Println(reply)

}
</code></pre>
<p>结果:
2013/03/20 22:36:07 调用:ReadRequestHeader
2013/03/20 22:36:07 调用:ReadRequestBody
2013/03/20 22:36:07 调用:ReadRequestHeader
2013/03/20 22:36:07 调用:WriteResponse
2013/03/20 22:36:07 56</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-serveconnconn-ioreadwritecloser"><a class="header" href="#func-serveconnconn-ioreadwritecloser">func ServeConn(conn io.ReadWriteCloser)</a></h2>
<p>参数列表
-conn 网络连接对象</p>
<p>返回值：</p>
<p>功能说明：</p>
<p>这个函数是运行一个单连接的DefaultServer，服务一直连接，直到客户端断开连接。实际上就是调用DefaultServer.ServeConn(conn)这个方法。</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;log&quot;
    &quot;net&quot;
    &quot;net/rpc&quot;
    &quot;time&quot;
)

type Args struct {
    A, B int
}
type Quotient struct {
    Quo, Rem int
}
type Arith int

func (t *Arith) Multiply(args *Args, reply *int) error {
    *reply = args.A * args.B
    return nil
}

func myAccept(l net.Listener) {
    conn, e := l.Accept()
    if e != nil {
        log.Fatal(&quot;Accept error:&quot;, e)
    }
    go rpc.ServeConn(conn)
}
func main() {
    //设置服务端
    arith := new(Arith)
    //注册服务
    rpc.Register(arith)
    //将服务注册到了HTTP协议
    rpc.HandleHTTP()
    //创建连接监听
    l, e := net.Listen(&quot;tcp&quot;, &quot;:1234&quot;)
    if e != nil {
        log.Fatal(&quot;listen error:&quot;, e)
    }
    //设置连接监听
    go myAccept(l)
    //设置自定义的serverCodec

    //暂停2秒，让服务器有足够的时间开启
    time.Sleep(2 * time.Second)

    //设置客户端
    client, _ := rpc.Dial(&quot;tcp&quot;, &quot;127.0.0.1:1234&quot;)
    defer client.Close()

    args := &amp;Args{7, 8}
    var reply int
    //呼叫请求
    err := client.Call(&quot;Arith.Multiply&quot;, args, &amp;reply)
    if err != nil {
        log.Fatal(&quot;arith error:&quot;, err)
    }
    log.Println(reply)

}
</code></pre>
<p>结果:
2013/03/20 22:49:30 56</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-server-server-acceptlis-netlistener-1"><a class="header" href="#func-server-server-acceptlis-netlistener-1">func (server *Server) Accept(lis net.Listener)</a></h2>
<p>参数列表</p>
<p>-lis 要设置的网络监听对象</p>
<p>返回值：</p>
<p>功能说明：</p>
<p>这个函数主要来设置网络连接监听，以响应每次的网络连接请求。这个方法一般用go rpc.Accept(l)进行调用。 </p>
<p>代码实例：</p>
<pre><code>    package main

import (
    &quot;errors&quot;
    &quot;log&quot;
    &quot;net&quot;
    &quot;net/rpc&quot;
    &quot;time&quot;
)

type Args struct {
    A, B int
}
type Quotient struct {
    Quo, Rem int
}
type Arith int

func (t *Arith) Multiply(args *Args, reply *int) error {
    *reply = args.A * args.B
    return nil
}
func (t *Arith) Divide(args *Args, quo *Quotient) error {
    if args.B == 0 {
        return errors.New(&quot;divide by zero&quot;)
    }
    quo.Quo = args.A / args.B
    quo.Rem = args.A % args.B
    return nil
}

func main() {
    //设置服务端
    arith := new(Arith)
    //注册服务
    server := rpc.NewServer()
    server.Register(arith)
    //创建连接监听
    l, e := net.Listen(&quot;tcp&quot;, &quot;:1234&quot;)
    if e != nil {
        log.Fatal(&quot;listen error:&quot;, e)
    }
    //设置连接监听
    go server.Accept(l)

    //暂停2秒，让服务器有足够的时间开启
    time.Sleep(2 * time.Second)

    //使用TCP的方式进行网络请求
    client, _ := rpc.Dial(&quot;tcp&quot;, &quot;127.0.0.1:1234&quot;)
    defer client.Close()

    args := &amp;Args{7, 8}
    var reply int
    //呼叫请求
    err := client.Call(&quot;Arith.Multiply&quot;, args, &amp;reply)
    if err != nil {
        log.Fatal(&quot;arith error:&quot;, err)
    }
    log.Println(reply)

}
</code></pre>
<p>结果:2013/03/21 20:56:39 56</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-server-server-handlehttprpcpath-debugpath-string-1"><a class="header" href="#func-server-server-handlehttprpcpath-debugpath-string-1">func (server *Server) HandleHTTP(rpcPath, debugPath string)</a></h2>
<p>参数列表
-rpcPath rpc路径
-debugPath debug路径</p>
<p>返回值：</p>
<p>功能说明：</p>
<p>这个函数是将rpc的服务注册到http协议上，使用http的方式进行接受数据和传送数据，并可以设置 rpcPath和debugPath。</p>
<p>代码实例：</p>
<pre><code>    package main

import (
    &quot;errors&quot;
    &quot;log&quot;
    &quot;net&quot;
    &quot;net/rpc&quot;
    &quot;time&quot;
)

type Args struct {
    A, B int
}
type Quotient struct {
    Quo, Rem int
}
type Arith int

func (t *Arith) Multiply(args *Args, reply *int) error {
    *reply = args.A * args.B
    return nil
}
func (t *Arith) Divide(args *Args, quo *Quotient) error {
    if args.B == 0 {
        return errors.New(&quot;divide by zero&quot;)
    }
    quo.Quo = args.A / args.B
    quo.Rem = args.A % args.B
    return nil
}

func main() {
    //设置服务端
    arith := new(Arith)
    //注册服务
    server := rpc.NewServer()
    server.Register(arith)
    server.HandleHTTP(rpc.DefaultRPCPath, rpc.DefaultDebugPath)
    //创建连接监听
    l, e := net.Listen(&quot;tcp&quot;, &quot;:1234&quot;)
    if e != nil {
        log.Fatal(&quot;listen error:&quot;, e)
    }
    //设置连接监听
    go server.Accept(l)

    //暂停2秒，让服务器有足够的时间开启
    time.Sleep(2 * time.Second)

    //使用TCP的方式进行网络请求
    client, _ := rpc.Dial(&quot;tcp&quot;, &quot;127.0.0.1:1234&quot;)
    defer client.Close()

    args := &amp;Args{7, 8}
    var reply int
    //呼叫请求
    err := client.Call(&quot;Arith.Multiply&quot;, args, &amp;reply)
    if err != nil {
        log.Fatal(&quot;arith error:&quot;, err)
    }
    log.Println(reply)

}
</code></pre>
<p>结果:2013/03/21 21:01:02 56</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-server-server-registerrcvr-interface-error-1"><a class="header" href="#func-server-server-registerrcvr-interface-error-1">func (server *Server) Register(rcvr interface{}) error</a></h2>
<p>参数列表
-rcvr 要注册的服务对象</p>
<p>返回值：</p>
<p>-error 错误对象，当注册服务出现错误时，就会返回一个错误对象。</p>
<p>功能说明：</p>
<p>这个函数是用来注册服务的，看源码也会发现这个方式实际上是调用DefaultServer.Register(rcvr)这个方法。</p>
<p>代码实例：</p>
<pre><code>    package main

import (
    &quot;errors&quot;
    &quot;log&quot;
    &quot;net&quot;
    &quot;net/rpc&quot;
    &quot;time&quot;
)

type Args struct {
    A, B int
}
type Quotient struct {
    Quo, Rem int
}
type Arith int

func (t *Arith) Multiply(args *Args, reply *int) error {
    *reply = args.A * args.B
    return nil
}
func (t *Arith) Divide(args *Args, quo *Quotient) error {
    if args.B == 0 {
        return errors.New(&quot;divide by zero&quot;)
    }
    quo.Quo = args.A / args.B
    quo.Rem = args.A % args.B
    return nil
}

func main() {
    //设置服务端
    arith := new(Arith)
    //注册服务
    server := rpc.NewServer()
    server.Register(arith)
    server.HandleHTTP(rpc.DefaultRPCPath, rpc.DefaultDebugPath)
    //创建连接监听
    l, e := net.Listen(&quot;tcp&quot;, &quot;:1234&quot;)
    if e != nil {
        log.Fatal(&quot;listen error:&quot;, e)
    }
    //设置连接监听
    go server.Accept(l)

    //暂停2秒，让服务器有足够的时间开启
    time.Sleep(2 * time.Second)

    //使用TCP的方式进行网络请求
    client, _ := rpc.Dial(&quot;tcp&quot;, &quot;127.0.0.1:1234&quot;)
    defer client.Close()

    args := &amp;Args{7, 8}
    var reply int
    //呼叫请求
    err := client.Call(&quot;Arith.Multiply&quot;, args, &amp;reply)
    if err != nil {
        log.Fatal(&quot;arith error:&quot;, err)
    }
    log.Println(reply)

}
</code></pre>
<p>结果:2013/03/21 21:01:02 56</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-server-server-registernamename-string-rcvr-interface-errorr-1"><a class="header" href="#func-server-server-registernamename-string-rcvr-interface-errorr-1">func (server *Server) RegisterName(name string, rcvr interface{}) errorr</a></h2>
<p>参数列表
-name 要使用的服务别名
-rcvr 要注册的服务对象</p>
<p>返回值：</p>
<p>-error 错误对象，当注册服务出现错误时，就会返回一个错误对象。</p>
<p>功能说明：</p>
<p>这个函数是用来注册服务的，但是提供一个名称用来代替具体的服务类型，例如原本的类型为Arith,可以使用其他名称来代替这个名称。</p>
<p>代码实例：</p>
<pre><code>   package main

import (
    &quot;errors&quot;
    &quot;log&quot;
    &quot;net&quot;
    &quot;net/rpc&quot;
    &quot;time&quot;
)

type Args struct {
    A, B int
}
type Quotient struct {
    Quo, Rem int
}
type Arith int

func (t *Arith) Multiply(args *Args, reply *int) error {
    *reply = args.A * args.B
    return nil
}
func (t *Arith) Divide(args *Args, quo *Quotient) error {
    if args.B == 0 {
        return errors.New(&quot;divide by zero&quot;)
    }
    quo.Quo = args.A / args.B
    quo.Rem = args.A % args.B
    return nil
}

func main() {
    //设置服务端
    arith := new(Arith)
    //注册服务
    server := rpc.NewServer()
    server.RegisterName(&quot;Serve&quot;, arith)
    server.HandleHTTP(rpc.DefaultRPCPath, rpc.DefaultDebugPath)
    //创建连接监听
    l, e := net.Listen(&quot;tcp&quot;, &quot;:1234&quot;)
    if e != nil {
        log.Fatal(&quot;listen error:&quot;, e)
    }
    //设置连接监听
    go server.Accept(l)

    //暂停2秒，让服务器有足够的时间开启
    time.Sleep(2 * time.Second)

    //使用TCP的方式进行网络请求
    client, _ := rpc.Dial(&quot;tcp&quot;, &quot;127.0.0.1:1234&quot;)
    defer client.Close()

    args := &amp;Args{7, 8}
    var reply int
    //呼叫请求
    err := client.Call(&quot;Serve.Multiply&quot;, args, &amp;reply)
    if err != nil {
        log.Fatal(&quot;arith error:&quot;, err)
    }
    log.Println(reply)

}
</code></pre>
<p>结果:2013/03/21 21:03:40 56</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-server-server-servecodeccodec-servercodec-1"><a class="header" href="#func-server-server-servecodeccodec-servercodec-1">func (server *Server) ServeCodec(codec ServerCodec)</a></h2>
<p>参数列表
-codec 用使用的ServerCodec</p>
<p>返回值：</p>
<p>功能说明：</p>
<p>这个函数是运行一个单连接的DefaultServer，服务一直开启，直到客户端断开连接，并且可以设置ServeCodec，用于处理请求和回复。</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;bufio&quot;
    &quot;encoding/gob&quot;
    &quot;errors&quot;
    &quot;io&quot;
    &quot;log&quot;
    &quot;net&quot;
    &quot;net/rpc&quot;
    &quot;time&quot;
)

type Args struct {
    A, B int
}
type Quotient struct {
    Quo, Rem int
}
type Arith int

func (t *Arith) Multiply(args *Args, reply *int) error {
    *reply = args.A * args.B
    return nil
}
func (t *Arith) Divide(args *Args, quo *Quotient) error {
    if args.B == 0 {
        return errors.New(&quot;divide by zero&quot;)
    }
    quo.Quo = args.A / args.B
    quo.Rem = args.A % args.B
    return nil
}

type myServerCodec struct {
    rwc    io.ReadWriteCloser
    dec    *gob.Decoder
    enc    *gob.Encoder
    encBuf *bufio.Writer
}

func (c *myServerCodec) ReadRequestHeader(r *rpc.Request) error {
    log.Println(&quot;调用:ReadRequestHeader&quot;)
    return c.dec.Decode(r)
}

func (c *myServerCodec) ReadRequestBody(body interface{}) error {
    log.Println(&quot;调用:ReadRequestBody&quot;)
    return c.dec.Decode(body)
}

func (c *myServerCodec) WriteResponse(r *rpc.Response, body interface{}) (err error) {
    log.Println(&quot;调用:WriteResponse&quot;)
    if err = c.enc.Encode(r); err != nil {
        return
    }
    if err = c.enc.Encode(body); err != nil {
        return
    }
    return c.encBuf.Flush()
}

func (c *myServerCodec) Close() error {
    log.Println(&quot;调用:Close&quot;)
    return c.rwc.Close()
}

func myAccept(l net.Listener) {
    //设置服务端
    arith := new(Arith)
    //注册服务
    server := rpc.NewServer()
    server.RegisterName(&quot;Serve&quot;, arith)
    server.HandleHTTP(rpc.DefaultRPCPath, rpc.DefaultDebugPath)
    conn, e := l.Accept()
    if e != nil {
        log.Fatal(&quot;Accept error:&quot;, e)
    }
    //创建一个自定义的ServerCode，实际上这些代码就从go源码中获取出来的
    buf := bufio.NewWriter(conn)
    codec := &amp;myServerCodec{conn, gob.NewDecoder(conn), gob.NewEncoder(buf), buf}
    //运行连接
    go server.ServeCodec(codec)
}
func main() {

    //创建连接监听
    l, e := net.Listen(&quot;tcp&quot;, &quot;:1234&quot;)
    if e != nil {
        log.Fatal(&quot;listen error:&quot;, e)
    }
    //运行服务监听
    go myAccept(l)

    //暂停2秒，让服务器有足够的时间开启
    time.Sleep(2 * time.Second)

    //设置客户端
    address, err := net.ResolveTCPAddr(&quot;tcp&quot;, &quot;127.0.0.1:1234&quot;)
    if err != nil {
        panic(err)
    }
    //使用TCP的方式进行网络请求
    conn, _ := net.DialTCP(&quot;tcp&quot;, nil, address)
    defer conn.Close()
    //创建一个客户端
    client := rpc.NewClient(conn)
    defer client.Close()

    args := &amp;Args{7, 8}
    var reply int
    err = client.Call(&quot;Serve.Multiply&quot;, args, &amp;reply)
    if err != nil {
        log.Fatal(&quot;arith error:&quot;, err)
    }
    log.Println(reply)

}
</code></pre>
<p>结果:
2013/03/21 21:07:59 56</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-server-server-serveconnconn-ioreadwritecloser-1"><a class="header" href="#func-server-server-serveconnconn-ioreadwritecloser-1">func (server *Server) ServeConn(conn io.ReadWriteCloser)</a></h2>
<p>参数列表
-conn 网络连接对象</p>
<p>返回值：</p>
<p>功能说明：</p>
<p>这个函数是运行一个单连接的DefaultServer，服务一直连接，直到客户端断开连接。</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;errors&quot;
    &quot;log&quot;
    &quot;net&quot;
    &quot;net/rpc&quot;
    &quot;time&quot;
)

type Args struct {
    A, B int
}
type Quotient struct {
    Quo, Rem int
}
type Arith int

func (t *Arith) Multiply(args *Args, reply *int) error {
    *reply = args.A * args.B
    return nil
}
func (t *Arith) Divide(args *Args, quo *Quotient) error {
    if args.B == 0 {
        return errors.New(&quot;divide by zero&quot;)
    }
    quo.Quo = args.A / args.B
    quo.Rem = args.A % args.B
    return nil
}

func myAccept(l net.Listener) {
    arith := new(Arith)
    //注册服务
    server := rpc.NewServer()
    server.Register(arith)
    server.HandleHTTP(rpc.DefaultRPCPath, rpc.DefaultDebugPath)
    conn, e := l.Accept()
    if e != nil {
        log.Fatal(&quot;Accept error:&quot;, e)
    }
    go server.ServeConn(conn)
}
func main() {
    //创建连接监听
    l, e := net.Listen(&quot;tcp&quot;, &quot;:1234&quot;)
    if e != nil {
        log.Fatal(&quot;listen error:&quot;, e)
    }
    //设置连接监听
    go myAccept(l)
    //设置自定义的serverCodec

    //暂停2秒，让服务器有足够的时间开启
    time.Sleep(2 * time.Second)

    //设置客户端
    address, err := net.ResolveTCPAddr(&quot;tcp&quot;, &quot;127.0.0.1:1234&quot;)
    if err != nil {
        panic(err)
    }
    //使用TCP的方式进行网络请求
    conn, _ := net.DialTCP(&quot;tcp&quot;, nil, address)
    defer conn.Close()
    //创建一个客户端
    client := rpc.NewClient(conn)
    defer client.Close()

    args := &amp;Args{7, 8}
    var reply int
    err = client.Call(&quot;Arith.Multiply&quot;, args, &amp;reply)
    if err != nil {
        log.Fatal(&quot;arith error:&quot;, err)
    }
    log.Println(reply)

}
</code></pre>
<p>结果:
2013/03/21 21:38:43 56</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-server-server-servehttpw-httpresponsewriter-req-httprequest-1"><a class="header" href="#func-server-server-servehttpw-httpresponsewriter-req-httprequest-1">func (server *Server) ServeHTTP(w http.ResponseWriter, req *http.Request)</a></h2>
<p>参数列表
-w ResponseWriter对象
-req Request对象</p>
<p>返回值：</p>
<p>功能说明：</p>
<p>这个函数是实现回复和请求的处理。</p>
<p>代码实例：</p>
<pre><code>   package main

import (
    &quot;errors&quot;
    &quot;log&quot;
    &quot;net&quot;
    &quot;net/rpc&quot;
    &quot;time&quot;
)

type Args struct {
    A, B int
}
type Quotient struct {
    Quo, Rem int
}
type Arith int

func (t *Arith) Multiply(args *Args, reply *int) error {
    *reply = args.A * args.B
    return nil
}
func (t *Arith) Divide(args *Args, quo *Quotient) error {
    if args.B == 0 {
        return errors.New(&quot;divide by zero&quot;)
    }
    quo.Quo = args.A / args.B
    quo.Rem = args.A % args.B
    return nil
}

func main() {
    //设置服务端
    arith := new(Arith)
    //注册服务
    server := rpc.NewServer()
    server.RegisterName(&quot;Serve&quot;, arith)
    server.HandleHTTP(rpc.DefaultRPCPath, rpc.DefaultDebugPath)
    //创建连接监听
    l, e := net.Listen(&quot;tcp&quot;, &quot;:1234&quot;)
    if e != nil {
        log.Fatal(&quot;listen error:&quot;, e)
    }
    //设置连接监听
    go server.Accept(l)

    //暂停2秒，让服务器有足够的时间开启
    time.Sleep(2 * time.Second)

    //使用TCP的方式进行网络请求
    client, _ := rpc.Dial(&quot;tcp&quot;, &quot;127.0.0.1:1234&quot;)
    defer client.Close()

    args := &amp;Args{7, 8}
    var reply int
    //呼叫请求
    err := client.Call(&quot;Serve.Multiply&quot;, args, &amp;reply)
    if err != nil {
        log.Fatal(&quot;arith error:&quot;, err)
    }
    log.Println(reply)

}
</code></pre>
<p>结果:2013/03/21 21:03:40 56</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-server-server-serverequestcodec-servercodec-error-1"><a class="header" href="#func-server-server-serverequestcodec-servercodec-error-1">func (server *Server) ServeRequest(codec ServerCodec) error</a></h2>
<p>参数列表
-codec 用使用的ServerCodec</p>
<p>返回值：
-error 返回错误信息</p>
<p>功能说明：</p>
<p>这个函数类似ServeCodec,不过这个是同步的。</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;bufio&quot;
    &quot;encoding/gob&quot;
    &quot;errors&quot;
    &quot;io&quot;
    &quot;log&quot;
    &quot;net&quot;
    &quot;net/rpc&quot;
    &quot;time&quot;
)

type Args struct {
    A, B int
}
type Quotient struct {
    Quo, Rem int
}
type Arith int

func (t *Arith) Multiply(args *Args, reply *int) error {
    *reply = args.A * args.B
    return nil
}
func (t *Arith) Divide(args *Args, quo *Quotient) error {
    if args.B == 0 {
        return errors.New(&quot;divide by zero&quot;)
    }
    quo.Quo = args.A / args.B
    quo.Rem = args.A % args.B
    return nil
}

type myServerCodec struct {
    rwc    io.ReadWriteCloser
    dec    *gob.Decoder
    enc    *gob.Encoder
    encBuf *bufio.Writer
}

func (c *myServerCodec) ReadRequestHeader(r *rpc.Request) error {
    log.Println(&quot;调用:ReadRequestHeader&quot;)
    return c.dec.Decode(r)
}

func (c *myServerCodec) ReadRequestBody(body interface{}) error {
    log.Println(&quot;调用:ReadRequestBody&quot;)
    return c.dec.Decode(body)
}

func (c *myServerCodec) WriteResponse(r *rpc.Response, body interface{}) (err error) {
    log.Println(&quot;调用:WriteResponse&quot;)
    if err = c.enc.Encode(r); err != nil {
        return
    }
    if err = c.enc.Encode(body); err != nil {
        return
    }
    return c.encBuf.Flush()
}

func (c *myServerCodec) Close() error {
    log.Println(&quot;调用:Close&quot;)
    return c.rwc.Close()
}

func myAccept(l net.Listener) {
    // for {
    arith := new(Arith)
    //注册服务
    server := rpc.NewServer()
    server.Register(arith)
    server.HandleHTTP(rpc.DefaultRPCPath, rpc.DefaultDebugPath)
    conn, e := l.Accept()
    if e != nil {
        log.Fatal(&quot;Accept error:&quot;, e)
    }
    buf := bufio.NewWriter(conn)
    codec := &amp;myServerCodec{conn, gob.NewDecoder(conn), gob.NewEncoder(buf), buf}
    e = server.ServeRequest(codec)
    if e != nil {
        log.Fatal(&quot;ServeRequst Error&quot;, e)
    }
    // }
}
func main() {
    //设置服务端
    //创建连接监听
    l, e := net.Listen(&quot;tcp&quot;, &quot;:1234&quot;)
    if e != nil {
        log.Fatal(&quot;listen error:&quot;, e)
    }
    //设置连接监听
    go myAccept(l)
    //设置自定义的serverCodec

    //暂停2秒，让服务器有足够的时间开启
    time.Sleep(2 * time.Second)

    //设置客户端
    address, err := net.ResolveTCPAddr(&quot;tcp&quot;, &quot;127.0.0.1:1234&quot;)
    if err != nil {
        panic(err)
    }
    //使用TCP的方式进行网络请求
    conn, _ := net.DialTCP(&quot;tcp&quot;, nil, address)
    defer conn.Close()
    //创建一个客户端
    client := rpc.NewClient(conn)
    defer client.Close()

    args := &amp;Args{7, 8}
    var reply int
    err = client.Call(&quot;Arith.Multiply&quot;, args, &amp;reply)
    if err != nil {
        log.Fatal(&quot;arith error:&quot;, err)
    }
    log.Println(reply)

}
</code></pre>
<p>结果:
2013/03/21 21:41:51 调用:ReadRequestHeader
2013/03/21 21:41:51 调用:ReadRequestBody
2013/03/21 21:41:51 调用:WriteResponse
2013/03/21 21:41:51 56</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-serverequestcodec-servercodec-error"><a class="header" href="#func-serverequestcodec-servercodec-error">func ServeRequest(codec ServerCodec) error</a></h2>
<p>参数列表
-codec 用使用的ServerCodec</p>
<p>返回值：</p>
<p>功能说明：</p>
<p>这个函数类似ServeCodec,不过这个是同步的。</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;bufio&quot;
    &quot;encoding/gob&quot;
    &quot;io&quot;
    &quot;log&quot;
    &quot;net&quot;
    &quot;net/rpc&quot;
    &quot;time&quot;
)

type Args struct {
    A, B int
}
type Quotient struct {
    Quo, Rem int
}
type Arith int

func (t *Arith) Multiply(args *Args, reply *int) error {
    *reply = args.A * args.B
    return nil
}

type myServerCodec struct {
    rwc    io.ReadWriteCloser
    dec    *gob.Decoder
    enc    *gob.Encoder
    encBuf *bufio.Writer
}

func (c *myServerCodec) ReadRequestHeader(r *rpc.Request) error {
    log.Println(&quot;调用:ReadRequestHeader&quot;)
    return c.dec.Decode(r)
}

func (c *myServerCodec) ReadRequestBody(body interface{}) error {
    log.Println(&quot;调用:ReadRequestBody&quot;)
    return c.dec.Decode(body)
}

func (c *myServerCodec) WriteResponse(r *rpc.Response, body interface{}) (err error) {
    log.Println(&quot;调用:WriteResponse&quot;)
    if err = c.enc.Encode(r); err != nil {
        return
    }
    if err = c.enc.Encode(body); err != nil {
        return
    }
    return c.encBuf.Flush()
}

func (c *myServerCodec) Close() error {
    log.Println(&quot;调用:Close&quot;)
    return c.rwc.Close()
}

func myAccept(l net.Listener) {
    // for {
    conn, e := l.Accept()
    if e != nil {
        log.Fatal(&quot;Accept error:&quot;, e)
    }
    buf := bufio.NewWriter(conn)
    codec := &amp;myServerCodec{conn, gob.NewDecoder(conn), gob.NewEncoder(buf), buf}
    e = rpc.ServeRequest(codec)
    if e != nil {
        log.Fatal(&quot;ServeRequst Error&quot;, e)
    }
    // }
}
func main() {
    //设置服务端
    arith := new(Arith)
    //注册服务
    rpc.Register(arith)
    //将服务注册到了HTTP协议
    rpc.HandleHTTP()
    //创建连接监听
    l, e := net.Listen(&quot;tcp&quot;, &quot;:1234&quot;)
    if e != nil {
        log.Fatal(&quot;listen error:&quot;, e)
    }
    //设置连接监听
    go myAccept(l)
    //设置自定义的serverCodec

    //暂停2秒，让服务器有足够的时间开启
    time.Sleep(2 * time.Second)

    //创建一个客户端
    client, _ := rpc.Dial(&quot;tcp&quot;, &quot;127.0.0.1:1234&quot;)
    defer client.Close()

    args := &amp;Args{7, 8}
    var reply int
    err := client.Call(&quot;Arith.Multiply&quot;, args, &amp;reply)
    if err != nil {
        log.Fatal(&quot;arith error:&quot;, err)
    }
    log.Println(reply)

}
</code></pre>
<p>结果:
2013/03/20 22:57:00 调用:ReadRequestHeader
2013/03/20 22:57:00 调用:ReadRequestBody
2013/03/20 22:57:00 调用:WriteResponse
2013/03/20 22:57:00 56</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="netsmtp"><a class="header" href="#netsmtp">net/smtp</a></h1>
<p>RFC 5321 (SMTP, Simple Mail Transfer Protocol, 简单邮件传输协议) 的 Golang 实现。想发邮件，你就找对了。</p>
<p>类型列表</p>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/smtp/Auth.html">Auth</a> - smtp 用户认证方法</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/smtp/Client.html">Client</a> - smtp 客户端实现</li>
<li>ServerInfo</li>
</ul>
<p>ServerInfo 只用于传参, 为简单 struct, 没有成员函数.</p>
<p>函数列表</p>
<ul>
<li>func <a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/smtp/SendMail.html">SendMail</a>(addr string, a Auth, from string, to []string, msg []byte) error</li>
</ul>
<p>一般简单的发送邮件任务请直接是用 SendMail() 函数.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="type-auth"><a class="header" href="#type-auth">type Auth</a></h2>
<p>Auth 是一个接口类型, 用于表示 smtp 认证过程中的具体方法.</p>
<p>这里简单科普下, 具体内容请查阅 RFC. SMTP 中一般有三种认证方法, LOGIN, PLAIN, CRAM-MD5. net/smtp
中有后两种的实现, 缺少一个 LOGIN 实现. 一般国内邮件服务都支持前两种认证方法, CRAM-MD5 支持商不多.</p>
<pre><code class="language-go">type Auth
    func CRAMMD5Auth(username, secret string) Auth
    func PlainAuth(identity, username, password, host string) Auth
</code></pre>
<p>PlainAuth 的使用例子可以参考 <a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/smtp/SendMail.html">SendMail</a>.</p>
<p>下面这个略复杂的例子里, 简单实现了一个 LOGIN 认证的 Auth 对象, 并发送邮件.</p>
<pre><code class="language-go">package main

import (
        &quot;log&quot;
        &quot;net/mail&quot;
        &quot;net/smtp&quot;
        &quot;fmt&quot;
        &quot;strings&quot;
        &quot;errors&quot;
)

func encodeRFC2047(String string) string{
        // use mail's rfc2047 to encode any string
        addr := mail.Address{String, &quot;&quot;}
        return strings.Trim(addr.String(), &quot; &lt;&gt;&quot;)
}

type loginAuth struct {
        username, password string
}

func LoginAuth(username, password string) smtp.Auth {
        return &amp;loginAuth{username, password}
}

func (a *loginAuth) Start(server *smtp.ServerInfo) (string, []byte, error) {
        if !server.TLS {
                log.Fatal(&quot;unencrypted connection&quot;)
        }
        return &quot;LOGIN&quot;, []byte{}, nil
}

func (a *loginAuth) Next(fromServer []byte, more bool) ([]byte, error) {
        if more {
                switch string(fromServer) {
                case &quot;Username:&quot;:
                        return []byte(a.username), nil
                case &quot;Password:&quot;:
                        return []byte(a.password), nil
                default:
                        return nil, errors.New(&quot;Unkown fromServer&quot;)
                }
        }
        return nil, nil
}

func main() {
        var err error
        // Set up authentication information.
        smtpServer := &quot;smtp.qq.com:25&quot;
        client, err := smtp.Dial(smtpServer)
        handleError(err)
        defer client.Quit()

        if ok, desc := client.Extension(&quot;AUTH&quot;); ok {
                fmt.Println(&quot;wow! server support auth:&quot;, desc)
        }

        err = client.Auth(LoginAuth(&quot;username@qq.com&quot;, &quot;PASSWORD&quot;))
        handleError(err)

        handleError(client.Mail(&quot;username@qq.com&quot;))
        handleError(client.Rcpt(&quot;fledna@foxmail.com&quot;))
        writer, err := client.Data()
        handleError(err)
        writer.Write([]byte(`MIME-Version: 1.0
Subject: =?utf-8?q?=E5=BD=93=E5=89=8D=E6=97=B6=E6=AE=B5=E7=BB=9F=E8=AE=A1=E6=8A=A5=E8=A1=A8?=
Content-Type: text/plain; charset=&quot;utf-8&quot;
From: =?utf-8?q?=E7=9B=91=E6=8E=A7=E4=B8=AD=E5=BF=83?= &lt;username@qq.com&gt;
Content-Transfer-Encoding: base64
To: =?utf-8?q?=E6=94=B6=E4=BB=B6=E4=BA=BA?= &lt;fledna@foxmail.com&gt;

5oql6KGo5YaF5a655LiA5YiH5q2j5bi4`))
        handleError(writer.Close())
}


func handleError(err error) {
        if err != nil {
                log.Fatal(err)
        }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="type-client-1"><a class="header" href="#type-client-1">type Client</a></h2>
<p>Client 用于和 smtp 服务器建立连接. 代码例子请参考 <a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/smtp/Auth.html">Auth</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-sendmail"><a class="header" href="#func-sendmail">func SendMail</a></h1>
<pre><code class="language-go">func SendMail(addr string, a Auth, from string, to []string, msg []byte) error
</code></pre>
<p>net/smtp 里最重要的函数, 一般发送邮件任务都可以胜任.</p>
<pre><code class="language-go">package main

import (
        &quot;log&quot;
        &quot;net/mail&quot;
        &quot;encoding/base64&quot;
        &quot;net/smtp&quot;
        &quot;fmt&quot;
        &quot;strings&quot;
)

func encodeRFC2047(String string) string{
        // use mail's rfc2047 to encode any string
        addr := mail.Address{String, &quot;&quot;}
        return strings.Trim(addr.String(), &quot; &lt;&gt;&quot;)
}


func main() {
        // Set up authentication information.

        smtpServer := &quot;smtp.163.com&quot;
        auth := smtp.PlainAuth(
                &quot;&quot;,
                &quot;fledna@163.com&quot;,
                &quot;PASSWORD&quot;,
                smtpServer,
        )

        from := mail.Address{&quot;监控中心&quot;, &quot;fledna@163.com&quot;}
        to := mail.Address{&quot;收件人&quot;, &quot;haskell@renren.com&quot;}
        title := &quot;当前时段统计报表&quot;

        body := &quot;报表内容一切正常&quot;;

        header := make(map[string]string)
        header[&quot;From&quot;] = from.String()
        header[&quot;To&quot;] = to.String()
        header[&quot;Subject&quot;] = encodeRFC2047(title)
        header[&quot;MIME-Version&quot;] = &quot;1.0&quot;
        header[&quot;Content-Type&quot;] = &quot;text/plain; charset=\&quot;utf-8\&quot;&quot;
        header[&quot;Content-Transfer-Encoding&quot;] = &quot;base64&quot;

        message := &quot;&quot;
        for k, v := range header {
                message += fmt.Sprintf(&quot;%s: %s\r\n&quot;, k, v)
        }
        message += &quot;\r\n&quot; + base64.StdEncoding.EncodeToString([]byte(body))
        println(message)
        // Connect to the server, authenticate, set the sender and recipient,
        // and send the email all in one step.
        err := smtp.SendMail(
                smtpServer + &quot;:25&quot;,
                auth,
                from.Address,
                []string{to.Address},
                []byte(message),
        )
        if err != nil {
                log.Fatal(err)
        }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名-54"><a class="header" href="#包名-54">包名</a></h1>
<p>函数列表</p>
<ul>
<li>xxx1</li>
<li>xxx2</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名neturl"><a class="header" href="#包名neturl">包名:net/url</a></h1>
<h1 id="概术"><a class="header" href="#概术">概术:</a></h1>
<p>Package url parses URLs and implements query escaping. </p>
<h1 id="函数列表-2"><a class="header" href="#函数列表-2">函数列表</a></h1>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/url/QueryEscape.html">func QueryEscape(s string) string</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/net/url/QueryUnescape.html">func QueryUnescape(s string) (string, error)</a></li>
<li>func Parse(rawurl string) (url *URL, err error)</li>
<li>func ParseRequestURI(rawurl string) (url *URL, err error)</li>
<li>func User(username string) *Userinfo</li>
<li>func UserPassword(username, password string) *Userinfo</li>
<li>func ParseQuery(query string) (m Values, err error)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>#func ParseQuery(query string) (m Values, err error)</p>
<p>[参数列表]：</p>
<ul>
<li>query 表示需要参数(字符串) </li>
</ul>
<p>[返回值]：</p>
<p>-m mps
-err 错误信息</p>
<p>[功能说明]：
通过ParseQuery解析URL编码的查询字符串，并返回一个map ，列出每个键的值
ParseQuery总是返回一个非空的map，包含所有有效的查询参数，通过&quot;;&quot;与&quot;&amp;&quot;分割;如果遇到解析异常将通过err返回错误信息</p>
<p>[代码实例]：
package main</p>
<p>import (
&quot;fmt&quot;
&quot;net/url&quot;
)</p>
<p>func main() {
//http://127.0.0.1:6060/src/pkg/url/url.go?h=%22%26%22;s=14652:14657#L534&amp;test=abc;123
test,err := url.ParseQuery(&quot;h=%22%26%22;s=14652:14657#L534&amp;test=abc;123&quot;)
if err == nil {
fmt.Println(test)
}else{
fmt.Println(err)
}</p>
<p>}</p>
<div style="break-before: page; page-break-before: always;"></div><p>#func QueryEscape(s string) string</p>
<p>[参数列表]：</p>
<ul>
<li>s 表示需要参数(字符串) </li>
</ul>
<p>[返回值]：</p>
<p>-返回值为：转义字符串</p>
<p>[功能说明]：</p>
<p>escapes the string so it can be safely placed inside a URL query.</p>
<p>逃避查询，因此它可以被安全的放置在URL查询字符串。请参阅RFC 3986。</p>
<p>[代码实例]：</p>
<pre><code>package main	
import (
	&quot;fmt&quot;
	&quot;net/url&quot;
)

func main() {
	sUrl := url.QueryEscape(&quot;http://www.golang.org&quot;)
	fmt.Println(sUrl)
}
//输出结果：http%3A%2F%2Fwww.golang.org
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>#func QueryUnescape(s string) (string, error)</p>
<p>[参数列表]：</p>
<ul>
<li>s 表示需要参数(字符串) </li>
</ul>
<p>[返回值]：</p>
<p>-返回值为：字符串,错误信息</p>
<p>[功能说明]：
对QueryEscape函数转换的值进行逆转。如果%后没有包含两个十六进制数，它将返回一个错语</p>
<p>[代码实例]：</p>
<pre><code>package main	
import (
	&quot;fmt&quot;
	&quot;net/url&quot;
)

func main() {
	uUrl,err := url.QueryUnescape(&quot;http%3A%2F%2Fwww.golang.org&quot;)
	if err == nil {
		fmt.Printf(uUrl)
	}else{
		fmt.Println(err)
	}
}
//输出结果：http://www.golang.org
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="类型-addr"><a class="header" href="#类型-addr">类型 Addr</a></h2>
<p>Addr是一个接口,代表一个网络端的地址</p>
<p>结构:</p>
<pre><code>type Addr interface {
 	Network() string // 网络名字符串
 	String() string  // 地址字符串
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="类型-addrerror"><a class="header" href="#类型-addrerror">类型 AddrError</a></h2>
<p>Addr 错误结构 - 请参考 Error包</p>
<p>结构:</p>
<pre><code>type AddrError struct {
    Err  string
    Addr string
}
</code></pre>
<ul>
<li>
<p>func (*AddrError) Error</p>
</li>
<li>
<p>func (*AddrError) Temporary</p>
</li>
<li>
<p>func (*AddrError) Timeout</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-cidrmaskones-bits-int-ipmask"><a class="header" href="#func-cidrmaskones-bits-int-ipmask">func CIDRMask(ones, bits int) IPMask</a></h2>
<p>参数列表:</p>
<ul>
<li>ones 网络字符串</li>
<li>bits 服务名</li>
</ul>
<p>返回列表:</p>
<ul>
<li>IPMask 掩码结构</li>
</ul>
<p><a href="http://baike.baidu.com/view/4217886.htm">百度百科 - CIDR</a></p>
<p>返回CIDR规范的掩码
ones 必须 大于0 小于 bits
bits 必须为 4(IPv4的字节数)或16(IPv6的字节数)的8倍</p>
<p>代码实例:</p>
<pre><code>package main

import &quot;fmt&quot;
import &quot;net&quot;

func main() {
	mask := net.CIDRMask(2,32)
	fmt.Printf(&quot;%#V&quot;,mask) //返回 %!V(net.IPMask=[192 0 0 0])
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="结构-conn"><a class="header" href="#结构-conn">结构 Conn</a></h2>
<p>Conn 是一个接口(interface)</p>
<p>需要实现以下方法:</p>
<p>====</p>
<ul>
<li>
<p>Read(b []byte) (n int, err error) </p>
<p>从缓冲区读取数据,当读取超时时可以返回Timeout错误(需要设置超时时间)</p>
</li>
</ul>
<p>====</p>
<ul>
<li>
<p>Write(b []byte) (n int, err error) </p>
<p>写入数据到缓冲区,当写入超时时可以返回Timeout错误(需要设置超时时间)</p>
</li>
</ul>
<p>====</p>
<ul>
<li>
<p>Close() error</p>
<p>关闭连接</p>
</li>
</ul>
<p>====</p>
<ul>
<li>
<p>LocalAddr() Addr</p>
<p>返回本地网络地址</p>
</li>
</ul>
<p>====</p>
<ul>
<li>
<p>RemoteAddr() Addr</p>
<p>返回远端网络地址</p>
</li>
</ul>
<p>====</p>
<ul>
<li>
<p>SetDeadline(t time.Time) error</p>
<p>设置读写超时时间</p>
</li>
</ul>
<p>====</p>
<ul>
<li>
<p>SetReadDeadline(t time.Time) error</p>
<p>设置读取超时时间</p>
</li>
</ul>
<p>====</p>
<ul>
<li>
<p>SetWriteDeadline(t time.Time) error</p>
<p>设置写入超时时间</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-dialnet-addr-string-conn-error"><a class="header" href="#func-dialnet-addr-string-conn-error">func Dial(net, addr string) (Conn, error)</a></h2>
<p>参数列表:</p>
<ul>
<li>net 网络类型 字符串</li>
<li>addr 地址信息 字符串</li>
</ul>
<p>返回列表:</p>
<ul>
<li>Conn 连接接口</li>
<li>err 错误信息</li>
</ul>
<p>使用相应的网络类型连接远端地址,并返回连接接口或错误信息</p>
<p>网络类型可以是以下几种</p>
<ul>
<li>&quot;tcp&quot;</li>
<li>&quot;tcp4&quot; (仅限IPv4)</li>
<li>&quot;tcp6&quot; (仅限IPv6)</li>
<li>&quot;udp&quot;</li>
<li>&quot;udp4&quot; (仅限IPv4)</li>
<li>&quot;udp6&quot; (仅限IPv6)</li>
<li>&quot;ip&quot;</li>
<li>&quot;ip4&quot; (仅限IPv4)</li>
<li>&quot;ip6&quot; (仅限IPv6)</li>
<li>&quot;unix&quot;</li>
<li>&quot;unixpacket&quot;</li>
</ul>
<p>代码实例:</p>
<pre><code>package main

import &quot;fmt&quot;
import &quot;net&quot;

func main() {
	conn,err := net.Dial(&quot;tcp&quot;,&quot;www.163.com:80&quot;)
	if err != nil {
		fmt.Println(err)
	}
	fmt.Printf(&quot;%#v&quot;,conn) //返回类似 &amp;net.TCPConn{fd:(*net.netFD)(0xf840069000)}
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-dialipnetproto-string-laddr-raddr-ipaddr-ipconn-error"><a class="header" href="#func-dialipnetproto-string-laddr-raddr-ipaddr-ipconn-error">func DialIP(netProto string, laddr, raddr *IPAddr) (*IPConn, error)</a></h2>
<p>参数列表:</p>
<ul>
<li>netProto 网络类型协议 字符串</li>
<li>laddr 本地地址</li>
<li>raddr 远端地址</li>
</ul>
<p>netProto必须为以下三种之一</p>
<ul>
<li>&quot;ip&quot;</li>
<li>&quot;ip4&quot;</li>
<li>&quot;ip6&quot;</li>
</ul>
<p>返回列表:</p>
<ul>
<li>IPConn ip连接指针</li>
<li>error 错误信息</li>
</ul>
<p>用连接网络类型协议和本地地址连接远端地址,返回IP连接</p>
<p>代码实例:</p>
<pre><code>package main

import &quot;fmt&quot;
import &quot;net&quot;

func main() {
	raddr, _ := net.ResolveIPAddr(&quot;tcp&quot;, &quot;www.163.com&quot;)
	ipconn, err := net.DialIP(&quot;ip:1&quot;, nil, raddr)
	if err != nil {
		fmt.Println(err)
	}
	fmt.Printf(&quot;ipconn:%#v&quot;, ipconn) //ipconn:&amp;net.IPConn{fd:(*net.netFD)(0xf840069000)}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-dialtimeoutnet-addr-string-timeout-timeduration-conn-error"><a class="header" href="#func-dialtimeoutnet-addr-string-timeout-timeduration-conn-error">func DialTimeout(net, addr string, timeout time.Duration) (Conn, error)</a></h2>
<p>参数列表:</p>
<ul>
<li>net 网络类型 字符串</li>
<li>addr 远端地址 字符串</li>
<li>timeout 超时时间</li>
</ul>
<p>返回列表:</p>
<ul>
<li>Conn 连接接口</li>
<li>error 错误信息</li>
</ul>
<p>查找特定网络的端口和服务</p>
<p>代码实例:</p>
<pre><code>package main

import &quot;fmt&quot;
import &quot;net&quot;
import &quot;time&quot;

func main() {
	timeOut := time.Duration(10) * time.Second
	conn, err := net.DialTimeout(&quot;tcp&quot;, &quot;www.163.com:80&quot;, timeOut)
	if err != nil {
		fmt.Println(err)
	}
	fmt.Printf(&quot;%#v&quot;, conn) //返回类似 &amp;net.TCPConn{fd:(*net.netFD)(0xf840069000)}
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="结构-dnsconfigerror"><a class="header" href="#结构-dnsconfigerror">结构 DNSConfigError</a></h2>
<p>DNSConfigError 错误结构 - 请参考 Error包</p>
<p>结构:</p>
<pre><code>type DNSConfigError struct {
    Err  error
}
</code></pre>
<ul>
<li>
<p>func (*DNSConfigError) Error</p>
</li>
<li>
<p>func (*DNSConfigError) Temporary</p>
</li>
<li>
<p>func (*DNSConfigError) Timeout</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="结构-dnserror"><a class="header" href="#结构-dnserror">结构 DNSError</a></h2>
<p>DNSError 错误结构 - 请参考 Error包</p>
<p>结构:</p>
<pre><code>type DNSError struct {
		Err       string // 错误说明
		Name      string // 错误名
		Server    string // 使用的服务名
		IsTimeout bool // 是否超时
}
</code></pre>
<ul>
<li>
<p>func (*DNSError) Error</p>
</li>
<li>
<p>func (*DNSError) Temporary</p>
</li>
<li>
<p>func (*DNSError) Timeout</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="接口-error"><a class="header" href="#接口-error">接口 Error</a></h2>
<p>网络错误接口</p>
<pre><code>type Error interface {
    error
    Timeout() bool   // 是否属于一个超时错误
    Temporary() bool // 是否是一个临时错误
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-filelistenerf-osfile-l-listener-err-error"><a class="header" href="#func-filelistenerf-osfile-l-listener-err-error">func FileListener(f *os.File) (l Listener, err error)</a></h2>
<p>参数列表:</p>
<ul>
<li>f 文件名</li>
</ul>
<p>返回列表:</p>
<ul>
<li>l 监听者</li>
<li>err 错误</li>
</ul>
<p>打开一个文件,并负责他的关闭,返回一个监听者或者错误</p>
<p>代码实例:</p>
<pre><code>package main

import &quot;fmt&quot;
import &quot;net&quot;

func main() {
	port,err := net.LookupPort(&quot;tcp&quot;,&quot;https&quot;)
	if err != nil {
		fmt.Println(err)
	}
	fmt.Println(port) //返回 443
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="结构-flags"><a class="header" href="#结构-flags">结构　Flags</a></h2>
<pre><code>type Flags uint

const (
    FlagUp           Flags = 1 &lt;&lt; iota // 连接接口标志
    FlagBroadcast                      // 广播连接接口标志
    FlagLoopback                       // 环回连接接口标志
    FlagPointToPoint                   //点对点连接接口标志
    FlagMulticast                      // 多播连接接口标志
)
</code></pre>
<ul>
<li>func (f Flags) String() string</li>
</ul>
<p>返回接口标志</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="hardwareaddr-结构"><a class="header" href="#hardwareaddr-结构">HardwareAddr 结构</a></h2>
<pre><code>type HardwareAddr []byte
</code></pre>
<p>物理硬件地址</p>
<p>====</p>
<ul>
<li>func (a HardwareAddr) String() string</li>
</ul>
<p>返回 物理硬件地址的字符串	</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="结构-interface"><a class="header" href="#结构-interface">结构 Interface</a></h2>
<pre><code>type Interface struct {
    Index        int          // 从1计数(不存在0的情况)
    MTU          int          // 最大传输单位
    Name         string       // 比如 &quot;en0&quot;, &quot;lo0&quot;, &quot;eth0.100&quot;
    HardwareAddr HardwareAddr // IEEE MAC-48, EUI-48 and EUI-64 form
    Flags        Flags        // 比如 FlagUp, FlagLoopback, FlagMulticast
}
</code></pre>
<p>网络接口结构(译者注:你可以暂时理解为网卡/网关/路由信息)</p>
<p>====</p>
<ul>
<li>func (ifi *Interface) Addrs() ([]Addr, error)</li>
</ul>
<p>获取该网络接口下所有地址</p>
<p>====</p>
<ul>
<li>func (ifi *Interface) MulticastAddrs() ([]Addr, error)</li>
</ul>
<p>获取该网络接口下所有多播地址</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-interfaceaddrs-addr-error"><a class="header" href="#func-interfaceaddrs-addr-error">func InterfaceAddrs() ([]Addr, error)</a></h2>
<p>参数列表:</p>
<ul>
<li>无</li>
</ul>
<p>返回列表:</p>
<ul>
<li>[]Addr 网络地址列表</li>
<li>error 错误信息</li>
</ul>
<p>返回系统网络地址列表,和错误.</p>
<p>代码实例:</p>
<pre><code>package main

import &quot;fmt&quot;
import &quot;net&quot;

func main() {
	addrs,err := net.InterfaceAddrs()
	if err != nil {
		fmt.Println(&quot;error&quot;)
	}
	fmt.Println(addrs) // 打印结果应该类似 [127.0.0.1/8 10.200.54.178/20 42.121.14.243/22]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-interfacebyindexindex-int-interface-error"><a class="header" href="#func-interfacebyindexindex-int-interface-error">func InterfaceByIndex(index int) (*Interface, error)</a></h2>
<p>参数列表:</p>
<ul>
<li>index 索引号</li>
</ul>
<p>返回列表:</p>
<ul>
<li>I*nterface 接口结构指针</li>
<li>error 错误信息</li>
</ul>
<p>根据索引查找网络接口</p>
<p>代码实例:</p>
<pre><code>package main

import &quot;fmt&quot;
import &quot;net&quot;

func main() {
	interf,err := net.InterfaceByIndex(1)
	if err != nil {
		fmt.Println(err)
	}
	fmt.Println(interf) //返回 &amp;{1 16436 lo  up|loopback}
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-interfacebynamename-string-interface-error"><a class="header" href="#func-interfacebynamename-string-interface-error">func InterfaceByName(name string) (*Interface, error)</a></h2>
<p>参数列表:</p>
<ul>
<li>name 网络接口名称</li>
</ul>
<p>返回列表:</p>
<ul>
<li>I*nterface 接口结构指针</li>
<li>error 错误信息</li>
</ul>
<p>根据索引查找网络接口</p>
<p>代码实例:</p>
<pre><code>package main

import &quot;fmt&quot;
import &quot;net&quot;

func main() {
	interf,err := net.InterfaceByName(&quot;eth0&quot;)
	if err != nil {
		fmt.Println(err)
	}
	fmt.Println(interf) //返回 &amp;{2 1500 eth0 00:16:3e:01:04:1f up|broadcast|multicast}
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-interfaces-interface-error"><a class="header" href="#func-interfaces-interface-error">func Interfaces() ([]Interface, error)</a></h2>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回列表</p>
<ul>
<li>[]Interface 系统网络设备信息列表</li>
<li>error 错误信息</li>
</ul>
<p>返回系统网络设备信息列表</p>
<p>实例:</p>
<pre><code>package main

import &quot;fmt&quot;
import &quot;net&quot;

func main() {
	eths,err := net.Interfaces()
	if err != nil {
		fmt.Println(&quot;error&quot;)
	}
	fmt.Println(eths) // 打印结果应该类似[{1 16436 lo  up|loopback} {2 1500 eth0 00:16:3e:01:04:1f up|broadcast|multicast} {3 1500 eth1 00:16:3e:01:04:1e up|broadcast|multicast}
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="结构-invalidaddrerror"><a class="header" href="#结构-invalidaddrerror">结构 InvalidAddrError</a></h2>
<pre><code>type InvalidAddrError string
</code></pre>
<p>非法地址错误,请查看Error包</p>
<p>====</p>
<ul>
<li>
<p>func (e InvalidAddrError) Error() string</p>
</li>
<li>
<p>func (e InvalidAddrError) Temporary() bool</p>
</li>
<li>
<p>func (e InvalidAddrError) Timeout() bool</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="结构-ip"><a class="header" href="#结构-ip">结构 IP</a></h2>
<pre><code>type IP []byte
</code></pre>
<p>ip地址结构</p>
<p>====</p>
<ul>
<li>func (ip IP) DefaultMask() IPMask</li>
</ul>
<p>获取默认IP掩码</p>
<p>====</p>
<ul>
<li>func (ip IP) Equal(x IP) bool</li>
</ul>
<p>判断两个IP是否相等,x 里可以是IPv6</p>
<p>====</p>
<ul>
<li>func (ip IP) IsGlobalUnicast() bool</li>
</ul>
<p>判断是否全球单播地址</p>
<p><a href="http://baike.baidu.com/view/625843.htm">百度百科 - 单播</a></p>
<p>====</p>
<ul>
<li>func (ip IP) IsInterfaceLocalMulticast() bool</li>
</ul>
<p>判断是否本地多播接口</p>
<p>====</p>
<ul>
<li>func (ip IP) IsLinkLocalMulticast() bool</li>
</ul>
<p>判断是否本地多播连接</p>
<p>====</p>
<ul>
<li>func (ip IP) IsLinkLocalUnicast() bool</li>
</ul>
<p>判断是否本地单播连接</p>
<p>====</p>
<ul>
<li>func (ip IP) IsLoopback() bool</li>
</ul>
<p>判断是否环回地址</p>
<p>====</p>
<ul>
<li>func (ip IP) IsMulticast() bool</li>
</ul>
<p>判断是否多播地址</p>
<p>====</p>
<ul>
<li>func (ip IP) IsUnspecified() bool</li>
</ul>
<p>判断ip地址是否是不确定地址</p>
<p>====</p>
<ul>
<li>func (ip IP) Mask(mask IPMask) IP</li>
</ul>
<p>设置网络掩码</p>
<p>====</p>
<ul>
<li>func (ip IP) String() string</li>
</ul>
<p>返回ip地址的字符串形式</p>
<p>====</p>
<ul>
<li>func (ip IP) To16() IP</li>
</ul>
<p>返回16位ip地址</p>
<p>====</p>
<ul>
<li>func (ip IP) To4() IP</li>
</ul>
<p>返回4位IP地址</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="结构-ipaddr"><a class="header" href="#结构-ipaddr">结构 IPAddr</a></h2>
<pre><code>type IPAddr struct {
    IP IP
}
</code></pre>
<p>IP地址结构</p>
<p>====</p>
<ul>
<li>func (a *IPAddr) Network() string</li>
</ul>
<p>返回该ip地址的网络类型名称</p>
<p>====</p>
<ul>
<li>func (a *IPAddr) String() string</li>
</ul>
<p>返回该ip地址下的字符串形式IP</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="结构-ipconn"><a class="header" href="#结构-ipconn">结构 IPConn</a></h2>
<pre><code>type IPConn struct {
    // 空结构
}
</code></pre>
<p>IPConn是 Conn接口的实现</p>
<p>====</p>
<ul>
<li>func (*IPConn) Close</li>
</ul>
<p>关闭IP连接</p>
<p>====</p>
<ul>
<li>func (c *IPConn) File() (f *os.File, err error)</li>
</ul>
<p>返回一个独占模式的系统文件结构指针,注意.当该连接关闭或者文件关闭时互不影响</p>
<p>====</p>
<ul>
<li>func (c *IPConn) LocalAddr() Addr</li>
</ul>
<p>返回连接的本地地址</p>
<p>====</p>
<ul>
<li>func (c *IPConn) Read(b []byte) (int, error)</li>
</ul>
<p>读取数据到缓冲区(b),返回读取字节数或者错误</p>
<p>====</p>
<ul>
<li>func (c *IPConn) ReadFrom(b []byte) (int, Addr, error)</li>
</ul>
<p>读取数据到缓冲区(b),返回读取字节数,地址结构,或者错误</p>
<p>====</p>
<ul>
<li>func (c *IPConn) ReadFromIP(b []byte) (int, *IPAddr, error)</li>
</ul>
<p>读取数据到缓冲区(b),返回读取字节数,IP地址结构,或者错误</p>
<p>====</p>
<ul>
<li>func (c *IPConn) RemoteAddr() Addr</li>
</ul>
<p>返回远端地址结构</p>
<p>====</p>
<ul>
<li>func (c *IPConn) SetDeadline(t time.Time) error</li>
</ul>
<p>设置读/写超时时间</p>
<p>====</p>
<ul>
<li>func (c *IPConn) SetReadBuffer(bytes int) error</li>
</ul>
<p>设置读缓冲区长度</p>
<p>====</p>
<ul>
<li>func (c *IPConn) SetReadDeadline(t time.Time) error</li>
</ul>
<p>设置读取超时时间</p>
<p>====</p>
<ul>
<li>func (c *IPConn) SetWriteBuffer(bytes int) error</li>
</ul>
<p>设置写缓存区长度</p>
<p>====</p>
<ul>
<li>func (c *IPConn) SetWriteDeadline(t time.Time) error</li>
</ul>
<p>设置写入超时时间</p>
<p>====</p>
<ul>
<li>func (c *IPConn) Write(b []byte) (int, error)</li>
</ul>
<p>往缓冲区写入数据,返回写入缓冲区的字节数或者错误</p>
<p>====</p>
<ul>
<li>func (c *IPConn) WriteTo(b []byte, addr Addr) (int, error)</li>
</ul>
<p>往对应地址结构的缓冲区写入数据 ,返回写入缓冲区的字节数或者错误- 实现PacketConn接口方法</p>
<p>====</p>
<ul>
<li>func (c *IPConn) WriteToIP(b []byte, addr *IPAddr) (int, error)</li>
</ul>
<p>往对应IP地址结构的缓冲区写入数据 ,返回写入缓冲区的字节数或者错误</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="结构-ipmask"><a class="header" href="#结构-ipmask">结构 IPMask</a></h2>
<pre><code>type IPMask []byte
</code></pre>
<p>IP掩码结构</p>
<p>====</p>
<ul>
<li>func (m IPMask) Size() (ones, bits int)</li>
</ul>
<p>返回在同一网段内该掩码下能支持多少个IP</p>
<p>====</p>
<ul>
<li>func (m IPMask) String() string</li>
</ul>
<p>返回 掩码的字符串形式</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="结构-ipnet"><a class="header" href="#结构-ipnet">结构 IPNet</a></h2>
<pre><code>type IPNet struct {
    IP   IP     // network number
    Mask IPMask // network mask
}
</code></pre>
<p>IPNet 结构</p>
<p>====</p>
<ul>
<li>func (n *IPNet) Contains(ip IP) bool</li>
</ul>
<p>返回此IP网络是否包含该IP</p>
<p>====</p>
<ul>
<li>func (n *IPNet) Network() string</li>
</ul>
<p>返回此IP网络名称  &quot;ip+net&quot;</p>
<p>====</p>
<ul>
<li>func (n *IPNet) String() string</li>
</ul>
<p>返回IP网络的字符串形式</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-ipv4a-b-c-d-byte-ip"><a class="header" href="#func-ipv4a-b-c-d-byte-ip">func IPv4(a, b, c, d byte) IP</a></h2>
<p>参数列表:</p>
<ul>
<li>a IP地址的第1个字节</li>
<li>b IP地址的第2个字节</li>
<li>c IP地址的第3个字节</li>
<li>d IP地址的第4个字节</li>
</ul>
<p>返回列表:</p>
<ul>
<li>IP ip结构</li>
</ul>
<p>函数功能:</p>
<ul>
<li>根据a,b,c,d四个字节返回ip结构</li>
</ul>
<p>代码实例:</p>
<pre><code>package main

import &quot;fmt&quot;
import &quot;net&quot;

func main() {
    ip := net.IPv4(127,0,1,1)
    fmt.Println(ip)
}
</code></pre>
<p>代码输出:</p>
<pre><code>127.0.1.1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-ipv4maska-b-c-d-byte-ipmask"><a class="header" href="#func-ipv4maska-b-c-d-byte-ipmask">func IPv4Mask(a, b, c, d byte) IPMask</a></h2>
<p>参数列表:</p>
<ul>
<li>a IP掩码的第1个字节</li>
<li>b IP掩码的第2个字节</li>
<li>c IP掩码的第3个字节</li>
<li>d IP掩码的第4个字节</li>
</ul>
<p>返回列表:</p>
<ul>
<li>IPMask 掩码</li>
</ul>
<p>函数功能</p>
<ul>
<li>生成IP掩码</li>
</ul>
<p>代码实例:</p>
<pre><code>package main

import &quot;fmt&quot;
import &quot;net&quot;

func main() {
	mask := net.IPv4Mask(127, 127, 127, 127)
	fmt.Printf(&quot;%#v&quot;,mask)
}
</code></pre>
<p>代码输出：</p>
<pre><code>net.IPMask{0x7f, 0x7f, 0x7f, 0x7f}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-joinhostporthost-port-string-string"><a class="header" href="#func-joinhostporthost-port-string-string">func JoinHostPort(host, port string) string</a></h2>
<p>参数列表</p>
<ul>
<li>host string 主机名</li>
<li>port string 端口号</li>
</ul>
<p>返回列表</p>
<ul>
<li>string 主机名与端口号结合后的字符串</li>
</ul>
<p>返回主机名与端口号结合后的字符串,类似host:port
比如:</p>
<pre><code>host 为 gocn_server
port 为 8080
则返回字符串是 gocn_server:8080
</code></pre>
<p>如果主机名中存在冒号
比如:</p>
<pre><code>host 为 gocn:server
port 为 8080
则返回的字符串是 [gocn:server]:8080
</code></pre>
<p>实例:</p>
<pre><code>package main

import &quot;fmt&quot;
import &quot;net&quot;

func main() {
	addr1 := net.JoinHostPort(&quot;gocn_server&quot;,&quot;8080&quot;)
	addr2 := net.JoinHostPort(&quot;gocn:server&quot;,&quot;8080&quot;)
	fmt.Println(addr1) // 打印结果应该为 gocn_server:8080
	fmt.Println(addr2) // 打印结果应该为 [gocn:server]:8080
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-listennet-laddr-string-listener-error"><a class="header" href="#func-listennet-laddr-string-listener-error">func Listen(net, laddr string) (Listener, error)</a></h2>
<p>参数列表:</p>
<ul>
<li>net 网络字符串</li>
<li>laddr 本地地址字符串</li>
</ul>
<p>返回列表:</p>
<ul>
<li>Listener 监听者</li>
<li>err 错误信息</li>
</ul>
<p>查找特定网络的端口和服务</p>
<p>代码实例:</p>
<pre><code>package main

import &quot;io&quot;
import &quot;log&quot;
import &quot;net&quot;

func main() {
	l, err := net.Listen(&quot;tcp&quot;, &quot;:2000&quot;)
	if err != nil {
	    log.Fatal(err)
	}
	for {
	    // 等待下一个连接,如果没有连接,l.Accept会阻塞
	    conn, err := l.Accept()
	    if err != nil {
	        log.Fatal(err)
	    }
	    // 将新连接放入一个goroute里,然后再等下一个新连接.
	    go func(c net.Conn) {
	        // 显示连接发送来的内容
	        io.Copy(c, c)
	        // 关闭连接
	        c.Close()
	    }(conn)
	}
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="接口-listener"><a class="header" href="#接口-listener">接口 Listener</a></h2>
<pre><code>type Listener interface {
    // 等待并返回下一个连接或错误
    Accept() (c Conn, err error)

    // 关闭这个监听者
    Close() error

    // 返回监听信息
    Addr() Addr
}
</code></pre>
<p>监听者接口</p>
<pre><code>// Listen on TCP port 2000 on all interfaces.
l, err := net.Listen(&quot;tcp&quot;, &quot;:2000&quot;)
if err != nil {
    log.Fatal(err)
}
for {
    // Wait for a connection. 
    conn, err := l.Accept()
    if err != nil {
        log.Fatal(err)
    }
    // Handle the connection in a new goroutine.
    // The loop then returns to accepting, so that
    // multiple connections may be served concurrently.
    go func(c net.Conn) {
        // Echo all incoming data.
        io.Copy(c, c)
        // Shut down the connection.
        c.Close()
    }(conn)
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-listenipnetproto-string-laddr-ipaddr-ipconn-error"><a class="header" href="#func-listenipnetproto-string-laddr-ipaddr-ipconn-error">func ListenIP(netProto string, laddr *IPAddr) (*IPConn, error)</a></h2>
<p>参数列表:</p>
<ul>
<li>netProto 网络类型 字符串</li>
<li>laddr 本地地址指针</li>
</ul>
<p>返回列表:</p>
<ul>
<li>IPConn ip连接指针</li>
<li>error 错误信息</li>
</ul>
<p>监听netProto协议和本地地址,返回IP连接指针</p>
<p>代码实例:</p>
<pre><code>package main

import &quot;fmt&quot;
import &quot;net&quot;

func main() {
	ipaddr,_ := net.ResolveIPAddr(&quot;tcp&quot;,&quot;0.0.0.0&quot;)
	ipconn,err := net.ListenIP(&quot;ip:1&quot;,ipaddr)
	if err != nil {
		fmt.Println(err)
	}
	fmt.Printf(&quot;ipconn:%#v&quot;,ipconn) //返回 ipconn:&amp;net.IPConn{fd:(*net.netFD)(0xf840069000)}
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-lookupaddraddr-string-name-string-err-error"><a class="header" href="#func-lookupaddraddr-string-name-string-err-error">func LookupAddr(addr string) (name []string, err error)</a></h2>
<p>参数列表</p>
<ul>
<li>addr  地址字符串</li>
</ul>
<p>返回列表</p>
<ul>
<li>name  主机名列表</li>
<li>err   错误信息</li>
</ul>
<p>功能说明</p>
<ul>
<li>通过IP地址查询域名列表</li>
</ul>
<p>代码实例:</p>
<pre><code>package main

import &quot;fmt&quot;
import &quot;net&quot;

func main() {
	names := net.LookupAddr(&quot;173.194.127.81&quot;)
	fmt.Println(addr)
}
</code></pre>
<p>代码输出：</p>
<pre><code>[hkg03s11-in-f17.1e100.net.]
&lt;nil&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-lookupcnamename-string-cname-string-err-error"><a class="header" href="#func-lookupcnamename-string-cname-string-err-error">func LookupCNAME(name string) (cname string, err error)</a></h2>
<p>参数列表:</p>
<ul>
<li>name 域名字符串</li>
</ul>
<p>返回列表:</p>
<ul>
<li>cname 主机名</li>
<li>error 错误信息</li>
</ul>
<p>返回该域名的CNAME记录</p>
<p><a href="http://baike.baidu.com/view/552919.htm">CNAME-百度百科</a></p>
<p>代码实例:</p>
<pre><code>package main

import &quot;fmt&quot;
import &quot;net&quot;

func main() {
    fmt.Println( net. LookupCNAME(&quot;any.weizhe.net&quot;))
    fmt.Println( net. LookupCNAME(&quot;blog.weizhe.net&quot;))
}
</code></pre>
<p>代码输出：</p>
<pre><code>blog.weizhe.net. &lt;nil&gt;
blog.weizhe.net. &lt;nil&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-lookuphosthost-string-addrs-string-err-error"><a class="header" href="#func-lookuphosthost-string-addrs-string-err-error">func LookupHost(host string) (addrs []string, err error)</a></h2>
<p>参数列表:</p>
<ul>
<li>host 服务器字符串</li>
</ul>
<p>返回列表:</p>
<ul>
<li>地址列表</li>
<li>err 错误信息</li>
</ul>
<p>返回该域名的所有地址字符串列表</p>
<p>代码实例:</p>
<pre><code>package main

import &quot;fmt&quot;
import &quot;net&quot;

func main() {
	addrs,err := net.LookupHost(&quot;www.163.com&quot;)
	if err != nil {
		fmt.Println(err)
	}
	fmt.Println(addrs) // 打印结果应该类似 [122.228.218.179 183.129.198.96]
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-lookupiphost-string-addrs-ip-err-error"><a class="header" href="#func-lookupiphost-string-addrs-ip-err-error">func LookupIP(host string) (addrs []IP, err error)</a></h2>
<p>参数列表:</p>
<ul>
<li>host 服务器字符串</li>
</ul>
<p>返回列表:</p>
<ul>
<li>ip地址列表</li>
<li>err 错误信息</li>
</ul>
<p>返回该域名的所有ip地址列表</p>
<p>代码实例:</p>
<pre><code>package main

import &quot;fmt&quot;
import &quot;net&quot;

func main() {
	addrs,err := net.LookupIP(&quot;www.163.com&quot;)
	if err != nil {
		fmt.Println(err)
	}
	fmt.Println(addrs) // 打印结果应该类似 [122.228.218.179 183.129.198.96]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-lookupmxname-string-mx-mx-err-error"><a class="header" href="#func-lookupmxname-string-mx-mx-err-error">func LookupMX(name string) (mx []*MX, err error)</a></h2>
<p>参数列表:</p>
<ul>
<li>name 域名字符串</li>
</ul>
<p>返回列表:</p>
<ul>
<li>mx记录列表</li>
<li>err 错误信息</li>
</ul>
<p><a href="http://baike.baidu.cn/view/65595.htm">MX记录-百度百科</a></p>
<p>返回该域名的所有mx记录列表</p>
<p>代码实例:</p>
<pre><code>package main

import &quot;fmt&quot;
import &quot;net&quot;

func main() {
	mxs,err := net.LookupMX(&quot;163.com&quot;)
	if err != nil {
		fmt.Println(err)
	}
	for _,mx := range mxs{
		fmt.Println(mx) 
		// 打印结果应该类似 
		// &amp;{163mx02.mxmail.netease.com. 10}
		// &amp;{163mx01.mxmail.netease.com. 10}
		// &amp;{163mx03.mxmail.netease.com. 10}
		// &amp;{163mx00.mxmail.netease.com. 50}
	}
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-lookupportnetwork-service-string-port-int-err-error"><a class="header" href="#func-lookupportnetwork-service-string-port-int-err-error">func LookupPort(network, service string) (port int, err error)</a></h2>
<p>参数列表:</p>
<ul>
<li>network 网络字符串</li>
<li>service 服务名</li>
</ul>
<p>返回列表:</p>
<ul>
<li>port 端口号</li>
<li>err 错误信息</li>
</ul>
<p>查找特定网络的端口和服务</p>
<p>代码实例:</p>
<pre><code>package main

import &quot;fmt&quot;
import &quot;net&quot;

func main() {
	port,err := net.LookupPort(&quot;tcp&quot;,&quot;https&quot;)
	if err != nil {
		fmt.Println(err)
	}
	fmt.Println(port) //返回 443
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-lookupsrvservice-proto-name-string-cname-string-addrs-srv-err-error"><a class="header" href="#func-lookupsrvservice-proto-name-string-cname-string-addrs-srv-err-error">func LookupSRV(service, proto, name string) (cname string, addrs []*SRV, err error)</a></h2>
<p>参数列表:</p>
<ul>
<li>service 服务名</li>
<li>proto 协议名</li>
<li>name 域名</li>
</ul>
<p>返回列表:</p>
<ul>
<li>cname cname字符串</li>
<li>addrs SRV记录列表</li>
<li>err 错误信息</li>
</ul>
<p>查找该服务和协议下的SRV记录地址</p>
<p><a href="http://baike.baidu.com/view/1372993.htm">百度百科-SRV记录</a></p>
<p>代码实例:</p>
<pre><code>package main

import &quot;fmt&quot;
import &quot;net&quot;

func main() {
	cname,addrs,err:=net.LookupSRV(&quot;xmpp-server&quot;,&quot;tcp&quot;,&quot;gocn.im&quot;)
	if err != nil {
		fmt.Println(err)
	}
	for _,addr := range addrs {
		fmt.Println(addr) // 返回类似 &amp;{xmpp-server.l.google.com. 5269 5 0}
	}
	fmt.Println(cname) //返回类似 _xmpp-server._tcp.gocn.im.
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-lookuptxtname-string-txt-string-err-error"><a class="header" href="#func-lookuptxtname-string-txt-string-err-error">func LookupTXT(name string) (txt []string, err error)</a></h2>
<p>参数列表:</p>
<ul>
<li>name 域名</li>
</ul>
<p>返回列表:</p>
<ul>
<li>txt txt记录名</li>
<li>err 错误信息</li>
</ul>
<p>查找该域名下的txt记录</p>
<p><a href="http://baike.baidu.com/view/1372987.htm">百度百科-TXT记录</a></p>
<p>代码实例:</p>
<pre><code>package main

import &quot;fmt&quot;
import &quot;net&quot;

func main() {
	txts,err:=net.LookupTXT(&quot;163.com&quot;)
	if err != nil {
		fmt.Println(err)
	}
	for _,txt := range txts {
		fmt.Println(txt) // 返回类似 v=spf1 include:spf.163.com -all
	}
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="结构-mx"><a class="header" href="#结构-mx">结构 MX</a></h2>
<pre><code>type MX struct {
    Host string
    Pref uint16
}
</code></pre>
<p>DNS 的MX记录结构</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="结构-operror"><a class="header" href="#结构-operror">结构 OpError</a></h2>
<pre><code>type OpError struct {
    Op   string
    Net  string
    Addr Addr
    Err  error
}
</code></pre>
<p>请参考Error包</p>
<p>====</p>
<ul>
<li>
<p>func (*OpError) Error</p>
</li>
<li>
<p>func (e *OpError) Temporary() bool</p>
</li>
<li>
<p>func (e *OpError) Timeout() bool</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-parsecidrs-string-ip-ipnet-error"><a class="header" href="#func-parsecidrs-string-ip-ipnet-error">func ParseCIDR(s string) (IP, *IPNet, error)</a></h2>
<p>参数列表:</p>
<ul>
<li>s 字符串</li>
</ul>
<p>返回列表:</p>
<ul>
<li>IP IP结构</li>
<li>IPNet 结构</li>
<li>error 错误信息</li>
</ul>
<p>解析 CIDR(无类域间路由) 格式字符串,返回 IP结构,IPNet结构和错误信息</p>
<p><a href="http://baike.baidu.com/view/4217886.htm">百度百科 - CIDR</a></p>
<p>代码实例:</p>
<pre><code>package main

import &quot;fmt&quot;
import &quot;net&quot;

func main() {
	ip,ipnet,err := net.ParseCIDR(&quot;198.168.0.0/16&quot;)
	if err != nil {
		fmt.Println(err)
	}
	fmt.Printf(&quot;IP:%#v&quot;,ip) //返回 IP:[]byte{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff, 0xff, 0xc6, 0xa8, 0x0, 0x0}
	fmt.Printf(&quot;IPNet:%#v&quot;,ipnet) //返回 IPNet:&amp;net.IPNet{IP:[]byte{0xc6, 0xa8, 0x0, 0x0}, Mask:[]byte{0xff, 0xff, 0x0, 0x0}}
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-parseips-string-ip"><a class="header" href="#func-parseips-string-ip">func ParseIP(s string) IP</a></h2>
<p>参数列表:</p>
<ul>
<li>s ip地址字符串，可以是IPv4或IPv6格式( (&quot;74.125.19.99&quot;) or (&quot;2001:4860:0:2001::68&quot;) )</li>
</ul>
<p>返回列表:</p>
<ul>
<li>IP IP结构</li>
</ul>
<p>解析IP地址,返回IP结构</p>
<p>代码实例:</p>
<pre><code>package main

import &quot;fmt&quot;
import &quot;net&quot;

func main() {
	ip := net.ParseIP(&quot;74.125.19.99&quot;)
	fmt.Printf(&quot;%#v&quot;,ip)
	ip = net.ParseIP(&quot;2001:4860:0:2001::68&quot;)
	fmt.Printf(&quot;%#v&quot;,ip)
</code></pre>
<p>}</p>
<p>函数输出：</p>
<pre><code>net.IP{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff, 0xff, 0x4a, 0x7d, 0x13, 0x63}
net.IP{0x20, 0x1, 0x48, 0x60, 0x0, 0x0, 0x20, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x68}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-parsemacs-string-hw-hardwareaddr-err-error"><a class="header" href="#func-parsemacs-string-hw-hardwareaddr-err-error">func ParseMAC(s string) (hw HardwareAddr, err error)</a></h2>
<p>参数列表:</p>
<ul>
<li>s 符合 IEEE 802 MAC-48, EUI-48 或 EUI-64 标准的MAC地址字符串。支持以下格式
<ul>
<li>01:23:45:67:89:ab</li>
<li>01:23:45:67:89:ab:cd:ef</li>
<li>01-23-45-67-89-ab</li>
<li>01-23-45-67-89-ab-cd-ef</li>
<li>0123.4567.89ab</li>
<li>0123.4567.89ab.cdef</li>
</ul>
</li>
</ul>
<p>返回列表:</p>
<ul>
<li>hw 物理硬件地址</li>
<li>err 错误信息</li>
</ul>
<p>将mac地址解析为物理硬件地址结构</p>
<p>代码实例:</p>
<pre><code>package main

import &quot;fmt&quot;
import &quot;net&quot;

func main() {
	hw,err := net.ParseMAC(&quot;01:23:45:67:89:ab&quot;)
	if err != nil {
		fmt.Println(err)
	}
	fmt.Printf(&quot;%#v&quot;,hw) 
}
</code></pre>
<p>函数输出：</p>
<pre><code>net.HardwareAddr{0x1, 0x23, 0x45, 0x67, 0x89, 0xab}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-pipe-conn-conn"><a class="header" href="#func-pipe-conn-conn">func Pipe() (Conn, Conn)</a></h2>
<p>参数列表:</p>
<ul>
<li>无</li>
</ul>
<p>返回列表:</p>
<ul>
<li>Conn 连接接口</li>
<li>Conn 连接接口</li>
</ul>
<p>函数功能：</p>
<ul>
<li>创建一个同步的,全内存的,无缓冲的,全双工管道,并返回2个连接接口。</li>
<li><a href="http://baike.baidu.com/view/25133.htm#3">百度百科 - 管道</a></li>
</ul>
<p>代码实例:</p>
<pre><code>package main

import &quot;fmt&quot;
import &quot;net&quot;

func main() {
	conn1, conn2 := net.Pipe()
	fmt.Printf(&quot;conn1: %#v \n conn2:%#v&quot;, conn1, conn2) 
}
</code></pre>
<p>代码输出：</p>
<pre><code>conn1: &amp;net.pipe{PipeReader:(*io.PipeReader)(0xf840043048), PipeWriter:(*io.PipeWriter)(0xf840043060)} 
conn2:&amp;net.pipe{PipeReader:(*io.PipeReader)(0xf840043058), PipeWriter:(*io.PipeWriter)(0xf840043050)}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-resolveipaddrnet-addr-string-ipaddr-error"><a class="header" href="#func-resolveipaddrnet-addr-string-ipaddr-error">func ResolveIPAddr(net, addr string) (*IPAddr, error)</a></h2>
<p>参数列表:</p>
<ul>
<li>net 网络类型 字符串</li>
<li>addr 地址 字符串</li>
</ul>
<p>返回列表:</p>
<ul>
<li>IPAddr ip地址指针</li>
<li>error 错误信息</li>
</ul>
<p>返回网络类型下的ip地址/域名的IPAddr结构指针</p>
<p>代码实例:</p>
<pre><code>package main

import &quot;fmt&quot;
import &quot;net&quot;

func main() {
	ipaddr,err := net.ResolveIPAddr(&quot;tcp&quot;,&quot;www.163.com&quot;)
	if err != nil {
		fmt.Println(err)
	}
	fmt.Printf(&quot;ipaddr:%#v&quot;,ipaddr) //ipaddr:&amp;net.IPAddr{IP:[]byte{0x7a, 0xe4, 0xda, 0xb3}}
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-splithostporthostport-string-host-port-string-err-error"><a class="header" href="#func-splithostporthostport-string-host-port-string-err-error">func SplitHostPort(hostport string) (host, port string, err error)</a></h2>
<p>参数列表:</p>
<ul>
<li>hostport 主机端口字符串</li>
</ul>
<p>返回列表:</p>
<ul>
<li>host 主机字符串</li>
<li>port 端口字符串</li>
<li>err 错误信息</li>
</ul>
<p>分解主机端口字符串</p>
<p>代码实例:</p>
<pre><code>package main

import &quot;fmt&quot;
import &quot;net&quot;

func main() {
	host,port,err:=net.SplitHostPort(&quot;163.com:80&quot;)
	if err != nil {
		fmt.Println(err)
	}
	fmt.Println(host) // 返回 163.com
	fmt.Println(port) // 返回 80
	
	host1,port1,err1:=net.SplitHostPort(&quot;[abc:bbc]:88&quot;)
	if err1 != nil {
		fmt.Println(err1)
	}
	fmt.Println(host1) // 返回 abc:bbc
	fmt.Println(port1) // 返回 88
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="结构-udpaddr"><a class="header" href="#结构-udpaddr">结构 UDPAddr</a></h1>
<pre><code>type UDPAddr struct {
    IP   IP		// Ip地址
    Port int	// 端口
    Zone string // IPv6 寻址空间
}
</code></pre>
<p>UDPAddr代表一个UDP地址</p>
<h2 id="func-resolveudpaddrnet-addr-string-udpaddr-error"><a class="header" href="#func-resolveudpaddrnet-addr-string-udpaddr-error">func ResolveUDPAddr(net, addr string) (*UDPAddr, error)</a></h2>
<p>参数列表</p>
<ul>
<li>net UDP类型,可接受字符串:udp, udp4, udp6</li>
<li>addr 地址的字符串: [host]:[port]</li>
</ul>
<p>返回值：</p>
<ul>
<li>*UDPAddr UDP地址</li>
<li>error 错误(如果有)</li>
</ul>
<p>功能说明：</p>
<p>该函数将字符串转换成对应的udp地址,以用于后续操作</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;net&quot;
)

func main() {
    addr, err := net.ResolveUDPAddr(&quot;udp&quot;, &quot;:53&quot;)
    if err != nil {
    	fmt.Println(err)
    	return
    }
    fmt.Println(addr)
}
</code></pre>
<h2 id="func-a-udpaddr-network-string"><a class="header" href="#func-a-udpaddr-network-string">func (a *UDPAddr) Network() string</a></h2>
<p>返回值：</p>
<ul>
<li>string 地址类型</li>
</ul>
<p>功能说明：</p>
<p>该函数返回UDPAddr实例的地址类型</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;net&quot;
)

func main() {
	addr, err := net.ResolveUDPAddr(&quot;udp&quot;, &quot;:53&quot;)
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Println(addr.Network())
}
</code></pre>
<h2 id="func-a-udpaddr-string-string"><a class="header" href="#func-a-udpaddr-string-string">func (a *UDPAddr) String() string</a></h2>
<p>返回值:</p>
<ul>
<li>string 地址的字符串表示</li>
</ul>
<p>功能说明：</p>
<p>该函数返回UDPAddr实例的字符串地址</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;net&quot;
)

func main() {
	addr, err := net.ResolveUDPAddr(&quot;udp&quot;, &quot;:53&quot;)
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Println(addr.String())
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="os函数列表"><a class="header" href="#os函数列表">os函数列表</a></h1>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/Chdir.html">func Chdir(dir string) error</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/Chmod.html">func Chmod(name string, mode FileMode) error</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/Chown.html">func Chown(name string, uid, gid int) error</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/Chtimes.html">func Chtimes(name string, atime time.Time, mtime time.Time) error</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/Clearenv.html">func Clearenv()</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/Environ.html">func Environ() []string</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/Exit.html">func Exit(code int)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/Expand.html">func Expand(s string, mapping func(string) string) string</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/ExpandEnv.html">func ExpandEnv(s string) string</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/Getegid.html">func Getegid() int</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/Getenv.html">func Getenv(key string) string</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/Geteuid.html">func Geteuid() int</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/Getgid.html">func Getgid() int</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/Getgroups.html">func Getgroups() ([]int, error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/Getpagesize.html">func Getpagesize() int</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/Getpid.html">func Getpid() int</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/Getppid.html">func Getppid() int</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/Getuid.html">func Getuid() int</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/Getwd.html">func Getwd() (pwd string, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/Hostname.html">func Hostname() (name string, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/IsExist.html">func IsExist(err error) bool</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/IsNotExist.html">func IsNotExist(err error) bool</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/IsPathSeparator.html">func IsPathSeparator(c uint8) bool</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/IsPermission.html">func IsPermission(err error) bool</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/Lchown.html">func Lchown(name string, uid, gid int) error</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/Link.html">func Link(oldname, newname string) error</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/Mkdir.html">func Mkdir(name string, perm FileMode) error</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/MkdirAll.html">func MkdirAll(path string, perm FileMode) error</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/NewSyscallError.html">func NewSyscallError(syscall string, err error) error</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/Readlink.html">func Readlink(name string) (string, error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/Remove.html">func Remove(name string) error</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/RemoveAll.html">func RemoveAll(path string) error</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/Rename.html">func Rename(oldname, newname string) error</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/SameFile.html">func SameFile(fi1, fi2 FileInfo) bool</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/Setenv.html">func Setenv(key, value string) error</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/Symlink.html">func Symlink(oldname, newname string) error</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/TempDir.html">func TempDir() string</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/Truncate.html">func Truncate(name string, size int64) error</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/File_Create.html">func Create(name string) (file *File, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/File_NewFile.html">func NewFile(fd uintptr, name string) *File</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/File_Open.html">func Open(name string) (file *File, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/File_OpenFile.html">func OpenFile(name string, flag int, perm FileMode) (file *File, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/File_Pipe.html">func Pipe() (r *File, w *File, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/File_Chdir.html">func (f *File) Chdir() error</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/File_Chmod.html">func (f *File) Chmod(mode FileMode) error</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/File_Chown.html">func (f *File) Chown(uid, gid int) error</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/File_Close.html">func (f *File) Close() error</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/File_Fd.html">func (f *File) Fd() uintptr</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/File_Name.html">func (f *File) Name() string</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/File_Read.html">func (f *File) Read(b []byte) (n int, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/File_ReadAt.html">func (f *File) ReadAt(b []byte, off int64) (n int, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/File_Readdir.html">func (f *File) Readdir(n int) (fi []FileInfo, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/File_Readdirnames.html">func (f *File) Readdirnames(n int) (names []string, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/File_Seek.html">func (f *File) Seek(offset int64, whence int) (ret int64, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/File_Stat.html">func (f *File) Stat() (fi FileInfo, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/File_Sync.html">func (f *File) Sync() (err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/File_Truncate.html">func (f *File) Truncate(size int64) error</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/File_Write.html">func (f *File) Write(b []byte) (n int, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/File_WriteAt.html">func (f *File) WriteAt(b []byte, off int64) (n int, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/File_WriteString.html">func (f *File) WriteString(s string) (ret int, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/FileInfo_Lstat.html">func Lstat(name string) (fi FileInfo, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/FileInfo_Stat.html">func Stat(name string) (fi FileInfo, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/FileMode_IsDir.html">func (m FileMode) IsDir() bool</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/FileMode_Perm.html">func (m FileMode) Perm() FileMode</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/FileMode_String.html">func (m FileMode) String() string</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/LinkError_Error.html">func (e *LinkError) Error() string</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/PathError_Error.html">func (e *PathError) Error() string</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/Process_FindProcess.html">func FindProcess(pid int) (p *Process, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/Process_StartProcess.html">func StartProcess(name string, argv []string, attr *ProcAttr) (*Process, error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/Process_Kill.html">func (p *Process) Kill() error</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/Process_Release.html">func (p *Process) Release() error</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/Process_Signal.html">func (p *Process) Signal(sig Signal) error</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/Process_Wait.html">func (p *Process) Wait() (*ProcessState, error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/ProcessState_Exited.html">func (p *ProcessState) Exited() bool</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/ProcessState_Pid.html">func (p *ProcessState) Pid() int</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/ProcessState_String.html">func (p *ProcessState) String() string</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/ProcessState_Success.html">func (p *ProcessState) Success() bool</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/ProcessState_Sys.html">func (p *ProcessState) Sys() interface{}</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/ProcessState_SysUsage.html">func (p *ProcessState) SysUsage() interface{}</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/ProcessState_SystemTime.html">func (p *ProcessState) SystemTime() time.Duration</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/ProcessState_UserTime.html">func (p *ProcessState) UserTime() time.Duration</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/SyscallError_Error.html">func (e *SyscallError) Error() string</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="osexec函数列表"><a class="header" href="#osexec函数列表">os/exec函数列表</a></h1>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/exec/LookPath.html">func LookPath(file string) (string, error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/exec/Command.html">func Command(name string, arg ...string) *Cmd</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/exec/CombinedOutput.html">func (c *Cmd) CombinedOutput() ([]byte, error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/exec/Output.html">func (c *Cmd) Output() ([]byte, error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/exec/Run.html">func (c *Cmd) Run() error</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/exec/Start.html">func (c *Cmd) Start() error</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/exec/StderrPipe.html">func (c *Cmd) StderrPipe() (io.ReadCloser, error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/exec/StdinPipe.html">func (c *Cmd) StdinPipe() (io.WriteCloser, error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/exec/StdoutPipe.html">func (c *Cmd) StdoutPipe() (io.ReadCloser, error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/exec/Wait.html">func (c *Cmd) Wait() error</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/exec/Error.html">func (e *Error) Error() string</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/exec/ExitError.html">func (e *ExitError) Error() string</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="c-cmd-combinedoutput-byte-error"><a class="header" href="#c-cmd-combinedoutput-byte-error">(c *Cmd) CombinedOutput() ([]byte, error)</a></h2>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回[]byte 命令的执行结果</li>
<li>返回error 返回错误信息对象</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是执行*Cmd中的命令，把执行结果和错误合并到byte数组中</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os/exec&quot;
)

func main() {
    arg := []string{&quot;Hello&quot;, &quot;World!&quot;}
    cmd := exec.Command(&quot;mv&quot;, arg...)
    output, err := cmd.CombinedOutput()
    if err != nil {
        fmt.Printf(&quot;Error: %s\n&quot;, err)  //Error: exit status 1
    }
    //test in ArchLinux
    //当前目录中必须没有名为Hello的文件或文件夹
    fmt.Printf(&quot;The output is: %s\n&quot;, output)   //The output is: mv: 无法获取&quot;Hello&quot; 的文件状态(stat): 没有那个文件或目录
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-commandname-string-arg-string-cmd"><a class="header" href="#func-commandname-string-arg-string-cmd">func Command(name string, arg ...string) *Cmd</a></h2>
<p>参数列表</p>
<ul>
<li>name 表示需要执行的命令名</li>
<li>arg  表示跟在命令后的参数列表</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回*Cmd 按参数初始化Path和Args字段，其他字段执行默认初始化的Cmd结构体指针</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是用来初始化一个Cmd指针，Path和Args按参数初始化，其他字段执行默认初始化</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os/exec&quot;
)

func main() {
    arg := []string{&quot;Hello&quot;, &quot;World!&quot;}
    cmd := exec.Command(&quot;echo&quot;, arg...)
    output, err := cmd.Output()
    if err != nil {
        fmt.Printf(&quot;Error: %s\n&quot;, err)
        return
    }
    //test in ArchLinux
    fmt.Printf(&quot;The output is: %s\n&quot;, output)   //The output is: Hello World!
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-e-error-error-string"><a class="header" href="#func-e-error-error-string">func (e *Error) Error() string</a></h2>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回string 返回执行失败命令的错误信息</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是输出命令执行失败的错误信息</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;errors&quot;
    &quot;fmt&quot;
    &quot;os/exec&quot;
)

func main() {
    e := exec.Error{
        Name: &quot;mv&quot;,
        Err:  errors.New(&quot;无法获取\&quot;Hello\&quot; 的文件状态(stat): 没有那个文件或目录&quot;),
    }
    //test in ArchLinux
    fmt.Printf(&quot;%s\n&quot;, e.Error()) //exec: &quot;mv&quot;: 无法获取&quot;Hello&quot; 的文件状态(stat): 没有那个文件或目录
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-e-exiterror-error-string"><a class="header" href="#func-e-exiterror-error-string">func (e *ExitError) Error() string</a></h2>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回string 返回一个执行不成功命令的信息</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是返回一个执行不成功命令的信息</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os/exec&quot;
)

func main() {
    cmd := exec.Command(&quot;mv&quot;, &quot;Hello World!&quot;)
    cmd.Run()
    exitError := exec.ExitError{cmd.ProcessState}
    //test in ArchLinux
    fmt.Printf(&quot;The output is: %s\n&quot;, exitError.Error())   //The output is: exit status 1
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-lookpathfile-string-string-error"><a class="header" href="#func-lookpathfile-string-string-error">func LookPath(file string) (string, error)</a></h2>
<p>参数列表</p>
<ul>
<li>file 表示环境变量中执行的二进制文件名</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回string 可执行文件所在的路径</li>
<li>返回error 返回错误信息对象</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是用来查询可执行二进制文件的路径</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os/exec&quot;
)

func main() {
    path, err := exec.LookPath(&quot;echo&quot;)
    if err != nil {
        fmt.Printf(&quot;Error: %s\n&quot;, err)
        return
    }
    //测试环境为ArchLinux
    fmt.Printf(&quot;echo is available at %s\n&quot;, path)    //echo is available at /usr/bin/echo
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="c-cmd-output-byte-error"><a class="header" href="#c-cmd-output-byte-error">(c *Cmd) Output() ([]byte, error)</a></h2>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回[]byte 命令的执行结果</li>
<li>返回error 返回错误信息对象</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是执行*Cmd中的命令，返回执行结果</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os/exec&quot;
)

func main() {
    arg := []string{&quot;Hello&quot;, &quot;World!&quot;}
    cmd := exec.Command(&quot;echo&quot;, arg...)
    output, err := cmd.Output()
    if err != nil {
        fmt.Printf(&quot;Error: %s\n&quot;, err)
        return
    }
    //test in ArchLinux
    fmt.Printf(&quot;The output is: %s\n&quot;, output)   //The output is: Hello World!
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="c-cmd-run-error"><a class="header" href="#c-cmd-run-error">(c *Cmd) Run() error</a></h2>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回error 返回错误信息对象</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是执行*Cmd中的命令，并且会等待命令执行完成，如果命令执行不成功，则返回错误信息</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;bytes&quot;
    &quot;fmt&quot;
    &quot;os/exec&quot;
)

func main() {
    arg := []string{&quot;Hello&quot;, &quot;World!&quot;}
    cmd := exec.Command(&quot;echo&quot;, arg...)
    var output bytes.Buffer
    cmd.Stdout = &amp;output
    err := cmd.Run()
    if err != nil {
        fmt.Printf(&quot;Error: %s\n&quot;, err)
        return
    }
    //test in ArchLinux
    fmt.Printf(&quot;The output is: %s\n&quot;, output.Bytes())   //The output is: Hello World!
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="c-cmd-start-error"><a class="header" href="#c-cmd-start-error">(c *Cmd) Start() error</a></h2>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回error 返回错误信息对象</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是执行*Cmd中的命令，只是让命令开始执行，并不会等待命令执行完。</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os/exec&quot;
)

func main() {
    cmd := exec.Command(&quot;sleep&quot;, &quot;5&quot;)
    err := cmd.Start()
    if err != nil {
        fmt.Printf(&quot;Error: %s\n&quot;, err)
        return
    }
    fmt.Printf(&quot;Waiting for command to finish...\n&quot;)
    err = cmd.Wait()
    fmt.Printf(&quot;Command finished with error: %v\n&quot;, err)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-c-cmd-stderrpipe-ioreadcloser-error"><a class="header" href="#func-c-cmd-stderrpipe-ioreadcloser-error">func (c *Cmd) StderrPipe() (io.ReadCloser, error)</a></h2>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回io.ReadCloser 连接到错误标准输出的管道</li>
<li>返回error 返回错误信息对象</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是用于连接到命令启动时错误标准输出的管道，命令结束时，管道会自动关闭</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os/exec&quot;
)

func main() {
    arg := []string{&quot;Hello&quot;, &quot;World!&quot;}
    cmd := exec.Command(&quot;mv&quot;, arg...)
    stderr, err := cmd.StderrPipe()
    if err != nil {
        fmt.Printf(&quot;Error: %s\n&quot;, err)
        return
    }
    if err = cmd.Start(); err != nil {
        fmt.Printf(&quot;Error: %s\n&quot;, err)
    }
    output, err := ioutil.ReadAll(stderr)
    if err != nil {
        fmt.Printf(&quot;Error: %s\n&quot;, err)
        return
    }
    if err = cmd.Wait(); err != nil {
        fmt.Printf(&quot;Error: %s\n&quot;, err)  //Error: exit status 1
    }
    //test in ArchLinux
    //当前目录中必须没有名为Hello的文件或文件夹
    fmt.Printf(&quot;The mv command error is: %s\n&quot;, output)   //The mv command error is: mv: 无法获取&quot;Hello&quot; 的文件状态(stat): 没有那个文件或目录
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-c-cmd-stdinpipe-iowritecloser-error"><a class="header" href="#func-c-cmd-stdinpipe-iowritecloser-error">func (c *Cmd) StdinPipe() (io.WriteCloser, error)</a></h2>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回io.WriteCloser 连接到标准输入的管道</li>
<li>返回error 返回错误信息对象</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是用于连接到命令启动时标准输入的管道</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;bytes&quot;
    &quot;fmt&quot;
    &quot;os/exec&quot;
)

func main() {
    var output bytes.Buffer
    cmd := exec.Command(&quot;cat&quot;)
    cmd.Stdout = &amp;output
    stdin, err := cmd.StdinPipe()
    if err != nil {
        fmt.Printf(&quot;Error: %s\n&quot;, err)
        return
    }
    if err = cmd.Start(); err != nil {
        fmt.Printf(&quot;Error: %s\n&quot;, err)
    }
    stdin.Write([]byte(&quot;Hello World!&quot;))
    stdin.Close()
    if err = cmd.Wait(); err != nil {
        fmt.Printf(&quot;Error: %s\n&quot;, err)
    }
    //test in ArchLinux
    fmt.Printf(&quot;The output is: %s\n&quot;, output.Bytes())   //The output is: Hello World!
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-c-cmd-stdoutpipe-ioreadcloser-error"><a class="header" href="#func-c-cmd-stdoutpipe-ioreadcloser-error">func (c *Cmd) StdoutPipe() (io.ReadCloser, error)</a></h2>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回io.ReadCloser 连接到标准输出的管道</li>
<li>返回error 返回错误信息对象</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是用于连接到命令启动时标准输出的管道，命令结束时，管道会自动关闭</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;io/ioutil&quot;
    &quot;os/exec&quot;
)

func main() {
    cmd := exec.Command(&quot;echo&quot;, &quot;Hello World!&quot;)
    stdout, err := cmd.StdoutPipe()
    if err != nil {
        fmt.Printf(&quot;Error: %s\n&quot;, err)
        return
    }
    if err = cmd.Start(); err != nil {
        fmt.Printf(&quot;Error: %s\n&quot;, err)
    }
    output, _ := ioutil.ReadAll(stdout)
    if err = cmd.Wait(); err != nil {
        fmt.Printf(&quot;Error: %s\n&quot;, err)
    }
    //test in ArchLinux
    fmt.Printf(&quot;The output is: %s\n&quot;, output)   //The output is: Hello World!
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="c-cmd-wait-error"><a class="header" href="#c-cmd-wait-error">(c *Cmd) Wait() error</a></h2>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回error 返回错误信息对象</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是等待*Cmd中的已开始执行的命令执行完成</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os/exec&quot;
)

func main() {
    cmd := exec.Command(&quot;sleep&quot;, &quot;5&quot;)
    err := cmd.Start()
    if err != nil {
        fmt.Printf(&quot;Error: %s\n&quot;, err)
        return
    }
    fmt.Printf(&quot;Waiting for command to finish...\n&quot;)
    err = cmd.Wait()
    fmt.Printf(&quot;Command finished with error: %v\n&quot;, err)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名-55"><a class="header" href="#包名-55">包名</a></h1>
<p>函数列表</p>
<ul>
<li>xxx1</li>
<li>xxx2</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-notifyc-chan--ossignal-sig-ossignal"><a class="header" href="#func-notifyc-chan--ossignal-sig-ossignal">func Notify(c chan&lt;- os.Signal, sig ...os.Signal)</a></h2>
<p>参数列表</p>
<ul>
<li>c 信号 channel</li>
<li>sig 需要捕获的信号</li>
</ul>
<p>实例：
package main</p>
<pre><code>import(
    &quot;fmt&quot;
    &quot;os&quot;
    &quot;os/signal&quot;
)

func main() {
    schan := make(chan os.Signal)
    go signal.Notify(schan, os.Interrupt, os.Kill)
    fmt.Printf(&quot;Signal captured: %d&quot;, &lt;-schan)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="osuser包函数列表"><a class="header" href="#osuser包函数列表">os/user包函数列表</a></h1>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/user/Current.html">func Current() (*User, error)</a> </li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/user/Lookup.html">func Lookup(username string) (*User, error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/os/user/LookupId.html">func LookupId(uid string) (*User, error)</a> </li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-current-user-error"><a class="header" href="#func-current-user-error">func Current() (*User, error)</a></h2>
<p>参数列表</p>
<p>返回值：</p>
<ul>
<li>返回User 当前用户对象</li>
<li>返回error 返回错误信息对象</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是用来获取系统当前的用户对象</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os/user&quot;
)

func main() {
    user, err := user.Current()
    if err != nil {
        fmt.Println(err)
    }
    //我所在环境为Mac os X 10.8.2
    fmt.Println(&quot;用户id:&quot;, user.Uid)      //用户id: 501
    fmt.Println(&quot;用户所在组id:&quot;, user.Gid)   //    用户所在组id: 20
    fmt.Println(&quot;用户名:&quot;, user.Username)  //用户名: lsdev
    fmt.Println(&quot;用户全名:&quot;, user.Name)     //用户全名: 吴 佳煌
    fmt.Println(&quot;用户家目录:&quot;, user.HomeDir) //用户家目录: /Users/lsdev

}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-lookupusername-string-user-error"><a class="header" href="#func-lookupusername-string-user-error">func Lookup(username string) (*User, error)</a></h2>
<p>参数列表</p>
<p>-username 要查询的用户的用户名</p>
<p>返回值：</p>
<ul>
<li>返回User 查询到用户对象</li>
<li>返回error 返回错误信息对象</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是用来根据username来查询系统用户对象</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os/user&quot;
)

func main() {
    findedUser, err := user.Lookup(&quot;lsdev&quot;)
    if err != nil {
        fmt.Println(err)
    }
    //我所在环境为Mac os X 10.8.2
    fmt.Println(&quot;用户id:&quot;, findedUser.Uid)      //用户id: 501
    fmt.Println(&quot;用户所在组id:&quot;, findedUser.Gid)   //    用户所在组id: 20
    fmt.Println(&quot;用户名:&quot;, findedUser.Username)  //用户名: lsdev
    fmt.Println(&quot;用户全名:&quot;, findedUser.Name)     //用户全名: 吴 佳煌
    fmt.Println(&quot;用户家目录:&quot;, findedUser.HomeDir) //用户家目录: /Users/lsdev

}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-lookupiduid-string-user-error"><a class="header" href="#func-lookupiduid-string-user-error">func LookupId(uid string) (*User, error)</a></h2>
<p>参数列表</p>
<p>-uid 要查询的用户的uid</p>
<p>返回值：</p>
<ul>
<li>返回User 查询到用户对象</li>
<li>返回error 返回错误信息对象</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是用来根据uid来查询系统用户对象</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os/user&quot;
)

func main() {
    findedUser, err := user.LookupId(&quot;501&quot;)
    if err != nil {
        fmt.Println(err)
    }
    //我所在环境为Mac os X 10.8.2
    fmt.Println(&quot;用户id:&quot;, findedUser.Uid)      //用户id: 501
    fmt.Println(&quot;用户所在组id:&quot;, findedUser.Gid)   //    用户所在组id: 20
    fmt.Println(&quot;用户名:&quot;, findedUser.Username)  //用户名: lsdev
    fmt.Println(&quot;用户全名:&quot;, findedUser.Name)     //用户全名: 吴 佳煌
    fmt.Println(&quot;用户家目录:&quot;, findedUser.HomeDir) //用户家目录: /Users/lsdev

}   
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-chdirdir-string-error"><a class="header" href="#func-chdirdir-string-error">func Chdir(dir string) error</a></h2>
<p>参数列表</p>
<ul>
<li>dir 目录路径</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回error 返回错误信息对象</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是改变当前工作目录</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    pwd, err := os.Getwd()
    if err != nil {
        fmt.Printf(&quot;Error: %s\n&quot;, err)
        return
    }
    fmt.Printf(&quot;The current directory is: %s\n&quot;, pwd)

    if err = os.Chdir(&quot;go-study&quot;); err != nil {
        fmt.Printf(&quot;Error: %s\n&quot;, err)
        return
    }

    pwd, err = os.Getwd()
    if err != nil {
        fmt.Printf(&quot;Error: %s\n&quot;, err)
        return
    }
    fmt.Printf(&quot;Now the current directory is: %s\n&quot;, pwd)
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux
//go-study为当前文件所有目录下的一个子目录
The current directory is: /home/miraclesu/Programs/go
Now the current directory is: /home/miraclesu/Programs/go/go-study
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-chmodname-string-mode-filemode-error"><a class="header" href="#func-chmodname-string-mode-filemode-error">func Chmod(name string, mode FileMode) error</a></h2>
<p>参数列表</p>
<ul>
<li>name 修改的文件名</li>
<li>mode 文件修改的目标模式</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回error 返回错误信息对象</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是修改一个文件的模式，如果文件为一个链接，修改的则是链接的目标文件</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    fi, err := os.Stat(&quot;Hello.go&quot;)
    if err != nil {
        fmt.Printf(&quot;Error: %s\n&quot;, err)
        return
    }
    fmt.Printf(&quot;Hello.go's mode is: %s(%o)\n&quot;, fi.Mode(), fi.Mode()&amp;0777)

    err = os.Chmod(&quot;Hello.go&quot;, 0777)
    if err != nil {
        fmt.Printf(&quot;Error: %s\n&quot;, err)
        return
    }

    fi, err = os.Stat(&quot;Hello.go&quot;)
    if err != nil {
        fmt.Printf(&quot;Error: %s\n&quot;, err)
        return
    }
    fmt.Printf(&quot;Now Hello.go's mode is: %s(%o)\n&quot;, fi.Mode(), fi.Mode()&amp;0777)
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux
Hello.go's mode is: -rw-r--r--(644)
Now Hello.go's mode is: -rwxrwxrwx(777)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-chownname-string-uid-gid-int-error"><a class="header" href="#func-chownname-string-uid-gid-int-error">func Chown(name string, uid, gid int) error</a></h2>
<p>参数列表</p>
<ul>
<li>name 修改的文件名</li>
<li>uid  用户id</li>
<li>gid  用户组id</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回error 返回错误信息对象</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是修改一个文件的所属用户和用户组，如果文件为一个链接，修改的则是链接的目标文件</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
    &quot;syscall&quot;
)

func main() {
    fi, err := os.Stat(&quot;Hello.go&quot;)
    if err != nil {
        fmt.Printf(&quot;Error: %s\n&quot;, err)
        return
    }
    fmt.Printf(&quot;Hello.go: uid=%d, gid=%d\n&quot;, fi.Sys().(*syscall.Stat_t).Uid, fi.Sys().(*syscall.Stat_t).Gid)

    err = os.Chown(&quot;Hello.go&quot;, 99, 99)  //nobody, nobody
    if err != nil {
        fmt.Printf(&quot;Error: %s\n&quot;, err)
        return
    }

    fi, err = os.Stat(&quot;Hello.go&quot;)
    if err != nil {
        fmt.Printf(&quot;Error: %s\n&quot;, err)
        return
    }
    fmt.Printf(&quot;Now Hello.go: uid=%d, gid=%d\n&quot;, fi.Sys().(*syscall.Stat_t).Uid, fi.Sys().(*syscall.Stat_t).Gid)
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux by root user
Hello.go: uid=0, gid=0
Now Hello.go: uid=99, gid=99
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-chtimesname-string-atime-timetime-mtime-timetime-error"><a class="header" href="#func-chtimesname-string-atime-timetime-mtime-timetime-error">func Chtimes(name string, atime time.Time, mtime time.Time) error</a></h2>
<p>参数列表</p>
<ul>
<li>name  修改的文件名</li>
<li>atime 访问时间</li>
<li>mtime 修改时间</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回error 返回错误信息对象</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是修改一个文件的访问时间和修改时间</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
    &quot;syscall&quot;
    &quot;time&quot;
)

func main() {
    fi, err := os.Stat(&quot;Hello.go&quot;)
    if err != nil {
        fmt.Printf(&quot;Error: %s\n&quot;, err)
        return
    }
    fmt.Printf(&quot;Hello.go: atime=%+v, mtime=%v\n&quot;, fi.Sys().(*syscall.Stat_t).Atim, fi.ModTime())

    err = os.Chtimes(&quot;Hello.go&quot;, time.Now(), time.Now())
    if err != nil {
        fmt.Printf(&quot;Error: %s\n&quot;, err)
        return
    }

    fi, err = os.Stat(&quot;Hello.go&quot;)
    if err != nil {
        fmt.Printf(&quot;Error: %s\n&quot;, err)
        return
    }
    fmt.Printf(&quot;Now Hello.go: atime=%+v, mtime=%v\n&quot;, fi.Sys().(*syscall.Stat_t).Atim, fi.ModTime())
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux
Hello.go: atime={Sec:1363663572 Nsec:515975000}, mtime=2013-03-19 11:26:12.515978 +0800 CST
Now Hello.go: atime={Sec:1363663747 Nsec:130183000}, mtime=2013-03-19 11:29:07.130184 +0800 CST
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-clearenv"><a class="header" href="#func-clearenv">func Clearenv()</a></h2>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>无</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是清空当前环境变量</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    fmt.Printf(&quot;The path is: %+v\n&quot;, os.Environ())
    os.Clearenv()
    fmt.Printf(&quot;Now the path is: %+v\n&quot;, os.Environ())
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux
//只放了一部分结果
The path is: [USER=miraclesu LG_ALL=zh_CN.UTF-8]
Now the path is: []
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-environ-string"><a class="header" href="#func-environ-string">func Environ() []string</a></h2>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>[]string 环境变量</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是获取当前环境变量</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    fmt.Printf(&quot;The path is: %+v\n&quot;, os.Environ())
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux
//只放了一部分结果
The path is: [USER=miraclesu LG_ALL=zh_CN.UTF-8]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-exitcode-int"><a class="header" href="#func-exitcode-int">func Exit(code int)</a></h2>
<p>参数列表</p>
<ul>
<li>code 程序退出状态码</li>
</ul>
<p>返回值：</p>
<ul>
<li>无</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是立即终止当前程序，defer的函数不会运行</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    fmt.Printf(&quot;running...\n&quot;)
    defer fmt.Printf(&quot;defer function\n&quot;)
    os.Exit(1)
    fmt.Printf(&quot;finished\n&quot;)
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux
running...
exit status 1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-expands-string-mapping-funcstring-string-string"><a class="header" href="#func-expands-string-mapping-funcstring-string-string">func Expand(s string, mapping func(string) string) string</a></h2>
<p>参数列表</p>
<ul>
<li>s 需要替换的字符串</li>
<li>mapping 替换规则函数</li>
</ul>
<p>返回值：</p>
<ul>
<li>string 替换后的字符串</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是把一个字符串里带$var或${var}这样的字符串按自定义的规则替换成自己想要的字符串，如果没有对应的，则替换成空</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    mapping := func(s string) string {
        m := map[string]string{&quot;hello&quot;:&quot;world&quot;, &quot;go&quot;:&quot;perfect program language&quot;}
        return m[s]
    }
    str := &quot;Golang is$not a $go in the ${hello}!&quot;
    fmt.Printf(&quot;%s\n&quot;, os.Expand(str, mapping))
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux
Golang is a perfect program language in the world!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-expandenvs-string-string"><a class="header" href="#func-expandenvs-string-string">func ExpandEnv(s string) string</a></h2>
<p>参数列表</p>
<ul>
<li>s 需要替换的字符串</li>
</ul>
<p>返回值：</p>
<ul>
<li>string 替换后的字符串</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是把一个字符串里带$var或${var}这样的字符串替换成当前环境变量中的内容，如果没有对应的，则替换成空</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    s := &quot;The language path is: $LANG&quot;
    fmt.Printf(&quot;%s\n&quot;, os.ExpandEnv(s))
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux
The language path is: zh_CN.UTF-8
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-f-file-chdir-error"><a class="header" href="#func-f-file-chdir-error">func (f *File) Chdir() error</a></h2>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回error 返回错误信息对象</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是改变当前工作目录，f必须是一个目录的信息</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    pwd, err := os.Getwd()
    if err != nil {
        fmt.Printf(&quot;Error: %s\n&quot;, err)
        return
    }
    fmt.Printf(&quot;The current directory is: %s\n&quot;, pwd)

    f, _ := os.Open(&quot;World&quot;)
    if err = f.Chdir(); err != nil {
        fmt.Printf(&quot;Error: %s\n&quot;, err)
    }

    pwd, err = os.Getwd()
    if err != nil {
        fmt.Printf(&quot;Error: %s\n&quot;, err)
        return
    }
    fmt.Printf(&quot;Now the current directory is: %s\n&quot;, pwd)
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux
//World为当前文件所有目录下的一个子目录
The current directory is: /home/miraclesu/Programs/go
Now the current directory is: /home/miraclesu/Programs/go/World
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-f-file-chmodmode-filemode-error"><a class="header" href="#func-f-file-chmodmode-filemode-error">func (f *File) Chmod(mode FileMode) error</a></h2>
<p>参数列表</p>
<ul>
<li>mode 文件修改的目标模式</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回error 返回错误信息对象</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是修改文件的模式</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    fi, err := os.Stat(&quot;Hello.go&quot;)
    if err != nil {
        fmt.Printf(&quot;Error: %s\n&quot;, err)
        return
    }
    fmt.Printf(&quot;Hello.go's mode is: %s(%o)\n&quot;, fi.Mode(), fi.Mode()&amp;0777)

    f, _ := os.Open(&quot;Hello.go&quot;)
    err = f.Chmod(0777)
    if err != nil {
        fmt.Printf(&quot;Error: %s\n&quot;, err)
    }
    f.Close()

    fi, err = os.Stat(&quot;Hello.go&quot;)
    if err != nil {
        fmt.Printf(&quot;Error: %s\n&quot;, err)
        return
    }
    fmt.Printf(&quot;Now Hello.go's mode is: %s(%o)\n&quot;, fi.Mode(), fi.Mode()&amp;0777)
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux
Hello.go's mode is: -rw-r--r--(644)
Now Hello.go's mode is: -rwxrwxrwx(777)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-f-file-chownuid-gid-int-error"><a class="header" href="#func-f-file-chownuid-gid-int-error">func (f *File) Chown(uid, gid int) error</a></h2>
<p>参数列表</p>
<ul>
<li>uid  用户id</li>
<li>gid  用户组id</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回error 返回错误信息对象</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是修改文件的所属用户和用户组</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
    &quot;syscall&quot;
)

func main() {
    fi, err := os.Stat(&quot;Hello.go&quot;)
    if err != nil {
        fmt.Printf(&quot;Error: %s\n&quot;, err)
        return
    }
    fmt.Printf(&quot;Hello.go: uid=%d, gid=%d\n&quot;, fi.Sys().(*syscall.Stat_t).Uid, fi.Sys().(*syscall.Stat_t).Gid)

    f, _ := os.Open(&quot;Hello.go&quot;)
    err = f.Chown(99, 99)  //nobody, nobody
    if err != nil {
        fmt.Printf(&quot;Error: %s\n&quot;, err)
    }
    f.Close()

    fi, err = os.Stat(&quot;Hello.go&quot;)
    if err != nil {
        fmt.Printf(&quot;Error: %s\n&quot;, err)
        return
    }
    fmt.Printf(&quot;Now Hello.go: uid=%d, gid=%d\n&quot;, fi.Sys().(*syscall.Stat_t).Uid, fi.Sys().(*syscall.Stat_t).Gid)
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux by root user
Hello.go: uid=0, gid=0
Now Hello.go: uid=99, gid=99
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-f-file-close-error"><a class="header" href="#func-f-file-close-error">func (f *File) Close() error</a></h2>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回error 返回错误信息对象</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是关闭文件指针</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    fi, err := os.Open(&quot;Hello.go&quot;)
    if err != nil {
        fmt.Printf(&quot;Error: %s\n&quot;, err)
    }
    if err = fi.Close(); err != nil {
        fmt.Printf(&quot;Error: %s\n&quot;, err)
    }
    fmt.Printf(&quot;fi has been closed!&quot;)
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux
fi has been closed!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-createname-string-file-file-err-error"><a class="header" href="#func-createname-string-file-file-err-error">func Create(name string) (file *File, err error)</a></h2>
<p>参数列表</p>
<ul>
<li>name 文件名</li>
</ul>
<p>返回值：</p>
<ul>
<li>file 文件指针</li>
<li>error 返回错误信息对象</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是创建一个文件，此方法会覆盖已存在的文件</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    fi, err := os.Create(&quot;Hello.go&quot;)
    if err != nil {
        fmt.Printf(&quot;Error: %v\n&quot;, err)
        return
    }
    defer fi.Close()
    fmt.Printf(&quot;The %s has been created!\n&quot;, fi.Name())
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux
The Hello.go has been created!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-f-file-fd-uintptr"><a class="header" href="#func-f-file-fd-uintptr">func (f *File) Fd() uintptr</a></h2>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回unitptr 返回文件句柄</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是获取文件句柄</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    fi, err := os.Open(&quot;Hello.go&quot;)
    if err != nil {
        fmt.Printf(&quot;Error: %s\n&quot;, err)
        return
    }
    defer fi.Close()
    fmt.Printf(&quot;%v\n&quot;, fi.Fd())
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux
3
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-f-file-name-string"><a class="header" href="#func-f-file-name-string">func (f *File) Name() string</a></h2>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回string 返回文件名</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是获取文件名</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    fi, err := os.Open(&quot;Hello.go&quot;)
    if err != nil {
        fmt.Printf(&quot;Error: %s\n&quot;, err)
        return
    }
    defer fi.Close()
    fmt.Printf(&quot;The file name is: %v\n&quot;, fi.Name())
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux
The file name is: Hello.go
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-newfilefd-uintptr-name-string-file"><a class="header" href="#func-newfilefd-uintptr-name-string-file">func NewFile(fd uintptr, name string) *File</a></h2>
<p>参数列表</p>
<ul>
<li>fd 文件句柄</li>
<li>name 文件名</li>
</ul>
<p>返回值：</p>
<ul>
<li>file 文件指针</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是新建一个文件（但不保存），返回文件指针</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    fi, err := os.Open(&quot;Hello.go&quot;)
    if err != nil {
        fmt.Printf(&quot;Error: %v\n&quot;, err)
        return
    }
    defer fi.Close()
    file := os.NewFile(fi.Fd(), &quot;World.go&quot;)
    defer file.Close()
    fmt.Printf(&quot;The %s has been new!\n&quot;, file.Name())
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux
The World.go has been new!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-openname-string-file-file-err-error"><a class="header" href="#func-openname-string-file-file-err-error">func Open(name string) (file *File, err error)</a></h2>
<p>参数列表</p>
<ul>
<li>name 文件名</li>
</ul>
<p>返回值：</p>
<ul>
<li>file 文件指针</li>
<li>error 返回错误信息对象</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是以只读的模式打开一个文件</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    fi, err := os.Open(&quot;Hello.go&quot;)
    if err != nil {
        fmt.Printf(&quot;Error: %v\n&quot;, err)
        return
    }
    defer fi.Close()
    data := make([]byte, 100)
    fi.Read(data)
    fmt.Printf(&quot;The %s's content is: %s \n&quot;, fi.Name(), data)
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux
The Hello.go's content is: Hello World!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-openfilename-string-flag-int-perm-filemode-file-file-err-error"><a class="header" href="#func-openfilename-string-flag-int-perm-filemode-file-file-err-error">func OpenFile(name string, flag int, perm FileMode) (file *File, err error)</a></h2>
<p>参数列表</p>
<ul>
<li>name 文件名</li>
<li>flag 文件打开方式</li>
<li>perm 文件权限</li>
</ul>
<p>返回值：</p>
<ul>
<li>file 文件指针</li>
<li>error 返回错误信息对象</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是打开一个文件，方式和权限通过参数控制</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    fi, err := os.OpenFile(&quot;Hello.go&quot;, os.O_RDWR | os.O_APPEND | os.O_CREATE, 0777)
    if err != nil {
        fmt.Printf(&quot;Error: %v\n&quot;, err)
        return
    }
    defer fi.Close()
    data := make([]byte, 100)
    fi.Read(data)
    fmt.Printf(&quot;The %s's content is: %s \n&quot;, fi.Name(), data)
    fi.WriteString(&quot;come on!!\n&quot;)
    fi.Seek(0, 0)
    fi.Read(data)
    fmt.Printf(&quot;Now the %s's content is: %s \n&quot;, fi.Name(), data)
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux
The Hello.go's content is: Hello World!

Now the Hello.go's content is: Hello World!
come on!!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-pipe-r-file-w-file-err-error"><a class="header" href="#func-pipe-r-file-w-file-err-error">func Pipe() (r *File, w *File, err error)</a></h2>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>r 只读文件指针</li>
<li>w 只写文件指针</li>
<li>error 返回错误信息对象</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是获取一对文件指针，一个只读（如：stdout)，一个只写（如：stdin）</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    r, w, err := os.Pipe()
    fmt.Printf(&quot;Read *Files: %+v, Write *Files: %+v, err: %v\n&quot;, r, w, err)
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux
Read *Files: &amp;{file:0xf840027ae0}, Write *Files: &amp;{file:0xf840027ab0}, err: &lt;nil&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-f-file-readb-byte-n-int-err-error"><a class="header" href="#func-f-file-readb-byte-n-int-err-error">func (f *File) Read(b []byte) (n int, err error)</a></h2>
<p>参数列表</p>
<ul>
<li>[]byte 存储读取内容的byte slice</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回int 返回读取文件内容的字节长度</li>
<li>返回error 返回error错误对象</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是读取文件内容到[]byte</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    b := make([]byte, 10)
    fi, err := os.Open(&quot;Hello.go&quot;)
    if err != nil {
        fmt.Printf(&quot;Error: %s\n&quot;, err)
        return
    }
    defer fi.Close()
    n, _ := fi.Read(b)
    fmt.Printf(&quot;%d\n&quot;, n)
    fmt.Printf(&quot;%s\n&quot;, b[:n])
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux
//有两个字符是'\n'
6
aa
bb
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-f-file-readatb-byte-off-int64-n-int-err-error"><a class="header" href="#func-f-file-readatb-byte-off-int64-n-int-err-error">func (f *File) ReadAt(b []byte, off int64) (n int, err error)</a></h2>
<p>参数列表</p>
<ul>
<li>[]byte 存储读取内容的byte slice</li>
<li>int64 开始读取内容的下标，单位是byte</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回int 返回读取文件内容的字节长度</li>
<li>返回error 返回error错误对象</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是从文件的某处开始读取内容到[]byte</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    b := make([]byte, 10)
    fi, err := os.Open(&quot;Hello.go&quot;)
    if err != nil {
        fmt.Printf(&quot;Error: %s\n&quot;, err)
        return
    }
    defer fi.Close()
    n, _ := fi.ReadAt(b, 3)
    fmt.Printf(&quot;%d\n&quot;, n)
    fmt.Printf(&quot;%s\n&quot;, b[:n])
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux
//Hello.go文件内容&quot;aa\nbb\n&quot;
3
bb
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-f-file-readdirn-int-fi-fileinfo-err-error"><a class="header" href="#func-f-file-readdirn-int-fi-fileinfo-err-error">func (f *File) Readdir(n int) (fi []FileInfo, err error)</a></h2>
<p>参数列表</p>
<ul>
<li>int 需要取出的文件信息数</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回[]FileInfo 返回文件目录中文件的信息slice</li>
<li>返回error 返回error错误对象</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是读取目录下的文件信息，如果参数n&gt;0，则读取min(n, 文件夹下的文件数目)个文件信息，如果n&lt;=0，则读取文件夹下所有的文件信息</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    fi, err := os.Open(&quot;Hello&quot;)
    if err != nil {
        fmt.Printf(&quot;Error: %s\n&quot;, err)
        return
    }
    defer fi.Close()
    ff, _ := fi.Readdir(10)
    for i, f := range ff {
        fmt.Printf(&quot;fileinfo %d: %+v\n&quot;, i, f)
    }
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux
//文件夹下有Hello.go World.go两个文件
fileinfo 0: &amp;{name:World.go size:0 mode:420 modTime:{sec:63500830281 nsec:418121275 loc:0x4de468} sys:0xf84004e000}
fileinfo 1: &amp;{name:Hello.go size:0 mode:420 modTime:{sec:63500830275 nsec:878120955 loc:0x4de468} sys:0xf84004e090}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-f-file-seekoffset-int64-whence-int-ret-int64-err-error"><a class="header" href="#func-f-file-seekoffset-int64-whence-int-ret-int64-err-error">func (f *File) Seek(offset int64, whence int) (ret int64, err error)</a></h2>
<p>参数列表</p>
<ul>
<li>offset 文件指针的位置</li>
<li>whence 相对位置标识</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回ret 返回文件指针的位置</li>
<li>返回err 返回error错误对象</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是把文件指针移动到文件的指定位置，whence为0时代表相对文件开始的位置，1代表相对当前位置，2代表相对文件结尾的位置</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    b := make([]byte, 10)
    fi, err := os.Open(&quot;Hello.go&quot;)
    if err != nil {
        fmt.Printf(&quot;Error: %s\n&quot;, err)
        return
    }
    defer fi.Close()
    fi.Seek(3, 0)
    n, _ := fi.Read(b)
    fmt.Printf(&quot;%d\n&quot;, n)
    fmt.Printf(&quot;%s\n&quot;, b[:n])
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux
//Hello.go内容为&quot;aa\nbb\n&quot;
3
bb
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-f-file-stat-fi-fileinfo-err-error"><a class="header" href="#func-f-file-stat-fi-fileinfo-err-error">func (f *File) Stat() (fi FileInfo, err error)</a></h2>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回fi 返回文件的信息</li>
<li>返回err 返回error错误对象</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是获取文件信息</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    fi, err := os.Open(&quot;Hello.go&quot;)
    if err != nil {
        fmt.Printf(&quot;Error: %s\n&quot;, err)
        return
    }
    defer fi.Close()
    f, _ := fi.Stat()
    fmt.Printf(&quot;file info: %+v\n&quot;, f)
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux
file info: &amp;{name:Hello.go size:6 mode:420 modTime:{sec:63500829488 nsec:441408659 loc:0x4dd468} sys:0xf84004c000}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-f-file-sync-err-error"><a class="header" href="#func-f-file-sync-err-error">func (f *File) Sync() (err error)</a></h2>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回err 返回error错误对象</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是把f内存里的内容写到磁盘上，即使是断电或系统崩溃，也能做到数据不丢失（注：一般不用调用这个方法）</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    fi, err := os.OpenFile(&quot;Hello.go&quot;, os.O_RDWR | os.O_APPEND, 0420)
    if err != nil {
        fmt.Printf(&quot;Error: %s\n&quot;, err)
        return
    }
    defer fi.Close()
    fi.Write([]byte(&quot;cc\n&quot;))
    fi.Sync()
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-f-file-truncatesize-int64-error"><a class="header" href="#func-f-file-truncatesize-int64-error">func (f *File) Truncate(size int64) error</a></h2>
<p>参数列表</p>
<ul>
<li>size 截断后的大小</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回error 返回error错误对象</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是把文件截断到指定大小</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    fi, err := os.OpenFile(&quot;Hello.go&quot;, os.O_RDWR, 0420)
    if err != nil {
        fmt.Printf(&quot;Error: %s\n&quot;, err)
        return
    }
    defer fi.Close()
    f, _ := fi.Stat()
    fmt.Printf(&quot;file size: %+v\n&quot;, f.Size())
    fi.Truncate(6)
    f, _ = fi.Stat()
    fmt.Printf(&quot;now file size: %+v\n&quot;, f.Size())
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux
file size: 9
now file size: 6
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-f-file-writeb-byte-n-int-err-error"><a class="header" href="#func-f-file-writeb-byte-n-int-err-error">func (f *File) Write(b []byte) (n int, err error)</a></h2>
<p>参数列表</p>
<ul>
<li>b 要写入的内容</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回int 返回写入的字节数</li>
<li>返回err 返回error错误对象</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是往一个文件里写入内容</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    b := make([]byte, 10)
    fi, err := os.OpenFile(&quot;Hello.go&quot;, os.O_RDWR | os.O_APPEND, 0420)
    if err != nil {
        fmt.Printf(&quot;Error: %s\n&quot;, err)
        return
    }
    defer fi.Close()
    n, _ := fi.Read(b)
    fmt.Printf(&quot;len: %d, file content: %s\n&quot;, n, b[:n])
    fi.Write([]byte(&quot;cc\n&quot;))
    fi.Seek(0, 0)
    n, _ = fi.Read(b)
    fmt.Printf(&quot;now len: %d, file content: %s\n&quot;, n, b[:n])
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux
len: 6, file content: aa
bb

now len: 9, file content: aa
bb
cc
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-f-file-writeatb-byte-off-int64-n-int-err-error"><a class="header" href="#func-f-file-writeatb-byte-off-int64-n-int-err-error">func (f *File) WriteAt(b []byte, off int64) (n int, err error)</a></h2>
<p>参数列表</p>
<ul>
<li>b 要写入的内容</li>
<li>off 要写入的位置</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回int 返回写入的字节数</li>
<li>返回err 返回error错误对象</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是往一个文件的指定位置开始写入内容</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    b := make([]byte, 10)
    fi, err := os.OpenFile(&quot;Hello.go&quot;, os.O_RDWR, 0420)
    if err != nil {
        fmt.Printf(&quot;Error: %s\n&quot;, err)
        return
    }
    defer fi.Close()
    n, _ := fi.Read(b)
    fmt.Printf(&quot;len: %d, file content: %s\n&quot;, n, b[:n])
    fi.Seek(0, 0)
    fi.WriteAt([]byte(&quot;cc\n&quot;), 3)
    fi.Seek(0, 0)
    n, _ = fi.Read(b)
    fmt.Printf(&quot;now len: %d, file content: %s\n&quot;, n, b[:n])
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux
len: 6, file content: aa
bb

now len: 6, file content: aa
cc
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-f-file-writestrings-string-ret-int-err-error"><a class="header" href="#func-f-file-writestrings-string-ret-int-err-error">func (f *File) WriteString(s string) (ret int, err error)</a></h2>
<p>参数列表</p>
<ul>
<li>s 要写入的内容</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回ret 返回写入的字节数</li>
<li>返回err 返回error错误对象</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是往一个文件里写入内容</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    b := make([]byte, 20)
    fi, err := os.OpenFile(&quot;Hello.go&quot;, os.O_RDWR | os.O_APPEND, 0420)
    if err != nil {
        fmt.Printf(&quot;Error: %s\n&quot;, err)
        return
    }
    defer fi.Close()
    n, _ := fi.Read(b)
    fmt.Printf(&quot;len: %d, file content: %s\n&quot;, n, b[:n])
    fi.WriteString(&quot;Hello World!\n&quot;)
    fi.Seek(0, 0)
    n, _ = fi.Read(b)
    fmt.Printf(&quot;now len: %d, file content: %s\n&quot;, n, b[:n])
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux
len: 6, file content: aa
cc

now len: 9, file content: aa
bb
Hello World!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-lstatname-string-fi-fileinfo-err-error"><a class="header" href="#func-lstatname-string-fi-fileinfo-err-error">func Lstat(name string) (fi FileInfo, err error)</a></h2>
<p>参数列表</p>
<ul>
<li>name 文件名</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回fi 文件信息结构体</li>
<li>返回err 返回error错误对象</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是获取一个文件的信息，如果这个文件是一个链接，返回的是链接本身的信息</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    fi, err := os.Lstat(&quot;Hello.go&quot;)
    if err != nil {
        fmt.Printf(&quot;Error: %s\n&quot;, err)
        return
    }
    fmt.Printf(&quot;file info: %+v\n&quot;, fi)
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux
file info: &amp;{name:Hello.go size:6 mode:420 modTime:{sec:63500837998 nsec:888568469 loc:0x4dd468} sys:0xf84004c000}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-statname-string-fi-fileinfo-err-error"><a class="header" href="#func-statname-string-fi-fileinfo-err-error">func Stat(name string) (fi FileInfo, err error)</a></h2>
<p>参数列表</p>
<ul>
<li>name 文件名</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回fi 文件信息结构体</li>
<li>返回err 返回error错误对象</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是获取一个文件的信息，如果这个文件是一个链接，返回的是目标文件的信息</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    fi, err := os.Stat(&quot;Hello.go&quot;)
    if err != nil {
        fmt.Printf(&quot;Error: %s\n&quot;, err)
        return
    }
    fmt.Printf(&quot;file info: %+v\n&quot;, fi)
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux
file info: &amp;{name:Hello.go size:6 mode:420 modTime:{sec:63500837998 nsec:888568469 loc:0x4dd468} sys:0xf84004c000}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-m-filemode-isdir-bool"><a class="header" href="#func-m-filemode-isdir-bool">func (m FileMode) IsDir() bool</a></h2>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回bool</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是判断一个文件模式是否为文件夹</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    f, err := os.Open(&quot;Hello.go&quot;)
    if err != nil {
        fmt.Printf(&quot;Error: %s\n&quot;, err)
        return
    }
    defer f.Close()
    fi, _ := f.Stat()
    fmt.Printf(&quot;%s is dir?: %t\n&quot;, fi.Name(), fi.Mode().IsDir())
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux
Hello.go is dir?: false
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-m-filemode-perm-filemode"><a class="header" href="#func-m-filemode-perm-filemode">func (m FileMode) Perm() FileMode</a></h2>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回FileMode 返回Unix权限</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是获取一个文件模式的Unix权限</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    f, err := os.Open(&quot;Hello.go&quot;)
    if err != nil {
        fmt.Printf(&quot;Error: %s\n&quot;, err)
        return
    }
    defer f.Close()
    fi, _ := f.Stat()
    fmt.Printf(&quot;%s mode: %v\n&quot;, fi.Name(), fi.Mode().Perm()&amp;0777)
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux
Hello.go mode: -rw-r--r--
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-m-filemode-string-string"><a class="header" href="#func-m-filemode-string-string">func (m FileMode) String() string</a></h2>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回string 返回文件模式的字符串形式</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是获取文件模式的字符串形式</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    f, err := os.Open(&quot;Hello.go&quot;)
    if err != nil {
        fmt.Printf(&quot;Error: %s\n&quot;, err)
        return
    }
    defer f.Close()
    fi, _ := f.Stat()
    fmt.Printf(&quot;%s mode: %v\n&quot;, fi.Name(), fi.Mode().String())
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux
Hello.go mode: -rw-r--r--
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-getegid-int"><a class="header" href="#func-getegid-int">func Getegid() int</a></h2>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>int 调用者的有效用户组id</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是返回调用者的有效用户组id</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    fmt.Printf(&quot;%d\n&quot;, os.Getegid())
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux
100
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-getenvkey-string-string"><a class="header" href="#func-getenvkey-string-string">func Getenv(key string) string</a></h2>
<p>参数列表</p>
<ul>
<li>key 环境变量的key</li>
</ul>
<p>返回值：</p>
<ul>
<li>string 返回环境变量的key对应的值</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是根据key来获取相当环境变量的值</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    fmt.Printf(&quot;%s\n&quot;, os.Getenv(&quot;LANG&quot;))
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux
zh_CN.UTF-8
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-geteuid-int"><a class="header" href="#func-geteuid-int">func Geteuid() int</a></h2>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>int 调用者的有效用户id</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是返回调用者的有效用户id</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    fmt.Printf(&quot;%d\n&quot;, os.Geteuid())
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux
1000
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-getgid-int"><a class="header" href="#func-getgid-int">func Getgid() int</a></h2>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>int 调用者的用户组id</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是返回调用者的用户组id</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    fmt.Printf(&quot;%d\n&quot;, os.Getgid())
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux
100
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-getgroups-int-error"><a class="header" href="#func-getgroups-int-error">func Getgroups() ([]int, error)</a></h2>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>[]int 调用者所属用户组的所有id</li>
<li>error 返回错误信息对象</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是返回调用者所属用户组的所有id</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    ids, err := os.Getgroups()
    if err != nil {
        fmt.Printf(&quot;Error: %v\n&quot;, err)
        return
    }
    fmt.Printf(&quot;%v\n&quot;, ids)
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux
[7 10 50 91 92 1000]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-getpagesize-int"><a class="header" href="#func-getpagesize-int">func Getpagesize() int</a></h2>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>int 返回系统内在的大小，单位为MB</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是返回系统内存的大小</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    fmt.Printf(&quot;%d\n&quot;, os.Getpagesize())
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux
4096
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-getpid-int"><a class="header" href="#func-getpid-int">func Getpid() int</a></h2>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>int 返回调用者进程id</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是返回调用者进程id</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    fmt.Printf(&quot;%d\n&quot;, os.Getpid())
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux
//每次执行的结果可能都不一样
11396
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-getppid-int"><a class="header" href="#func-getppid-int">func Getppid() int</a></h2>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>int 返回调用者的父进程id</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是返回调用者的父进程id</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    fmt.Printf(&quot;%d\n&quot;, os.Getppid())
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux
//每次执行的结果可能都不一样
11355
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-getuid-int"><a class="header" href="#func-getuid-int">func Getuid() int</a></h2>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>int 调用者的用户id</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是返回调用者的用户id</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    fmt.Printf(&quot;%d\n&quot;, os.Getuid())
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux
1000
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-getwd-pwd-string-err-error"><a class="header" href="#func-getwd-pwd-string-err-error">func Getwd() (pwd string, err error)</a></h2>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>pwd 当前目录</li>
<li>err 返回错误信息对象</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是返回当前目录</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    pwd, err := os.Getwd()
    if err != nil {
        fmt.Printf(&quot;Error: %v\n&quot;, err)
        return
    }
    fmt.Printf(&quot;The current directory is: %s\n&quot;, pwd)
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux
The current directory is: /home/miraclesu/Programs/go
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-hostname-name-string-err-error"><a class="header" href="#func-hostname-name-string-err-error">func Hostname() (name string, err error)</a></h2>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>name hostname</li>
<li>err 返回错误信息对象</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是返回机器的hostname</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    name, err := os.Hostname()
    if err != nil {
        fmt.Printf(&quot;Error: %v\n&quot;, err)
        return
    }
    fmt.Printf(&quot;The hostname is: %s\n&quot;, name)
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux
The hostname is: arch
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-isexisterr-error-bool"><a class="header" href="#func-isexisterr-error-bool">func IsExist(err error) bool</a></h2>
<p>参数列表</p>
<ul>
<li>err 错误信息对象</li>
</ul>
<p>返回值：</p>
<ul>
<li>bool 是否为文件或目录已存在的错误</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是判断一个错误是否为文件或目录已存在的错误</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;errors&quot;
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    fmt.Printf(&quot;%t\n&quot;, os.IsExist(os.ErrExist))
    fmt.Printf(&quot;%t\n&quot;, os.IsExist(errors.New(&quot;Custom Error&quot;)))
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux
true
false
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-isnotexisterr-error-bool"><a class="header" href="#func-isnotexisterr-error-bool">func IsNotExist(err error) bool</a></h2>
<p>参数列表</p>
<ul>
<li>err 错误信息对象</li>
</ul>
<p>返回值：</p>
<ul>
<li>bool 是否为文件或目录不存在的错误</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是判断一个错误是否为文件或目录不存在的错误</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;errors&quot;
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    fmt.Printf(&quot;%t\n&quot;, os.IsNotExist(os.ErrNotExist))
    fmt.Printf(&quot;%t\n&quot;, os.IsNotExist(errors.New(&quot;Custom Error&quot;)))
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux
true
false
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-ispathseparatorc-uint8-bool"><a class="header" href="#func-ispathseparatorc-uint8-bool">func IsPathSeparator(c uint8) bool</a></h2>
<p>参数列表</p>
<ul>
<li>c 判断字符</li>
</ul>
<p>返回值：</p>
<ul>
<li>bool 是否为目录路径分割符</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是判断一个字符是否为目录路径分割符</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    fmt.Printf(&quot;%t\n&quot;, os.IsPathSeparator('/'))
    fmt.Printf(&quot;%t\n&quot;, os.IsPathSeparator('.'))
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux
true
false
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-ispermissionerr-error-bool"><a class="header" href="#func-ispermissionerr-error-bool">func IsPermission(err error) bool</a></h2>
<p>参数列表</p>
<ul>
<li>err 错误信息对象</li>
</ul>
<p>返回值：</p>
<ul>
<li>bool 是否为无权限错误</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是判断一个错误是否为无权限错误</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;errors&quot;
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    fmt.Printf(&quot;%t\n&quot;, os.IsPermission(os.ErrPermission))
    fmt.Printf(&quot;%t\n&quot;, os.IsPermission(errors.New(&quot;Custom Error&quot;)))
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux
true
false
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-lchownname-string-uid-gid-int-error"><a class="header" href="#func-lchownname-string-uid-gid-int-error">func Lchown(name string, uid, gid int) error</a></h2>
<p>参数列表</p>
<ul>
<li>name 修改的文件名</li>
<li>uid  用户id</li>
<li>gid  用户组id</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回error 返回错误信息对象</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是修改一个文件的所属用户和用户组，如果文件为一个链接，修改的则是链接文件本身</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
    &quot;syscall&quot;
)

func main() {
    fi, err := os.Stat(&quot;Hello.go&quot;)
    if err != nil {
        fmt.Printf(&quot;Error: %s\n&quot;, err)
        return
    }
    fmt.Printf(&quot;Hello.go: uid=%d, gid=%d\n&quot;, fi.Sys().(*syscall.Stat_t).Uid, fi.Sys().(*syscall.Stat_t).Gid)

    err = os.Lchown(&quot;Hello.go&quot;, 99, 99)  //nobody, nobody
    if err != nil {
        fmt.Printf(&quot;Error: %s\n&quot;, err)
        return
    }

    fi, err = os.Stat(&quot;Hello.go&quot;)
    if err != nil {
        fmt.Printf(&quot;Error: %s\n&quot;, err)
        return
    }
    fmt.Printf(&quot;Now Hello.go: uid=%d, gid=%d\n&quot;, fi.Sys().(*syscall.Stat_t).Uid, fi.Sys().(*syscall.Stat_t).Gid)
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux by root user
Hello.go: uid=0, gid=0
Now Hello.go: uid=99, gid=99
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-linkoldname-newname-string-error"><a class="header" href="#func-linkoldname-newname-string-error">func Link(oldname, newname string) error</a></h2>
<p>参数列表</p>
<ul>
<li>oldname 源文件名</li>
<li>newname 目标文件名</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回error 返回错误信息对象</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是给一个文件建立一个硬链接</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    if err := os.Link(&quot;Hello.go&quot;, &quot;Lhello.go&quot;); err != nil {
        fmt.Printf(&quot;Error: %v\n&quot;, err)
    }
    fmt.Printf(&quot;Lhello.go has created!\n&quot;)
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux
Lhello.go has been created!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-e-linkerror-error-string"><a class="header" href="#func-e-linkerror-error-string">func (e *LinkError) Error() string</a></h2>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回string 返回LinkError的字符串形式</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是获取LinkError的字符串形式</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;errors&quot;
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    le := &amp;os.LinkError{
        Op:  &quot;ln&quot;,
        Old: &quot;old&quot;,
        New: &quot;new&quot;,
        Err: errors.New(&quot;ln Error!&quot;),
    }
    fmt.Printf(&quot;%s\n&quot;, le.Error())
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux
ln old new: ln Error!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-mkdirname-string-perm-filemode-error"><a class="header" href="#func-mkdirname-string-perm-filemode-error">func Mkdir(name string, perm FileMode) error</a></h2>
<p>参数列表</p>
<ul>
<li>name 目录名</li>
<li>perm 权限</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回error 返回错误信息对象</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是新建一个指定权限的目录</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    if err := os.Mkdir(&quot;hello_go&quot;, 0777); err != nil {
        fmt.Printf(&quot;Error: %v\n&quot;, err)
    }
    fmt.Printf(&quot;hello_go has been created!\n&quot;)
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux
hello_go has been created!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-mkdirallpath-string-perm-filemode-error"><a class="header" href="#func-mkdirallpath-string-perm-filemode-error">func MkdirAll(path string, perm FileMode) error</a></h2>
<p>参数列表</p>
<ul>
<li>path 目录路径</li>
<li>perm 权限</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回error 返回错误信息对象</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是按文件目录路径新建目录，如果路径中的上一级目录不存在，会自动创建</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    if err := os.MkdirAll(&quot;hello_go/world&quot;, 0777); err != nil {
        fmt.Printf(&quot;Error: %v\n&quot;, err)
    }
    fmt.Printf(&quot;hello_go/world has been created!\n&quot;)
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux
hello_go/world has been created!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-newsyscallerrorsyscall-string-err-error-error"><a class="header" href="#func-newsyscallerrorsyscall-string-err-error-error">func NewSyscallError(syscall string, err error) error</a></h2>
<p>参数列表</p>
<ul>
<li>syscall 系统调用名</li>
<li>err 错误信息对象</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回error 返回SyscallError对象</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是新建SyscallError对象</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;errors&quot;
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    fmt.Printf(&quot;%s\n&quot;, os.NewSyscallError(&quot;custom&quot;, errors.New(&quot;something wrong&quot;)))
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux
custom: something wrong
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-e-patherror-error-string"><a class="header" href="#func-e-patherror-error-string">func (e *PathError) Error() string</a></h2>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回string 返回PathError的字符串形式</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是获取PathError的字符串形式</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;errors&quot;
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    pe := &amp;os.PathError{
        Op:   &quot;cp&quot;,
        Path: &quot;/oh/my/god&quot;,
        Err:  errors.New(&quot;path does'n exists!&quot;),
    }
    fmt.Printf(&quot;%s\n&quot;, pe.Error())
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux
cp /oh/my/god: path does'n exists!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-findprocesspid-int-p-process-err-error"><a class="header" href="#func-findprocesspid-int-p-process-err-error">func FindProcess(pid int) (p *Process, err error)</a></h2>
<p>参数列表</p>
<ul>
<li>pid 进程pid</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回p 返回进程结构体指针</li>
<li>返回err 返回error错误对象信息</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是通过进程pid查找一个进程对象</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    p, err := os.FindProcess(12)
    if err != nil {
        fmt.Printf(&quot;Error: %v\n&quot;, err)
        return
    }
    fmt.Printf(&quot;Process info: %+v\n&quot;, p)
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux
Process info: &amp;{Pid:12 handle:0 isdone:0}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-p-process-kill-error"><a class="header" href="#func-p-process-kill-error">func (p *Process) Kill() error</a></h2>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回error 返回error错误对象信息</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是杀死一个进程</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    attr := &amp;os.ProcAttr{
        Files: []*os.File{os.Stdin, os.Stdout},
        Env: os.Environ(),
    }
    p, err := os.StartProcess(&quot;/bin/pwd&quot;, []string{&quot;/bin/pwd&quot;}, attr)
    if err != nil {
        fmt.Printf(&quot;Error: %v\n&quot;, err)
        return
    }
    fmt.Printf(&quot;Process info: %+v\n&quot;, p)
    if err := p.Kill(); err != nil {
        fmt.Printf(&quot;Error: %v\n&quot;, err)
    }
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux
Process info: &amp;{Pid:3538 handle:0 isdone:0}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-p-process-release-error"><a class="header" href="#func-p-process-release-error">func (p *Process) Release() error</a></h2>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回error 返回error错误对象信息</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是释放一个进程相关的资源</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    attr := &amp;os.ProcAttr{
        Files: []*os.File{os.Stdin, os.Stdout},
        Env: os.Environ(),
    }
    p, err := os.StartProcess(&quot;/bin/pwd&quot;, []string{&quot;/bin/pwd&quot;}, attr)
    if err != nil {
        fmt.Printf(&quot;Error: %v\n&quot;, err)
        return
    }
    fmt.Printf(&quot;Process info: %+v\n&quot;, p)
    if err := p.Release(); err != nil {
        fmt.Printf(&quot;Error: %v\n&quot;, err)
    }
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux
Process info: &amp;{Pid:3997 handle:0 isdone:0}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-p-process-signalsig-signal-error"><a class="header" href="#func-p-process-signalsig-signal-error">func (p *Process) Signal(sig Signal) error</a></h2>
<p>参数列表</p>
<ul>
<li>sig 系统信号</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回error 返回error错误对象信息</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是给一个进程发送一个信号</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    attr := &amp;os.ProcAttr{
        Files: []*os.File{os.Stdin, os.Stdout},
        Env: os.Environ(),
    }
    p, err := os.StartProcess(&quot;/bin/pwd&quot;, []string{&quot;/bin/pwd&quot;}, attr)
    if err != nil {
        fmt.Printf(&quot;Error: %v\n&quot;, err)
        return
    }
    fmt.Printf(&quot;Process info: %+v\n&quot;, p)
    if err := p.Signal(os.Kill); err != nil {
        fmt.Printf(&quot;Error: %v\n&quot;, err)
    }
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux
Process info: &amp;{Pid:4497 handle:0 isdone:0}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-startprocessname-string-argv-string-attr-procattr-process-error"><a class="header" href="#func-startprocessname-string-argv-string-attr-procattr-process-error">func StartProcess(name string, argv []string, attr *ProcAttr) (*Process, error)</a></h2>
<p>参数列表</p>
<ul>
<li>name 执行命令</li>
<li>argv 命令参数</li>
<li>attr 命令相关环境参数</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回*Process 返回进程结构体指针</li>
<li>返回error 返回error错误对象信息</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是启动一个进程</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    attr := &amp;os.ProcAttr{
        Files: []*os.File{os.Stdin, os.Stdout},
        Env: os.Environ(),
    }
    p, err := os.StartProcess(&quot;/bin/pwd&quot;, []string{&quot;/bin/pwd&quot;}, attr)
    if err != nil {
        fmt.Printf(&quot;Error: %v\n&quot;, err)
        return
    }
    fmt.Printf(&quot;Process info: %+v\n&quot;, p)
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux
Process info: &amp;{Pid:2596 handle:0 isdone:0}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-p-process-wait-processstate-error"><a class="header" href="#func-p-process-wait-processstate-error">func (p *Process) Wait() (*ProcessState, error)</a></h2>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回*ProcessState 返回进程状态结构体指针</li>
<li>返回error 返回error错误对象信息</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是等待一个进程执行完成</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    attr := &amp;os.ProcAttr{
        Files: []*os.File{os.Stdin, os.Stdout},
        Env: os.Environ(),
    }
    p, err := os.StartProcess(&quot;/bin/pwd&quot;, []string{&quot;/bin/pwd&quot;}, attr)
    if err != nil {
        fmt.Printf(&quot;Error: %v\n&quot;, err)
        return
    }
    ps, _ := p.Wait()
    fmt.Printf(&quot;Process stat: %+v\n&quot;, ps)
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux
/home/mirclesu/Programs/go
Process stat: exit status 0
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-p-processstate-exited-bool"><a class="header" href="#func-p-processstate-exited-bool">func (p *ProcessState) Exited() bool</a></h2>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回bool 进程是否已退出</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是判断一个进程是否已退出</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    attr := &amp;os.ProcAttr{
        Files: []*os.File{os.Stdin, os.Stdout},
        Env: os.Environ(),
    }
    p, err := os.StartProcess(&quot;/bin/pwd&quot;, []string{&quot;/bin/pwd&quot;}, attr)
    if err != nil {
        fmt.Printf(&quot;Error: %v\n&quot;, err)
        return
    }
    ps, _ := p.Wait()
    fmt.Printf(&quot;Process has been exited?: %t\n&quot;, ps.Exited())
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux
/home/mirclesu/Programs/go
Process has been exited?: true
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-p-processstate-pid-int"><a class="header" href="#func-p-processstate-pid-int">func (p *ProcessState) Pid() int</a></h2>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回int 已退出进程的pid</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是获取已退出进程的pid</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    attr := &amp;os.ProcAttr{
        Files: []*os.File{os.Stdin, os.Stdout},
        Env: os.Environ(),
    }
    p, err := os.StartProcess(&quot;/bin/pwd&quot;, []string{&quot;/bin/pwd&quot;}, attr)
    if err != nil {
        fmt.Printf(&quot;Error: %v\n&quot;, err)
        return
    }
    ps, _ := p.Wait()
    fmt.Printf(&quot;Process pid is: %d\n&quot;, ps.Pid())
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux
/home/mirclesu/Programs/go
Process pid is: 7767
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-p-processstate-string-string"><a class="header" href="#func-p-processstate-string-string">func (p *ProcessState) String() string</a></h2>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回string 进程状态的字符串</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是获取进程状态的字符串</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    attr := &amp;os.ProcAttr{
        Files: []*os.File{os.Stdin, os.Stdout},
        Env: os.Environ(),
    }
    p, err := os.StartProcess(&quot;/bin/pwd&quot;, []string{&quot;/bin/pwd&quot;}, attr)
    if err != nil {
        fmt.Printf(&quot;Error: %v\n&quot;, err)
        return
    }
    ps, _ := p.Wait()
    fmt.Printf(&quot;Process stat: %s\n&quot;, ps.String())
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux
/home/mirclesu/Programs/go
Process stat: exit status 0
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-p-processstate-success-bool"><a class="header" href="#func-p-processstate-success-bool">func (p *ProcessState) Success() bool</a></h2>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回bool 进程是否已成功退出</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是判断一个进程是否已成功退出</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    attr := &amp;os.ProcAttr{
        Files: []*os.File{os.Stdin, os.Stdout},
        Env: os.Environ(),
    }
    p, err := os.StartProcess(&quot;/bin/pwd&quot;, []string{&quot;/bin/pwd&quot;}, attr)
    if err != nil {
        fmt.Printf(&quot;Error: %v\n&quot;, err)
        return
    }
    ps, _ := p.Wait()
    fmt.Printf(&quot;Process has been exited successfully?: %t\n&quot;, ps.Success())
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux
/home/mirclesu/Programs/go
Process has been exited successfully?: true
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-p-processstate-sys-interface"><a class="header" href="#func-p-processstate-sys-interface">func (p *ProcessState) Sys() interface{}</a></h2>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回interface{}</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是获取进程的退出信息</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    attr := &amp;os.ProcAttr{
        Files: []*os.File{os.Stdin, os.Stdout},
        Env: os.Environ(),
    }
    p, err := os.StartProcess(&quot;/bin/pwd&quot;, []string{&quot;/bin/pwd&quot;}, attr)
    if err != nil {
        fmt.Printf(&quot;Error: %v\n&quot;, err)
        return
    }
    ps, _ := p.Wait()
    fmt.Printf(&quot;Process exit status: %+v\n&quot;, ps.Sys())
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux
/home/mirclesu/Programs/go
Process exit status: 0
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-p-processstate-systemtime-timeduration"><a class="header" href="#func-p-processstate-systemtime-timeduration">func (p *ProcessState) SystemTime() time.Duration</a></h2>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回time.Duration 进程系统cpu使用时间</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是获取的进程的系统cpu使用时间</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    attr := &amp;os.ProcAttr{
        Files: []*os.File{os.Stdin, os.Stdout},
        Env: os.Environ(),
    }
    p, err := os.StartProcess(&quot;/bin/pwd&quot;, []string{&quot;/bin/pwd&quot;}, attr)
    if err != nil {
        fmt.Printf(&quot;Error: %v\n&quot;, err)
        return
    }
    ps, _ := p.Wait()
    fmt.Printf(&quot;Process system cpu time: %+v\n&quot;, ps.SystemTime())
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux
/home/mirclesu/Programs/go
Process system cpu time : 0
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-p-processstate-sysusage-interface"><a class="header" href="#func-p-processstate-sysusage-interface">func (p *ProcessState) SysUsage() interface{}</a></h2>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回interface{}</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是获取进程资源使用情况</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    attr := &amp;os.ProcAttr{
        Files: []*os.File{os.Stdin, os.Stdout},
        Env: os.Environ(),
    }
    p, err := os.StartProcess(&quot;/bin/pwd&quot;, []string{&quot;/bin/pwd&quot;}, attr)
    if err != nil {
        fmt.Printf(&quot;Error: %v\n&quot;, err)
        return
    }
    ps, _ := p.Wait()
    fmt.Printf(&quot;Process resource usage: %+v\n&quot;, ps.SysUsage())
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux
/home/mirclesu/Programs/go
Process resource usage: &amp;{Utime:{Sec:0 Usec:0} Stime:{Sec:0 Usec:0} Maxrss:640 Ixrss:0 Idrss:0 Isrss:0 Minflt:179 Majflt:0 Nswap:0 Inblock:0 Oublock:0 Msgsnd:0 Msgrcv:0 Nsignals:0 Nvcsw:1 Nivcsw:3}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-p-processstate-usertime-timeduration"><a class="header" href="#func-p-processstate-usertime-timeduration">func (p *ProcessState) UserTime() time.Duration</a></h2>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回time.Duration 进程用户cpu使用时间</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是获取的进程的用户cpu使用时间</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    attr := &amp;os.ProcAttr{
        Files: []*os.File{os.Stdin, os.Stdout},
        Env: os.Environ(),
    }
    p, err := os.StartProcess(&quot;/bin/pwd&quot;, []string{&quot;/bin/pwd&quot;}, attr)
    if err != nil {
        fmt.Printf(&quot;Error: %v\n&quot;, err)
        return
    }
    ps, _ := p.Wait()
    fmt.Printf(&quot;Process user cpu time: %+v\n&quot;, ps.UserTime())
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux
/home/mirclesu/Programs/go
Process user cpu time : 0
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-readlinkname-string-string-error"><a class="header" href="#func-readlinkname-string-string-error">func Readlink(name string) (string, error)</a></h2>
<p>参数列表</p>
<ul>
<li>name 链接名</li>
</ul>
<p>返回值：</p>
<ul>
<li>string 目标文件</li>
<li>error 返回错误信息对象</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是返回一个链接的目标文件</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    link, err := os.Readlink(&quot;src&quot;)
    if err != nil {
        fmt.Printf(&quot;Error: %s\n&quot;, err)
        return
    }
    fmt.Printf(&quot;%s\n&quot;, link)
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux
// src -&gt; /home/miraclesu/go/own/src
/home/miraclesu/go/own/src
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-removename-string-error"><a class="header" href="#func-removename-string-error">func Remove(name string) error</a></h2>
<p>参数列表</p>
<ul>
<li>name 文件或目录名</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回error 返回错误信息对象</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是删除一个文件或目录</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    err := os.Remove(&quot;Hello.go&quot;)
    if err != nil {
        fmt.Printf(&quot;Error: %s\n&quot;, err)
        return
    }
    fmt.Printf(&quot;Hello.go has been removed!\n&quot;)
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux
Hello.go has been removed!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-removeallname-string-error"><a class="header" href="#func-removeallname-string-error">func RemoveAll(name string) error</a></h2>
<p>参数列表</p>
<ul>
<li>name 文件或目录名</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回error 返回错误信息对象</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是删除一个文件或目录（包括子目录）</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    err := os.RemoveAll(&quot;hello_go/world&quot;)
    if err != nil {
        fmt.Printf(&quot;Error: %s\n&quot;, err)
        return
    }
    fmt.Printf(&quot;hello_go/world has been removed!\n&quot;)
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux
hello_go/world has been removed!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-renameoldname-newname-string-error"><a class="header" href="#func-renameoldname-newname-string-error">func Rename(oldname, newname string) error</a></h2>
<p>参数列表</p>
<ul>
<li>oldname 原文件名</li>
<li>newname 新文件名</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回error 返回错误信息对象</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是给一个文件重命名</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    err := os.Rename(&quot;Hello.go&quot;, &quot;World.go&quot;)
    if err != nil {
        fmt.Printf(&quot;Error: %s\n&quot;, err)
        return
    }
    fmt.Printf(&quot;Hello.go has been renamed to World.go!\n&quot;)
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux
Hello.go has been renamed to World.go!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-samefilefi1-fi2-fileinfo-bool"><a class="header" href="#func-samefilefi1-fi2-fileinfo-bool">func SameFile(fi1, fi2 FileInfo) bool</a></h2>
<p>参数列表</p>
<ul>
<li>fi1 文件信息</li>
<li>fi2 文件信息</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回bool 两个信息是否相同</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是判断两个文件信息是否相同</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    fi1, err := os.Stat(&quot;Hello.go&quot;)
    if err != nil {
        fmt.Printf(&quot;Error: %v\n&quot;, err)
        return
    }
    fi2, err := os.Stat(&quot;World.go&quot;)
    if err != nil {
        fmt.Printf(&quot;Error: %v\n&quot;, err)
        return
    }
    fmt.Printf(&quot;%t\n&quot;, os.SameFile(fi1, fi2))
    fmt.Printf(&quot;%t\n&quot;, os.SameFile(fi1, fi1))
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux
false
true
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-setenvkey-value-string-error"><a class="header" href="#func-setenvkey-value-string-error">func Setenv(key, value string) error</a></h2>
<p>参数列表</p>
<ul>
<li>key 环境变量名</li>
<li>value 环境变量名的值</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回error 返回错误信息对象</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是设置一个环境变量</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    fmt.Printf(&quot;Path of go is: %s\n&quot;, os.Getenv(&quot;go&quot;))
    if err := os.Setenv(&quot;go&quot;, &quot;/path/to/go&quot;); err != nil {
        fmt.Printf(&quot;Error: %v&quot;, err)
    }
    fmt.Printf(&quot;Now Path of go is: %s\n&quot;, os.Getenv(&quot;go&quot;))
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux
Path of go is:
Now Path of go is: /path/to/go
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-symlinkoldname-newname-string-error"><a class="header" href="#func-symlinkoldname-newname-string-error">func Symlink(oldname, newname string) error</a></h2>
<p>参数列表</p>
<ul>
<li>oldname 文件名</li>
<li>newname 新链接名</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回error 返回错误信息对象</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是给一个文件创建一个软链接</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    if err := os.Symlink(&quot;Hello.go&quot;, &quot;Lhello.go&quot;); err != nil {
        fmt.Printf(&quot;Error: %v&quot;, err)
        return
    }
    fmt.Printf(&quot;The Hello.go's  symbolic link Lhello.go has been created!\n&quot;)
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux
The Hello.go's  symbolic link Lhello.go has been created!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-e-syscallerror-error-string"><a class="header" href="#func-e-syscallerror-error-string">func (e *SyscallError) Error() string</a></h2>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回string 返回SyscallError的字符串形式</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是获取SyscallError的字符串形式</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;errors&quot;
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    se := &amp;os.SyscallError{
        Syscall: &quot;/xx&quot;,
        Err:     errors.New(&quot;Syscall Error!&quot;),
    }
    fmt.Printf(&quot;%s\n&quot;, se.Error())
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux
/xx: Syscall Error!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-tempdir-string"><a class="header" href="#func-tempdir-string">func TempDir() string</a></h2>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回string 系统的tmp目录</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是获取系统的tmp目录</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    fmt.Printf(&quot;The temp dir is: %s\n&quot;, os.TempDir())
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux
The temp dir is: /tmp
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-truncatename-string-size-int64-error"><a class="header" href="#func-truncatename-string-size-int64-error">func Truncate(name string, size int64) error</a></h2>
<p>参数列表</p>
<ul>
<li>name 文件名</li>
<li>size 目标长度，单位为byte</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回error 返回错误信息对象</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是截短一个文件到新的长度</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    fi, err := os.Stat(&quot;Hello.go&quot;)
    if err != nil {
        fmt.Printf(&quot;Error: %v\n&quot;, err)
        return
    }
    fmt.Printf(&quot;The Hello.go's size is: %d\n&quot;, fi.Size())

    if err = os.Truncate(&quot;Hello.go&quot;, 10); err != nil {
        fmt.Printf(&quot;Error: %v\n&quot;, err)
    }

    fi, err = os.Stat(&quot;Hello.go&quot;)
    if err != nil {
        fmt.Printf(&quot;Error: %v\n&quot;, err)
    }
    fmt.Printf(&quot;Now the Hello.go's size is: %d\n&quot;, fi.Size())
}
</code></pre>
<p>代码输出：</p>
<pre><code>//test in ArchLinux
The Hello.go's size is: 15
Now the Hello.go's size is: 10
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="path函数列表"><a class="header" href="#path函数列表">path函数列表</a></h1>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/path/Base.html">func Base(path string) string</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/path/Clean.html">func Clean(path string) string</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/path/Dir.html">func Dir(path string) string</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/path/Ext.html">func Ext(path string) string</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/path/IsAbs.html">func IsAbs(path string) bool</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/path/Join.html">func Join(elem ...string) string</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/path/Match.html">func Match(pattern, name string) (matched bool, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/path/Split.html">func Split(path string) (dir, file string)</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pathfilepath"><a class="header" href="#pathfilepath">path/filepath</a></h1>
<p>函数列表</p>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/path/filepath/Abs.html">func Abs(path string) (string, error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/path/filepath/Base.html">func Base(path string) string</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/path/filepath/Clean.html">func Clean(path string) string</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/path/filepath/Dir.html">func Dir(path string) string</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/path/filepath/EvalSymlinks.html">func EvalSymlinks(path string) (string error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/path/filepath/Ext.html">func Ext(path string) string</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/path/filepath/FromSlash.html">func FromSlash(path string) string</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/path/filepath/Glob.html">func Glob(pattern string) (matches []string, err error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/path/filepath/HasPrefix.html">func HasPrefix(p, prefix string)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/path/filepath/IsAbs.html">func IsAbs(path string) bool</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/path/filepath/Join.html">func Join(elem ...string) string</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/path/filepath/Match.html">func Match(pattern, name string) (matched bool, err error</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/path/filepath/Rel.html">func Rel(basepath, targpath string) (string, error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/path/filepath/SplitList.html">func SplitList(path string) []string</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/path/filepath/Split.html">func Split(path string) (dir, file string)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/path/filepath/ToSlash.html">func ToSlash(path string) string</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/path/filepath/VolumeName.html">func VolumeName(path string) (v string)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/path/filepath/Walk.html">func Walk(root string, walkFn WalkFunc) error </a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-abspath-string-string-error"><a class="header" href="#func-abspath-string-string-error">func Abs(path string) (string, error)</a></h2>
<p>参数列表:</p>
<ul>
<li>path: </li>
</ul>
<p>返回值列表:</p>
<ul>
<li>返回所给路径的绝对路径string </li>
<li>error</li>
</ul>
<p>功能说明：</p>
<p>返回所给的路径的的绝对路径。</p>
<p>示例:</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;path/filepath&quot;
)

func main(){
    // 当前路径为/home, 如下返回的path将会是/home/abs_demo.go
    path, _ := filepath.Abs(&quot;abs_demo.go&quot;)
    fmt.Printf(&quot;%v\n&quot;, path)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>具体用法件 path.Base</p>
<div style="break-before: page; page-break-before: always;"></div><p>具体用法见 path.Clean</p>
<div style="break-before: page; page-break-before: always;"></div><p>具体用法件 path.Dir</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-evalsymlinkspath-string-string-error"><a class="header" href="#func-evalsymlinkspath-string-string-error">func EvalSymlinks(path string) (string, error)</a></h2>
<p>参数列表:</p>
<ul>
<li>path: 路径</li>
</ul>
<p>返回值列表:</p>
<ul>
<li>实际的路径</li>
<li>errors </li>
</ul>
<p>功能说明:
返回一个链接文件的实际的路径。例如在/home下创建一个link.log的文件，然后cd xuchdong;
ln -s /home/link.log link， 使用该函数可以找到原始的文件即/home/link.log</p>
<p>示例:</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;path/filepath&quot;
)

func main(){
    // 环境准备：首先在/home目录下创建一个link.log的文件,
    // 然后在当前目录下使用ln -s /home/link.log link_other

    path, _ := filepath.EvalSymlinks(&quot;link_other&quot;)
    fmt.Printf(&quot;%s\n&quot;, path) // /home/link.log
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>具体用法见 path.Ext</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-fromslashpath-string-string"><a class="header" href="#func-fromslashpath-string-string">func FromSlash(path string) string</a></h2>
<p>参数列表:</p>
<ul>
<li>路径字符串</li>
</ul>
<p>返回值:</p>
<ul>
<li>返回替换后的字符串。</li>
</ul>
<p>功能说明:</p>
<p>将所有的&quot;/&quot;使用路径分隔符替换。分隔符见os.PathSeparator, linux默认的分隔符是&quot;/&quot;。</p>
<p>示例：</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-globpattern-string-matches-string-err-error"><a class="header" href="#func-globpattern-string-matches-string-err-error">func Glob(pattern string) (matches []string, err error)</a></h2>
<p>参数列表</p>
<ul>
<li>pattern 匹配的模式</li>
</ul>
<p>返回值：</p>
<ul>
<li>matches 所有匹配的文件 </li>
<li>返回bool error</li>
</ul>
<p>功能说明：</p>
<p>返回目录下所有匹配的文件</p>
<p>示例:</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;path/filepath&quot;
)


func main(){
    //返回目录下所有的go文件
    matches, _ := filepath.Glob(&quot;*.go&quot;)

    //找出/home/ 目录下的所有的log文件 
    matches, _ = filepath.Glob(&quot;/home/*.log&quot;)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>具体使用方法见strings.HasPrefix, 该函数是为了兼容以前的版本，不建议使用</p>
<div style="break-before: page; page-break-before: always;"></div><p>具体的使用方法件 path.IsAbs</p>
<div style="break-before: page; page-break-before: always;"></div><p>具体用法见 path.Join</p>
<div style="break-before: page; page-break-before: always;"></div><p>具体的用法见 path.Match</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-relbasepath-targpath-string-string-error"><a class="header" href="#func-relbasepath-targpath-string-string-error">func Rel(basepath, targpath string) (string, error)</a></h2>
<p>参数列表:</p>
<ul>
<li>basepath: 基准路径</li>
<li>targpath: 目标路径</li>
</ul>
<p>返回值列表:</p>
<ul>
<li>返回以basepath为基准的相对路径。 </li>
<li>error</li>
</ul>
<p>功能说明:
返回以basepath为基准的相对路径。Join(basepath, Rel(basepath, targpath)) 等于targpath。</p>
<p>示例:</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;path/filepath&quot;
)

func main(){
    // 返回 xuchdong/rel_demo.go
    path, _ := filepath.Rel(&quot;/home&quot;, &quot;/home/xuchdong/rel_demo.go&quot;)
    fmt.Printf(&quot;%s\n&quot;, path)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>具体用法见 path.Split</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-splitlistpath-string-string"><a class="header" href="#func-splitlistpath-string-string">func SplitList(path string) []string</a></h2>
<p>参数列表:</p>
<ul>
<li>路径字符串</li>
</ul>
<p>返回值:</p>
<ul>
<li>路径列表。</li>
</ul>
<p>功能说明:</p>
<p>将路径字符串使用路径列表分隔符分开。路径列表分隔符见os.PathListSeparator, linux的
路径列表分隔符是&quot;:&quot;, windows的路径列表分隔符是&quot;;&quot;，主要用于PATH或是GOPATH等环境变
量。</p>
<p>示例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;path/filepath&quot;
)

func main(){
    fmt.Printf(&quot;%v\n&quot;, filepath.SplitList(&quot;a/b;c/d&quot;))  //[a/b; c/d]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-toslashpath-string-string"><a class="header" href="#func-toslashpath-string-string">func ToSlash(path string) string</a></h2>
<p>参数列表:</p>
<ul>
<li>路径字符串</li>
</ul>
<p>返回值:</p>
<ul>
<li>返回替换后的字符串。</li>
</ul>
<p>功能说明:</p>
<p>将所有的路径分隔符使用&quot;/&quot;替换。分隔符见os.PathSeparator, linux默认的分隔符是&quot;/&quot;。</p>
<p>示例：</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-volumenamepath-string-v-string"><a class="header" href="#func-volumenamepath-string-v-string">func VolumeName(path string) (v string)</a></h2>
<p>参数列表</p>
<ul>
<li>path: 路径名</li>
</ul>
<p>返回值列表</p>
<ul>
<li>v: 如果是window平台返回分区名,如给定&quot;c:\foo\bar&quot;, 将返回&quot;c:&quot;, 如果给定&quot;\host\share\foo&quot;, 返回&quot;\host\share&quot;, 其他平台返回&quot;&quot;</li>
</ul>
<p>功能说明</p>
<p>windows平台下返回文件的分区名。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-walkroot-string-walkfunc-walkfunc-error"><a class="header" href="#func-walkroot-string-walkfunc-walkfunc-error">func Walk(root string, walkFunc WalkFunc) error</a></h2>
<p>参数列表:</p>
<ul>
<li>root: 需要遍历的目录</li>
<li>walkFunc: 处理单个文件的函数(linux下目录和文件统称为文件),类型为WalkFunc, WalkFunc的定义为type WalkFunc func(path string, info os.FileInfo, err error) error。path为文件名，info文件的信息，遍历中的错误。 </li>
</ul>
<p>返回值列表:</p>
<ul>
<li>返回error</li>
</ul>
<p>功能说明:
使用walkFunc遍历处理path目录下的所的文件，包括path。</p>
<p>示例:</p>
<pre><code>package main

import (
    &quot;os&quot;
    &quot;fmt&quot;
    &quot;path/filepath&quot;
)

func walkFunc (path string, info os.FileInfo, err error) error {
    fmt.Printf(&quot;%s\n&quot;, path)
    return nil
}

func main(){
    //遍历打印所有的文件名
    filepath.Walk(&quot;/home&quot;, walkFunc)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-basepath-string-string"><a class="header" href="#func-basepath-string-string">func Base(path string) string</a></h2>
<p>参数列表</p>
<ul>
<li>path 表示需要取路径的字符串 </li>
</ul>
<p>返回值：</p>
<ul>
<li>返回string</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是用来返回最后一个元素的路径,如果路径为空返回.如果路径由斜线组成,返回/</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;path&quot;
)

func main() {
	fmt.Println(path.Base(&quot;/a/b&quot;))  // b
	fmt.Println(path.Base(&quot;&quot;))	// .	
	fmt.Println(path.Base(&quot;////&quot;))	// /
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-cleanpath-string-string"><a class="header" href="#func-cleanpath-string-string">func Clean(path string) string</a></h2>
<p>参数列表</p>
<ul>
<li>path 表示需要清理的路径字符串 </li>
</ul>
<p>返回值：</p>
<ul>
<li>返回string</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是返回等价的最短路径
清理规则：</p>
<ul>
<li>
<pre><code>  1.用一个斜线替换多个斜线
</code></pre>
</li>
<li>
<pre><code>  2.清除当前路径.
</code></pre>
</li>
<li>
<pre><code>  3.清除内部的..和他前面的元素，如a/b/.. 得到结果a
</code></pre>
</li>
<li>
<pre><code>  4.以/..开头的，变成/
</code></pre>
</li>
</ul>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;path&quot;
)

func main() {
	fmt.Println(path.Clean(&quot;a/c&quot;))// a/c
	fmt.Println(path.Clean(&quot;a//c&quot;))//以一个/代替// , a/c
	fmt.Println(path.Clean(&quot;a/c/.&quot;))//清除. , a/c
	fmt.Println(path.Clean(&quot;a/c/b/..&quot;))// 清除内部..以及前面的元素b; a/c
	fmt.Println(path.Clean(&quot;111/../a/c&quot;))// 清除内部..以及前面的元素111; a/c
	fmt.Println(path.Clean(&quot;/../a/b/../././/c&quot;))// 清除/..开头,..以及前面的元素b; /a/c
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-dirpath-string-string"><a class="header" href="#func-dirpath-string-string">func Dir(path string) string</a></h2>
<p>参数列表</p>
<ul>
<li>path 表示路径字符串 </li>
</ul>
<p>返回值：</p>
<ul>
<li>返回string</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是返回path中最后一个元素的路径</p>
<ul>
<li>规则：</li>
<li>
<pre><code>  1.通常是路径最后一个元素的路径目录
</code></pre>
</li>
<li>
<pre><code>  2.路径为空返回.
</code></pre>
</li>
</ul>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;path&quot;
)

func main() {
	fmt.Println(path.Dir(&quot;/a/b/c&quot;)) // /a/b
	fmt.Println(path.Dir(&quot;&quot;)) // .
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-extpath-string-string"><a class="header" href="#func-extpath-string-string">func Ext(path string) string</a></h2>
<p>参数列表</p>
<ul>
<li>path 表示路径字符串 </li>
</ul>
<p>返回值：</p>
<ul>
<li>返回string</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是返回path中文件的扩展名
-规则：</p>
<ul>
<li>
<pre><code>  1.最后一个点开始的扩展名
</code></pre>
</li>
<li>
<pre><code>  2.如果没有点，返回空
</code></pre>
</li>
</ul>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;path&quot;
)

func main() {
	fmt.Println(path.Ext(&quot;/a/b/c/bar.css&quot;)) // .css
	fmt.Println(path.Ext(&quot;/a/b/c/bar&quot;))	// &quot;&quot;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-isabspath-string-bool"><a class="header" href="#func-isabspath-string-bool">func IsAbs(path string) bool</a></h2>
<p>参数列表</p>
<ul>
<li>path 表示路径字符串 </li>
</ul>
<p>返回值：</p>
<ul>
<li>返回bool</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是判断路径是不是绝对路径，如果是绝对路径返回true</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;path&quot;
)

func main() {
	fmt.Println(path.IsAbs(&quot;/home/zzz/go.pdf&quot;)) // true
	fmt.Println(path.IsAbs(&quot;home/zzz/go.pdf&quot;))  // false
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-joinelem-string-string"><a class="header" href="#func-joinelem-string-string">func Join(elem ...string) string</a></h2>
<p>参数列表</p>
<ul>
<li>elem 表示要连接的路径</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回string</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是连接路径，返回的结果是已经Clean的，如果是空路径就忽略</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;path&quot;
)

func main() {
	fmt.Println(path.Join(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) // a/b/c
	fmt.Println(path.Join(&quot;a&quot;, &quot;&quot;, &quot;c&quot;))  // a/c
	fmt.Println(path.Join(&quot;a&quot;, &quot;../bb/../c&quot;, &quot;c&quot;)) // c/c
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-matchpattern-name-string-matched-bool-err-error"><a class="header" href="#func-matchpattern-name-string-matched-bool-err-error">func Match(pattern, name string) (matched bool, err error)</a></h2>
<p>参数列表</p>
<ul>
<li>pattern 匹配的模式</li>
<li>name 原始字符串</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回bool error</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是文件名匹配，只有完全匹配则返回true，nil</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;path&quot;
)

func main() {
	fmt.Println(path.Match(&quot;*&quot;,&quot;alll&quot;)) //true nil
	fmt.Println(path.Match(&quot;*&quot;,&quot;a/lll&quot;)) //false nil
	fmt.Println(path.Match(&quot;?&quot;,&quot;alll&quot;)) //false nil
	fmt.Println(path.Match(&quot;?&quot;,&quot;a&quot;)) //true nil
	fmt.Println(path.Match(&quot;a&quot;,&quot;a&quot;)) //true nil
	fmt.Println(path.Match(&quot;\\a&quot;,&quot;a&quot;)) //true nil
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-splitpath-string-dir-file-string"><a class="header" href="#func-splitpath-string-dir-file-string">func Split(path string) (dir, file string)</a></h2>
<p>参数列表</p>
<ul>
<li>path 表示路径字符串</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回string,string</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是分离路径中的文件目录和文件</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;path&quot;
)

func main() {
	fmt.Println(path.Split(&quot;static/myfile.css&quot;)) // static/ myfile.css
	fmt.Println(path.Split(&quot;static&quot;))	// &quot;&quot; static
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reflect包函数列表"><a class="header" href="#reflect包函数列表">reflect包函数列表</a></h1>
<ul>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Copy.html">func Copy(dst, src Value) int</a>    // 复制Slice或Array</p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/DeepEqual.html">func DeepEqual(a1, a2 interface{}) bool</a>    // 平等比较</p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Select.html">func Select(cases []SelectCase) (chosen int, recv Value, recvOK bool)</a>    // 等介于 select</p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/ChanDir.html">type ChanDir int</a>    // 代表信道类型方向</p>
<ul>
<li>
<p>func (d ChanDir) String() string    // 以字符形式打印出来</p>
<pre><code>  const (
  	RecvDir ChanDir             = 1 &lt;&lt; iota // &lt;-chan 信道读取
  	SendDir                                 // chan&lt;- 信道写入
  	BothDir = RecvDir | SendDir             // chan   信道读取与写入
  )
</code></pre>
</li>
</ul>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Kind.html">type Kind uint</a>    // 一种数据类型</p>
<ul>
<li>
<p>func (k Kind) String() string    // 以字符形式打印出来</p>
<pre><code>  const (
  	Invalid Kind = iota	// 无效
  	Bool				// 布尔
  	Int					// 整数（有符号）
  	Int8				// 整数8位（有符号）
  	Int16				// 整数16位（有符号）
  	Int32				// 整数32位（有符号）
  	Int64				// 整数64位（有符号）
  	Uint				// 整数（无符号）
  	Uint8				// 整数8（无符号）
  	Uint16				// 整数16（无符号）
  	Uint32				// 整数（无符号）
  	Uint64				// 整数（无符号）
  	Uintptr				// 整数（指针,无符号）
  	Float32				// 浮点数32位
  	Float64				// 浮点数64位
  	Complex64			// 复数64位
  	Complex128			// 复数128位
  	Array				// 数组
  	Chan				// 信道
  	Func				// 函数
  	Interface			// 接口
  	Map					// 地图
  	Ptr					// 指针
  	Slice				// 切片
  	String				// 字符
  	Struct				// 结构
  	UnsafePointer		// 安全指针
  )
</code></pre>
</li>
</ul>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Method.html">type Method struct</a>    // 方法</p>
<pre><code>  type Method struct {
  	Name	string	// 方法的名称
  	PkgPath string	// 方法的路径（包的路径）
  	Type  	Type	// 方法类型（reflect.Type）
  	Func  	Value	// 方法的值（reflect.Value）
  	Index 	int		// 指数列，“方法集”中的此方法排在第几。
  }
</code></pre>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/SelectCase.html">type SelectCase struct</a>    // 设置select，若设置 Dir 值为SelectDefault，Chan与Send无需设置。Chan表示接收。Chan与Send不可同时设置。</p>
<pre><code>  type SelectCase struct {
  	    Dir  SelectDir		// select方向，SelectDir 的值就是 SelectSend、SelectRecv、SelectDefault
  	    Chan Value			// 通道使用（接收）
  	    Send Value			// 发送的值（发送）
  	}
</code></pre>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/SelectDir.html">type SelectDir int</a>    // select方向值</p>
<pre><code>  	const (
  		_	SelectDir = iota		// 初始化
  	    SelectSend					// 发送方向 Chan &lt;- Send
  	    SelectRecv					// 接受方向 &lt;-Chan:
  	    SelectDefault				// 默认方向
  	)
</code></pre>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/SliceHeader.html">type SliceHeader struct</a>    // 是表示切片运行时。它不能被安全地使用，或者可移植。</p>
<pre><code>  type SliceHeader struct {
  	Data	uintptr	// 指针
  	Len		int		// 长度
  	Cap		int		// 容量
  }
</code></pre>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/StringHeader.html">type StringHeader struct</a>    // 是表示切片运行时。它不能被安全地使用，或者可移植。</p>
<pre><code>  type StringHeader struct {
  	Data	uintptr	// 指针
  	Len		int		// 长度
  }
</code></pre>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/StructField.html">type StructField struct</a>    // 在一个Struct结构内StructField描述了一个单一的字段。</p>
<pre><code>  type StructField struct {
  	Name		string		// 字段名称
  	PkgPath 	string		// 结构路径名
  	Type		Type      	// 字段类型
  	Tag			StructTag 	// 字段标签字符
  	Offset		uintptr   	// 结构内的偏移量，以字节为单位
  	Index		[]int     	// 指数序列，“字段集”中的此字段排在第几。Type.FieldByIndex
  	Anonymous	bool      	// 判断是否是匿名的字段。（没有类型）
  }
</code></pre>
</li>
<li>
<p>type StructTag string    // 字符串标记，在结构字段内。</p>
<ul>
<li>func (tag StructTag) Get(key string) string    // 返回Key键标记字符串的值</li>
</ul>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Type.html">type Type interface</a>    // 类型</p>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/ChanOf.html">func ChanOf(dir ChanDir, t Type) Type</a>    // 创建反射的信道。其实就是类似这样 reflect.TypeOf(chan int)</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/MapOf.html">func MapOf(key, elem Type) Type</a>    // 创建反射的Map。其实就是类似这样 reflect.TypeOf(map[int]string)</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/SliceOf.html">func SliceOf(t Type) Type</a>    // 创建反射的Slice。其实就是类似这样 reflect.TypeOf([]int)</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/PtrTo.html">func PtrTo(t Type) Type</a>    // 返回元素 t 的指针类型</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/TypeOf.html">func TypeOf(i interface{}) Type</a>    // 返回反射interface{}接口的类型</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Type.NumMethod.html">NumMethod() int</a>    // 函数总数量，在struct结构中</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Type.Method.html">Method(int) Method</a>    // 指定返回函数的 Method 类型，在struct结构中</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Type.MethodByName.html">MethodByName(string) (Method, bool)</a>    // 使用“字符串”函数名称返回函数的 Method 类型，在struct结构中</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Type.NumField.html">NumField() int</a>    // 字段总数量，在struct结构中</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Type.Field.html">Field(i int) StructField</a>    // 指定返回字段的 StructField 类型，在struct结构中</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Type.FieldByIndex.html">FieldByIndex(index []int) StructField</a>    // 指定返回“嵌套”字段的 StructField 类型，在struct结构中</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Type.FieldByName.html">FieldByName(name string) (StructField, bool)</a>    // 使用“字符串”字段名称返回字段的 StructField 类型，在struct结构中</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Type.FieldByNameFunc.html">FieldByNameFunc(match func(string) bool) (StructField, bool)</a>    // 传入字段“字符串”名称，并判断，func 返回 true，返回字段的 StructField 类型，在struct结构中</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Type.NumIn.html">NumIn() int</a>    // 函数输入参数总数量</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Type.In.html">In(i int) Type</a>    // 返回函数输入参数的第i个类型 Type</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Type.NumOut.html">NumOut() int</a>    // 函数输出参数总数量</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Type.Out.html">Out(i int) Type</a>    // 返回函数输出参数的第i个类型 Type</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Type.Align.html">Align() int</a>    // 在分配在内存时的此类型的一个值（以字节为单位）的对齐。</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Type.FieldAlign.html">FieldAlign() int</a>    // 返回字段对齐的值（以字节为单位）</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Type.Name.html">Name() string</a>    // 变量名称或字段的名称</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Type.PkgPath.html">PkgPath() string</a>    // 变量的（包）路径名</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Type.Size.html">Size() uintptr</a>    // 值的数据大小（以字节为单位）</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Type.String.html">String() string</a>    // （包）路径名称+类型名称</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Type.Kind.html">Kind() Kind</a>    // 变量的类型</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Type.Implements.html">Implements(u Type) bool</a>    // 判断是否存在与 u 相同的接口</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Type.AssignableTo.html">AssignableTo(u Type) bool</a>    // 判断值是否可分配给 u</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Type.ConvertibleTo.html">ConvertibleTo(u Type) bool</a>    // 判断值是否可以转换为 u 类型</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Type.Bits.html">Bits() int</a>    // 返回类型比特的大小</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Type.ChanDir.html">ChanDir() ChanDir</a>    // 返回信道的方向</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Type.IsVariadic.html">IsVariadic() bool</a>    // 返回函数的类型最后一个输入参数是否是“...”参数。</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Type.Elem.html">Elem() Type</a>    // 指针指向内存地址</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Type.Key.html">Key() Type</a>    // 返回 Map 键Key的类型</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Type.Len.html">Len() int</a>    // 返回 Array 的长度</li>
</ul>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Value.html">type Value struct</a>    // 值</p>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Append.html">func Append(s Value, x ...Value) Value</a>    // 追加Slice</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/AppendSlice.html">func AppendSlice(s, t Value) Value</a>    // 批量追加Slice</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Indirect.html">func Indirect(v Value) Value</a>    // 返回指针源内存地址</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/MakeChan.html">func MakeChan(typ Type, buffer int) Value</a>    // 初始化信道</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/MakeFunc.html">func MakeFunc(typ Type, fn func(args []Value) (results []Value)) Value</a>    // 初始化函数，并可以对函数的参数进得修改操作。</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/MakeMap.html">func MakeMap(typ Type) Value</a>    // 初始化Map</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/MakeSlice.html">func MakeSlice(typ Type, len, cap int) Value</a>    // 初始化Slice</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/New.html">func New(typ Type) Value</a>    // 初始化并返回指针</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/NewAt.html">func NewAt(typ Type, p unsafe.Pointer) Value</a>    // 初始化 p 并返回指针，转向给 typ</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Zero.html">func Zero(typ Type) Value</a>    // 初始化 typ 为零值</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/ValueOf.html">func ValueOf(i interface{}) Value</a>    // 返回反射interface{}接口的值</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Value.Elem.html">func (v Value) Elem() Value</a>    // 指针指向内存地址</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Value.Type.html">func (v Value) Type() Type</a>    // 返回类型 rflect.Type</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Value.Convert.html">func (v Value) Convert(t Type) Value</a>    // 转换v 为 t 同一种类型</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Value.NumField.html">func (v Value) NumField() int</a>    // 字段总数量，在struct结构中</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Value.Field.html">func (v Value) Field(i int) Value</a>    // 指定返回字段的 Value 类型，在struct结构中</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Value.FieldByIndex.html">func (v Value) FieldByIndex(index []int) Value</a>    // 指定返回“嵌套”字段的 Value 类型，在struct结构中</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Value.FieldByName.html">func (v Value) FieldByName(name string) Value</a>    // 使用“字符串”字段名称返回字段的 Value 类型，在struct结构中</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Value.FieldByNameFunc.html">func (v Value) FieldByNameFunc(match func(string) bool) Value</a>    // 传入字段“字符串”名称，并判断，func 返回 true，返回字段的 Value 类型，在struct结构中</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Value.NumMethod.html">func (v Value) NumMethod() int</a>    // 函数总数量，在struct结构中</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Value.Method.html">func (v Value) Method(i int) Value</a>    // 指定返回函数的 Value 类型，在struct结构中</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Value.MethodByName.html">func (v Value) MethodByName(name string) Value</a>    // 使用“字符串”函数名称返回函数的 Value 类型，在struct结构中</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Value.Index.html">func (v Value) Index(i int) Value</a>    // 返回Array或Slice类型的第i个切片，在struct结构中</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Value.Kind.html">func (v Value) Kind() Kind</a>    // 值的类型</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Value.Call.html">func (v Value) Call(in []Value) []Value</a>    // 调用函数，in 切片装入参数，传入函数</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Value.CallSlice.html">func (v Value) CallSlice(in []Value) []Value</a>    // 调用函数，in 切片装入参数，传入函数。用于可变参数函数</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Value.IsValid.html">func (v Value) IsValid() bool</a>    // 判断值是否是零值</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Value.IsNil.html">func (v Value) IsNil() bool</a>    // 判断值是否是 nil，限制支持 Chan，Func，Interface，Map，Ptr，或Slice</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Value.CanInterface.html">func (v Value) CanInterface() bool</a>    // 判断值是否可以做为 interface{} 类型读出</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Value.Interface.html">func (v Value) Interface() (i interface{})</a>    // 以接口类型读出数据</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Value.InterfaceData.html">func (v Value) InterfaceData() [2]uintptr</a>    // 返回一对作为uintptr的接口值</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Value.Slice.html">func (v Value) Slice(beg, end int) Value</a>    // 返回指定长度的切片</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Value.CanAddr.html">func (v Value) CanAddr() bool</a>    // 判断是否是可以寻址</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Value.Addr.html">func (v Value) Addr() Value</a>    // 返回指针值的地址</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Value.UnsafeAddr.html">func (v Value) UnsafeAddr() uintptr</a>    // 返回安全指针指向v的数据</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Value.CanSet.html">func (v Value) CanSet() bool</a>    // 判断是否可以写入值</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Value.Set.html">func (v Value) Set(x Value)</a>    // 写入新值，支持所有类型</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Value.Bool.html">func (v Value) Bool() bool</a>    // 返回 Bool 类型的值</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Value.SetBool.html">func (v Value) SetBool(x bool)</a>    // 写入 Bool 类型的值</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Value.Bytes.html">func (v Value) Bytes() []byte</a>    // 返回 Byte 类型的值</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Value.SetBytes.html">func (v Value) SetBytes(x []byte)</a>    // 写入 Byte 类型的值</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Value.Int.html">func (v Value) Int() int64</a>    // 返回 Int 类型的值</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Value.OverflowInt.html">func (v Value) OverflowInt(x int64) bool</a>    // 判断 Int 类型的值承受范围</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Value.SetInt.html">func (v Value) SetInt(x int64)</a>    // 写入 Int 类型的值</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Value.Uint.html">func (v Value) Uint() uint64</a>    // 返回 Uint 类型的值</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Value.OverflowUint.html">func (v Value) OverflowUint(x uint64) bool</a>    // 判断 Uint 类型的值承受范围</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Value.SetUint.html">func (v Value) SetUint(x uint64)</a>    // 写入 Uint 类型的值</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Value.Float.html">func (v Value) Float() float64</a>    // 返回 Float 类型的值</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Value.OverflowFloat.html">func (v Value) OverflowFloat(x float64) bool</a>    // 判断 Float 类型的值承受范围</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Value.SetFloat.html">func (v Value) SetFloat(x float64)</a>    // 写入 Float 类型的值</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Value.Complex.html">func (v Value) Complex() complex128</a>    // 返回 Complex 类型的值</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Value.OverflowComplex.html">func (v Value) OverflowComplex(x complex128) bool</a>    // 判断 Complex 类型的值承受范围</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Value.SetComplex.html">func (v Value) SetComplex(x complex128)</a>    // 写入 Complex 类型的值</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Value.Pointer.html">func (v Value) Pointer() uintptr</a>    // 返回指针（整数）</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Value.SetPointer.html">func (v Value) SetPointer(x unsafe.Pointer)</a>    // 写入新的指针</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Value.String.html">func (v Value) String() string</a>    // 返回 String 类型的值</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Value.SetString.html">func (v Value) SetString(x string)</a>    // 写入 String 类型的值</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Value.MapKeys.html">func (v Value) MapKeys() []Value</a>    // 返回 Map 中的所有 Key 名称</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Value.MapIndex.html">func (v Value) MapIndex(key Value) Value</a>    // 返回 Map 中 Key 的值</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Value.SetMapIndex.html">func (v Value) SetMapIndex(key, val Value)</a>    // 设置 Mep 的 值</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Value.Len.html">func (v Value) Len() int</a>    // 返回 Slice，Array，Chan，Map，String 长度</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Value.Cap.html">func (v Value) Cap() int</a>    // 返回 Slice，Array，Chan 容量</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Value.SetLen.html">func (v Value) SetLen(n int)</a>    // 改变 Slice 长度</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Value.Recv.html">func (v Value) Recv() (x Value, ok bool)</a>    // 信道接收</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Value.Send.html">func (v Value) Send(x Value)</a>    // 信道发送</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Value.TryRecv.html">func (v Value) TryRecv() (x Value, ok bool)</a>    // 信道尝式接收</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Value.TrySend.html">func (v Value) TrySend(x Value) bool</a>    // 信道尝式发送</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/reflect/Value.Close.html">func (v Value) Close()</a>    // 关闭信道</li>
</ul>
</li>
<li>
<p>type ValueError struct    // 调用方法不支持</p>
<pre><code>  type ValueError struct {
  	Method string		// 方法名称
  	Kind   Kind			// 方法类型
  }
</code></pre>
<ul>
<li>func (e *ValueError) Error() string    // 返回错误内容</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-appends-value-x-value-value"><a class="header" href="#func-appends-value-x-value-value">func Append(s Value, x ...Value) Value</a></h1>
<p>参数列表</p>
<ul>
<li>s Value 原切片数据，类型是 reflect.Value</li>
<li>x ...Value 新切片数据，将此切片追加到s切片中，类型是 reflect.Value</li>
</ul>
<p>返回值：</p>
<ul>
<li>Value 返回新的切片</li>
</ul>
<p>功能说明：</p>
<ul>
<li>追加一个切片x值到切片，并返回所创建的Slice。在Go中，每一个x值必须是分配给切片的元素类型。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
	&quot;fmt&quot;
	&quot;reflect&quot;
)

func main(){
	var a []int
	var value reflect.Value = reflect.ValueOf(&amp;a)
	
	//判断指针是否指向内存地址
	if !value.CanSet() {
		value = value.Elem() //使指针指向内存地址
	}
	
	value = reflect.Append(value, reflect.ValueOf(1))
	value = reflect.Append(value, reflect.ValueOf(2))
	value = reflect.Append(value, reflect.ValueOf(3), reflect.ValueOf(4)) //支持可变参数
	
	fmt.Println(value.Kind(), value.Slice(0, value.Len()).Interface())
	//&gt;&gt;slice [1 2 3 4]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-appendslices-t-value-value"><a class="header" href="#func-appendslices-t-value-value">func AppendSlice(s, t Value) Value</a></h1>
<p>参数列表</p>
<ul>
<li>s Value 原切片数据，类型是 reflect.Value</li>
<li>t Value 新切片数据，将此切片追加到s切片中，类型是 reflect.Value</li>
</ul>
<p>返回值：</p>
<ul>
<li>Value 返回新的切片</li>
</ul>
<p>功能说明：</p>
<ul>
<li>追加一个切片t到另一个切片s，并返回所创建的Slice。在Go中，每一个x值必须是分配给切片的元素类型。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
	&quot;fmt&quot;
	&quot;reflect&quot;
)

func main(){
	var a []int
	var value reflect.Value = reflect.ValueOf(&amp;a)
	
	//判断指针是否指向内存地址
	if !value.CanSet() {
		value = value.Elem() //使指针指向内存地址
	}
	
	value = reflect.AppendSlice(value, reflect.ValueOf([]int{1,2})) //支持切片
	value = reflect.AppendSlice(value, reflect.ValueOf([]int{3,4,5,6,7,8,9})) //支持切片
	
	fmt.Println(value.Kind(), value.Slice(0, value.Len()).Interface())
	//&gt;&gt;slice [1 2 3 4 5 6 7 8 9]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-chandir"><a class="header" href="#type-chandir">type ChanDir</a></h1>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>无</li>
</ul>
<p>功能说明：</p>
<ul>
<li>ChanDir 代表的信道类型方向。
<ul>
<li>reflect.ChanDir 有三个常量成员
- reflect.RecvDir 接收数据
- reflect.SendDir 发送数据
- reflect.BothDir 双向信道</li>
</ul>
</li>
</ul>
<p>代码实例：</p>
<pre><code>	package main
	import (
	    &quot;fmt&quot;
	    &quot;reflect&quot;
	)
	func main() {
		var a chan int
		func(c &lt;-chan int) { // &lt;-chan 代表是信道接收数据
			var chanDir = reflect.TypeOf(c).ChanDir()
			fmt.Println(chanDir == reflect.RecvDir) // reflect.RecvDir 常量代表信道接收数据
			//&gt;&gt;true
		}(a)
		func(c chan&lt;- int) { // chan&lt;- 代表是信道发送数据
			var chanDir = reflect.TypeOf(c).ChanDir()
			fmt.Println(chanDir == reflect.SendDir) // reflect.SendDir 常量代表信道发送数据
			//&gt;&gt;true
		}(a)
		func(c chan int) {	// chan 代表是双向信道
			var chanDir = reflect.TypeOf(c).ChanDir()
			fmt.Println(chanDir == reflect.BothDir) // reflect.BothDir 常量代表双向信道
			//&gt;&gt;true
		}(a)
	}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-chanofdir-chandir-t-type-type"><a class="header" href="#func-chanofdir-chandir-t-type-type">func ChanOf(dir ChanDir, t Type) Type</a></h1>
<p>参数列表</p>
<ul>
<li>dir ChanDir 信道的方向，类型是 reflect.ChanDir</li>
<li>t Type 信道的类型，类型是 reflect.Type</li>
</ul>
<p>返回值：</p>
<ul>
<li>Type 返回 reflect.Type 类型，更多方法可以查看reflect.Type 接口</li>
</ul>
<p>功能说明：</p>
<ul>
<li>ChanOf 返回信道类型与给定的方向和元素类型。例如，如果t表示是整型，那么 ChanOf(RecvDir, t) 这样就表示&lt;-chan int。</li>
<li>GC 运行时强加限制 64 KB  的通道元素类型。如果t的大小等于或超过此限制，ChanOf恐慌(panic)。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
	&quot;fmt&quot;
	&quot;reflect&quot;
)

func main(){
	var i int
	var recvDir reflect.ChanDir = reflect.RecvDir
	var chanOf reflect.Type = reflect.ChanOf(recvDir, reflect.TypeOf(i))
	fmt.Println(chanOf.Kind(), chanOf.ChanDir(), chanOf.String())
	//&gt;&gt;chan chan &lt;-chan int
	
	var i1 int
	var recvDir1 reflect.ChanDir = reflect.SendDir
	var chanOf1 reflect.Type = reflect.ChanOf(recvDir1, reflect.TypeOf(i1))
	fmt.Println(chanOf1.Kind(), chanOf1.ChanDir(), chanOf1.String())
	//&gt;&gt;chan chan chan&lt;- int
	
	var i2 int
	var recvDir2 reflect.ChanDir = reflect.BothDir
	var chanOf2 reflect.Type = reflect.ChanOf(recvDir2, reflect.TypeOf(i2))
	fmt.Println(chanOf2.Kind(), chanOf2.ChanDir(), chanOf2.String())
	//&gt;&gt;chan chan chan int
	
	var i3 string
	var recvDir3 reflect.ChanDir = reflect.BothDir
	var chanOf3 reflect.Type = reflect.ChanOf(recvDir3, reflect.TypeOf(i3))
	fmt.Println(chanOf3.Kind(), chanOf3.ChanDir(), chanOf3.String())
	//&gt;&gt;chan chan chan string
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-copydst-src-value-int"><a class="header" href="#func-copydst-src-value-int">func Copy(dst, src Value) int</a></h1>
<p>参数列表</p>
<ul>
<li>dst Value 是目标切片Slice或数组Array</li>
<li>src Value 是源切片Slice或数组Array</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回 int 复制过去元素的数量</li>
</ul>
<p>功能说明：</p>
<ul>
<li>Copy 复制src的内容复制到dst，直到dst已被填补满，或src已经耗尽。它返回复制的元素的数量。每个 dst 和 src 的 Kind（样）都必须切片(Slice)“或”数组(Array)，dst和src必须具有相同的元素类型。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

type A struct {
  A0 []int
  A1 []int
}

func main(){
	var a A
	a.A0 = append(a.A0, []int{1,2,3,4,5,6,7}...)
	a.A1 = append(a.A1, 9, 8, 7, 6)
	var n = reflect.Copy(reflect.ValueOf(a.A0), reflect.ValueOf(a.A1))
	fmt.Println(n, a)
	//&gt;&gt;4 {[9 8 7 6 5 6 7] [9 8 7 6]}}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-deepequala1-a2-interface-bool"><a class="header" href="#func-deepequala1-a2-interface-bool">func DeepEqual(a1, a2 interface{}) bool</a></h1>
<p>参数列表</p>
<ul>
<li>a1 interface{} 比较A</li>
<li>a2 interface{} 比较B</li>
</ul>
<p>返回值：</p>
<ul>
<li>bool 如果两个参数的类型与值是相等的返回true,否则返回false。</li>
</ul>
<p>功能说明：</p>
<ul>
<li>DeepEqual 深刻的平等判断。在可能的情况下它使用 默认==平等，将扫描Array，Slice，Map，Struct和字段（Field）的成员。正确处理递归类型。如果他们俩都nil，那么函数是相等的。</li>
</ul>
<p>代码实例1：</p>
<pre><code>package main
	import (
	    &quot;fmt&quot;
	    &quot;reflect&quot;
	)
	func main() {
		var a int
		var b int
		a = 1
		b = 2
		var booL = reflect.DeepEqual(a, b)
		fmt.Println(booL)
		//&gt;&gt;false
		b = 1
		booL = reflect.DeepEqual(a, b)
		fmt.Println(booL)
		//&gt;&gt;true
	}
</code></pre>
<p>代码实例2：</p>
<pre><code>	package main
	import (
	    &quot;fmt&quot;
	    &quot;reflect&quot;
	)
	func main() {
	 	type A struct {
			A0 int
		}
		type B struct {
			A0 int
		}
		var a A
		var b B
		var booL = reflect.DeepEqual(a, b)
		fmt.Println(booL)
		//&gt;&gt;false

		booL = reflect.DeepEqual(a.A0, b.A0)
		fmt.Println(booL)
		//&gt;&gt;true
	}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-indirectv-value-value"><a class="header" href="#func-indirectv-value-value">func Indirect(v Value) Value</a></h1>
<p>参数列表</p>
<ul>
<li>v Value 传入是一个 reflect.Value 类型的变量</li>
</ul>
<p>返回值：</p>
<ul>
<li>Value 输出v的指针</li>
</ul>
<p>功能说明：</p>
<ul>
<li>返回值v的指针。如果v是一个零指针，间接返回零值。如果v不是一个指针，间接的返回v。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
	&quot;fmt&quot;
	&quot;reflect&quot;
)

func main(){
	var a []int
	
	//例子1
	var value reflect.Value = reflect.ValueOf(&amp;a)
	fmt.Println(value.Kind())
	//&gt;&gt;ptr
	
	//判断指针是否指向内存地址
	if !value.CanSet() {
		value = value.Elem() //使指针指向内存地址
	}
	fmt.Println(value.Kind())
	//&gt;&gt;slice
	
	//例子2
	var value1 reflect.Value = reflect.ValueOf(&amp;a)
	fmt.Println(value1.Kind())
	//&gt;&gt;ptr
	
	value1 = reflect.Indirect(value1) //功能等介于上面例子1
	
	fmt.Println(value1.Kind())
	//&gt;&gt;slice
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-kind"><a class="header" href="#type-kind">type Kind</a></h1>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>无</li>
</ul>
<p>功能说明：</p>
<ul>
<li>一个类型代表一种特定类型的类型，零Kind不是有效的Kind。
<ul>
<li>reflect.Kind 有以下常量成员
<ul>
<li>reflect.Invalid       // 无效</li>
<li>reflect.Bool          // 布尔</li>
<li>reflect.Int           // 整数（有符号）</li>
<li>reflect.Int8          // 整数8位（有符号）</li>
<li>reflect.Int16         // 整数16位（有符号）</li>
<li>reflect.Int32         // 整数32位（有符号）</li>
<li>reflect.Int64         // 整数64位（有符号）</li>
<li>reflect.Uint          // 整数（无符号）</li>
<li>reflect.Uint8         // 整数8（无符号）</li>
<li>reflect.Uint16        // 整数16（无符号）</li>
<li>reflect.Uint32        // 整数（无符号）</li>
<li>reflect.Uint64        // 整数（无符号）</li>
<li>reflect.Uintptr       // 整数（指针,无符号）</li>
<li>reflect.Float32       // 浮点数32位</li>
<li>reflect.Float64       // 浮点数64位</li>
<li>reflect.Complex64     // 复数64位</li>
<li>reflect.Complex128    // 复数128位</li>
<li>reflect.Array         // 数组</li>
<li>reflect.Chan          // 信道</li>
<li>reflect.Func          // 函数</li>
<li>reflect.Interface     // 接口</li>
<li>reflect.Map           // 地图</li>
<li>reflect.Ptr           // 指针</li>
<li>reflect.Slice         // 切片</li>
<li>reflect.String        // 字符</li>
<li>reflect.Struct        // 结构</li>
<li>reflect.UnsafePointer // 安全指针</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>代码实例：</p>
<pre><code>	package main
	import (
	    &quot;fmt&quot;
	    &quot;reflect&quot;
	)
	func main() {
		var a string
		var kind reflect.Kind = reflect.TypeOf(a).Kind()
		fmt.Println(kind, kind == reflect.String, kind == reflect.Int)
		//&gt;&gt;string true false
	}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-makechantyp-type-buffer-int-value"><a class="header" href="#func-makechantyp-type-buffer-int-value">func MakeChan(typ Type, buffer int) Value</a></h1>
<p>参数列表</p>
<ul>
<li>typ Type 传入信道的 reflect.Type 类型</li>
<li>buffer int 初始化信道的缓冲区大小</li>
</ul>
<p>返回值：</p>
<ul>
<li>Value 输出已被初始的信道 reflect.Value 类型</li>
</ul>
<p>功能说明：</p>
<ul>
<li>指定类型初始化一个信道和设置缓冲区大小。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
	&quot;fmt&quot;
	&quot;reflect&quot;
)

func main(){
	var a chan int
	
	var value reflect.Value = reflect.ValueOf(&amp;a)
	
	value = reflect.Indirect(value) //使指针指向内存地址
	
	value = reflect.MakeChan(value.Type(), 99)
	
	fmt.Println(value.Kind(), value.Cap())
	//&gt;&gt;chan 99
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-makefunctyp-type-fn-funcargs-value-results-value-value"><a class="header" href="#func-makefunctyp-type-fn-funcargs-value-results-value-value">func MakeFunc(typ Type, fn func(args []Value) (results []Value)) Value</a></h1>
<p>参数列表</p>
<ul>
<li>typ Type 一个未初化函数的方法值，类型是reflect.Type</li>
<li>fn func(args []Value) (results []Value) 另一个函数，作用于对第一个函数参数操作。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Value 返回 reflect.Value 类型，更多方法可以查看reflect.Value 结构中绑定的方法</li>
</ul>
<p>功能说明：</p>
<ul>
<li>MakeFunc 返回一个新的类型“函数”包含 fn 函数（绑定着fn函数）。
<ul>
<li>注：这个函数的价值，还在摸索中...</li>
</ul>
</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
	&quot;fmt&quot;
	&quot;reflect&quot;
)

func main(){
	var swap = func(in []reflect.Value) []reflect.Value {
		fmt.Println(in[0].Interface(), in[1].Interface())
		//1 2
		return []reflect.Value{in[1], in[0]}
	}
	var makeSwap = func(fptr interface{}) {
		var valueOf reflect.Value = reflect.Indirect( reflect.ValueOf(fptr))
		var v reflect.Value = reflect.MakeFunc(valueOf.Type(), swap)
		valueOf.Set(v)
		
		fmt.Println(valueOf)
		//&lt;func(int, int) (int, int) Value&gt;
		fmt.Println(v)
		//&lt;func(int, int) (int, int) Value&gt;
	}
	var intSwap func(int, int) (int, int)
	makeSwap(&amp;intSwap)
	fmt.Println(intSwap(1, 2))
	//2 1
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-makemaptyp-type-value"><a class="header" href="#func-makemaptyp-type-value">func MakeMap(typ Type) Value</a></h1>
<p>参数列表</p>
<ul>
<li>typ Type 传入Map的 reflect.Type 类型</li>
</ul>
<p>返回值：</p>
<ul>
<li>Value 输出已被初始Map的 reflect.Value 类型</li>
</ul>
<p>功能说明：</p>
<ul>
<li>指定类型初始化一个新的Map。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
	&quot;fmt&quot;
	&quot;reflect&quot;
)

func main(){
	var a map[int]string
	
	var value reflect.Value = reflect.ValueOf(&amp;a)
	
	value = reflect.Indirect(value) //使指针指向内存地址
	
	value = reflect.MakeMap(value.Type())
	
	value.SetMapIndex(reflect.ValueOf(1), reflect.ValueOf(&quot;a&quot;))
	value.SetMapIndex(reflect.ValueOf(2), reflect.ValueOf(&quot;b&quot;))
	
	fmt.Println(value.Kind(), value.Interface())
	//&gt;&gt;map map[1:a 2:b]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-makeslicetyp-type-len-cap-int-valu"><a class="header" href="#func-makeslicetyp-type-len-cap-int-valu">func MakeSlice(typ Type, len, cap int) Valu</a></h1>
<p>参数列表</p>
<ul>
<li>typ Type 传入Slice的 reflect.Type 类型</li>
<li>len int 传入需要初始化切片的长度</li>
<li>cap int 传入需要被始化切片的容量</li>
</ul>
<p>返回值：</p>
<ul>
<li>Value 输出已被初始Map的 reflect.Value 类型</li>
</ul>
<p>功能说明：</p>
<ul>
<li>指定切片类型创建一个新的初始化切片长度和容量。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
	&quot;fmt&quot;
	&quot;reflect&quot;
)

func main(){
	var a []int
	
	var value reflect.Value = reflect.ValueOf(&amp;a)
	
	value = reflect.Indirect(value) //使指针指向内存地址
	
	value = reflect.MakeSlice(value.Type(), 88, 99)
	
	fmt.Println(value.Kind(), value.Len(), value.Cap())
	//&gt;&gt;slice 88 99
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-mapofkey-elem-type-type"><a class="header" href="#func-mapofkey-elem-type-type">func MapOf(key, elem Type) Type</a></h1>
<p>参数列表</p>
<ul>
<li>key Type 表示着Map[int]string 中的 int类型</li>
<li>elem Type 表示着Map[int]string 中的 string类型</li>
</ul>
<p>返回值：</p>
<ul>
<li>Type 返回 reflect.Type 类型，更多方法可以查看reflect.Type 接口</li>
</ul>
<p>功能说明：</p>
<ul>
<li>MapOf 返回Map类型与键和元素的类型。例如，如果 k表示 int和 e表示 string，MapOf(k, e) 就是这样表示 Map[int]string。</li>
<li>如果 Key类型非是一个有效Map的 Key类型（也就是说，如果它没有实现Go的 == 操作符），MapOf恐慌（panic）。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
	&quot;fmt&quot;
	&quot;reflect&quot;
)

func main(){
	var key int
	var val string
	var mapOf reflect.Type = reflect.MapOf(reflect.TypeOf(key), reflect.TypeOf(val))
	fmt.Println(mapOf.Kind(), mapOf.String())
	//map map[int]string
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-method"><a class="header" href="#type-method">type Method</a></h1>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>.Index int 返回当前方法的索引号</li>
<li>.PkgPath string 返回当前方法包的路径</li>
<li>.Name string 返回当前方法的名称</li>
<li>.Type reflect.Type 返回当前方法的 Type 类型</li>
<li>.Func reflect.Value 返回当前方法的 Value 类型</li>
</ul>
<p>功能说明：</p>
<ul>
<li>Method 是一种单独的方法。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
	import (
	    &quot;fmt&quot;
	    &quot;reflect&quot;
	)
	
	type A struct {
	}
	func (A) test(){}
	
	func main(){
		var a A
		var method reflect.Method = reflect.TypeOf(a).Method(0) //0 表示是 a 结构中的第几位函数
		fmt.Println(method.Index, method.PkgPath, method.Name, method.Type, method.Func)
		//&gt;&gt;0 test main func(main.A) &lt;func(main.A) Value&gt;
	}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-newtyp-type-value"><a class="header" href="#func-newtyp-type-value">func New(typ Type) Value</a></h1>
<p>参数列表</p>
<ul>
<li>typ Type 传入新值的 reflect.Type 类型</li>
</ul>
<p>返回值：</p>
<ul>
<li>Value 输出已被初始新值的 reflect.Value 类型</li>
</ul>
<p>功能说明：</p>
<ul>
<li>指定类型初始化一个新的零值，返回一个指针指向被初始化的零值Value。也就是说，返回值的类型是PtrTo(t)。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
	&quot;fmt&quot;
	&quot;reflect&quot;
)

func main(){
	var a []int
	
	var value reflect.Value = reflect.ValueOf(&amp;a)
	
	value = reflect.Indirect(value) //使指针指向内存地址
	
	value = reflect.New(value.Type()) //初始化后返回指针
	fmt.Println(value.Kind())
	//&gt;&gt;ptr
	
	value = reflect.Indirect(value) //使指针指向内存地址
	fmt.Println(value.Kind())
	//&gt;&gt;slice
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-newattyp-type-p-unsafepointer-value"><a class="header" href="#func-newattyp-type-p-unsafepointer-value">func NewAt(typ Type, p unsafe.Pointer) Value</a></h1>
<p>参数列表</p>
<ul>
<li>typ Type 传入新值的 reflect.Type 类型</li>
<li>p unsafe.Pointer 另一个新值的指针</li>
</ul>
<p>返回值：</p>
<ul>
<li>Value 输出已被初始新值的指针，类型是 reflect.Value</li>
</ul>
<p>功能说明：</p>
<ul>
<li>返回一个值，该值表示指定类型的指针的值，使用p作为该指针。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
	&quot;fmt&quot;
	&quot;reflect&quot;
	&quot;unsafe&quot;
)

func main(){
	var a []int
	var b []int
	var value reflect.Value = reflect.ValueOf(&amp;a)
	var value1 reflect.Value = reflect.ValueOf(&amp;b)
	
	value = reflect.Indirect(value) //使指针指向内存地址
	value1 = reflect.Indirect(value1) //使指针指向内存地址
	
	value1 = reflect.NewAt(value.Type(), unsafe.Pointer(reflect.ValueOf(&amp;b).Pointer())).Elem()
	b = append(b, 1)
	a = append(a, 2)
	fmt.Println(value.Pointer(), value1.Pointer())
	//&gt;&gt;282918952 282918960
	
	value.Set(value1)
	
	fmt.Println(value1.Kind(), value.Pointer(), value1.Pointer(), value.Interface(), value1.Interface(), a, b)
	//&gt;&gt;slice 282918960 282918960 [1] [1] [1] [1]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-ptrtot-type-type"><a class="header" href="#func-ptrtot-type-type">func PtrTo(t Type) Type</a></h1>
<p>参数列表</p>
<ul>
<li>t Type 是一个反射类型</li>
</ul>
<p>返回值：</p>
<ul>
<li>Type 返回指针类型(reflect.Type)</li>
</ul>
<p>功能说明：</p>
<ul>
<li>PtrTo 返回元素 t 的指针类型。例如，t 表示 Foo 类型，则 PtrTo(T) 代表 *Foo 类型。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
	&quot;fmt&quot;
	&quot;reflect&quot;
)

func main(){
	var a int
	var pt reflect.Type = reflect.PtrTo(reflect.TypeOf(a))
	fmt.Println(pt.Kind(), pt.Elem().Kind()) // .Emel() 表示直接寻址
	// &gt;&gt;*int int
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-selectcases-selectcase-chosen-int-recv-value-recvok-bool"><a class="header" href="#func-selectcases-selectcase-chosen-int-recv-value-recvok-bool">func Select(cases []SelectCase) (chosen int, recv Value, recvOK bool)</a></h1>
<p>参数列表</p>
<ul>
<li>cases []SelectCase 使用此参数之前要设置SelectCase，告诉Select目的。</li>
</ul>
<p>返回值：</p>
<ul>
<li>chosen int 返回参数[]SelectCase 切片的序号</li>
<li>recv Value 返回信道的值，类型是reflect.Value</li>
<li>recvOk bool 返回false，如果信道被关闭。</li>
</ul>
<p>功能说明：</p>
<ul>
<li>Select 等介于 select，拥有一样的随机的选择。</li>
</ul>
<p>代码实例1：</p>
<pre><code>package main
import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

func main(){
	var c = make( chan int, 1)
	go func(c chan int){
		for i:=0;i&lt;10;i++{
			c&lt;-i
		}
		close(c)
	}(c)
	
	L:for {
		select {
		case val, ok:=&lt;-c:
			if ok {
				fmt.Println(&quot;接收: &quot;, val)
			}else{
				fmt.Println(&quot;信道关闭了&quot;)
				break L
			}
		}
	}
	//接收:  0
	//接收:  1
	//接收:  2
	//接收:  3
	//接收:  4
	//接收:  5
	//接收:  6
	//接收:  7
	//接收:  8
	//接收:  9
	//信道关闭了
}
</code></pre>
<p>代码实例2：</p>
<pre><code>package main
import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

func main(){
	var chs = make(chan int)
	var worker = func(c chan int){
		for i:=0;i&lt;5;i++{
			c&lt;-i
		}
		close(c)
	}
	
	go worker(chs)
	
	var selectCase = make([]reflect.SelectCase, 1)
	selectCase[0].Dir = reflect.SelectRecv //设置信道是接收
	selectCase[0].Chan = reflect.ValueOf(chs)
	
	numDone := 0
	for numDone &lt; 1 {
		chosen, recv, recvOk := reflect.Select(selectCase)
		if recvOk {
			fmt.Println(chosen, recv.Int(), recvOk)
			//0 0 true
			//0 1 true
			//0 2 true
		}else{
			numDone++
		}
	}
}
</code></pre>
<p>代码实例3：</p>
<pre><code>package main
import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

func main(){
	var n int = 1
	var chs = make([]chan int, n)
	
	var worker = func(n int, c chan int){
		for i:=0;i&lt;n;i++{
			c&lt;-i
		}
		close(c)
	}
	
	for i:=0;i&lt;n;i++{
		chs[i]=make(chan int)
		go worker(3+i, chs[i])
	}
	
	var selectCase = make([]reflect.SelectCase, n)
	for i:=0;i&lt;n;i++{
		selectCase[i].Dir = reflect.SelectRecv //设置信道是接收
		selectCase[i].Chan = reflect.ValueOf(chs[i])
	}
	
	numDone := 0
	for numDone &lt; n {
		chosen, recv, recvOk := reflect.Select(selectCase)
		if recvOk {
			fmt.Println(chosen, recv.Int(), recvOk)
			//0 0 true
			//0 1 true
			//0 2 true
		}else{
			numDone++
		}
	}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-selectcase-struct"><a class="header" href="#type-selectcase-struct">type SelectCase struct</a></h1>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>无</li>
</ul>
<p>功能说明：</p>
<ul>
<li>
<p>预前设置Select目的，结合reflect.Select函数使用。若设置 Dir 值为SelectDefault，Chan与Send无需设置。Chan表示接收。Chan与Send不可同时现设置。</p>
</li>
<li>
<p>要懂这个类型之前，请先看 reflect.Select 函数如何使用，这样会很快就明白下面代码实例是什么意思。</p>
<pre><code>  type SelectCase struct {
  	Dir  SelectDir 	// select方向，SelectDir 的值就是 SelectSend、SelectRecv、SelectDefault
  	Chan Value		// 通道使用（接收）
  	Send Value		// 发送的值（发送）
  }
</code></pre>
</li>
</ul>
<p>代码实例1：</p>
<pre><code>package main
import (
	&quot;fmt&quot;
	&quot;reflect&quot;
)

func main(){
	var chs = make(chan int, 1)
	var selectCase = make([]reflect.SelectCase, 1)
	selectCase[0].Dir = reflect.SelectRecv //2
	selectCase[0].Chan = reflect.ValueOf(chs) //接收
	fmt.Println(selectCase)
	//[{2 &lt;chan int Value&gt; &lt;invalid Value&gt;}]
	
	var selectCase1 = make([]reflect.SelectCase, 1)
	selectCase1[0].Dir = reflect.SelectSend //1
	selectCase1[0].Send = reflect.ValueOf(chs) //发送
	fmt.Println(selectCase1)
	//[{1 &lt;invalid Value&gt; &lt;chan int Value&gt;}]
	
	var selectCase2 = make([]reflect.SelectCase, 1)
	selectCase2[0].Dir = reflect.SelectDefault //1
	fmt.Println(selectCase2)
	//[{3 &lt;invalid Value&gt; &lt;invalid Value&gt;}]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-selectdir-int"><a class="header" href="#type-selectdir-int">type SelectDir int</a></h1>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>无</li>
</ul>
<p>功能说明：</p>
<ul>
<li>
<p>SelectDir 描述信道方向的选择case</p>
<pre><code>  const (
  	_	SelectDir = iota		// 初始化
      SelectSend					// 发送方向 Chan &lt;- Send
      SelectRecv					// 接受方向 &lt;-Chan
      SelectDefault				// 默认方向
  )
</code></pre>
</li>
</ul>
<p>代码实例1：</p>
<pre><code>package main
import (
	&quot;fmt&quot;
	&quot;reflect&quot;
)
  
func main(){
	var selectCase = make([]reflect.SelectCase, 1)
	selectCase[0].Dir = reflect.SelectRecv //2
	fmt.Println(selectCase)
	//[{2 &lt;chan int Value&gt; &lt;invalid Value&gt;}]
	
	var selectCase1 = make([]reflect.SelectCase, 1)
	selectCase1[0].Dir = reflect.SelectSend //1
	fmt.Println(selectCase1)
	//[{1 &lt;invalid Value&gt; &lt;chan int Value&gt;}]
	
	var selectCase2 = make([]reflect.SelectCase, 1)
	selectCase2[0].Dir = reflect.SelectDefault //3
	fmt.Println(selectCase2)
	//[{3 &lt;invalid Value&gt; &lt;invalid Value&gt;}]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-sliceheader-struct"><a class="header" href="#type-sliceheader-struct">type SliceHeader struct</a></h1>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>无</li>
</ul>
<p>功能说明：</p>
<ul>
<li>
<p>表示切片运行时。它不能被安全地使用，或者可移植。</p>
<pre><code>  type SliceHeader struct {
  	Data	uintptr	// 指针
  	Len		int		// 长度
  	Cap		int		// 容量
  }
</code></pre>
</li>
</ul>
<p>代码实例1：</p>
<pre><code>a := &quot;abc&quot;    // 字符串 &quot;abc&quot;
b := (*uintptr)(unsafe.Pointer(&amp;a))  // b 存储 a 的地址

var c []byte // d 将 c 的结构用 reflect.SliceHeader 表示
d := (*reflect.SliceHeader)((unsafe.Pointer(&amp;c)))
d.Cap = len(a)
d.Len = len(a)
d.Data = *b  // *b 存储字符串首元素地址
fmt.Println(c)
// [97 98 99]
</code></pre>
<p>代码实例2：</p>
<pre><code>package main
import (
	&quot;fmt&quot;
	&quot;reflect&quot;
	&quot;unsafe&quot;
)

func main(){
    type T struct {
        a int
        b int
        c int
    }
	
    t := &amp;T{a: 1, b: 2, c: 3}
    p := unsafe.Sizeof(*t)
    println(int(p))
    //12
    sl := &amp;reflect.SliceHeader{
        Data: uintptr(unsafe.Pointer(t)),
        Len:  int(p),
        Cap:  int(p),
    }
	
    b := *(*[]byte)(unsafe.Pointer(sl))
    println(len(b))
    //12
    fmt.Println(b)
	//[1 0 0 0 2 0 0 0 3 0 0 0]
	
    b[0] = 7
    b[4] = 5
    b[8] = 8
	
    fmt.Println(t)
	//&amp;{7 5 8}
}
</code></pre>
<p>代码实例3：</p>
<pre><code>package main
import (
	&quot;fmt&quot;
	&quot;reflect&quot;
	&quot;unsafe&quot;
)

func main(){
	type T struct {
		a int
		b int
		c int
	}
	
	var t=&amp;T{a:1,b:2,c:3}
	p := unsafe.Sizeof(*t)
	fmt.Println(int(p))
   //12
	
    sl := reflect.SliceHeader{
        Data: uintptr(unsafe.Pointer(t)),
        Len:  int(p),
        Cap:  int(p),
    }
	
    b := *(*[]byte)(unsafe.Pointer(&amp;sl))
    fmt.Println(len(b))
    //12
    fmt.Println(t, b)
	//&amp;{1 2 3} [1 0 0 0 2 0 0 0 3 0 0 0]
	
	//------------第一切片
	b[0] = 3
	
	//------------第二切片，下面的2就是表示二切片
	b[4] = 5
	b[5] = 1 //等介于 5 * 2 + 1
	
	//------------第三切片，下面的3就是表示三切片
	b[8] = 255 //最大255
	b[9] = 2 //等介于 255 * 3 + 2
	
	fmt.Println(t, b)
	//&amp;{3 261 767} [3 0 0 0 5 1 0 0 255 2 0 0]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-sliceoft-type-type"><a class="header" href="#func-sliceoft-type-type">func SliceOf(t Type) Type</a></h1>
<p>参数列表</p>
<ul>
<li>t Type 切片的类型，如[]int，传入int的反射类型。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Type 返回 reflect.Type 类型，更多方法可以查看reflect.Type 接口</li>
</ul>
<p>功能说明：</p>
<ul>
<li>SliceOf 返回t元素类型的一个切片 。例如，如果t表示整型（int），SliceOf(t)就是表示[]int。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
	&quot;fmt&quot;
	&quot;reflect&quot;
)

func main(){
	var i int
	var sliceOf reflect.Type = reflect.SliceOf(reflect.TypeOf(i))
	fmt.Println(sliceOf.Kind(), sliceOf.String())
	//slice []int
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-stringheader-struct"><a class="header" href="#type-stringheader-struct">type StringHeader struct</a></h1>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>无</li>
</ul>
<p>功能说明：</p>
<ul>
<li>
<p>表示切片运行时。它不能被安全地使用，或者可移植。</p>
<pre><code>  type StringHeader struct {
  	Data uintptr	// 指针
  	Len  int		// 长度
  }
</code></pre>
</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
	&quot;fmt&quot;
	&quot;reflect&quot;
	&quot;unsafe&quot;
)

func main(){
    var b = []byte{97, 98, 99}
    fmt.Println(unsafe.Sizeof(b), len(b))
	//12 3
	
    var sh = (*reflect.SliceHeader)(unsafe.Pointer(&amp;b))
	fmt.Println(sh.Data, sh.Len, sh.Cap)
	//820188969 3 3
	fmt.Println((*[]byte)(unsafe.Pointer(&amp;sh.Data)))
	//&amp;[97 98 99]
	
	var s string
	var sh1 =  (*reflect.StringHeader)(unsafe.Pointer(&amp;s))
	//sh1.Data = *(*uintptr)(unsafe.Pointer(&amp;b))
	sh1.Data = sh.Data
	sh1.Len = sh.Len
	fmt.Println(s)
	//abc
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-structfield"><a class="header" href="#type-structfield">type StructField</a></h1>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>.Index []int 返回当前的字段索引号</li>
<li>.PkgPath string 返回当前字段的包路径</li>
<li>.Name string 返回当前的字段名称</li>
<li>.Offect uintptr 返回当前的字段偏移量，从结构中的字段开始到当前字段开始的偏移量</li>
<li>.Type reflect.Type 返回当前的字段 Type 类型</li>
<li>.Tag reflect.StructTag 返回当前的字段标签名称</li>
<li>.Anonymous bool 返回当前的字段是否是匿名字段</li>
</ul>
<p>功能说明：</p>
<ul>
<li>StructField 在一个结构内描述了一个单一的字段。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

type A struct {
	A0 int &quot;这是A0&quot;
	A1 B &quot;嵌套B结构&quot;
	B &quot;匿名字段&quot;
}
type B struct {
	B0 string
	B1 int
}
func main(){
	var a A
	var typeof reflect.Type = reflect.TypeOf(a)
	var field reflect.StructField = typeof.Field(0) //0 表示是 a 结构中的第几位字段
	fmt.Println(field.Index, field.PkgPath, field.Name, field.Offset, field.Type, field.Tag, field.Anonymous)
	//&gt;&gt;[0]  A0 0 int 这是A0 false

	var field1 reflect.StructField = typeof.Field(1)
	fmt.Println(field1.Index, field1.PkgPath, field1.Name, field1.Offset, field1.Type, field1.Tag, field1.Anonymous)
	//&gt;&gt;[1]  A1 4 main.B 嵌套B结构 false

	var field2 reflect.StructField = typeof.Field(2)
	fmt.Println(field2.Index, field2.PkgPath, field2.Name, field2.Offset, field2.Type, field2.Tag, field2.Anonymous)
	//&gt;&gt;[2]  B 16 main.B 匿名字段 true
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="align-int"><a class="header" href="#align-int">Align() int</a></h1>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>int 变量在内存中对齐值</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.TypeOf(interface{}).Align() 在分配在内存时的此类型的一个值（以字节为单位）的对齐。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

func main(){
	var a int
	var typeof reflect.Type = reflect.TypeOf(a)
	fmt.Println(typeof.Align())
	//&gt;&gt;4
	var b string
	typeof = reflect.TypeOf(b)
	fmt.Println(typeof.Align())
	//&gt;&gt;4
	var c uint
	typeof = reflect.TypeOf(c)
	fmt.Println(typeof.Align())
	//&gt;&gt;4
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="assignabletou-type-bool"><a class="header" href="#assignabletou-type-bool">AssignableTo(u Type) bool</a></h1>
<p>参数列表</p>
<ul>
<li>u reflect.Type 传入一个类型</li>
</ul>
<p>返回值：</p>
<ul>
<li>bool 如果类型可以赋值，返回true，否则返回false。</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.TypeOf(interface{}).AssignableTo(reflect.Type) 如果一个类型的值是可分配给u，返回true。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

func main(){
	var a int
	var b int
	var c string
	var typeA reflect.Type = reflect.TypeOf(a)

	var typeB reflect.Type = reflect.TypeOf(b)
	fmt.Println(typeA.AssignableTo(typeB))
	//&gt;&gt;true

	var typeC reflect.Type = reflect.TypeOf(c)
	fmt.Println(typeA.AssignableTo(typeC))
	//&gt;&gt;false
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bits-int"><a class="header" href="#bits-int">Bits() int</a></h1>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>int 返回类型的位大小</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.TypeOf(interface{}).Bits() 返回类型的位大小，如果出现恐慌（panic），那么它的类型不是Int、Uint、Float或Complex。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

func main(){
	var a int8
	var typeA reflect.Type = reflect.TypeOf(a)
	fmt.Println(typeA.Bits())
	//&gt;&gt;8

	var b int64
	var typeB reflect.Type = reflect.TypeOf(b)
	fmt.Println(typeB.Bits())
	//&gt;&gt;64
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chandir-chandir"><a class="header" href="#chandir-chandir">ChanDir() ChanDir</a></h1>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>ChanDir 返回一个信道特定的 reflect.ChanDir 类型
<ul>
<li>reflect.ChanDir 有三个常量
<ul>
<li>reflect.SendDir 发送信道</li>
<li>reflect.RecvDir 接收信道</li>
<li>reflect.BothDir 双向信道</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.TypeOf(interface{}).ChanDir() 返回信道类型的方向，如果出现恐慌（panic），那么它不是 Chan 类型。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)
	
func main(){
	var a chan&lt;- int
	var typeA reflect.Type = reflect.TypeOf(a)
	fmt.Println(typeA.ChanDir(), typeA.ChanDir() == reflect.SendDir)
	//&gt;&gt;chan&lt;- true
	
	var b &lt;-chan int
	var typeB reflect.Type = reflect.TypeOf(b)
	fmt.Println(typeB.ChanDir(), typeB.ChanDir() == reflect.RecvDir)
	//&gt;&gt;&lt;-chan true
	
	var c chan int
	var typeC reflect.Type = reflect.TypeOf(c)
	fmt.Println(typeC.ChanDir(), typeC.ChanDir() == reflect.BothDir)
	//&gt;&gt;chan true
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="convertibletou-type-bool"><a class="header" href="#convertibletou-type-bool">ConvertibleTo(u Type) bool</a></h1>
<p>参数列表</p>
<ul>
<li>u Type 另一个变量的反映类型，类型是 reflect.Type</li>
</ul>
<p>返回值：</p>
<ul>
<li>bool 返回true，如果一个类型的值可以转换为 u 类型。</li>
</ul>
<p>功能说明：</p>
<ul>
<li>ConvertibleTo 返回true，如果一个类型的值可以转换为 u 类型。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
	&quot;fmt&quot;
	&quot;reflect&quot;
)

func main(){
	var i int64
	var typeOf reflect.Type = reflect.TypeOf(i)
	
	var k string
	fmt.Println(typeOf.ConvertibleTo(reflect.TypeOf(k)))
	//&gt;&gt;true
	
	var k1 rune
	fmt.Println(typeOf.ConvertibleTo(reflect.TypeOf(k1)))
	//&gt;&gt;true
	
	var k2 uintptr
	fmt.Println(typeOf.ConvertibleTo(reflect.TypeOf(k2)))
	//&gt;&gt;true
	
	var k3 complex128
	fmt.Println(typeOf.ConvertibleTo(reflect.TypeOf(k3)))
	//&gt;&gt;false
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="elem-type"><a class="header" href="#elem-type">Elem() Type</a></h1>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>Type reflect.Type 返回一个直接指向内存地址的 reflect.Type 类型</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.TypeOf(interface{}).Elem() 返回一个类型的元素类型。如果出现恐慌（panic），表示变量类型不是Array，Chan，Map，Ptr，或Slice。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

func main(){
	var a int
	var typeA reflect.Type = reflect.TypeOf(&amp;a)
	fmt.Println(typeA, typeA.Kind()) // 这里是指针，间接指向内存地址
	//&gt;&gt;*int ptr
	
	var b int
	var typeB reflect.Type = reflect.TypeOf(&amp;b)
	fmt.Println(typeB.Elem(), typeB.Elem().Kind()) // 加上.Elem() 就可以直接指向内存地址。Elem()很有用，很多时候都用的到它。
	//&gt;&gt;int int
	
	var c map[int]string
	var typeC reflect.Type = reflect.TypeOf(c)
	fmt.Println(typeC.Elem(), typeC.Elem().Kind())
	//&gt;&gt;string string
	
	var d map[int]string
	var typeD reflect.Type = reflect.TypeOf(&amp;d)
	fmt.Println(typeD.Elem(), typeD.Elem().Elem(), typeD.Elem().Kind())
	//&gt;&gt;map[int]string string map
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fieldi-int-structfield"><a class="header" href="#fieldi-int-structfield">Field(i int) StructField</a></h1>
<p>参数列表</p>
<ul>
<li>i int 传入字段的索引号</li>
</ul>
<p>返回值：</p>
<ul>
<li>.StructField 返回字段的 reflect.StructField 类型</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.TypeOf(interface{}).Field(int) 返回一个结构中的指定字段类型。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

type A struct {
	A0 int &quot;标签0&quot;
	A1 string &quot;标签1&quot;
	A2 []byte &quot;标签2&quot;
	B &quot;匿名嵌套&quot;
}
type B struct {}

func main(){
	var a A
	var typeof reflect.Type = reflect.TypeOf(a)
	for i:=0; i&lt;typeof.NumField(); i++ {
		f := typeof.Field(i)
		fmt.Println(f.Index, f.PkgPath, f.Name, f.Type, f.Tag, f.Anonymous)
		// 0 &gt;&gt;[0]  A0 int 标签0 false
		// 1 &gt;&gt;[1]  A1 string 标签1 false
		// 2 &gt;&gt;[2]  A2 []uint8 标签2 false
		// 3 &gt;&gt;[3]  B main.B 匿名嵌套 true
	}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fieldalign-int"><a class="header" href="#fieldalign-int">FieldAlign() int</a></h1>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>int 字段对齐的值</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.TypeOf(interface{}).FieldAlign() 返回字段对齐的值（以字节为单位）</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

type A struct {
	A0 int &quot;标签0&quot;
	A1 string &quot;标签1&quot;
	A2 []byte &quot;标签2&quot;
}

func main(){
	var a A
	var typeof reflect.Type = reflect.TypeOf(a.A0)
	fmt.Println(typeof.FieldAlign())
	//&gt;&gt;4
	typeof = reflect.TypeOf(a.A1)
	fmt.Println(typeof.FieldAlign())
	//&gt;&gt;4
	typeof = reflect.TypeOf(a.A2)
	fmt.Println(typeof.FieldAlign())
	//&gt;&gt;4
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fieldbyindexindex-int-structfield"><a class="header" href="#fieldbyindexindex-int-structfield">FieldByIndex(index []int) StructField</a></h1>
<p>参数列表</p>
<ul>
<li>index []int 传入字段与嵌套字段的索引号</li>
</ul>
<p>返回值：</p>
<ul>
<li>.StructField 返回字段的 reflect.StructField 类型</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.TypeOf(interface{}).FieldByIndex([]int) 返回对应的索引序列的嵌套字段。如果出现恐慌（panic），因为type不是struct类型。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

type A struct {
	A0 int &quot;标签0&quot;
	A1 string &quot;标签1&quot;
	A2 []byte &quot;标签2&quot;
	A3 *A &quot;指针指向自身&quot;
	B &quot;匿名嵌套&quot;
}
type B struct {
	B0 int &quot;B结构-标签B0&quot;
}

func main(){
	var a A
	var typeof reflect.Type = reflect.TypeOf(a)
	
	var r = []int{3,4}
	var f = typeof.FieldByIndex(r)
	fmt.Println(f.Index, f.PkgPath, f.Name, f.Type, f.Tag, f.Anonymous)
	//&gt;&gt;[4]  B main.B 匿名嵌套 true
	
	r = []int{4,0}
	f = typeof.FieldByIndex(r)
	fmt.Println(f.Index, f.PkgPath, f.Name, f.Type, f.Tag, f.Anonymous)
	//&gt;&gt;[0]  B0 int B结构-标签B0 false
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fieldbynamename-string-structfield-bool"><a class="header" href="#fieldbynamename-string-structfield-bool">FieldByName(name string) (StructField, bool)</a></h1>
<p>参数列表</p>
<ul>
<li>name string 传入一个“字符串”的字段名称</li>
</ul>
<p>返回值：</p>
<ul>
<li>.StructField 返回字段的 reflect.StructField 类型</li>
<li>bool 如果找到字段，返回true，则返回false</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.TypeOf(interface{}).FieldByName(string) 使用一个“字符串”的字段名称返回字段的 StructField 类型和布尔值。布尔值为true，表示找到该字段。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

type A struct {
	A0 int &quot;标签0&quot;
	A1 string &quot;标签1&quot;
	A2 []byte &quot;标签2&quot;
	A3 *A &quot;指针指向自身&quot;
}

func main(){
	var a A
	var typeof reflect.Type = reflect.TypeOf(a)
	
	var f, ok = typeof.FieldByName(&quot;A2&quot;)
	fmt.Println(ok, f.Index, f.PkgPath, f.Name, f.Type, f.Tag, f.Anonymous)
	//&gt;&gt;true [2]  A2 []uint8 标签2 false
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fieldbynamefuncmatch-funcstring-bool-structfield-bool"><a class="header" href="#fieldbynamefuncmatch-funcstring-bool-structfield-bool">FieldByNameFunc(match func(string) bool) (StructField, bool)</a></h1>
<p>参数列表</p>
<ul>
<li>match func(string) bool 传入一个函数用于筛选匹配的字段。函数又传入字段的“字符串”名称并判断，func 返回 true，表示找到匹配。</li>
</ul>
<p>返回值：</p>
<ul>
<li>.StructField 返回字段的 reflect.StructField 类型</li>
<li>bool 如果找到字段，返回true，则返回false</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.TypeOf(interface{}).FieldByNameFunc(func) 筛选并判断满足匹配的字段。如果找到了该字段的名称，返回的第一个结构字段和一个布尔值。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

type A struct {
	A0 int &quot;标签0&quot;
	A1 string &quot;标签1&quot;
	A2 []byte &quot;标签2&quot;
	A3 *A &quot;指针指向自身&quot;
}

func main(){
	var a A
	var typeof reflect.Type = reflect.TypeOf(a)

	var fun = func(s string) bool { //遍历字段，传入每个字段的字段名
		if s == &quot;A3&quot; { //请结合正则匹配，才能发挥最大效用。
			return true
		}
		return false
	}
	var f, ok = typeof.FieldByNameFunc(fun)
	fmt.Println(ok, f.Index, f.PkgPath, f.Name, f.Type, f.Tag, f.Anonymous)
	//&gt;&gt;true [3]  A3 *main.A 指针指向自身 false
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="implementsu-type-bool"><a class="header" href="#implementsu-type-bool">Implements(u Type) bool</a></h1>
<p>参数列表</p>
<ul>
<li>u reflect.Type 一个结构字段的 Type</li>
</ul>
<p>返回值：</p>
<ul>
<li>bool 如果结构能实现 u 的接口，返回true，否则返回false。</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.TypeOf(interface{}).Implements(reflect.Type)  如果该结构类型实现 U 接口，返回true。</li>
</ul>
<p>代码实例：</p>
<p>package main
import (
&quot;fmt&quot;
&quot;reflect&quot;
)</p>
<pre><code>type A struct {
	C
}
type B struct {
	C
	D
	E
}
type C interface {
	test()
}
type D interface {
	test1()
}
type E interface {}

func main(){
	var a A
	var b B
	var typeof reflect.Type = reflect.TypeOf(a)

	//判断a结构是否存在b结构中的C接口
	var booL = typeof.Implements( reflect.TypeOf(b).Field(0).Type )
	fmt.Println(booL)
	//&gt;&gt;true

	//判断a结构是否存在b结构中的D接口
	booL = typeof.Implements( reflect.TypeOf(b).Field(1).Type )
	fmt.Println(booL)
	//&gt;&gt;false

	//b结构中的E因为是空接口，所以也返回true。
	booL = typeof.Implements( reflect.TypeOf(b).Field(2).Type )
	fmt.Println(booL)
	//&gt;&gt;true
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inint-type"><a class="header" href="#inint-type">In(int) Type</a></h1>
<p>参数列表</p>
<ul>
<li>int 函数参数的索引号</li>
</ul>
<p>返回值：</p>
<ul>
<li>Type 函数参数的 reflect.Type 类型</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.TypeOf(interface{}).In(int) 函数输入的参数类型，如果出现恐慌（panic），该类型不是函数或索引号超出范围。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

func main(){
	var a = func(a1 int, a2 string, a3 uint, a4 interface{}) {}
	var typeof reflect.Type = reflect.TypeOf(a)
	for i:=0; i&lt;typeof.NumIn(); i++ {
		fmt.Println(typeof.In(i).Kind())
		// 0 &gt;&gt;int
		// 1 &gt;&gt;string
		// 2 &gt;&gt;uint
		// 3 &gt;&gt;interface
	}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="isvariadic-bool"><a class="header" href="#isvariadic-bool">IsVariadic() bool</a></h1>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>bool 如果函数支持可变参数，返回true。否则返回false。</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.TypeOf(interface{}).IsVariadic() 如果一个函数类型的最后一个输入参数是一个“...”参数，返回true。如果出现恐慌（panic），表示变量类型不是函数。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)
	
func main(){
	var a func(a1 int, a2 string, a3...interface{})
	var typeA reflect.Type = reflect.TypeOf(a)
	fmt.Println(typeA.IsVariadic())
	//&gt;&gt;true
	
	var b func(a1 int, a2 string, a3 interface{})
	var typeB reflect.Type = reflect.TypeOf(b)
	fmt.Println(typeB.IsVariadic())
	//&gt;&gt;false
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="key-type"><a class="header" href="#key-type">Key() Type</a></h1>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>Type reflect.Type 返回 map 类型 key 的类型。</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.TypeOf(interface{}).Key() 返回 map 类型 key 的类型。如果出现恐慌（panic），表示变量类型不是Map。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

func main(){
	var a map[int]string
	var typeA reflect.Type = reflect.TypeOf(a)
	fmt.Println(typeA.Key(), typeA.Elem().Kind())
	//&gt;&gt;int string
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kind-kind"><a class="header" href="#kind-kind">Kind() Kind</a></h1>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>Kind 返回特定的 reflect.Kind 类型</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.TypeOf(interface{}).Kind()  返回特定的 Kind 类型。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

func main(){
	var a int
	var typeof reflect.Type = reflect.TypeOf(a)
	fmt.Println(typeof.Kind(), typeof.Kind() == reflect.Int)
	//&gt;&gt;int true
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="len-int"><a class="header" href="#len-int">Len() int</a></h1>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>int 返回数组Array的长度</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.TypeOf(interface{}).Len() 返回数组Array的长度。如果出现恐慌（panic），表示变量类型不是Array。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

func main(){
	var a [33]int
	var typeA reflect.Type = reflect.TypeOf(a)
	fmt.Println(typeA.Len())
	//&gt;&gt;33
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-type"><a class="header" href="#type-type">type Type</a></h1>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>无</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.Type 只要是对“类型”或“结构”的字段与绑定函数的基本信息返回。
<ul>
<li>使用这两个函数可返回 reflect.Type 类型</li>
<li>func PtrTo(t Type) Type // 返回元素 t 的指针类型</li>
<li>func TypeOf(i interface{}) Type // 返回反射interface{}接口的类型
<ul>
<li>下面都是 reflect.Type 的方法</li>
<li>NumMethod() int    // 函数总数量，在struct结构中</li>
<li>Method(int) Method    // 指定返回函数的 Method 类型，在struct结构中</li>
<li>MethodByName(string) (Method, bool)    // 使用“字符串”函数名称返回函数的 Method 类型，在struct结构中</li>
<li>NumField() int    // 字段总数量，在struct结构中</li>
<li>Field(i int) StructField    // 指定返回字段的 StructField 类型，在struct结构中</li>
<li>FieldByIndex(index []int) StructField    // 指定返回“嵌套”字段的 StructField 类型，在struct结构中</li>
<li>FieldByName(name string) (StructField, bool)    // 使用“字符串”字段名称返回字段的 StructField 类型，在struct结构中</li>
<li>FieldByNameFunc(match func(string) bool) (StructField, bool)    // 传入字段“字符串”名称，并判断，func 返回 true，返回字段的 StructField 类型，在struct结构中</li>
<li>NumIn() int    // 函数输入参数总数量</li>
<li>In(i int) Type    // 返回函数输入参数的第i个类型 Type</li>
<li>NumOut() int    // 函数输出参数总数量</li>
<li>Out(i int) Type    // 返回函数输出参数的第i个类型 Type</li>
<li>Align() int    // 在分配在内存时候，返回此类型的一个值（以字节为单位）的对齐。</li>
<li>FieldAlign() int    // 返回字段对齐的值（以字节为单位）</li>
<li>Name() string    // 变量名称或字段的名称</li>
<li>PkgPath() string    // 变量的（包）路径名</li>
<li>Size() uintptr    // 值的数据大小（以字节为单位）</li>
<li>String() string    // （包）路径名称+类型名称</li>
<li>Kind() Kind    // 变量的类型</li>
<li>Implements(u Type) bool    // 判断是否存在与 u 相同的接口</li>
<li>AssignableTo(u Type) bool    // 判断值是否可分配给 u</li>
<li>ConvertibleTo(u Type) bool    // 判断值是否可以转换为 u 类型</li>
<li>Bits() int    // 返回类型比特的大小</li>
<li>ChanDir() ChanDir    // 返回信道的方向</li>
<li>IsVariadic() bool    // 返回函数的类型最后一个输入参数是否是“...”参数。</li>
<li>Elem() Type    // 指针指向内存地址</li>
<li>Key() Type    // 返回 Map 键Key的类型</li>
<li>Len() int    // 返回 Array 的长度</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

func main(){
	var a int
	var typeA reflect.Type = reflect.TypeOf(a)
	fmt.Println(typeA.String())
	//&gt;&gt;int
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="methodint-method"><a class="header" href="#methodint-method">Method(int) Method</a></h1>
<p>参数列表</p>
<ul>
<li>int 传入方法的索引号</li>
</ul>
<p>返回值：</p>
<ul>
<li>.Method  返回函数的 reflect.Method 类型</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.TypeOf(x).Method(x) 指定索引号返回struct结构绑定的方法</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

type A struct {
	A0 int
}
func (f A) test(){}
func (f A) test1(){}
func (f A) test2(){}

func main(){
	var a A
	var typeof reflect.Type = reflect.TypeOf(a)
	for i:=0; i&lt;typeof.NumMethod(); i++ {
		m := typeof.Method(i)
		fmt.Println(m.Index, m.PkgPath, m.Name, m.Type, m.Func)
		// 1 &gt;&gt;0 main test func(main.A) &lt;func(main.A) Value&gt;
		// 2 &gt;&gt;1 main test1 func(main.A) &lt;func(main.A) Value&gt;
		// 3 &gt;&gt;2 main test2 func(main.A) &lt;func(main.A) Value&gt;
	}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="methodbynamestring-method-bool"><a class="header" href="#methodbynamestring-method-bool">MethodByName(string) (Method, bool)</a></h1>
<p>参数列表</p>
<ul>
<li>string 传入“字符串”的函数名称</li>
</ul>
<p>返回值：</p>
<ul>
<li>.Method  返回函数的 reflect.Method 类型</li>
<li>bool 布尔值，如果找到指定的函数，返回true，则返回false。</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.TypeOf(interface{}).MethodByName(string) 使用“字符串”的函数名称返回函数的 reflect.Method 类型和一个布尔值。在struct结构中</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

type A struct {
	A0 int
}
func (f A) test(){}
func (f A) test1(){}
func (f A) test2(){}

func main(){
	var a A
	var typeof reflect.Type = reflect.TypeOf(a)
	var m, ok = typeof.MethodByName(&quot;test1&quot;)
	fmt.Println(ok, m.Index, m.PkgPath, m.Name, m.Type, m.Func)
	//&gt;&gt;true 1 main test1 func(main.A) &lt;func(main.A) Value&gt;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="name-string"><a class="header" href="#name-string">Name() string</a></h1>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>string 类型的名字</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.TypeOf(interface{}).Name() 返回类型的名字</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

func main(){
	var a int
	var typeof reflect.Type = reflect.TypeOf(a)
	fmt.Println(typeof.Name())
	//&gt;&gt;int
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="numfield-int"><a class="header" href="#numfield-int">NumField() int</a></h1>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>int 字段总数量</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.TypeOf(interface{}).NumField() 返回struct结构中的字段总数量</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

type A struct {
	A0 int
	A1 string
	A2 []byte
}

func main(){
	var a A
	var typeof reflect.Type = reflect.TypeOf(a)
	fmt.Println(typeof.NumField())
	//&gt;&gt;3
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="numin-int"><a class="header" href="#numin-int">NumIn() int</a></h1>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>int 函数传入参数的总数量</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.TypeOf(interface{}).NumIn() 函数传入参数的总数量，如果出现恐慌(panic)，该类型不是 Func。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

func main(){
	var a = func(a1 int, a2 string, a3 uint, a4 interface{}) {}
	var typeof reflect.Type = reflect.TypeOf(a)
	fmt.Println(typeof.NumIn())
	//&gt;&gt;4
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nummethod-int"><a class="header" href="#nummethod-int">NumMethod() int</a></h1>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>int 返回函数的总数量</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.TypeOf(x).NumMethod() 返回struct结构绑定的方法集。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

type A struct {
	A0 int
}
func (f A) test(){}
func (f A) test1(){}
func (f A) test2(){}

func main(){
	var a A
	var typeof reflect.Type = reflect.TypeOf(a)
	fmt.Println(typeof.NumMethod())
	//&gt;&gt;3
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="numout-int"><a class="header" href="#numout-int">NumOut() int</a></h1>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>int 函数输出参数总数量</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.TypeOf(interface{}).NumOut() 一个函数的输出参数总数量。如果出现恐慌（panic），表示该类型不是Func。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

func main(){
	var a = func() (int, string, uint, float64) {
		return 1, &quot;1&quot;, 2, 1.2
	}
	var typeof reflect.Type = reflect.TypeOf(a)
	fmt.Println(typeof.NumOut())
	//&gt;&gt;4
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="outi-int-type"><a class="header" href="#outi-int-type">Out(i int) Type</a></h1>
<p>参数列表</p>
<ul>
<li>i int 函数输出参数的索引号</li>
</ul>
<p>返回值：</p>
<ul>
<li>Type 函数输出参数的 reflect.Type 类型</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.TypeOf(interface{}).Out(int) 返回函数输出的参数类型。如果出现恐慌（panic），表示该类型不是Func或索引号超出范围。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

func main(){
	var a = func() (int, string, uint, float64) {
		return 1, &quot;1&quot;, 2, 1.2
	}
	var typeof reflect.Type = reflect.TypeOf(a)
	
	for i:=0; i&lt;typeof.NumOut(); i++ {
		fmt.Println(typeof.Out(i).Kind())
		// 0 &gt;&gt;int
		// 1 &gt;&gt;string
		// 2 &gt;&gt;uint
		// 3 &gt;&gt;float64
	}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pkgpath-string"><a class="header" href="#pkgpath-string">PkgPath() string</a></h1>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>string 包(package)的路径</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.TypeOf(interface{}).PkgPath() 返回包(package)的路径</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

func main(){
	type A struct {}
	var a A
	var typeof reflect.Type = reflect.TypeOf(a)
	fmt.Println(typeof.PkgPath())
	//&gt;&gt;main

	var b int
	typeof = reflect.TypeOf(b)
	fmt.Println(typeof.PkgPath())
	//&gt;&gt;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="size-uintptr"><a class="header" href="#size-uintptr">Size() uintptr</a></h1>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>uintptr 数据的字节数</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.TypeOf(interface{}).Size() 返回值存储的字节数，是类似 unsafe.Sizeof。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
    &quot;fmt&quot;
    &quot;reflect&quot;
	&quot;unsafe&quot;
)

func main(){
	var a int
	a = 1234
	var typeof reflect.Type = reflect.TypeOf(a)
	fmt.Println(typeof.Size(), unsafe.Sizeof(a)) //这两个功能是等介的
	//&gt;&gt;4 4
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="string-string"><a class="header" href="#string-string">String() string</a></h1>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>string 字符串表示的类型</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.TypeOf(interface{}).String() 返回一个字符串表示的类型</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

func main(){
	var a int
	var typeof reflect.Type = reflect.TypeOf(a)
	fmt.Println(typeof.String())
	//&gt;&gt;int
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-typeofi-interface-type"><a class="header" href="#func-typeofi-interface-type">func TypeOf(i interface{}) Type</a></h1>
<p>参数列表</p>
<ul>
<li>i interface{} 是一个接口类型，可以传入任何类型变量</li>
</ul>
<p>返回值：</p>
<ul>
<li>Type 返回反射类型 reflect.Type</li>
</ul>
<p>功能说明：</p>
<ul>
<li>TypeOf 返回interface{}接口的值反射它的类型。 TypeOf(nil) 返回nil。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
	&quot;fmt&quot;
	&quot;reflect&quot;
)

func main(){
	var a int
	var typeof reflect.Type = reflect.TypeOf(a)
	fmt.Println(typeof.String())
	//&gt;&gt;int
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-v-value-addr-value"><a class="header" href="#func-v-value-addr-value">func (v Value) Addr() Value</a></h1>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>Value 返回一个指针值的地址</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.ValueOf(interface{}).Addr() 返回一个指针值的地址，如果V 的 CanAddr() 返回false，它会出现恐慌（panic）。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

func main(){
	var a int
	var value reflect.Value = reflect.ValueOf(&amp;a)
	var ve = value.Elem()
	if ve.CanAddr() {
		fmt.Println(ve.Addr(), ve.Kind(), ve.Int())
		//&gt;&gt;&lt;*int Value&gt; int 0
	}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-v-value-bool"><a class="header" href="#func-v-value-bool">func (v Value) Bool()</a></h1>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>bool 布尔值</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.ValueOf(interface{}).Bool() 返回 v 的布尔值。如果出现恐慌（panic），表示值的类型不是Bool。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

func main(){
	var a bool // 默认值为 false
	var value reflect.Value = reflect.ValueOf(&amp;a)
	
	//判断指针是否指向内存地址
	if !value.CanSet() {
		value = value.Elem() //使指针指向内存地址
	}
	
	fmt.Println(value.Bool())
	//&gt;&gt;false
	
	a = true
	
	fmt.Println(value.Bool())
	//&gt;&gt;true
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-v-value-bytes-byte"><a class="header" href="#func-v-value-bytes-byte">func (v Value) Bytes() []byte</a></h1>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>[]byte 返回值的字节切片数据</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.ValueOf(interface{}).Bytes() 返回 v 的值（字节切片）。如果出现恐慌（panic)，表示v的值不是一个字节的切片。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

func main(){
	var a []byte
	var value reflect.Value = reflect.ValueOf(&amp;a)
	
	//判断指针是否指向内存地址
	if !value.CanSet() {
		value = value.Elem() //使指针指向内存地址
	}
	
	fmt.Println(value.Bytes())
	//&gt;&gt;[]
	
	a = []byte{1,2,3,4}
	
	fmt.Println(value.Bytes())
	//&gt;&gt;[1 2 3 4]
	
	fmt.Println(a)
	//[1 2 3 4]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-v-value-callin-value-value"><a class="header" href="#func-v-value-callin-value-value">func (v Value) Call(in []Value) []Value</a></h1>
<p>参数列表</p>
<ul>
<li>in []Value 切片的值是 reflect.Value 类型</li>
</ul>
<p>返回值：</p>
<ul>
<li>[]Value 从函数内以切片类型返回的多个值</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.ValueOf(interface{}).Call([]Value)  调用函数，in 切片装入函数的参数，并传到函数。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

func main(){
	var a = func(a1 int, a2 string, a3 float64) (int, string, float64){
		fmt.Println(a1, a2, a3)
		//&gt;&gt;123 456 123.456
		return a1, a2, a3
	}
	
	var value reflect.Value = reflect.ValueOf(a)
	var tt []reflect.Value
	tt = append(tt, reflect.ValueOf(123))
	tt = append(tt, reflect.ValueOf(&quot;456&quot;))
	tt = append(tt, reflect.ValueOf(123.456))
	var tt1 []reflect.Value = value.Call(tt)
	fmt.Println(tt1[0], tt1[1], tt1[2])
	//&gt;&gt;&lt;int Value&gt; 456 &lt;float64 Value&gt;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-v-value-callslicein-value-value"><a class="header" href="#func-v-value-callslicein-value-value">func (v Value) CallSlice(in []Value) []Value</a></h1>
<p>参数列表</p>
<ul>
<li>in []Value 切片的值是 reflect.Value 类型</li>
</ul>
<p>返回值：</p>
<ul>
<li>[]Value 从函数内以切片类型返回的多个值，值是 reflect.Value 类型</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.ValueOf(interface{}).CallSlice([]Value)  调用函数，in 切片装入参数，传到函数。用于可变参数函数。例如，if len(in) == 3，v.Call(in) 表示的go调用 test(in[0], in[1], in[2]...)。如果调用时出现恐慌（panic），表示类型的Kind不是Func，或者test不是可变参数。返回输出结果的Value。在GO中，每个输入参数必须是分配给函数的相应的输入参数的类型。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

func main(){
	var a = func(a1 int, a2 string, a3 ...float64) (int, string, []float64){
		fmt.Println(a1, a2, a3)
		//&gt;&gt;123 456 [1.1 2.2 3.3 4.4 5 5]
		return a1, a2, a3
	}
	
	var value reflect.Value = reflect.ValueOf(a)
	var tt []reflect.Value
	tt = append(tt, reflect.ValueOf(123))
	tt = append(tt, reflect.ValueOf(&quot;456&quot;))
	tt = append(tt, reflect.ValueOf([]float64{1.1, 2.2, 3.3, 4.4, 5,5}))
	var tt1 []reflect.Value = value.CallSlice(tt)
	fmt.Println(tt1)
	//&gt;&gt;[&lt;int Value&gt; 456 &lt;[]float64 Value&gt;]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-v-value-canaddr-bool"><a class="header" href="#func-v-value-canaddr-bool">func (v Value) CanAddr() bool</a></h1>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>bool 如果该值的地址可以得到寻址， 返回true。否则返回false。</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.ValueOf(interface{}).CanAddr()  如果该值的地址可以得到寻址，返回true。这样的值被称为寻址。如果元素它是一个切片，值是可寻址的。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

func main(){
	var a  int
	var value reflect.Value = reflect.ValueOf(&amp;a)
	fmt.Println(value.CanAddr(), value.Elem().CanAddr())
	//&gt;&gt;false true
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-v-value-caninterface-bool"><a class="header" href="#func-v-value-caninterface-bool">func (v Value) CanInterface() bool</a></h1>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>bool 如果值支持接口方式读出，返回true，否则返回false。</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.ValueOf(interface{}).CanInterface()  判断值是否可以做为 interface{} 类型读出</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

type A struct {
	A0 string
	A1 int
}
func (f A) test(){}
func (f A) test1(){}

func main(){
	var a A
	var value reflect.Value = reflect.ValueOf(a)
	for i:=0; i&lt;value.NumField(); i++ {
		vf := value.Field(i)
		fmt.Println(vf.CanInterface())
		// 0 &gt;&gt;true
		// 1 &gt;&gt;true
	}
	for i:=0; i&lt;value.NumMethod(); i++ {
		vf := value.Method(i)
		fmt.Println(vf.CanInterface())
		// 0 &gt;&gt;false
		// 1 &gt;&gt;false
	}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-v-value-canset-bool"><a class="header" href="#func-v-value-canset-bool">func (v Value) CanSet() bool</a></h1>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>bool 如果v的值可以更改或写入新值，返回true，否则返回false。</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.ValueOf(interface{}).CanSet() 如果v的值可以更改或写入新值，返回true。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

func main(){
	var a int
	var value reflect.Value = reflect.ValueOf(&amp;a)
	fmt.Println(value.CanSet())
	//&gt;&gt;false

	if !value.CanSet() {
		value = value.Elem() //使指针指向内存地址
	}

	fmt.Println(value.CanSet())
	//&gt;&gt;true
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-v-value-cap-int"><a class="header" href="#func-v-value-cap-int">func (v Value) Cap() int</a></h1>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>int 容量</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.ValueOf(interface{}).Cap() 返回 v 的容量。如果出现恐慌，表示 v 的Kind不是Array，Chan，Slice。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
	&quot;fmt&quot;
	&quot;reflect&quot;
)

func main(){
	var a []int
	a = make([]int, 9, 12)
	var value reflect.Value = reflect.ValueOf(&amp;a)
	
	//判断指针是否指向内存地址
	if !value.CanSet() {
		value = value.Elem() //使指针指向内存地址
	}
	
	fmt.Println(value.Cap())
	//&gt;&gt;12
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-v-value-close"><a class="header" href="#func-v-value-close">func (v Value) Close()</a></h1>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>无</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.ValueOf(interface{}).Close() 关闭 v 的信道。如果出现恐慌，表示v的Kind不是Chan。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
	&quot;fmt&quot;
	&quot;reflect&quot;
)

func main(){
	var a chan int
	a = make(chan int,1)
	var value reflect.Value = reflect.ValueOf(&amp;a)
	
	//判断指针是否指向内存地址
	if !value.CanSet() {
		value = value.Elem() //使指针指向内存地址
	}
	
	var gotest = func(c chan int, v *reflect.Value) {
		c&lt;-1
		v.Close() //信道关闭
	}
	go gotest(a,&amp;value)
	 var v ,ok = &lt;-a
	fmt.Println(v, ok)
	//&gt;&gt;1 true
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-v-value-complex-complex128"><a class="header" href="#func-v-value-complex-complex128">func (v Value) Complex() complex128</a></h1>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>complex128  以最大复数的complex128类型返回值。</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.ValueOf(interface{}).Complex() 返回 v 的值。如果出现恐慌，表示v的值不是Complex64 或Complex128 类型。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

func main(){
	var a complex64
	var value reflect.Value = reflect.ValueOf(&amp;a)
	
	//判断指针是否指向内存地址
	if !value.CanSet() {
		value = value.Elem() //使指针指向内存地址
	}
	
	fmt.Println(value.Complex())
	//&gt;&gt;(0+0i)
	
	a = 1+5i
	
	fmt.Println(value.Complex())
	//&gt;&gt;(1+5i)
	
	fmt.Println(a)
	//&gt;&gt;(1+5i)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-v-value-convertt-type-value"><a class="header" href="#func-v-value-convertt-type-value">func (v Value) Convert(t Type) Value</a></h1>
<p>参数列表</p>
<ul>
<li>t Type 另一个类型的reflect.Type</li>
</ul>
<p>返回值：</p>
<ul>
<li>Value 返回 reflect.Value 类型，更多方法可以查看reflect.Value 结构中绑定的方法</li>
</ul>
<p>功能说明：</p>
<ul>
<li>Convert 返回被 v 转换为类型 t 。如果通常Go转换规则不容许值v转换为类型t，转换将恐慌(panic)。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
	&quot;fmt&quot;
	&quot;reflect&quot;
)

func main(){
	var a int = 65 //A
	var b string = &quot;string&quot;
	var valueOf reflect.Value = reflect.ValueOf(a)
	var convert reflect.Value = valueOf.Convert(reflect.TypeOf(b))
	fmt.Println(convert.Kind(), convert.String())
	//string A
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-v-value-elem-value"><a class="header" href="#func-v-value-elem-value">func (v Value) Elem() Value</a></h1>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>Value 返回一个直接指向内存地址的 reflect.Value 类型</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.ValueOf(interface{}).Elem() 将指针地址指向内存地址，如果出现恐慌（panic），表示该类型不是 Ptr</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
	&quot;fmt&quot;
	&quot;reflect&quot;
)

func main(){
	var a int
	var value reflect.Value = reflect.ValueOf(&amp;a)
	fmt.Println(value.Kind(), value.Elem().Kind())
	//&gt;&gt;ptr int
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-v-value-fieldi-int-value"><a class="header" href="#func-v-value-fieldi-int-value">func (v Value) Field(i int) Value</a></h1>
<p>参数列表</p>
<ul>
<li>i int 字段的索引号</li>
</ul>
<p>返回值：</p>
<ul>
<li>Value  指定字段的返回 reflect.Vaue 类型</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.ValueOf(interface{}).Field(int) 指定索引号返回struct中字段的 Value 类型。如果出现恐慌(panic)，表示该类型不是struct。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

type A struct {
	A0 int
	A1 string
	A2 uint
	A4 float64
	A5 interface{}
}

func main(){
	var a A
	var value reflect.Value = reflect.ValueOf(a)
	for i:=0; i&lt;value.NumField(); i++ {
		vf := value.Field(i)
		fmt.Println(vf.Kind(), vf.Interface()) //Value 的方法有N多，这里就不一一演示。后面将一一介绍
		// 0 &gt;&gt;int 0
		// 1 &gt;&gt;string 
		// 2 &gt;&gt;uint 0
		// 3 &gt;&gt;float64 0
		// 4 &gt;&gt;interface &lt;nil&gt;
	}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-v-value-fieldbyindexindex-int-value"><a class="header" href="#func-v-value-fieldbyindexindex-int-value">func (v Value) FieldByIndex(index []int) Value</a></h1>
<p>参数列表</p>
<ul>
<li>index []int 嵌套字段的索引号</li>
</ul>
<p>返回值：</p>
<ul>
<li>Value  指定字段的返回 reflect.Vaue 类型</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.ValueOf(interface{}).FieldByIndex([]int) 对应索引号返回嵌套字段的 Value 类型。如果出现恐慌(panic)，表示该类型不是struct。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

type A struct {
	A0 int
	A1 B
}
type B struct {
	B0 string
}

func main(){
	var a A
	var value reflect.Value = reflect.ValueOf(a)
	var tt = []int{1,0} //1 表示 A1 B，0 表示 B0 string
	vf := value.FieldByIndex(tt)
	fmt.Println(vf.Kind(), vf.String(), vf.Kind() == reflect.String)
	//&gt;&gt;string  true
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-v-value-fieldbynamename-string-value"><a class="header" href="#func-v-value-fieldbynamename-string-value">func (v Value) FieldByName(name string) Value</a></h1>
<p>参数列表</p>
<ul>
<li>name string 指定一个“字符串”的字段名称</li>
</ul>
<p>返回值：</p>
<ul>
<li>Value  指定字段的返回 reflect.Vaue 类型</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.ValueOf(interface{}).FieldByName(string) 指定一个“字符串”字段名称返回字段的 Value 类型。如果出现恐慌(panic)，表示该类型不是struct。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

type A struct {
	A0 int
	A1 uint
}
func main(){
	var a A
	var value reflect.Value = reflect.ValueOf(a)
	vf := value.FieldByName(&quot;A1&quot;)
	fmt.Println(vf.Kind(), vf.Uint(), vf.Kind() == reflect.Uint)
	//&gt;&gt;uint 0 true
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-v-value-fieldbynamefuncmatch-funcstring-bool-value"><a class="header" href="#func-v-value-fieldbynamefuncmatch-funcstring-bool-value">func (v Value) FieldByNameFunc(match func(string) bool) Value</a></h1>
<p>参数列表</p>
<ul>
<li>match func(string) bool 使用函数功能来筛选想要的字段。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Value  返回字段的 reflect.Vaue 类型</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.ValueOf(interface{}).FieldByNameFunc(func(string) bool) 传入字段“字符串”名称，并判断，func 返回 true，返回字段的 Value 类型。如果出现恐慌(panic)，表示该类型不是struct。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

type A struct {
	A0 int
	A1 uint
}
func main(){
	var f = func(s string) bool {
		if s == &quot;A1&quot; { // 结合正则匹配，功能最强大。
			return true
		}
		return false
	}
	var a A
	var value reflect.Value = reflect.ValueOf(a)
	vf := value.FieldByNameFunc(f)
	fmt.Println(vf.Kind(), vf.Uint(), vf.Kind() == reflect.Uint)
	//&gt;&gt;uint 0 true
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-v-value-float-float64"><a class="header" href="#func-v-value-float-float64">func (v Value) Float() float64</a></h1>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>float64  以最大浮点数的float64类型返回值。</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.ValueOf(interface{}).Float() 返回 v 的值。如果出现恐慌，表示v的值不是Float64 或Float32 类型。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

func main(){
	var a float64
	var value reflect.Value = reflect.ValueOf(&amp;a)
	
	//判断指针是否指向内存地址
	if !value.CanSet() {
		value = value.Elem() //使指针指向内存地址
	}
	
	fmt.Println(value.Float())
	//&gt;&gt;0
	
	a = 1.2
	
	fmt.Println(value.Float())
	//&gt;&gt;1.2
	
	fmt.Println(a)
	//&gt;&gt;1.2
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-v-value-indexi-int-value"><a class="header" href="#func-v-value-indexi-int-value">func (v Value) Index(i int) Value</a></h1>
<p>参数列表</p>
<ul>
<li>i int 切片的序号(整数)</li>
</ul>
<p>返回值：</p>
<ul>
<li>Value 返回指定切片中的第i切片 reflect.Value 类型</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.ValueOf(interface{}).Index(int)  返回Array或Slice类型的第i个切片。如果出现恐慌(panic)，表示该类型不是Array、Slice或i超出了范围。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

type A struct {
	A0 []string
}
func main(){
	var a A
	a.A0 = append(a.A0, []string{&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;}...) //等介于 &quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;
	var value reflect.Value = reflect.ValueOf(a)
	vf := value.Field(0).Index(3)
	fmt.Println(vf.String(), vf.Kind() == reflect.String)
	//&gt;&gt;d true
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-v-value-int-int64"><a class="header" href="#func-v-value-int-int64">func (v Value) Int() int64</a></h1>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>int64 以最大整数的int64类型返回值。</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.ValueOf(interface{}).Int() 以最大整数的int64类型返回 v 的值。如果出现恐慌（panic），表示v的值不是Int，Int8，Int16，Int32，或Int64 类型。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

func main(){
	var a int
	var value reflect.Value = reflect.ValueOf(&amp;a)
	
	//判断指针是否指向内存地址
	if !value.CanSet() {
		value = value.Elem() //使指针指向内存地址
	}
	
	fmt.Println(value.Int())
	//&gt;&gt;0
	
	a = 123
	
	fmt.Println(value.Int())
	//&gt;&gt;123
	
	fmt.Println(a)
	//123
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-v-value-interface-i-interface"><a class="header" href="#func-v-value-interface-i-interface">func (v Value) Interface() (i interface{})</a></h1>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>i interface{} 返回一个接口类型的值</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.ValueOf(interface{}).Interface()  以接口类型读出数据</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

type A struct {
	A0 string
	A1 int
}
func (f A) test(){}
func (f A) test1(){}

func main(){
	var a A
	var value reflect.Value = reflect.ValueOf(a)
	//字段的类型都是可以支持 Interface() 方法读出值
	for i:=0; i&lt;value.NumField(); i++ {
		vf := value.Field(i)
		if vf.CanInterface() {
			fmt.Println(vf.Interface())
			// 0 &gt;&gt;0
			// 1 &gt;&gt;0
		}
	}
	
	//方法就不可使用 Interface() 方法读出值，因为方法没有值。
	for i:=0; i&lt;value.NumMethod(); i++ {
		vf := value.Method(i)
		if !vf.CanInterface() {
			fmt.Println(&quot;vf.CanInterface() == false&quot;)
			// 0 &gt;&gt;vf.CanInterface() == false
			// 1 &gt;&gt;vf.CanInterface() == false
		}
	}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-v-value-interfacedata-2uintptr"><a class="header" href="#func-v-value-interfacedata-2uintptr">func (v Value) InterfaceData() [2]uintptr</a></h1>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>[2]uintptr 返回一对作为uintptr的接口值</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.ValueOf(interface{}).InterfaceData()  返回一对作为uintptr的接口值，如果出现恐慌，表示该类型没有接口。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

type A struct {
	A0 float64
	A1 B
}
type B interface {}

func main(){
	var a A
	var value reflect.Value = reflect.ValueOf(a)
	fmt.Println(value.Field(1).InterfaceData())
	//&gt;&gt;[0 0]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-v-value-isnil-bool"><a class="header" href="#func-v-value-isnil-bool">func (v Value) IsNil() bool</a></h1>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>bool 如果是空值返回true，否则返回false。</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.ValueOf(interface{}).IsNil()  判断值是否是 nil，限制支持 Chan，Func，Interface，Map，Ptr，或Slice。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

func main(){
	var a chan int
	var value reflect.Value = reflect.ValueOf(&amp;a)
	fmt.Println(value.IsNil())
	//&gt;&gt;false
	
	var b []uintptr
	var value1 reflect.Value = reflect.ValueOf(b)
	fmt.Println(value1.IsNil())
	//&gt;&gt;true
	
	b = append(b, 123) //赋值 123
	value1 = reflect.ValueOf(b)
	fmt.Println(value1.IsNil()) // 赋值后，不再是空值
	//&gt;&gt;false
	
	var c func()
	var value2 reflect.Value = reflect.ValueOf(c)
	fmt.Println(value2.IsNil())
	//&gt;&gt;true
	
	var d map[int]string
	var value3 reflect.Value = reflect.ValueOf(d)
	fmt.Println(value3.IsNil())
	//&gt;&gt;true

}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-v-value-isvalid-bool"><a class="header" href="#func-v-value-isvalid-bool">func (v Value) IsValid() bool</a></h1>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>bool 如果是零值返回true，否则返回false。</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.ValueOf(interface{}).IsValid()  如果v代表一个值，返回true。如果v是零值，则返回false。零值不是变量初始化值。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

func main(){
	var a struct{}
	var value reflect.Value = reflect.ValueOf(a)
	fmt.Println(value.IsValid())
	//&gt;&gt;true
	
	var b interface{}
	var value1 reflect.Value = reflect.ValueOf(b)
	fmt.Println(value1.IsValid())
	//&gt;&gt;false
	
	var c int
	var value2 reflect.Value = reflect.ValueOf(c)
	fmt.Println(value2.IsValid())
	//&gt;&gt;true
	
	var d string
	var value3 reflect.Value = reflect.ValueOf(d)
	fmt.Println(value3.IsValid())
	//&gt;&gt;true
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-v-value-kind-kind"><a class="header" href="#func-v-value-kind-kind">func (v Value) Kind() Kind</a></h1>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>Kind 一种特定的 reflect.Kind 类型</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.ValueOf(interface{}).Kind()  返回特定的一种类型 reflect.Kind，如果v是零值（IsValid返回false），返回无效的Kind。。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

func main(){
	var a string = &quot;A&quot;
	var value reflect.Value = reflect.ValueOf(a)
	fmt.Println(value.String(), value.Kind() == reflect.String)
	//&gt;&gt;A true
	
	var b int = 999
	var value1 reflect.Value = reflect.ValueOf(b)
	fmt.Println(value1.Int(), value1.Kind() == reflect.Int)
	//&gt;&gt;999 true
	
	var c float64 = 999.999
	var value2 reflect.Value = reflect.ValueOf(c)
	fmt.Println(value2.Float(), value2.Kind() == reflect.Float64)
	//&gt;&gt;999.999 true
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-v-value-len-int"><a class="header" href="#func-v-value-len-int">func (v Value) Len() int</a></h1>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>int 长度</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.ValueOf(interface{}).Len() 返回 v 的长度。如果出现恐慌，表示 v 的Kind不是Array，Chan，Map，Slice，或String。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
	&quot;fmt&quot;
	&quot;reflect&quot;
)

func main(){
	var a []int
	a = make([]int, 9)
	var value reflect.Value = reflect.ValueOf(&amp;a)
	
	//判断指针是否指向内存地址
	if !value.CanSet() {
		value = value.Elem() //使指针指向内存地址
	}
	
	fmt.Println(value.Len())
	//&gt;&gt;9
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-v-value-mapindexkey-value-value"><a class="header" href="#func-v-value-mapindexkey-value-value">func (v Value) MapIndex(key Value) Value</a></h1>
<p>参数列表</p>
<ul>
<li>key Value 传入Map的键Key，类型是 reflect.Value</li>
</ul>
<p>返回值：</p>
<ul>
<li>Value 返回Map的值，类型是 reflect.Value</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.ValueOf(interface{}).MapIndex(reflect.Value) 指定键Key返回在v上的Map值。如果出现恐慌（panic），表示v的Kind不是Map。如果key在Map上没有找到，或v的Map是一个零Map，它返回零值。在Go中，该键的值必须是分配给map的键类型。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
	&quot;fmt&quot;
	&quot;reflect&quot;
)

func main(){
	var a = map[string]int{
		&quot;a&quot;:1,
		&quot;b&quot;:2,
		&quot;c&quot;:3,
		&quot;d&quot;:4,
		&quot;e&quot;:5,
	}
	var value reflect.Value = reflect.ValueOf(&amp;a)
	
	//判断指针是否指向内存地址
	if !value.CanSet() {
		value = value.Elem() //使指针指向内存地址
	}
	
	var(
		mv reflect.Value
		keys []reflect.Value = value.MapKeys() //返回无顺序的Keys
	)
	for i := 0; i&lt;len(keys); i++ {
		mv = value.MapIndex(keys[i]) //使用Key名称指定返回值
		fmt.Println(keys[i].String(), mv.Int())
		// 0 &gt;&gt;c 3
		// 1 &gt;&gt;d 4
		// 2 &gt;&gt;e 5
		// 3 &gt;&gt;a 1
		// 4 &gt;&gt;b 2
	}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-v-value-mapkeys-value"><a class="header" href="#func-v-value-mapkeys-value">func (v Value) MapKeys() []Value</a></h1>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>[]Value 返回一个切片包含的所有键Key</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.ValueOf(interface{}).MapKeys() 返回一个切片包含的所有键Key，无顺序。如果出现恐慌（panic），表示 v 的Kind不是Map。如果v是一个零的Map，它返回一个空切片。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
	&quot;fmt&quot;
	&quot;reflect&quot;
)

func main(){
	var a = map[string]int{
		&quot;a&quot;:1,
		&quot;b&quot;:2,
		&quot;c&quot;:3,
		&quot;d&quot;:4,
		&quot;e&quot;:5,
	}
	var value reflect.Value = reflect.ValueOf(&amp;a)
	
	//判断指针是否指向内存地址
	if !value.CanSet() {
		value = value.Elem() //使指针指向内存地址
	}
	
	fmt.Println(value.MapKeys()) //无顺序的返回Key
	//&gt;&gt;[c e a d b]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-value-1"><a class="header" href="#type-value-1">type Value</a></h1>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>无</li>
</ul>
<p>功能说明：</p>
<ul>
<li>refelct.Value 是反射Go的接口值。
<ul>
<li>以下函数返回 reflect.Value 类型</li>
<li>func Append(s Value, x ...Value) Value                // 追加Slice</li>
<li>func AppendSlice(s, t Value) Value                  // 批量追加Slice</li>
<li>func Indirect(v Value) Value                    // 返回指针源内存地址</li>
<li>func MakeChan(typ Type, buffer int) Value              // 初始化信道</li>
<li>func MakeMap(typ Type) Value                    // 初始化Map</li>
<li>func MakeSlice(typ Type, len, cap int) Value            // 初始化Slice</li>
<li>func New(typ Type) Value                      // 初始化并返回指针</li>
<li>func NewAt(typ Type, p unsafe.Pointer) Value            // 初始化 p 并返回指针，转向给 typ</li>
<li>func Zero(typ Type) Value                      // 初始化 typ 为零值</li>
<li>func ValueOf(i interface{}) Value                  // 返回反射interface{}接口的值
<ul>
<li>以下都是 reflect.Value 的方法</li>
<li>func (v Value) Elem() Value                      // 指针指向内存地址</li>
<li>func (v Value) Type() Type                      // 返回类型 rflect.Type</li>
<li>func (v Value) NumField() int                    // 字段总数量，在struct结构中</li>
<li>func (v Value) Field(i int) Value                  // 指定返回字段的 Value 类型，在struct结构中</li>
<li>func (v Value) FieldByIndex(index []int) Value            // 指定返回“嵌套”字段的 Value 类型，在struct结构中</li>
<li>func (v Value) FieldByName(name string) Value            // 使用“字符串”字段名称返回字段的 Value 类型，在struct结构中</li>
<li>func (v Value) FieldByNameFunc(match func(string) bool) Value    // 传入字段“字符串”名称，并判断，func 返回 true，返回字段的 Value 类型，在struct结构中</li>
<li>func (v Value) NumMethod() int                    // 函数总数量，在struct结构中</li>
<li>func (v Value) Method(i int) Value                  // 指定返回函数的 Value 类型，在struct结构中</li>
<li>func (v Value) MethodByName(name string) Value            // 使用“字符串”函数名称返回函数的 Value 类型，在struct结构中</li>
<li>func (v Value) Index(i int) Value                  // 返回Array或Slice类型的第i个切片，在struct结构中</li>
<li>func (v Value) Kind() Kind                      // 值的类型</li>
<li>func (v Value) Call(in []Value) []Value                // 调用函数，in 切片装入参数，传入函数</li>
<li>func (v Value) CallSlice(in []Value) []Value            // 调用函数，in 切片装入参数，传入函数。用于可变参数函数</li>
<li>func (v Value) IsValid() bool                    // 判断值是否是零值</li>
<li>func (v Value) IsNil() bool                      // 判断值是否是 nil，限制支持 Chan，Func，Interface，Map，Ptr，或Slice</li>
<li>func (v Value) CanInterface() bool                  // 判断值是否可以做为 interface{} 类型读出</li>
<li>func (v Value) Interface() (i interface{})              // 以接口类型读出数据</li>
<li>func (v Value) InterfaceData() [2]uintptr              // 返回一对作为uintptr的接口值</li>
<li>func (v Value) Slice(beg, end int) Value              // 返回指定长度的切片</li>
<li>func (v Value) Addr() Value                      // 返回指针</li>
<li>func (v Value) UnsafeAddr() uintptr                  // 返回安全指针</li>
<li>func (v Value) CanAddr() bool                    // 判断是否是可以寻址</li>
<li>func (v Value) CanSet() bool                    // 判断是否可以写入值</li>
<li>func (v Value) Bool() bool                      // 返回 Bool 类型的值</li>
<li>func (v Value) SetBool(x bool)                    // 写入 Bool 类型的值</li>
<li>func (v Value) Bytes() []byte                    // 返回 Byte 类型的值</li>
<li>func (v Value) SetBytes(x []byte)                  // 写入 Byte 类型的值</li>
<li>func (v Value) Int() int64                      // 返回 Int 类型的值</li>
<li>func (v Value) OverflowInt(x int64) bool              // 判断 Int 类型的值承受范围</li>
<li>func (v Value) SetInt(x int64)                    // 写入 Int 类型的值</li>
<li>func (v Value) Uint() uint64                    // 返回 Uint 类型的值</li>
<li>func (v Value) OverflowUint(x uint64) bool              // 判断 Uint 类型的值承受范围</li>
<li>func (v Value) SetUint(x uint64)                  // 写入 Uint 类型的值</li>
<li>func (v Value) Float() float64                    // 返回 Float 类型的值</li>
<li>func (v Value) OverflowFloat(x float64) bool            // 判断 Float 类型的值承受范围</li>
<li>func (v Value) SetFloat(x float64)                  // 写入 Float 类型的值</li>
<li>func (v Value) Complex() complex128                  // 返回 Complex 类型的值</li>
<li>func (v Value) OverflowComplex(x complex128) bool          // 判断 Complex 类型的值承受范围</li>
<li>func (v Value) SetComplex(x complex128)                // 写入 Complex 类型的值</li>
<li>func (v Value) Pointer() uintptr                  // 返回指针（整数）</li>
<li>func (v Value) SetPointer(x unsafe.Pointer)              // 写入新的指针</li>
<li>func (v Value) String() string                    // 返回 String 类型的值</li>
<li>func (v Value) SetString(x string)                  // 写入 String 类型的值</li>
<li>func (v Value) MapKeys() []Value                  // 返回 Map 中的所有 Key 名称</li>
<li>func (v Value) MapIndex(key Value) Value              // 返回 Map 中 Key 的值</li>
<li>func (v Value) SetMapIndex(key, val Value)              // 设置 Mep 的 值</li>
<li>func (v Value) Len() int                      // 返回 Array，Array 长度</li>
<li>func (v Value) Cap() int                      // 返回 Slice 容量</li>
<li>func (v Value) SetLen(n int)                    // 改变 Slice 长度</li>
<li>func (v Value) Set(x Value)                      // 写入新值，支持所有类型</li>
<li>func (v Value) Recv() (x Value, ok bool)              // 信道接收</li>
<li>func (v Value) Send(x Value)                    // 信道发送</li>
<li>func (v Value) TryRecv() (x Value, ok bool)              // 信道尝式接收</li>
<li>func (v Value) TrySend(x Value) bool                // 信道尝式发送</li>
<li>func (v Value) Close()                        // 关闭信道</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

func main(){
	var a int = 123456
	var value reflect.Value = reflect.ValueOf(a)
	fmt.Println(value.Int())
	//&gt;&gt;123456
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-v-value-methodi-int-value"><a class="header" href="#func-v-value-methodi-int-value">func (v Value) Method(i int) Value</a></h1>
<p>参数列表</p>
<ul>
<li>i int 传入方法的索引号</li>
</ul>
<p>返回值：</p>
<ul>
<li>Value 返回结构绑定的方法 reflect.Value 类型</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.ValueOf(interface{}).Method(int) 指定方法索引号返回结构绑定的方法 reflect.Value 类型。如果出现恐慌(panic)，表示该类型不是struct。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

type A struct {
}
func (p A) test(){}
func (p A) test1(){}

func main(){
	var a A
	var value reflect.Value = reflect.ValueOf(a)
	for i:=0; i&lt;value.NumMethod(); i++ {
		vf := value.Method(i)
		fmt.Println(vf.Kind(), vf.Kind() == reflect.Func)
		// 0 &gt;&gt;func true
		// 1 &gt;&gt;func true
	}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-v-value-methodbynamename-string-value"><a class="header" href="#func-v-value-methodbynamename-string-value">func (v Value) MethodByName(name string) Value</a></h1>
<p>参数列表</p>
<ul>
<li>name string 传入方法的&quot;字符串&quot;名称</li>
</ul>
<p>返回值：</p>
<ul>
<li>Value 返回结构绑定的方法 reflect.Value 类型</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.ValueOf(interface{}).MethodByName(string)  指定一个“字符串”的方法名称返回方法的 reflect.Value 类型。如果出现恐慌(panic)，表示该类型不是struct。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

type A struct {
}
func (p A) test(){}
func (p A) test1(){}

func main(){
	var a A
	var value reflect.Value = reflect.ValueOf(a)
	vf := value.MethodByName(&quot;test1&quot;)
	fmt.Println(vf.Kind(), vf.Kind() == reflect.Func)
	//&gt;&gt;func true
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-v-value-numfield-int"><a class="header" href="#func-v-value-numfield-int">func (v Value) NumField() int</a></h1>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>int  返回字段的数量</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.ValueOf(interface{}).NumField() 返回struct结构的字段数量。如果出现恐慌(panic)，表示该类型不是struct。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

type A struct {
	A0 int
	A1 string
	A2 uint
	A4 float64
	A5 interface{}
}

func main(){
	var a A
	var value reflect.Value = reflect.ValueOf(a)
	fmt.Println(value.NumField())
	//&gt;&gt;5
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-v-value-nummethod-int"><a class="header" href="#func-v-value-nummethod-int">func (v Value) NumMethod() int</a></h1>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>int 返回结构绑定的方法数量</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.ValueOf(interface{}).NumMethod() 绑定在结构中的方法数量。如果出现恐慌(panic)，表示该类型不是struct。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

type A struct {
}
func (p A) test(){}
func (p A) test1(){}

func main(){
	var a A
	var value reflect.Value = reflect.ValueOf(a)
	fmt.Println(value.NumMethod())
	//&gt;&gt;2
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-v-value-overflowcomplexx-complex128-bool"><a class="header" href="#func-v-value-overflowcomplexx-complex128-bool">func (v Value) OverflowComplex(x complex128) bool</a></h1>
<p>参数列表</p>
<ul>
<li>x complex128 传入参数必须是complex128类型，以最大范围。</li>
</ul>
<p>返回值：</p>
<ul>
<li>bool 如果判断值超出范围，返回true，否则返回false。</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.ValueOf(interface{}).OverflowComplex(complex128) 判断 complex 是否溢出。如果出现恐慌（panic），表示v的值不是Complex64 或Complex128 类型。
<ul>
<li>如果Complex64类型存储的值超出了该类型可容纳的范围，返回true，否则返回false。</li>
<li>警告：如果Complex128类型存储的值超出了该类型可容纳的范围，返回错误，否则返回false。
<ul>
<li>Complex各类型存储范围：</li>
<li>Complex64 值类型表示值介于 -3.4028234663852884e+38 到 3.4028234663852884e+38  // 2<strong>127 * (2</strong>24 - 1) / 2**23</li>
<li>Complex128 值类型表示值介于 -1.7976931348623158e+308 到 1.7976931348623158e+308 // 2<strong>1023 * (2</strong>53 - 1) / 2**52</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

func main(){
	var a complex64
	var value reflect.Value = reflect.ValueOf(&amp;a)
	
	//判断指针是否指向内存地址
	if !value.CanSet() {
		value = value.Elem() //使指针指向内存地址
	}
	
	var i complex128 = 3.4028234663852884e+38 + 3.4028234663852884e+38i
	if value.OverflowComplex(i) {
		fmt.Println(&quot;溢出：超出范围&quot;)
	}else {
		fmt.Println(&quot;正常：范围之内&quot;)
	}
	//&gt;&gt;正常：范围之内
	
	i = 3.4028234663852885e+38 + 3.4028234663852884e+38i
	if value.OverflowComplex(i) {
		fmt.Println(&quot;溢出：超出范围&quot;)
	}else {
		fmt.Println(&quot;正常：范围之内&quot;)
	}
	//&gt;&gt;溢出：超出范围
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-v-value-overflowfloatx-float64-bool"><a class="header" href="#func-v-value-overflowfloatx-float64-bool">func (v Value) OverflowFloat(x float64) bool</a></h1>
<p>参数列表</p>
<ul>
<li>float64 传入参数必须是Float64，以最大范围。</li>
</ul>
<p>返回值：</p>
<ul>
<li>bool 如果float类型的值范出范围，返回true，否则返回false。</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.ValueOf(interface{}).OverflowFloat(float64) 判断float 溢出。如果出现恐慌，表示v的值不是Float64 或Float32 类型。
<ul>
<li>如果float32类型存储的值超出了该类型可容纳的范围，返回true，否则返回false。</li>
<li>警告：如果float64类型存储的值超出了该类型可容纳的范围，返回错误，否则返回false。
<ul>
<li>float各类型存储范围：</li>
<li>Float32 值类型表示值介于 -3.4028234663852884e+38 到 3.4028234663852884e+38  // 2<strong>127 * (2</strong>24 - 1) / 2**23</li>
<li>Float64 值类型表示值介于 -1.7976931348623158e+308 到 1.7976931348623158e+308 // 2<strong>1023 * (2</strong>53 - 1) / 2**52</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

func main(){
	var a float32 //注意：类型是float32
	var value reflect.Value = reflect.ValueOf(&amp;a)
	
	//判断指针是否指向内存地址
	if !value.CanSet() {
		value = value.Elem() //使指针指向内存地址
	}
	
	var i float64 = 3.4028234663852884e+38
	if value.OverflowFloat(i) {
		fmt.Println(&quot;溢出：超出范围&quot;)
	}else {
		fmt.Println(&quot;正常：范围之内&quot;)
	}
	//&gt;&gt;正常：范围之内
	
	i = 1.7976931348623158e+308
	if value.OverflowFloat(i) {
		fmt.Println(&quot;溢出：超出范围&quot;)
	}else {
		fmt.Println(&quot;正常：范围之内&quot;)
	}
	//&gt;&gt;溢出：超出范围
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-v-value-overflowintx-int64-bool"><a class="header" href="#func-v-value-overflowintx-int64-bool">func (v Value) OverflowInt(x int64) bool</a></h1>
<p>参数列表</p>
<ul>
<li>x int64 传入参数必须是int64，以最大范围。</li>
</ul>
<p>返回值：</p>
<ul>
<li>bool 值超出范围，返回true，否则返回false</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.ValueOf(interface{}).OverflowInt(int64) 判断值是否溢出。如果出现恐慌，表示v的值不是Int，Int8，Int16，Int32，或Int64 类型。
<ul>
<li>如果int16或Int32类型存储的值超出了该类型可容纳的范围，返回true，否则返回false。</li>
<li>警告：如果int64类型存储的值超出了该类型可容纳的范围，返回错误，否则返回false。</li>
<li>int各类型存储范围：
<ul>
<li>Int8  值类型表示值介于 -128 到 +127 之间的有符号整数。</li>
<li>Int16 值类型表示值介于 -32,768 到 +32,767 之间的有符号整数。</li>
<li>Int32 值类型表示值介于 -2,147,483,648 到 +2,147,483,647 之间的有符号整数。</li>
<li>Int64 值类型表示值介于 -9,223,372,036,854,775,808 到 +9,223,372,036,854,775,807 之间的整数。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

func main(){
	var a int32 //注意：类型是32位
	var value reflect.Value = reflect.ValueOf(&amp;a)
	
	//判断指针是否指向内存地址
	if !value.CanSet() {
		value = value.Elem() //使指针指向内存地址
	}
	
	var i int64 = 2147483647
	if value.OverflowInt(i) {
		fmt.Println(&quot;溢出：超出范围&quot;)
	}else {
		fmt.Println(&quot;正常：范围之内&quot;)
	}
	//&gt;&gt;正常：范围之内
	
	i = 2147483648
	if value.OverflowInt(i) {
		fmt.Println(&quot;溢出：超出范围&quot;)
	}else {
		fmt.Println(&quot;正常：范围之内&quot;)
	}
	//&gt;&gt;溢出：超出范围
	
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-v-value-overflowuintx-uint64-bool"><a class="header" href="#func-v-value-overflowuintx-uint64-bool">func (v Value) OverflowUint(x uint64) bool</a></h1>
<p>参数列表</p>
<ul>
<li>x uint64 传入参数必须是uint64，以最大范围。</li>
</ul>
<p>返回值：</p>
<ul>
<li>bool 值超出范围返回true，否则返回false。</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.ValueOf(interface{}).OverflowUint(uint64) 判断 Uint 值是否溢出。如果出现恐慌，表示v的值不是Uint，Uint8，Uint16，Uint32，或Uint64 类型。
<ul>
<li>如果uint16或uint32类型存储的值超出了该类型可容纳的范围，返回true，否则返回false。</li>
<li>警告：如果uint64类型存储的值超出了该类型可容纳的范围，返回错误，否则返回false。
<ul>
<li>uint各类型存储范围：</li>
<li>Uint8 值类型表示值介于 0 到 255 之间的无符号整数。也是有符号整数 128*2-1 。</li>
<li>Uint16 值类型表示值介于 0 到 65535 之间的无符号整数。也是有符号整数 32768*2-1 。</li>
<li>Uint32 值类型表示值介于 0 到 4294967295 之间的无符号整数。也是有符号整数 2147483648*2-1 。</li>
<li>Uint64 值类型表示值介于 0 到 18446744073709551615 之间的无符号整数。也是有符号整数 9223372036854775808*2-1 。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

func main(){
	var a uint32 //注意：类型是32位
	var value reflect.Value = reflect.ValueOf(&amp;a)
	
	//判断指针是否指向内存地址
	if !value.CanSet() {
		value = value.Elem() //使指针指向内存地址
	}
	
	var i uint64 = 4294967295 //等介于 2147483648*2-1
	if !value.OverflowUint(i) {
		fmt.Println(&quot;正常：范围之内&quot;)
	}else {
		fmt.Println(&quot;溢出：超出范围&quot;)
	}
	//&gt;&gt;正常：范围之内
	
	i = 4294967296 //等介于 2147483648*2-0
	if !value.OverflowUint(i) {
		fmt.Println(&quot;正常：范围之内&quot;)
	}else {
		fmt.Println(&quot;溢出：超出范围&quot;)
	}
	//&gt;&gt;溢出：超出范围
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-v-value-pointer-uintptr"><a class="header" href="#func-v-value-pointer-uintptr">func (v Value) Pointer() uintptr</a></h1>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>uintptr 返回指针值（整数）</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.ValueOf(interface{}).Pointer() 返回 v 的指针值（uintptr）</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
    &quot;fmt&quot;
    &quot;reflect&quot;
		&quot;unsafe&quot;
)

func main(){
	var a complex64
	var value reflect.Value = reflect.ValueOf(&amp;a)
	fmt.Println(value.Pointer(), uintptr(unsafe.Pointer(&amp;a)))
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-v-value-recv-x-value-ok-bool"><a class="header" href="#func-v-value-recv-x-value-ok-bool">func (v Value) Recv() (x Value, ok bool)</a></h1>
<p>参数列表</p>
<ul>
<li>无 </li>
</ul>
<p>返回值：</p>
<ul>
<li>x Value 信道返回的值</li>
<li>ok bool 如果信道能返回值，返回true。如果信道被关闭，返回false。</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.ValueOf(interface{}).Recv(reflect.Value, bool) 从通道 v 接收与返回一个值，如果出现恐慌，表示Kind不是Chan。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
	&quot;fmt&quot;
	&quot;reflect&quot;
)

func main(){
	var a chan int
	a = make(chan int,1)
	var value reflect.Value = reflect.ValueOf(&amp;a)

	//判断指针是否指向内存地址
	if !value.CanSet() {
		value = value.Elem() //使指针指向内存地址
	}
	var gotest = func(c reflect.Value){
		c.Send(reflect.ValueOf(3888)) //3&gt;发送信息
	}
	go gotest(value) //1&gt;异步
	
	var c, ok = value.Recv() //2&gt;阻塞等待
	
	fmt.Println(c.Int(), ok) //4&gt;读出数据
	//&gt;&gt;3888 true
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-v-value-sendx-value"><a class="header" href="#func-v-value-sendx-value">func (v Value) Send(x Value)</a></h1>
<p>参数列表</p>
<ul>
<li>x Value 发送数据往信道</li>
</ul>
<p>返回值：</p>
<ul>
<li>无</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.ValueOf(interface{}).Send(reflect.Value) 发送x往通道上。 如果出现恐慌（panic），表示v的Kind不是Chan。在Go中，x的值必须是分配给该通道的元素类型。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
	&quot;fmt&quot;
	&quot;reflect&quot;
)

func main(){
	var a chan int
	a = make(chan int,1)
	var value reflect.Value = reflect.ValueOf(&amp;a)
	
	//判断指针是否指向内存地址
	if !value.CanSet() {
		value = value.Elem() //使指针指向内存地址
	}
	var gotest = func(c reflect.Value){
		c.Send(reflect.ValueOf(3888)) //3&gt;发送信息
	}
	go gotest(value) //1&gt;异步
	
	var c, ok = value.Recv() //2&gt;阻塞等待
	
	fmt.Println(c.Int(), ok) //4&gt;读出数据
	//&gt;&gt;3888 true
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-v-value-setx-value"><a class="header" href="#func-v-value-setx-value">func (v Value) Set(x Value)</a></h1>
<p>参数列表</p>
<ul>
<li>x Value 新的值，类型为 reflect.Value</li>
</ul>
<p>返回值：</p>
<ul>
<li>无</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.ValueOf(interface{}).Set(reflect.Value) 更改 v 的值为 x，支持所有类型的值更改。 如果CanSet()返回False，表示v的值不支持Set设置。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

type A struct {
	A0 float64
	A1 int
	A2 string
}

func main(){
	var a A
	var value reflect.Value = reflect.ValueOf(&amp;a)
	
	if !value.CanSet() {
		value = value.Elem() //使指针指向内存地址
	}
	
	//更改a结构字段的值
	value.Field(0).Set(reflect.ValueOf(123.123))
	value.Field(1).Set(reflect.ValueOf(456))
	value.Field(2).Set(reflect.ValueOf(&quot;789&quot;))
	
	fmt.Println(a)
	//&gt;&gt;{123.123 456 789}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-v-value-setboolx-bool"><a class="header" href="#func-v-value-setboolx-bool">func (v Value) SetBool(x bool)</a></h1>
<p>参数列表</p>
<ul>
<li>bool 布尔值</li>
</ul>
<p>返回值：</p>
<ul>
<li>无</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.ValueOf(interface{}).SetBool(bool) 设置 v 的值。如果CanSet()返回False，表示不支持SetBool设置。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

func main(){
	var a bool // 默认值为 false
	var value reflect.Value = reflect.ValueOf(&amp;a)
	
	//判断指针是否指向内存地址
	if !value.CanSet() {
		value = value.Elem() //使指针指向内存地址
	}
	
	fmt.Println(value.Bool())
	//&gt;&gt;false
	
	value.SetBool(true) //设置新值
	
	fmt.Println(value.Bool())
	//&gt;&gt;true
	
	fmt.Println(a)
	//true
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-v-value-setbytesx-byte"><a class="header" href="#func-v-value-setbytesx-byte">func (v Value) SetBytes(x []byte)</a></h1>
<p>参数列表</p>
<ul>
<li>x []byte 新的值（字节切片）</li>
</ul>
<p>返回值：</p>
<ul>
<li>无</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.ValueOf(interface{}).SetBytes([]byte) 设置 v 的值。如果出现恐慌（panic)，表示v的值不是字节（Bytes）的切片（Slice）。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

func main(){
	var a []byte
	var value reflect.Value = reflect.ValueOf(&amp;a)
	
	//判断指针是否指向内存地址
	if !value.CanSet() {
		value = value.Elem() //使指针指向内存地址
	}
	
	fmt.Println(value.Bytes())
	//&gt;&gt;[]
	
	value.SetBytes([]byte{'1','2','3','4','5'}) //设置新值
	
	fmt.Println(value.Bytes())
	//&gt;&gt;[49 50 51 52 53]
	
	fmt.Println(a)
	//[49 50 51 52 53]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-v-value-setcomplexx-complex128"><a class="header" href="#func-v-value-setcomplexx-complex128">func (v Value) SetComplex(x complex128)</a></h1>
<p>参数列表</p>
<ul>
<li>x complex128 传入参数必须是complex128类型，以最大范围。</li>
</ul>
<p>返回值：</p>
<ul>
<li>无</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.ValueOf(interface{}).SetComplex(complex128) 设置 v 的为 x。如果出现恐慌（panic），表示v的值不是Complex64 或Complex128 类型。
<ul>
<li>Complex各类型存储范围：</li>
<li>Complex64 值类型表示值介于 -3.4028234663852884e+38 到 3.4028234663852884e+38  // 2<strong>127 * (2</strong>24 - 1) / 2**23</li>
<li>Complex128 值类型表示值介于 -1.7976931348623158e+308 到 1.7976931348623158e+308 // 2<strong>1023 * (2</strong>53 - 1) / 2**52</li>
</ul>
</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

func main(){
	var a complex64 //注意：类型是complex64
	var value reflect.Value = reflect.ValueOf(&amp;a)
	
	//判断指针是否指向内存地址
	if !value.CanSet() {
		value = value.Elem() //使指针指向内存地址
	}
	
	var i complex128 = -3.4028234663852884e+38 + 3.4028234663852884e+38i
	if !value.OverflowComplex(i) {
		value.SetComplex(i)
	}
	fmt.Println(value.Complex())
	//&gt;&gt;(-3.4028234663852886e+38+3.4028234663852886e+38i)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-v-value-setfloatx-float64"><a class="header" href="#func-v-value-setfloatx-float64">func (v Value) SetFloat(x float64)</a></h1>
<p>参数列表</p>
<ul>
<li>float64 传入参数必须是Float64，以最大范围。</li>
</ul>
<p>返回值：</p>
<ul>
<li>无</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.ValueOf(interface{}).SetFloat(float64) 设置 v 的值为 x。如果出现恐慌，表示v的值不是Float64 或Float32 类型。
<ul>
<li>float各类型存储范围：</li>
<li>Float32 值类型表示值介于 -3.4028234663852884e+38 到 3.4028234663852884e+38  // 2<strong>127 * (2</strong>24 - 1) / 2**23</li>
<li>Float64 值类型表示值介于 -1.7976931348623158e+308 到 1.7976931348623158e+308 // 2<strong>1023 * (2</strong>53 - 1) / 2**52</li>
</ul>
</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

func main(){
	var a float32 //注意：类型是float32
	var value reflect.Value = reflect.ValueOf(&amp;a)
	
	//判断指针是否指向内存地址
	if !value.CanSet() {
		value = value.Elem() //使指针指向内存地址
	}
	
	var i float64 = 3.4028234663852884e+38
	if !value.OverflowFloat(i) {
		value.SetFloat(i) //执行这里
	}
	fmt.Println(value.Float())
	//&gt;&gt;3.4028234663852886e+38
	
	i = 1.7976931348623158e+308
	if value.OverflowFloat(i) {
		fmt.Println(&quot;溢出&quot;)
		//&gt;&gt;溢出
	}
	value.SetFloat(0)
	fmt.Println(value.Float())
	//&gt;&gt;0
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-v-value-setintx-int64"><a class="header" href="#func-v-value-setintx-int64">func (v Value) SetInt(x int64)</a></h1>
<p>参数列表</p>
<ul>
<li>x int64 传入参数必须是int64，以最大范围。</li>
</ul>
<p>返回值：</p>
<ul>
<li>无</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.ValueOf(interface{}).SetInt(x int64) 设置 v 的值为 x。如果出现恐慌，表示v的值不是Int，Int8，Int16，Int32，或Int64 类型。
<ul>
<li>int各类型存储范围：
<ul>
<li>Int8  值类型表示值介于 -128 到 +127 之间的有符号整数。</li>
<li>Int16 值类型表示值介于 -32,768 到 +32,767 之间的有符号整数。</li>
<li>Int32 值类型表示值介于 -2,147,483,648 到 +2,147,483,647 之间的有符号整数。</li>
<li>Int64 值类型表示值介于 -9,223,372,036,854,775,808 到 +9,223,372,036,854,775,807 之间的整数。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

func main(){
	var a int32 //注意：类型是32位
	var value reflect.Value = reflect.ValueOf(&amp;a)
	
	//判断指针是否指向内存地址
	if !value.CanSet() {
		value = value.Elem() //使指针指向内存地址
	}
	
	var i int64 = 2147483647
	if !value.OverflowInt(i) {
		value.SetInt(i) //执行这里
	}
	fmt.Println(value.Int())
	//&gt;&gt;2147483647
	
	i = 2147483648
	if !value.OverflowInt(i) {
		value.SetInt(i)
	}else{
		value.SetInt(0) //执行这里
	}
	fmt.Println(value.Int())
	//&gt;&gt;0
	
	i = 2147483650
	if value.OverflowInt(i) {//条件不带！
		value.SetInt(i) // 写入超出范围的整，看看会是什么结果！！！
	}
	fmt.Println(value.Int())
	//&gt;&gt;-2147483646
	
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-v-value-setlenn-int"><a class="header" href="#func-v-value-setlenn-int">func (v Value) SetLen(n int)</a></h1>
<p>参数列表</p>
<ul>
<li>n int 限制Slice的长度</li>
</ul>
<p>返回值：</p>
<ul>
<li>无</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.ValueOf(interface{}).SetLen(int) 设置 v 的长度为 n。如果出现恐慌，表示 v 的Kind不是Slice或n为负数或超过Slice的容量。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
	&quot;fmt&quot;
	&quot;reflect&quot;
)

func main(){
	var a []int
	var value reflect.Value = reflect.ValueOf(&amp;a)
	
	//判断指针是否指向内存地址
	if !value.CanSet() {
		value = value.Elem() //使指针指向内存地址
	}
	value.Set(reflect.ValueOf([]int{1,2,3,4,5,6,7,8,9,0}))
	
	fmt.Println(value.Interface())
	//&gt;&gt;[1 2 3 4 5 6 7 8 9 0]
	
	value.SetLen(5) //限制Slice长度
	
	fmt.Println(value.Interface())
	//&gt;&gt;[1 2 3 4 5]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-v-value-setmapindexkey-val-value"><a class="header" href="#func-v-value-setmapindexkey-val-value">func (v Value) SetMapIndex(key, val Value)</a></h1>
<p>参数列表</p>
<ul>
<li>key Value 传入对应的键名称，类型是 reflect.Value</li>
<li>val Value 传入一个键的新值，类型是 reflect.Value</li>
</ul>
<p>返回值：</p>
<ul>
<li>无</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.ValueOf(interface{}).SetMapIndex(reflect.Value) 设置 v 的Map键值。如果 v 的Kind不是Map，他会恐慌（panic）。如果值是零值（nil），SetMapIndex从Map上删除该键。在Go中，Key必须是分配给map的Key类型，和value必须是分配到Map的value类型中。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
	&quot;fmt&quot;
	&quot;reflect&quot;
)

func main(){
	var a = map[string]int{
		&quot;a&quot;:1,
		&quot;b&quot;:2,
		&quot;c&quot;:3,
		&quot;d&quot;:4,
		&quot;e&quot;:5,
	}
	var value reflect.Value = reflect.ValueOf(&amp;a)
	
	//判断指针是否指向内存地址
	if !value.CanSet() {
		value = value.Elem() //使指针指向内存地址
	}
	
	value.SetMapIndex(reflect.ValueOf(&quot;c&quot;), reflect.ValueOf(123456)) //修改键值
	
	value.SetMapIndex(reflect.ValueOf(&quot;a&quot;), reflect.ValueOf(nil)) //如果值是nil，则删除该键
	
	value.SetMapIndex(reflect.ValueOf(&quot;f&quot;), reflect.ValueOf(789)) //增加一个键
	
	fmt.Println(value.Interface())
	//&gt;&gt;map[f:789 b:2 e:5 d:4 c:123456]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-v-value-setpointerx-unsafepointer"><a class="header" href="#func-v-value-setpointerx-unsafepointer">func (v Value) SetPointer(x unsafe.Pointer)</a></h1>
<p>参数列表</p>
<ul>
<li>x unsafe.Pointer 传入一个unsafe.Pointer的值</li>
</ul>
<p>返回值：</p>
<ul>
<li>无</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.ValueOf(interface{}).SetPointer(unsafe.Pointer) 设置v的unsafe.Pointer值为 x 。如果出现恐慌，表示 v 不是UnsafePointer。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
	&quot;fmt&quot;
	&quot;reflect&quot;
	&quot;unsafe&quot;
)

func main(){
	var a int = 456
	var ap unsafe.Pointer = unsafe.Pointer(&amp;a)
	var value reflect.Value = reflect.ValueOf(&amp;ap).Elem()
	
	var b int = 123
	var bp unsafe.Pointer = unsafe.Pointer(&amp;b)
	
	fmt.Println(value.Pointer(), value.Kind(), uintptr(ap), uintptr(bp), a, b)
	//&gt;&gt;282918960 unsafe.Pointer 282918960 282918944 456 123
	
	value.SetPointer(bp)
	
	fmt.Println(value.Pointer(), value.Kind(), uintptr(ap), uintptr(bp), a, b)
	//&gt;&gt;282918944 unsafe.Pointer 282918944 282918944 456 123
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-v-value-setstringx-string"><a class="header" href="#func-v-value-setstringx-string">func (v Value) SetString(x string)</a></h1>
<p>参数列表</p>
<ul>
<li>x string 传入字符串</li>
</ul>
<p>返回值：</p>
<ul>
<li>无</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.ValueOf(interface{}).SetString(string) 设置 v的值为x。如果出现恐慌（panic），表示v的Kind不是String字符串。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
	&quot;fmt&quot;
	&quot;reflect&quot;
)

func main(){
	var a string = &quot;A&quot;
	var value reflect.Value = reflect.ValueOf(&amp;a)
	
	//判断指针是否指向内存地址
	if !value.CanSet() {
		value = value.Elem() //使指针指向内存地址
	}
	
	fmt.Println(value.String())
	//&gt;&gt;A
	
	value.SetString(&quot;B&quot;) //设置新字符
	
	fmt.Println(value.String())
	//&gt;&gt;B
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-v-value-setuintx-uint64"><a class="header" href="#func-v-value-setuintx-uint64">func (v Value) SetUint(x uint64)</a></h1>
<p>参数列表</p>
<ul>
<li>x uint64 传入参数必须是uint64，以最大范围。</li>
</ul>
<p>返回值：</p>
<ul>
<li>无</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.ValueOf(interface{}).SetUint(uint64) 设置 v 的值为 x。如果出现恐慌，表示v的值不是Uint，Uint8，Uint16，Uint32，或Uint64 类型。
<ul>
<li>uint各类型存储范围：
<ul>
<li>Uint8 值类型表示值介于 0 到 255 之间的无符号整数。也是有符号整数 128*2-1 。</li>
<li>Uint16 值类型表示值介于 0 到 65535 之间的无符号整数。也是有符号整数 32768*2-1 。</li>
<li>Uint32 值类型表示值介于 0 到 4294967295 之间的无符号整数。也是有符号整数 2147483648*2-1 。</li>
<li>Uint64 值类型表示值介于 0 到 18446744073709551615 之间的无符号整数。也是有符号整数 9223372036854775808*2-1 。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

func main(){
	var a uint32 //注意：类型是32位
	var value reflect.Value = reflect.ValueOf(&amp;a)
	
	//判断指针是否指向内存地址
	if !value.CanSet() {
		value = value.Elem() //使指针指向内存地址
	}
	
	var i uint64 = 4294967295 //等介于 2147483648*2-1
	if !value.OverflowUint(i) {
		value.SetUint(i) // 执行这里
	}
	fmt.Println(value.Uint(), a)
	//&gt;&gt;4294967295 4294967295
	
	i = 4294967296 //等介于 2147483648*2-0
	if !value.OverflowUint(i) {
		fmt.Println(&quot;溢出&quot;)
	}else{
		value.SetUint(0) // 执行这里
	}
	fmt.Println(value.Uint(), a)
	//&gt;&gt;0 0
	
	i = 4294967297 //等介于 2147483648*2-(-1)
	if value.OverflowUint(i) {
		value.SetUint(0) // 执行这里
	}
	fmt.Println(value.Uint(), a)
	//&gt;&gt;0 0
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-v-value-slicebeg-end-int-value"><a class="header" href="#func-v-value-slicebeg-end-int-value">func (v Value) Slice(beg, end int) Value</a></h1>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>Value 返回切片的 reflect.Value 类型</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.ValueOf(interface{}).Slice(int, int) 返回一个指定范围的Slice，如果出现恐慌，表示该类型不是 Array 或 Slice。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

func main(){
	var a  = []int{1,2,3,4,5,6,7,8,9,0}
	var value reflect.Value = reflect.ValueOf(a)
	var vs = value.Slice(3,8) //指定切片范围
	fmt.Println(vs.Interface()) //做为接口类型读出
	//&gt;&gt;[4 5 6 7 8]
	
	var b  = []interface{}{
		&quot;a&quot;,
		'a',
		1,
		1.1,
	}
	var value1 reflect.Value = reflect.ValueOf(b)
	var vs1 = value1.Slice(2,3)
	fmt.Println(vs1.Kind(), vs1.Interface())
	//&gt;&gt;slice [1]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-v-value-string-string"><a class="header" href="#func-v-value-string-string">func (v Value) String() string</a></h1>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>string 以字符串形式返回变量的值</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.ValueOf(interface{}).String() 作为一个字符串返回 v 的值。String是一个特殊方法，由于Go的字符串的方法约定。不像其他的gettters，如果v的Kind不是String，它并不会恐慌（panic）。相反，它返回一个字符串的形式为“<T value>”，其中T是v的类型。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
	&quot;fmt&quot;
	&quot;reflect&quot;
)

func main(){
	var a string = &quot;A&quot;
	var value reflect.Value = reflect.ValueOf(&amp;a)
	
	//判断指针是否指向内存地址
	if !value.CanSet() {
		value = value.Elem() //使指针指向内存地址
	}
	
	fmt.Println(value.String())
	//&gt;&gt;A
	
	a = &quot;B&quot;
	
	fmt.Println(value.String())
	//&gt;&gt;B
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-v-value-tryrecv-x-value-ok-bool"><a class="header" href="#func-v-value-tryrecv-x-value-ok-bool">func (v Value) TryRecv() (x Value, ok bool)</a></h1>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>x Value 尝式从通道接收一个值，类型是 reflect.Value</li>
<li>ok bool 信道能接收到值，返回true。信道被关闭，则返回false。</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.ValueOf(interface{}).TryRecv(reflect.Value, bool) 尝式从通道 v 接收一个值，但不会阻塞。如果出现恐慌（panic），表示v的Kind不是Chan。如果x是零值，接收将不能完成而阻塞。如果x的值来自通道，布尔确定是true。如果是false，它收到是一个零值，因为通道被关闭。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
	&quot;fmt&quot;
	&quot;reflect&quot;
)

func main(){
	var a chan int
	a = make(chan int,1)
	var value reflect.Value = reflect.ValueOf(&amp;a)
	
	//判断指针是否指向内存地址
	if !value.CanSet() {
		value = value.Elem() //使指针指向内存地址
	}
	
	a&lt;-1 // 值先发往信道
	var c, ok = value.TryRecv()
	fmt.Println(c.Int(), ok)
	//&gt;&gt;1 true
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-v-value-trysendx-value-bool"><a class="header" href="#func-v-value-trysendx-value-bool">func (v Value) TrySend(x Value) bool</a></h1>
<p>参数列表</p>
<ul>
<li>x Value 往信道发送的值，类型是 reflect.Value</li>
</ul>
<p>返回值：</p>
<ul>
<li>ok bool 如果值能往信道发送成功，返回true，否则返回false。</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.ValueOf(interface{}).TrySend(reflect.Value) 尝试通道发送 x 给 v，但不会阻止。如果出现恐慌，表示v的Kind不是Chan。如果该值被发送，则返回true，否则返回false。在GO中，x的值必须是分配给该通道的元素类型。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
	&quot;fmt&quot;
	&quot;reflect&quot;
)

func main(){
	var a chan int
	a = make(chan int,1)
	var value reflect.Value = reflect.ValueOf(&amp;a)
	
	//判断指针是否指向内存地址
	if !value.CanSet() {
		value = value.Elem() //使指针指向内存地址
	}
	
	var ok = value.TrySend(reflect.ValueOf(1)) //发送一个值往信道
	var c = &lt;- a
	fmt.Println(c, ok)
	//&gt;&gt;1 true
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-v-value-type-type"><a class="header" href="#func-v-value-type-type">func (v Value) Type() Type</a></h1>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>Type  返回一个特定的 reflect.Type 类型</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.ValueOf(interface{}).Type() 将 Value 类型“转到” Type 类型。Type 类型也可以“转到”Value 类型上的，可惜只有 reflect.Method.Func 才有，reflect.StructField 类型中没有。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

func main(){
	var a int
	var value reflect.Value = reflect.ValueOf(a)
	var typeof reflect.Type = value.Type() //reflect.Value 类型“转到” reflect.Type 类型
	fmt.Println(typeof)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-v-value-uint-uint64"><a class="header" href="#func-v-value-uint-uint64">func (v Value) Uint() uint64</a></h1>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>uint64 传入参数必须是uint64，以最大范围。</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.ValueOf(interface{}).Uint() 返回 v 的值。如果出现恐慌，表示v的值不是Uint，Uint8，Uint16，Uint32，或Uint64 类型。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

func main(){
	var a uint
	var value reflect.Value = reflect.ValueOf(&amp;a)
	
	//判断指针是否指向内存地址
	if !value.CanSet() {
		value = value.Elem() //使指针指向内存地址
	}
	
	fmt.Println(value.Uint())
	//&gt;&gt;0
	
	a = 123
	
	fmt.Println(value.Uint())
	//&gt;&gt;123
	
	fmt.Println(a)
	//&gt;&gt;123
	
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-v-value-unsafeaddr-uintptr"><a class="header" href="#func-v-value-unsafeaddr-uintptr">func (v Value) UnsafeAddr() uintptr</a></h1>
<p>参数列表</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>uintptr 返回指针（整数）</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.ValueOf(interface{}).UnsafeAddr() 返回一个指针指向v的数据。如果v是不可寻址，会出现恐慌（panic）。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

func main(){
	var a int
	var value reflect.Value = reflect.ValueOf(&amp;a)
	fmt.Println(value.Elem().UnsafeAddr(), uintptr(unsafe.Pointer(&amp;a)))
	//&gt;&gt;282918960 282918960
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-valueofi-interface-value"><a class="header" href="#func-valueofi-interface-value">func ValueOf(i interface{}) Value</a></h1>
<p>参数列表</p>
<ul>
<li>i interface{} 传入任何变量类型</li>
</ul>
<p>返回值：</p>
<ul>
<li>Value  返回一个特定的 reflect.Value 类型</li>
</ul>
<p>功能说明：</p>
<ul>
<li>reflect.ValueOf(interface{}) 反射返回一个存储在接口 i 的值。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

func main(){
	var a int
	var value reflect.Value = reflect.ValueOf(a)
	fmt.Println(value)
	//&gt;&gt;&lt;int Value&gt;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-zerotyp-type-value"><a class="header" href="#func-zerotyp-type-value">func Zero(typ Type) Value</a></h1>
<p>参数列表</p>
<ul>
<li>typ Type 传入变量，类型是 reflect.Type </li>
</ul>
<p>返回值：</p>
<ul>
<li>Value 返回类型的零值，类型是 reflect.Value</li>
</ul>
<p>功能说明：</p>
<ul>
<li>返回一个值，该值表示为指定的类型的零值。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main
import (
	&quot;fmt&quot;
	&quot;reflect&quot;
)

func main(){
	var a int
	a = 123456
	var value reflect.Value = reflect.ValueOf(&amp;a)
	value = reflect.Indirect(value)
	value = reflect.Zero(value.Type()) //返回a的默认值
	
	fmt.Println(value.Kind(), value.Int(), a)
	//&gt;&gt;int 0 123456
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名-56"><a class="header" href="#包名-56">包名</a></h1>
<p>函数列表</p>
<ul>
<li>xxx1</li>
<li>xxx2</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名-57"><a class="header" href="#包名-57">包名</a></h1>
<p>函数列表</p>
<ul>
<li>xxx1</li>
<li>xxx2</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名-58"><a class="header" href="#包名-58">包名</a></h1>
<p>函数列表</p>
<ul>
<li>xxx1</li>
<li>xxx2</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名-59"><a class="header" href="#包名-59">包名</a></h1>
<p>函数列表</p>
<ul>
<li>xxx1</li>
<li>xxx2</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名-60"><a class="header" href="#包名-60">包名</a></h1>
<p>函数列表</p>
<ul>
<li>xxx1</li>
<li>xxx2</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名-61"><a class="header" href="#包名-61">包名</a></h1>
<p>函数列表</p>
<ul>
<li>xxx1</li>
<li>xxx2</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sort包函数列表"><a class="header" href="#sort包函数列表">sort包函数列表</a></h1>
<ul>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/sort/Float64s.html">Float64s(a []float64)</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/sort/Float64sAreSorted.html">Float64sAreSorted(a []float64) bool</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/sort/Ints.html">Ints(a []int)</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/sort/IntsAreSorted.html">IntsAreSorted(a []int) bool</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/sort/IsSorted.html">IsSorted(data Interface) bool</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/sort/Search.html">Search(n int, f func(int) bool) int</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/sort/SearchFloat64s.html">SearchFloat64s(a []float64, x float64) int</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/sort/SearchInts.html">SearchInts(a []int, x int) int</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/sort/SearchStrings.html">SearchStrings(a []string, x string) int</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/sort/Sort.html">Sort(data Interface)</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/sort/Stable.html">Stable(data Interface)</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/sort/Strings.html">Strings(a []string)</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/sort/StringsAreSorted.html">StringsAreSorted(a []string) bool</a></p>
</li>
</ul>
<h1 id="结构-1"><a class="header" href="#结构-1">结构</a></h1>
<ul>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/sort/Interface.html">type Interface</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/sort/Reverse.html">Reverse(data Interface) Interface</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/sort/Float64Slice.html">type Float64Slice</a>	</p>
</li>
<li>
<p>Len() int</p>
</li>
<li>
<p>Less(i, j int) bool</p>
</li>
<li>
<p>Search(x float64) int</p>
</li>
<li>
<p>Sort()</p>
</li>
<li>
<p>Swap(i, j int)</p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/sort/IntSlice.html">type IntSlice</a></p>
</li>
<li>
<p>Len() int</p>
</li>
<li>
<p>Less(i, j int) bool</p>
</li>
<li>
<p>Search(x int) int</p>
</li>
<li>
<p>Sort()</p>
</li>
<li>
<p>Swap(i, j int)</p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/sort/StringSlice.html">type StringSlice</a></p>
</li>
<li>
<p>Len() int</p>
</li>
<li>
<p>Less(i, j int) bool</p>
</li>
<li>
<p>Search(x string) int</p>
</li>
<li>
<p>Sort()</p>
</li>
<li>
<p>Swap(i, j int)</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-float64sa-float64"><a class="header" href="#func-float64sa-float64">func Float64s(a []float64)</a></h2>
<p>参数列表</p>
<ul>
<li>a 表示要排序的 float64 切片</li>
</ul>
<p>功能说明：</p>
<p>Float64s 以升序排列 float64 切片</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;sort&quot;
)
	
func main() {
	a := []float64{5.5, 2.2, 6.6, 3.3, 1.1, 4.4} // unsorted
	sort.Float64s(a)
	fmt.Println(a)
	// Output: [1.1 2.2 3.3 4.4 5.5 6.6]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-float64saresorteda-float64-bool"><a class="header" href="#func-float64saresorteda-float64-bool">func Float64sAreSorted(a []float64) bool</a></h2>
<p>参数列表</p>
<ul>
<li>a 表示要判断的float64切片</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回 bool</li>
</ul>
<p>功能说明：</p>
<p>Float64sAreSorted 判断 float64 切片是否已经按升序排列。</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;sort&quot;
)
	
func main() {
	a := []float64{5.5, 2.2, 6.6, 3.3, 1.1, 4.4} // unsorted
	fmt.Println(sort.Float64sAreSorted(a))       // false
	sort.Float64s(a)
	fmt.Println(sort.Float64sAreSorted(a)) // true
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="结构-float64slice"><a class="header" href="#结构-float64slice">结构 Float64Slice</a></h2>
<p>====
type Float64Slice []float64</p>
<p>Float64Slice 针对 []Float64Slice 实现接口的方法，以升序排列</p>
<p>Float64Slice 有以下方法：</p>
<p>====</p>
<ul>
<li>
<p>func (p Float64Slice) Len() int</p>
<p>返回 p 的长度</p>
</li>
</ul>
<p>====</p>
<ul>
<li>
<p>func (p Float64Slice) Less(i, j int) bool </p>
<p>返回 p[i] &lt; p[j] 是否为真</p>
</li>
</ul>
<p>====</p>
<ul>
<li>
<p>func (p Float64Slice) Search(x float64) int</p>
<p>返回小于 x 的最小元素的索引</p>
</li>
</ul>
<p>====</p>
<ul>
<li>
<p>func (p Float64Slice) Swap(i, j int)</p>
<p>交换 p[i]和p[j] 的值</p>
</li>
</ul>
<p>====</p>
<ul>
<li>
<p>func (p Float64Slice) Sort() </p>
<p>按升序排列 p 切片</p>
</li>
</ul>
<p>代码案例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;sort&quot;
)

func main() {
	a := sort.Float64Slice{5.5, 2.2, 6.6, 3.3, 1.1, 4.4} // unsorted

	fmt.Println(a.Len()) // 6

	fmt.Println(a.Less(0, 1)) // false
	
	fmt.Println(a.Search(4.0)) // 5
	
	a.Swap(0, 1)
	fmt.Println(a)
	// Output: [2.2 5.5 6.6 3.3 1.1 4.4]

	a.Sort()
	fmt.Println(a)
	// Output: [1.1 2.2 3.3 4.4 5.5 6.6]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="接口-interface"><a class="header" href="#接口-interface">接口 Interface</a></h2>
<p>====
type Interface interface {</p>
<pre><code>		// Len 为集合内元素的总数
		Len() int
   	 		
		// Less 返回索引为 i 的元素是否应排在索引为 j 的元素之前。
		Less(i, j int) bool
  			
		// Swap 交换索引为 i 和 j 的元素
		Swap(i, j int)
	}	
</code></pre>
<p>任何实现了 sort.Interface 的类型（一般为集合），均可使用该包中的方法进行排序。这些方法要求集合内列出元素的索引为整数。</p>
<p>代码案例（一）：</p>
<pre><code>	package main

import (
	&quot;fmt&quot;
	&quot;sort&quot;
)

type Grams int

func (g Grams) String() string { return fmt.Sprintf(&quot;%dg&quot;, int(g)) }

type Organ struct {
	Name   string
	Weight Grams
}

type Organs []*Organ

func (s Organs) Len() int { return len(s) }

func (s Organs) Swap(i, j int) { s[i], s[j] = s[j], s[i] }

// ByName 通过提供 Less 方法并使用嵌入式 Organs 值的 Len 和 Swap 方法实现了sort.Interface。

type ByName struct{ Organs }

func (s ByName) Less(i, j int) bool { return s.Organs[i].Name &lt; s.Organs[j].Name }

// ByWeight 通过提供 Less 方法并使用嵌入式 Organs 值的 Len 和 Swap 方法实现了sort.Interface。

type ByWeight struct{ Organs }

func (s ByWeight) Less(i, j int) bool { return s.Organs[i].Weight &lt; s.Organs[j].Weight }

func printOrgans(s []*Organ) {
	for _, o := range s {
		fmt.Printf(&quot;%-8s (%v)\n&quot;, o.Name, o.Weight)
	}
}

func main() {
	s := []*Organ{
		{&quot;brain&quot;, 1340},
		{&quot;heart&quot;, 290},
		{&quot;liver&quot;, 1494},
		{&quot;pancreas&quot;, 131},
	}

	sort.Sort(ByWeight{s})
	fmt.Println(&quot;Organs by weight:&quot;)
	printOrgans(s)
	// Output:
	// Organs by weight:
	// pancreas (131g)
	// heart    (290g)
	// brain    (1340g)
	// liver    (1494g)
	
	sort.Sort(ByName{s})
	fmt.Println(&quot;Organs by name:&quot;)
	printOrgans(s)
	// Output:
	// Organs by name:
	// brain    (1340g)
	// heart    (290g)
	// liver    (1494g)
	// pancreas (131g)	
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-intsa-int"><a class="header" href="#func-intsa-int">func Ints(a []int)</a></h2>
<p>参数列表</p>
<ul>
<li>a 表示要排序的 int 切片</li>
</ul>
<p>功能说明：</p>
<p>Ints 以升序排列 int 切片</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;sort&quot;
)

func main() {
	a := []int{5, 2, 6, 3, 1, 4} // unsorted
	sort.Ints(a)
	fmt.Println(a) // [1 2 3 4 5 6]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-intsaresorteda-int-bool"><a class="header" href="#func-intsaresorteda-int-bool">func IntsAreSorted(a []int) bool</a></h2>
<p>参数列表</p>
<ul>
<li>a 表示要判断的 int 切片</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回 bool</li>
</ul>
<p>功能说明：</p>
<p>IntsAreSorted 判断 int 切片是否已经按升序排列。</p>
<p>代码实例：</p>
<pre><code>package main

import (
&quot;fmt&quot;
&quot;sort&quot;
)

func main() {
	a := []int{5, 2, 6, 3, 1, 4}       // unsorted
	fmt.Println(sort.IntsAreSorted(a)) // false
	sort.Ints(a)
	fmt.Println(a)                     // [1 2 3 4 5 6]
	fmt.Println(sort.IntsAreSorted(a)) // true
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="结构-intslice"><a class="header" href="#结构-intslice">结构 IntSlice</a></h2>
<p>====</p>
<pre><code>	type IntSlice []int
</code></pre>
<p>IntSlice 针对 []int 实现接口的方法，以升序排列</p>
<p>IntSlice 有以下方法：</p>
<p>====</p>
<ul>
<li>
<p>func (p IntSlice) Len() int</p>
<p>返回 p 的长度</p>
</li>
</ul>
<p>====</p>
<ul>
<li>
<p>func (p IntSlice) Less(i, j int) bool </p>
<p>返回 p[i] &lt; p[j] 是否为真</p>
</li>
</ul>
<p>====</p>
<ul>
<li>
<p>func (p IntSlice) Search(x int) int</p>
<p>返回小于 x 的最小元素的索引</p>
</li>
</ul>
<p>====</p>
<ul>
<li>
<p>func (p IntSlice) Swap(i, j int)</p>
<p>交换 p[i]和p[j] 的值</p>
</li>
</ul>
<p>====</p>
<ul>
<li>
<p>func (p IntSlice) Sort() </p>
<p>按升序排列 p 切片</p>
</li>
</ul>
<p>代码案例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;sort&quot;
)

func main() {
	a := sort.IntSlice{5, 2, 6, 3, 1, 4} // unsorted
	
	fmt.Println(a.Len()) // 6
	
	fmt.Println(a.Less(0, 1)) // false
	
	fmt.Println(a.Search(4)) // 5
	
	a.Swap(0, 1)
	fmt.Println(a) // Output: [2 5 6 3 1 4]
	
	a.Sort()
	fmt.Println(a) // Output: [1 2 3 4 5 6]	
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-issorteddata-interface-bool"><a class="header" href="#func-issorteddata-interface-bool">func IsSorted(data Interface) bool</a></h2>
<p>参数列表</p>
<ul>
<li>data 表示要判断的 Interface 数据</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回 bool</li>
</ul>
<p>功能说明：</p>
<p>IsSorted 判断数据是否已经按升序排列</p>
<p>代码案例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;sort&quot;
)

func main() {
	d := []int{5, 2, 6, 3, 1, 4}                 // unsorted
	fmt.Println(sort.IsSorted(sort.IntSlice(d))) // false

	sort.Sort(sort.IntSlice(d))
	fmt.Println(sort.IsSorted(sort.IntSlice(d))) // true

	a := []float64{5.5, 2.2, 6.6, 3.3, 1.1, 4.4}
	fmt.Println(sort.IsSorted(sort.Float64Slice(a))) // false

	sort.Sort(sort.Float64Slice(a))
	fmt.Println(sort.IsSorted(sort.Float64Slice(a))) // true

	s := []string{&quot;PHP&quot;, &quot;golang&quot;, &quot;java&quot;, &quot;python&quot;, &quot;C&quot;, &quot;Objective-C&quot;}
	fmt.Println(sort.IsSorted(sort.StringSlice(s))) // false

	sort.Sort(sort.StringSlice(s))
	fmt.Println(sort.IsSorted(sort.StringSlice(s))) // true
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-reversedata-interface-interface"><a class="header" href="#func-reversedata-interface-interface">func Reverse(data Interface) Interface</a></h2>
<p>参数列表</p>
<ul>
<li>data 表示要逆序的 Interface 数据</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回 Interface</li>
</ul>
<p>功能说明：</p>
<ul>
<li>Reverse 返回逆序的Inferface数据</li>
</ul>
<p>代码案例： </p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;sort&quot;
)

func main() {
	s := []int{5, 2, 6, 3, 1, 4} // unsorted
	sort.Sort(sort.Reverse(sort.IntSlice(s)))
	fmt.Println(s) // [6 5 4 3 2 1]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-searchn-int-f-funcint-bool-int"><a class="header" href="#func-searchn-int-f-funcint-bool-int">func Search(n int, f func(int) bool) int</a></h2>
<p>参数列表</p>
<ul>
<li>n 表示切片的长度</li>
<li>f func(int) bool类型的函数</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回切片的索引</li>
</ul>
<p>功能说明：</p>
<p>Search 使用二分查找法在 [0, n) 中寻找并返回满足 f(i)==true 的最小索引 i ，假定该索引在区间 [0, n)内，则	f(i) == true 就蕴含f(i+1) == true。Search 要求 f 对于输入区间 [0, n)（可能为空）的前一部分为false，而对于剩余（可能为空）的部分为 true；</p>
<p>Search 返回第一个 f 为 true 时的索引 i。若该索引不存在，Search 就返回 n。Search仅当 i 在区间 [0, n) 内时才调用 f(i)。</p>
<p>Search 常用于在一个已排序的，可索引的数据结构中寻找索引为 i 的值 x，例如数组或切片。这种情况下，实参f，一般是一个闭包，会捕获所要搜索的值，以及索引并排序该数据结构的方式。</p>
<p>例如，给定一个以升序排列的切片数据，调用</p>
<pre><code>	Search(len(data), func(i int) bool {
			return data[i] &gt;= 23
	})
</code></pre>
<p>会返回满足 data[i] &gt;= 23 的最小索引 i。若调用者想要判断 23 是否在此切片中，就必须单独测试 data[i] == 23的值。</p>
<p>搜索降以序排列的数据，需使用 &lt;= 操作符，而非 &gt;= 操作符。	</p>
<p>代码案例：</p>
<p>====
package main</p>
<pre><code>import (
	&quot;fmt&quot;
	&quot;sort&quot;
)

type finder struct {
	data []int
	targ int
	f    func(n int) bool
}

func MakeFinder1() *finder {
	var f finder
	f.f = func(i int) bool {
		return f.data[i] &gt;= f.targ
	}
	return &amp;f
}

func MakeFinder2() *finder {
	var f finder
	f.f = func(i int) bool {
		return f.data[i] &lt;= f.targ
	}
	return &amp;f
}

func (f *finder) Find(data []int, x int) int {
	f.data = data
	f.targ = x
	return sort.Search(len(f.data), f.f)
}

func main() {
	var data1 = []int{9, 19, 29, 39, 49, 59, 69, 79, 89, 99}
	var data2 = []int{99, 89, 79, 69, 59, 49, 40, 39, 29, 19, 9}
	f1 := MakeFinder1()
	i := f1.Find(data1, 50)
	fmt.Println(i, data1[i]) // 5 59

	f2 := MakeFinder2()
	i = f2.Find(data2, 40)
	fmt.Println(i, data2[i]) // 6 40
	if i &lt; len(data2) &amp;&amp; f2.targ == data2[i] {
		fmt.Printf(&quot;find %v in data2&quot;, f2.targ)
	} else {
		fmt.Printf(&quot;can'tfind %v in data2&quot;, f2.targ)
	}
	// find 40 in data2 
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-searchfloat64sa-float64-x-float64-int"><a class="header" href="#func-searchfloat64sa-float64-x-float64-int">func SearchFloat64s(a []float64, x float64) int</a></h2>
<p>参数列表</p>
<ul>
<li>a 表示升序排列的 float64 切片</li>
<li>x 表示搜索的 float64 值</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回索引</li>
</ul>
<p>功能说明：</p>
<p>SearchFloat64s 在 float64s 切片中搜索 x 并返回索引，如 Search 函数所述. 返回可以插入 x 值的索引位置，如果 x 不存在，返回数组a的长度。
切片必须以升序排列。</p>
<p>代码案例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;sort&quot;
)

func main() {
	a := [10]float64{-29.9, -19.9, -9.9, 0, 9, 19.9, 29, 39.9, 	49.9, 59}

	fmt.Println(sort.SearchFloat64s(a[:], -15)) // 2
	fmt.Println(sort.SearchFloat64s(a[:], 0.9)) // 4
	fmt.Println(sort.SearchFloat64s(a[:], 25))  // 6
	fmt.Println(sort.SearchFloat64s(a[:], 49))  // 8
}	
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-searchintsa-int-x-int-int"><a class="header" href="#func-searchintsa-int-x-int-int">func SearchInts(a []int, x int) int</a></h2>
<p>参数列表</p>
<p>返回值：</p>
<ul>
<li>a 表示升序排列的 int 切片 </li>
<li>x 表示搜索的 int 值</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回索引</li>
</ul>
<p>功能说明：</p>
<p>SearchInts 在 ints 切片中搜索x并返回索引，如 Search 函数所述。返回可以插入 x 值的索引位置，如果 x 不存在，返回数组 a 的长度。切片必须以升序排列。</p>
<p>代码案例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;sort&quot;
)

func main() {
	a := [10]int{-29, -19, -9, 0, 9, 19, 29, 39, 49, 59}
	
	fmt.Println(sort.SearchInts(a[:], -15)) // 2
	fmt.Println(sort.SearchInts(a[:], 5))   // 4
	fmt.Println(sort.SearchInts(a[:], 25))  // 6
	fmt.Println(sort.SearchInts(a[:], 49))  // 8
} 
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-searchstringsa-string-x-string-int"><a class="header" href="#func-searchstringsa-string-x-string-int">func SearchStrings(a []string, x string) int</a></h2>
<p>参数列表</p>
<p>返回值：</p>
<ul>
<li>a 表示升序排列的 string 切片 </li>
<li>x 表示搜索的 string 值 </li>
</ul>
<p>功能说明：</p>
<p>SearchStrings 在 strings 切片中搜索x并返回索引,如 Search 函数所述. 返回可以插入 x 值的索引位置，如果 x 不存在，返回数组 a 的长度。切片必须以升序排列。</p>
<p>代码案例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;sort&quot;
)

func main() {

	a := []string{&quot;Cupcake&quot;, &quot;Donut&quot;, &quot;Eclair&quot;, &quot;Froyo&quot;,&quot;Gingerbread&quot;,
		&quot;Honeycomb&quot;, &quot;IceCreamSandwich&quot;, &quot;JellyBean&quot;, &quot;KeyLimePie&quot;}
	
	fmt.Println(sort.SearchStrings(a, &quot;Google&quot;)) // 5
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-sortdata-interface"><a class="header" href="#func-sortdata-interface">func Sort(data Interface)</a></h2>
<p>参数列表</p>
<ul>
<li>data 表示要排序的 Interface 数据</li>
</ul>
<p>功能说明：</p>
<p>Sort 对 data 进行排序。 它调用一次 data.Len 来决定排序的长度 n，调用 data.Less 和 data.Swap 的开销为 O(n*log(n))。此排序为不稳定排序。</p>
<p>====
type Interface interface {	
// Len is the number of elements in the collection.
// Len 为集合内元素的总数
Len() int
// Less returns whether the element with index i should sort
// before the element with index j.
// Less 返回索引为 i 的元素是否应排在索引为 j 的元素之前。
Less(i, j int) bool
// Swap swaps the elements with indexes i and j.
// Swap 交换索引为 i 和 j 的元素
Swap(i, j int)
}</p>
<p>任何实现了 sort.Interface 的类型（一般为集合），均可使用该包中的方法进行排序。这些方法要求集合内列出元素的索引为整数。</p>
<p>代码案例（一）：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;sort&quot;
)

func main() {
	d := []int{5, 2, 6, 3, 1, 4} // unsorted
	sort.Sort(sort.IntSlice(d))
	fmt.Println(d)
	// Output:[1 2 3 4 5 6]

	a := []float64{5.5, 2.2, 6.6, 3.3, 1.1, 4.4}
	sort.Sort(sort.Float64Slice(a))
	fmt.Println(a)
	// Output:[1.1 2.2 3.3 4.4 5.5 6.6]
	
	s := []string{&quot;PHP&quot;, &quot;golang&quot;, &quot;java&quot;, &quot;python&quot;, &quot;C&quot;, &quot;Objective-C&quot;}
	sort.Sort(sort.StringSlice(s))
	fmt.Println(s)
	// Output:[C Objective-C PHP golang java python]
}
</code></pre>
<p>代码案例（二）：</p>
<pre><code>package main

import (
&quot;fmt&quot;
&quot;sort&quot;
)

type ByLength []string

func (s ByLength) Len() int {
	return len(s)
}

func (s ByLength) Swap(i, j int) {
	s[i], s[j] = s[j], s[i]
}

func (s ByLength) Less(i, j int) bool {
	return s[i] &lt; s[j]
}

func main() {
	fruits := []string{&quot;peach&quot;, &quot;banana&quot;, &quot;kiwi&quot;}
	sort.Sort(ByLength(fruits))
	fmt.Println(fruits)
	// Output:[banana kiwi peach]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-stabledata-interface"><a class="header" href="#func-stabledata-interface">func Stable(data Interface)</a></h2>
<p>参数列表</p>
<ul>
<li>data 表示要排序的 Interface 数据</li>
</ul>
<p>功能说明：</p>
<p>Stable 稳定排序算法，算法会将相等的元素值维持其相对次序。如果一个排序算法是稳定的，当有两个有相等的元素值 R 和 S，且在原本的列表中 R 出现在 S 之前，那么在排序过的列表中 R 也将会是在 S 之前。对于比较排序算法，我们都能给出 n 个输入的数值，使算法以 Ω(n*logn) 时间运行。稳定排序算法：插入排序、冒泡排序、归并排序、计数排序、基数排序、桶排序。</p>
<p>代码案例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;sort&quot;
)

type MyString []string

func (s MyString) Len() int {
	return len(s)
}
func (s MyString) Less(i, j int) bool {
	if s[i] == &quot;&quot; {
		return true
	}
	if s[j] == &quot;&quot; {
		return false
	}
	return []byte(s[i])[0] &lt; []byte(s[j])[0] //比较字符串的第一个字符大小
}
func (s MyString) Swap(i, j int) {
	s[i], s[j] = s[j], s[i]
}
func main() {
	data := MyString{&quot;5A*&quot;, &quot;24&quot;, &quot;65&quot;, &quot;23&quot;, &quot;1&quot;, &quot;57&quot;, &quot;4&quot;, &quot;624&quot;} // unsorted
	sort.Stable(data)
	fmt.Println(data) // [1 24 23 4 5A* 57 65 624]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-stringsa-string"><a class="header" href="#func-stringsa-string">func Strings(a []string)</a></h2>
<p>参数列表</p>
<ul>
<li>a 表示要排序的 string 切片</li>
</ul>
<p>功能说明：</p>
<p>Strings 以升序排列 string 切片</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;sort&quot;
)

func main() {
	a := []string{&quot;PHP&quot;, &quot;golang&quot;, &quot;java&quot;, &quot;python&quot;, &quot;C&quot;, &quot;Objective-C&quot;}
	sort.Strings(a)
	fmt.Println(a) // [C Objective-C PHP golang java python]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-stringsaresorteda-string-bool"><a class="header" href="#func-stringsaresorteda-string-bool">func StringsAreSorted(a []string) bool</a></h2>
<p>参数列表</p>
<ul>
<li>a 表示要判断的 string 切片</li>
</ul>
<p>功能说明：</p>
<p>StringsAreSorted 判断 string 切片是否已经按升序排列</p>
<p>代码案例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;sort&quot;
)

func main() {
	a := []string{&quot;PHP&quot;, &quot;golang&quot;, &quot;java&quot;, &quot;python&quot;, &quot;C&quot;, &quot;Objective-C&quot;}
	fmt.Println(sort.StringsAreSorted(a)) // false
	sort.Strings(a)
	fmt.Println(sort.StringsAreSorted(a)) //true
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="结构-stringslice"><a class="header" href="#结构-stringslice">结构 StringSlice</a></h2>
<p>====</p>
<pre><code>	type StringSlice []String
</code></pre>
<p>StringSlice 针对 []String 实现接口的方法，以升序排列</p>
<p>StringSlice 有以下方法：</p>
<p>====</p>
<ul>
<li>
<p>func (p StringSlice) Len() int</p>
<p>返回 p 的长度</p>
</li>
</ul>
<p>====</p>
<ul>
<li>
<p>func (p StringSlice) Less(i, j int) bool </p>
<p>返回 p[i] &lt; p[j] 是否为真</p>
</li>
</ul>
<p>====</p>
<ul>
<li>
<p>func (p StringSlice) Search(x String) int</p>
<p>返回小于 x 的最小元素的索引</p>
</li>
</ul>
<p>====</p>
<ul>
<li>
<p>func (p StringSlice) Swap(i, j int)</p>
<p>交换 p[i]和p[j] 的值</p>
</li>
</ul>
<p>====</p>
<ul>
<li>
<p>func (p StringSlice) Sort() </p>
<p>按升序排列 p 切片</p>
</li>
</ul>
<p>代码案例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;sort&quot;
)

func main() {
	p := sort.StringSlice{&quot;PHP&quot;, &quot;golang&quot;, &quot;java&quot;, &quot;python&quot;, &quot;C&quot;, &quot;Objective-C&quot;}

	fmt.Println(p.Len()) // 6

	fmt.Println(p.Less(0, 1)) // true

	fmt.Println(p.Search(&quot;go&quot;)) // 1

	p.Swap(0, 1)
	fmt.Println(p)
	// Output: [golang PHP java python C Objective-C]

	p.Sort()
	fmt.Println(p)
	// Output: [C Objective-C PHP golang java python]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="strconv"><a class="header" href="#strconv">strconv</a></h1>
<p>函数列表</p>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/strconv/AppendBool.html">func AppendBool(dst []byte, b bool) []byte</a> </li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/strconv/AppendFloat.html">func AppendFloat(dst []byte, f float64, fmt byte, prec int, bitSize int) []byte</a> </li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/strconv/AppendInt.html">func AppendInt(dst []byte, i int64, base int) []byte</a> </li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/strconv/AppendQuote.html">func AppendQuote(dst []byte, s string) []byte</a> </li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/strconv/AppendQuoteRune.html">func AppendQuoteRune(dst []byte, r rune) []byte</a> </li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/strconv/AppendQuoteRuneToASCII.html">func AppendQuoteRuneToASCII(dst []byte, r rune) []byte</a> </li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/strconv/AppendQuoteToASCII.html">func AppendQuoteToASCII(dst []byte, s string) []byte</a> </li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/strconv/AppendUint.html">func AppendUint(dst []byte, i uint64, base int) []byte</a> </li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/strconv/Atoi.html">func Atoi(s string) (i int, err error)</a> </li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/strconv/CanBackquote.html">func CanBackquote(s string) bool</a> </li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/strconv/FormatBool.html">func FormatBool(b bool) string</a> </li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/strconv/FormatFloat.html">func FormatFloat(f float64, fmt byte, prec, bitSize int) string</a> </li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/strconv/FormatInt.html">func FormatInt(i int64, base int) string</a> </li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/strconv/FormatUint.html">func FormatUint(i uint64, base int) string</a> </li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/strconv/IsPrint.html">func IsPrint(r rune) bool</a> </li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/strconv/Itoa.html">func Itoa(i int) string</a> </li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/strconv/ParseBool.html">func ParseBool(str string) (value bool, err error)</a> </li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/strconv/ParseFloat.html">func ParseFloat(s string, bitSize int) (f float64, err error)</a> </li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/strconv/ParseInt.html">func ParseInt(s string, base int, bitSize int) (i int64, err error)</a> </li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/strconv/ParseUint.html">func ParseUint(s string, base int, bitSize int) (n uint64, err error)</a> </li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/strconv/Quote.html">func Quote(s string) string</a> </li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/strconv/QuoteRune.html">func QuoteRune(r rune) string</a> </li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/strconv/QuoteRuneToASCII.html">func QuoteRuneToASCII(r rune) string</a> </li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/strconv/QuoteToASCII.html">func QuoteToASCII(s string) string</a> </li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/strconv/Unquote.html">func Unquote(s string) (t string, err error)</a> </li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/strconv/UnquoteChar.html">func UnquoteChar(s string, quote byte) (value rune, multibyte bool, tail string, err error)</a> </li>
<li>type NumError
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/strconv/NumError.Error.html">func (e *NumError) Error() string</a></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-appendbooldst-byte-b-bool-byte"><a class="header" href="#func-appendbooldst-byte-b-bool-byte">func AppendBool(dst []byte, b bool) []byte</a></h1>
<p>参数列表</p>
<ul>
<li>dst 表示原列表 </li>
<li>b   表示需要添加的bool值，true或者false</li>
</ul>
<p>返回值：</p>
<ul>
<li>[]byte  返回原列表追加bool后新生成的列表 </li>
</ul>
<p>功能说明：</p>
<ul>
<li>将布尔值 b 转换为字符串 &quot;true&quot; 或 &quot;false&quot; 然后将结果追加到 dst 的尾部，返回追加后的 []byte</li>
</ul>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;strconv&quot;
)

func main() {
	newlist := strconv.AppendBool(make([]byte, 3), false)
	fmt.Println(newlist)//[0 0 0 102 97 108 115 101]
	newlist = strconv.AppendBool(newlist, true)
	fmt.Println(newlist)//[0 0 0 102 97 108 115 101 116 114 117 101]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-appendfloatdst-byte-f-float64-fmt-byte-prec-int-bitsize-int-byte"><a class="header" href="#func-appendfloatdst-byte-f-float64-fmt-byte-prec-int-bitsize-int-byte">func AppendFloat(dst []byte, f float64, fmt byte, prec int, bitSize int) []byte</a></h1>
<p>参数列表</p>
<ul>
<li>dst     原列表</li>
<li>f       需要append到列表的浮点数</li>
<li>fmt     转换格式 'b' 'e' 'E' 'f' 'g'或'G'</li>
<li>prec    浮点数精度</li>
<li>bitSize 32或64，32对应float32，64对应float64</li>
</ul>
<p>返回值:</p>
<ul>
<li>[]byte  返回列表</li>
</ul>
<p>功能说明：</p>
<ul>
<li>将浮点数f转换为字符串值，并将转换结果追加到dst的尾部，返回追加后的[]byte。</li>
<li>浮点数格式有'b' (-ddddp±ddd, 二进制指数), 'e' (-d.dddde±dd, 十进制指数), 'E' (-d.ddddE±dd, 十进制指数), 'f' (-ddd.dddd, 无指数), 'g' (大指数时相当于'e', 其他情况时相当于'f'), 'G' (大指数时相当于'E', 其他情况相当于'f').</li>
<li>精度用于控制当格式为'e' 'E' 'f' 'g' 'G'时除指数外的数字的个数；对于'e' 'E' 'f'指小数点后位数；对于'g' 'G'则表示总共的位数；如果使用-1，表示不改变数值的最小位数</li>
</ul>
<p>代码示例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;strconv&quot;
)

func main() {
	f := 100.123456789
	fmt.Println(f)
	c := strconv.AppendFloat(make([]byte, 0), f, 'f', 10, 32)
	fmt.Println(string(c))
	c = strconv.AppendFloat(make([]byte, 0), f, 'e', 10, 32)
	fmt.Println(string(c))
	c = strconv.AppendFloat(make([]byte, 0), f, 'f', 10, 64)
	fmt.Println(string(c))
	c = strconv.AppendFloat(make([]byte, 0), f, 'e', 10, 64)
	fmt.Println(string(c))
}
</code></pre>
<p>代码输出：</p>
<pre><code>100.123456789
100.1234588623
1.0012345886e+02
100.1234567890
1.0012345679e+02
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-appendintdst-byte-i-int64-base-int-byte"><a class="header" href="#func-appendintdst-byte-i-int64-base-int-byte">func AppendInt(dst []byte, i int64, base int) []byte</a></h1>
<p>参数列表</p>
<ul>
<li>dst   表示原列表</li>
<li>i     表示需要添加的int64值</li>
<li>base  表示进制数 2 &lt;= base &lt;= 36</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回[]byte 表示原列表添加数值后新生成的列表</li>
</ul>
<p>功能说明：</p>
<ul>
<li>类似AppendFloat，只能追加int类型，base表示int表示的进制数，返回追加后的 []byte。当进制大于10时，大于10的值将使用小写a-z表示。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;strconv&quot;
)

func main() {
    newlist := strconv.AppendInt(make([]byte, 0), 123000, 10)
    fmt.Println(newlist) //[49 50 51 48 48 48]
    newlist = strconv.AppendInt(make([]byte, 0), 8, 2)
    fmt.Println(newlist) //[49 48 48 48]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-appendquotedst-byte-s-string-byte"><a class="header" href="#func-appendquotedst-byte-s-string-byte">func AppendQuote(dst []byte, s string) []byte</a></h1>
<p>参数列表</p>
<ul>
<li>dst   原列表</li>
<li>s     需要append到列表的字符串</li>
</ul>
<p>返回值:</p>
<ul>
<li>[]byte  返回列表</li>
</ul>
<p>功能说明：</p>
<ul>
<li>将字符串s转换为双引号引起来的字符串，并将结果追加到dst的尾部，返回追加后的[]byte。其中的特殊字符将被转换为转义字符</li>
</ul>
<p>代码示例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;strconv&quot;
)

func main() {
    newlist := strconv.AppendQuote(make([]byte, 0), &quot;&quot;)
    fmt.Println(newlist)
    newlist = strconv.AppendQuote(make([]byte, 0), &quot;abc&quot;)
    fmt.Println(newlist)
    newlist = strconv.AppendQuote(make([]byte, 0), &quot;中文&quot;)
    fmt.Println(newlist)
    newlist = strconv.AppendQuote(make([]byte, 0), &quot;	&quot;) // \t
    fmt.Println(newlist)
}
</code></pre>
<p>代码输出：</p>
<pre><code>[34 34]
[34 97 98 99 34]
[34 228 184 173 230 150 135 34]
[34 92 116 34]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-appendquoterunedst-byte-r-rune-byte"><a class="header" href="#func-appendquoterunedst-byte-r-rune-byte">func AppendQuoteRune(dst []byte, r rune) []byte</a></h1>
<p>参数列表</p>
<ul>
<li>dst   原列表</li>
<li>r     需要append到列表的字符</li>
</ul>
<p>返回值:</p>
<ul>
<li>[]byte  返回列表</li>
</ul>
<p>功能说明：</p>
<ul>
<li>将符文s转换为单引号引起来的字符串，并将结果追加到dst的尾部，返回追加后的[]byte。其中的特殊字符将被转换为转义字符</li>
</ul>
<p>代码示例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;strconv&quot;
)

func main() {
    newlist := strconv.AppendQuoteRune(make([]byte, 0), 'a')
    fmt.Println(newlist)
    newlist = strconv.AppendQuoteRune(make([]byte, 0), '\'')
    fmt.Println(newlist)
    newlist = strconv.AppendQuoteRune(make([]byte, 0), '中')
    fmt.Println(newlist)
}
</code></pre>
<p>代码输出：</p>
<pre><code>[39 97 39]
[39 92 39 39]
[39 228 184 173 39]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-appendquoterunetoasciidst-byte-r-rune-byte"><a class="header" href="#func-appendquoterunetoasciidst-byte-r-rune-byte">func AppendQuoteRuneToASCII(dst []byte, r rune) []byte</a></h1>
<p>参数列表</p>
<ul>
<li>dst   原列表</li>
<li>r     需要append到列表的字符</li>
</ul>
<p>返回值:</p>
<ul>
<li>[]byte  返回列表</li>
</ul>
<p>功能说明：</p>
<ul>
<li>将符文s转换为单引号引起来的字符串，非ASCII字符将转换为ASCII，并将结果追加到dst的尾部，返回追加后的[]byte。其中的特殊字符将被转换为转义字符</li>
</ul>
<p>代码示例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;strconv&quot;
)

func main() {
    newlist := strconv.AppendQuoteRune(make([]byte, 0), 'a')
    fmt.Println(newlist)
    newlist = strconv.AppendQuoteRune(make([]byte, 0), '\'')
    fmt.Println(newlist)
    newlist = strconv.AppendQuoteRune(make([]byte, 0), '中')
    fmt.Println(newlist)
    newlist = strconv.AppendQuoteRuneToASCII(make([]byte, 0), 'a')
    fmt.Println(newlist)
    newlist = strconv.AppendQuoteRuneToASCII(make([]byte, 0), '\'')
    fmt.Println(newlist)
    newlist = strconv.AppendQuoteRuneToASCII(make([]byte, 0), '中')
    fmt.Println(newlist)
}
</code></pre>
<p>代码输出：</p>
<pre><code>[39 97 39]
[39 92 39 39]
[39 228 184 173 39]
[39 97 39]
[39 92 39 39]
[39 92 117 52 101 50 100 39]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-appenduintdst-byte-i-uint64-base-int-byte"><a class="header" href="#func-appenduintdst-byte-i-uint64-base-int-byte">func AppendUint(dst []byte, i uint64, base int) []byte</a></h1>
<p>参数列表</p>
<ul>
<li>dst   原列表</li>
<li>i     需要追加到列表的unit64值</li>
<li>base  unit64的进制</li>
</ul>
<p>返回值:</p>
<ul>
<li>[]byte  返回列表</li>
</ul>
<p>功能说明：</p>
<ul>
<li>类似AppendInt，只能追加uint类型，base表示uint表示的进制数，返回追加后的 []byte</li>
</ul>
<p>代码示例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;strconv&quot;
)

func main() {
    newlist := strconv.AppendUint(make([]byte, 0), 10,2) // 1010
    fmt.Println(newlist)
    newlist = strconv.AppendUint(make([]byte, 0), 10,8) // 12
    fmt.Println(newlist)
}
</code></pre>
<p>代码输出：</p>
<pre><code>[49 48 49 48]
[49 50]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-atois-string-i-int-err-error"><a class="header" href="#func-atois-string-i-int-err-error">func Atoi(s string) (i int, err error)</a></h1>
<p>参数列表</p>
<ul>
<li>s 表示数字字符串，如“1234” </li>
</ul>
<p>返回值：</p>
<ul>
<li>i 表示转换后的数值 </li>
</ul>
<p>功能说明：</p>
<ul>
<li>Atoi是函数ParseInt(s, 10, 0)的简写。把字符串格式的数字如“12345”转化为数字12345</li>
</ul>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;strconv&quot;
)

func main() {
    fmt.Println(strconv.Atoi(&quot;12345&quot;))
    fmt.Println(strconv.Atoi(&quot;abcde&quot;))
}
</code></pre>
<p>代码输出：</p>
<pre><code>12345 &lt;nil&gt;
0 strconv.ParseInt: parsing &quot;abcde&quot;: invalid syntax</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-canbackquotes-string-bool"><a class="header" href="#func-canbackquotes-string-bool">func CanBackquote(s string) bool</a></h1>
<p>参数列表</p>
<ul>
<li>s 字符串 </li>
</ul>
<p>返回值：</p>
<ul>
<li>i 表示转换后的数值 </li>
</ul>
<p>功能说明：</p>
<ul>
<li>判断字符串 s 是否可以表示为一个单行的“反引号”字符串， 字符串中不能含有控制字符（除了 \t）和“反引号”字符，否则返回 false</li>
</ul>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;strconv&quot;
)

func main() {
    s := strconv.CanBackquote(&quot;C:\\Windows\n&quot;)
    fmt.Println(s) // false
    s = strconv.CanBackquote(&quot;C:\\Windows\r&quot;)
    fmt.Println(s) // false
    s = strconv.CanBackquote(&quot;C:\\Windows\f&quot;)
    fmt.Println(s) // false
    s = strconv.CanBackquote(&quot;C:\\Windows\t&quot;)
    fmt.Println(s) // true
    s = strconv.CanBackquote(&quot;C:\\`Windows`&quot;)
    fmt.Println(s) // false
}
</code></pre>
<p>代码输出：</p>
<pre><code>false
false
false
true
false</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-formatboolb-bool-string"><a class="header" href="#func-formatboolb-bool-string">func FormatBool(b bool) string</a></h1>
<p>参数列表</p>
<ul>
<li>b 需要被转换的bool值 </li>
</ul>
<p>返回值：</p>
<ul>
<li>返回string 表示转换后的字符串 </li>
</ul>
<p>功能说明：</p>
<ul>
<li>将true或false转换为字符串</li>
</ul>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;strconv&quot;
)

func main() {
    b := strconv.FormatBool(true)
    fmt.Println(b)
    b = strconv.FormatBool(false)
    fmt.Println(b)
}
</code></pre>
<p>代码输出：</p>
<pre><code>true
false</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-formatfloatf-float64-fmt-byte-prec-bitsize-int-string"><a class="header" href="#func-formatfloatf-float64-fmt-byte-prec-bitsize-int-string">func FormatFloat(f float64, fmt byte, prec, bitSize int) string</a></h1>
<p>参数列表</p>
<ul>
<li>f         需要被转换的float64值 </li>
<li>fmt       转换格式 'b' 'e' 'E' 'f' 'g'或'G'</li>
<li>prec      浮点数精度</li>
<li>bitSize   32或64，32对应float32，64对应float64</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回string 表示转换后的字符串 </li>
</ul>
<p>功能说明：</p>
<ul>
<li>将浮点数转换为字符串</li>
<li>浮点数格式有'b' (-ddddp±ddd, 二进制指数), 'e' (-d.dddde±dd, 十进制指数), 'E' (-d.ddddE±dd, 十进制指数), 'f' (-ddd.dddd, 无指数), 'g' (大指数时相当于'e', 其他情况时相当于'f'), 'G' (大指数时相当于'E', 其他情况相当于'f').</li>
<li>精度用于控制当格式为'e' 'E' 'f' 'g' 'G'时除指数外的数字的个数；对于'e' 'E' 'f'指小数点后位数；对于'g' 'G'则表示总共的位数；如果使用-1，表示不改变数值的最小位数</li>
</ul>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;strconv&quot;
)

func main() {
    fmt.Println(strconv.FormatFloat(10.1,'b',5,64))
    fmt.Println(strconv.FormatFloat(10.1,'e',5,64))
    fmt.Println(strconv.FormatFloat(10.1,'E',5,64))
    fmt.Println(strconv.FormatFloat(10.1,'f',5,64))
    fmt.Println(strconv.FormatFloat(10.1,'g',5,64))
    fmt.Println(strconv.FormatFloat(100000000.1,'g',5,64))
    fmt.Println(strconv.FormatFloat(10.1,'G',5,64))
    fmt.Println(strconv.FormatFloat(100000000.1,'G',5,64))
    
    
    fmt.Println(strconv.FormatFloat(10.1,'e',-1,64))
    fmt.Println(strconv.FormatFloat(10.00001,'e',-1,64))
}
</code></pre>
<p>代码输出：</p>
<pre><code>5685794529555251p-49
1.01000e+01
1.01000E+01
10.10000
10.1
1e+08
10.1
1E+08
1.01e+01
1.010001e+01</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-formatinti-int64-base-int-string"><a class="header" href="#func-formatinti-int64-base-int-string">func FormatInt(i int64, base int) string</a></h1>
<p>参数列表</p>
<ul>
<li>i     表示需要被转换为字符串的int64值</li>
<li>base  表示进制数  2 &lt;= base &lt;= 36</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回string 表示转换后的字符串，当进制大于10时，大于10的值将使用小写a-z表示。</li>
</ul>
<p>功能说明：</p>
<ul>
<li>将数值按照进制格式转换为字符串</li>
</ul>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;strconv&quot;
)

func main() {
    fmt.Println(strconv.FormatInt(9223372036854775807, 2))
    fmt.Println(strconv.FormatInt(9223372036854775807, 10))
}
</code></pre>
<p>代码输出：</p>
<pre><code>111111111111111111111111111111111111111111111111111111111111111
9223372036854775807</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-formatuinti-uint64-base-int-string"><a class="header" href="#func-formatuinti-uint64-base-int-string">func FormatUint(i uint64, base int) string</a></h1>
<p>参数列表</p>
<ul>
<li>i     表示需要被转换为字符串的int64值</li>
<li>base  表示进制数  2 &lt;= base &lt;= 36</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回string 表示转换后的字符串，当进制大于10时，大于10的值将使用小写a-z表示。</li>
</ul>
<p>功能说明：</p>
<ul>
<li>将数值按照进制格式转换为字符串</li>
</ul>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;strconv&quot;
)

func main() {
    fmt.Println(strconv.FormatUint(18446744073709551615, 2))
    fmt.Println(strconv.FormatUint(18446744073709551615, 10))
}
</code></pre>
<p>代码输出：</p>
<pre><code>1111111111111111111111111111111111111111111111111111111111111111
18446744073709551615</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-isprintr-rune-bool"><a class="header" href="#func-isprintr-rune-bool">func IsPrint(r rune) bool</a></h1>
<p>参数列表</p>
<ul>
<li>r     表示rune字符</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回bool true表示可以打印，false表示不可以打印。</li>
</ul>
<p>功能说明：</p>
<ul>
<li>判断rune字符在golang中是否被定义为可打印，与unicode.IsPrint相同。可打印范围包括字符、数字、标点、符号以及ASCII中的空格。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;strconv&quot;
)

func main() {
    fmt.Println(strconv.IsPrint(' '))
    fmt.Println(strconv.IsPrint('\t'))
    fmt.Println(strconv.IsPrint('\n'))
    fmt.Println(strconv.IsPrint('\r'))
}
</code></pre>
<p>代码输出：</p>
<pre><code>true
false
false
false</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-itoai-int-string"><a class="header" href="#func-itoai-int-string">func Itoa(i int) string</a></h1>
<p>参数列表</p>
<ul>
<li>i     表示需要被转换为字符串的int值</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回string 表示转换后的字符串。</li>
</ul>
<p>功能说明：</p>
<ul>
<li>将数值按照10进制转换为字符串,是等同于FormatInt(i, 10)的简写。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;strconv&quot;
)

func main() {
    fmt.Println(strconv.FormatInt(9223372036854775807, 10))
}
</code></pre>
<p>代码输出：</p>
<pre><code>9223372036854775807</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-e-numerror-error-string"><a class="header" href="#func-e-numerror-error-string">func (e *NumError) Error() string</a></h1>
<p>返回值：</p>
<ul>
<li>返回string     描述错误的字符串</li>
</ul>
<p>功能说明：</p>
<ul>
<li>返回描述NumError类型错误的字符串</li>
</ul>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;strconv&quot;
)

func main() {
    err := errors.New(&quot;too large&quot;)
    er := strconv.NumError{Func: &quot;anyfunc&quot;, Num: &quot;1e100&quot;,Err:err}
    fmt.Println(er.Error())
}
</code></pre>
<p>代码输出：</p>
<pre><code>strconv.anyfunc: parsing &quot;1e100&quot;: too large</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-parseboolstr-string-value-bool-err-error"><a class="header" href="#func-parseboolstr-string-value-bool-err-error">func ParseBool(str string) (value bool, err error)</a></h1>
<p>参数列表</p>
<ul>
<li>str     可以表示bool值的字符串</li>
</ul>
<p>返回值：</p>
<ul>
<li>value   通过str转换的bool值</li>
<li>err     当str无法转换为bool返回错误，否则为nil</li>
</ul>
<p>功能说明：</p>
<ul>
<li>尝试将表示bool值的字符串转换为bool值。str可以是1, t, T, TRUE, true, True, 0, f, F, FALSE, false, False，其他的字符将返回错误。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;strconv&quot;
)

func main() {
    fmt.Println(strconv.ParseBool(&quot;1&quot;))
    fmt.Println(strconv.ParseBool(&quot;0&quot;))
    fmt.Println(strconv.ParseBool(&quot;a&quot;))
}
</code></pre>
<p>代码输出：</p>
<pre><code>true &lt;nil&gt;
false &lt;nil&gt;
false strconv.ParseBool: parsing &quot;a&quot;: invalid syntax</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-parsefloats-string-bitsize-int-f-float64-err-error"><a class="header" href="#func-parsefloats-string-bitsize-int-f-float64-err-error">func ParseFloat(s string, bitSize int) (f float64, err error)</a></h1>
<p>参数列表</p>
<ul>
<li>str     可以表示float64值的字符串</li>
<li>bitSize 精度 按64位或32位转换为float64值</li>
</ul>
<p>返回值：</p>
<ul>
<li>f       通过str转换的float64值.如果解析出错，返回0；数值超范围返回±Inf。</li>
<li>err     当str无法转换为float64值返回错误，否则为nil</li>
</ul>
<p>功能说明：</p>
<ul>
<li>
<p>尝试按照bitSize指定的精度将表示float64值的字符串转换为float64值。当bitSize指定32位时，返回值仍然是float64值而非float32值,但却可以在不改变数值的情况下将float64转换为float32。</p>
</li>
<li>
<p>如果s是一个float格式或接近float格式的字符串，ParseFloat将返回按照IEEE 754规范舍入的float64值。</p>
</li>
<li>
<p>返回的err是*NumError格式，并且err.Num = s</p>
</li>
<li>
<p>如果s格式不是float格式，返回语法错误 err.Err = ErrSyntax。</p>
</li>
<li>
<p>如果s格式正确但转换成浮点数值后比bitSize指定的精度的最大浮点数大1/2 ULP（unit in the last place），返回值 f = ±Inf, err.Err = ErrRange。
代码实例：</p>
<p>package main</p>
<p>import (
&quot;fmt&quot;
&quot;strconv&quot;
)</p>
<p>func main() {
fmt.Println(strconv.ParseFloat(&quot;1.0231e2&quot;,64))
}</p>
</li>
</ul>
<p>代码输出：</p>
<pre><code>102.31 &lt;nil&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-parseints-string-base-int-bitsize-int-i-int64-err-error"><a class="header" href="#func-parseints-string-base-int-bitsize-int-i-int64-err-error">func ParseInt(s string, base int, bitSize int) (i int64, err error)</a></h1>
<p>参数列表</p>
<ul>
<li>str     可以表示int64值的字符串</li>
<li>base    进制 (2 to 36) </li>
<li>bitSize 精度 0、8、16、32、64对应int、int8、int16、int32、int64</li>
</ul>
<p>返回值：</p>
<ul>
<li>i       通过str转换的int64值.</li>
<li>err     当str无法转换为init64值返回错误，否则为nil.</li>
</ul>
<p>功能说明：</p>
<ul>
<li>尝试按照base指定的进制(2-36)将表示int64值的字符串转换为int64值。如果base为0,则参考s的格式自动确定进制，如：&quot;0x&quot;是16进制，&quot;O&quot;是8进制，其余是10进制。</li>
<li>返回err是*NumError格式，并且err.Num = s。如果s格式错误，则err.Err = ErrSyntax，并且i将返回0.如果转换的数值超过bitSize指定的带符号数值（signed integer），i将返回符合该bitSize的最大值符号数值。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;strconv&quot;
)

func main() {
    fmt.Println(strconv.ParseInt(&quot;9223372036854775807&quot;,10,64))
    fmt.Println(strconv.ParseInt(&quot;9223372036854775808&quot;,10,64))
    fmt.Println(strconv.ParseInt(&quot;0xa&quot;,0,64))
}
</code></pre>
<p>代码输出：</p>
<pre><code>9223372036854775807 &lt;nil&gt;
9223372036854775807 strconv.ParseInt: parsing &quot;9223372036854775808&quot;: value out of range
10 &lt;nil&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-parseuints-string-base-int-bitsize-int-n-uint64-err-error"><a class="header" href="#func-parseuints-string-base-int-bitsize-int-n-uint64-err-error">func ParseUint(s string, base int, bitSize int) (n uint64, err error)</a></h1>
<p>参数列表</p>
<ul>
<li>str     可以表示int64值的字符串</li>
<li>base    进制 (2 to 36) </li>
<li>bitSize 精度 0、8、16、32、64对应uint、uint8、uint16、uint32、uint64</li>
</ul>
<p>返回值：</p>
<ul>
<li>i       通过str转换的uint64值.</li>
<li>err     当str无法转换为uinit64值返回错误，否则为nil.</li>
</ul>
<p>功能说明：</p>
<ul>
<li>ParseUint is like <a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/strconv/ParseInt.html">ParseInt</a> but for unsigned numbers.</li>
</ul>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;strconv&quot;
)

func main() {
    fmt.Println(strconv.ParseUint(&quot;18446744073709551615&quot;,10,64))
    fmt.Println(strconv.ParseUint(&quot;18446744073709551616&quot;,10,64))
    fmt.Println(strconv.ParseUint(&quot;0xa&quot;,0,64))
}
</code></pre>
<p>代码输出：</p>
<pre><code>18446744073709551615 &lt;nil&gt;
18446744073709551615 strconv.ParseUint: parsing &quot;18446744073709551616&quot;: value out of range
10 &lt;nil&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-quotes-string-string"><a class="header" href="#func-quotes-string-string">func Quote(s string) string</a></h1>
<p>参数列表</p>
<ul>
<li>s     被引用的字符串</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回string 将s转换为被引用的字符串格式</li>
</ul>
<p>功能说明：</p>
<ul>
<li>对s两侧添加双引号，并对s中的控制字符和不可打印的字符进行转义。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;strconv&quot;
)

func main() {
    fmt.Println(strconv.Quote(&quot;abc	中文&quot;))
    fmt.Println(strconv.Quote(strconv.Quote(&quot;abc	中文&quot;)))
}
</code></pre>
<p>代码输出：</p>
<pre><code>&quot;abc\t中文&quot;
&quot;\&quot;abc\\t中文\&quot;&quot;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-quoteruner-rune-string"><a class="header" href="#func-quoteruner-rune-string">func QuoteRune(r rune) string</a></h1>
<p>参数列表</p>
<ul>
<li>r     被引用的rune字符</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回string 将r转换为被引用的字符格式</li>
</ul>
<p>功能说明：</p>
<ul>
<li>对s两侧添加单引号，并对r中的控制字符和不可打印的字符进行转义。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;strconv&quot;
)

func main() {
    fmt.Println(strconv.QuoteRune('	'))
    fmt.Println(strconv.QuoteRune(100))
}
</code></pre>
<p>代码输出：</p>
<pre><code>'\t'
'd'</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-quoterunetoasciir-rune-string"><a class="header" href="#func-quoterunetoasciir-rune-string">func QuoteRuneToASCII(r rune) string</a></h1>
<p>参数列表</p>
<ul>
<li>r     被引用的rune字符</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回string 将r转换为被引用的字符格式</li>
</ul>
<p>功能说明：</p>
<ul>
<li>对s两侧添加单引号，并对r中的非ASCII字符和不可打印的字符进行转义。</li>
</ul>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;strconv&quot;
)

func main() {
    fmt.Println(strconv.QuoteRune('中'))
    fmt.Println(strconv.QuoteRuneToASCII('中'))
    fmt.Println(strconv.QuoteRuneToASCII('	'))
}
</code></pre>
<p>代码输出：</p>
<pre><code>'中'
'\u4e2d'
'\t'</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-unquotes-string-t-string-err-error"><a class="header" href="#func-unquotes-string-t-string-err-error">func Unquote(s string) (t string, err error)</a></h1>
<p>参数列表</p>
<ul>
<li>s     被单引号、双引号或反引号引用的字符串</li>
</ul>
<p>返回值：</p>
<ul>
<li>t     将s转换为被引用前的字符串</li>
<li>err</li>
</ul>
<p>功能说明：</p>
<ul>
<li>返回将被（单引号、双引号、反引号）引用的字符串的原字符串。（如果s是被单引号引用，则被引用的字符串必须是go中的字符，并返回该单字符的字符串。）</li>
</ul>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;strconv&quot;
)

func main() {
    test := func(s string) {
        t, err := strconv.Unquote(s)
        if err != nil {
            fmt.Printf(&quot;Unquote(%#v) error： %v\n&quot;, s, err)
        } else {
            fmt.Printf(&quot;Unquote(%#v) = %v\n&quot;, s, t)
        }
    }

    s := `cafe\u0301`
    // If the string doesn't have quotes, it can't be unquoted.
    test(s) // invalid syntax
    test(&quot;`&quot; + s + &quot;`&quot;)
    test(`&quot;` + s + `&quot;`)

    test(`'\u00e9'`)

}
</code></pre>
<p>代码输出：</p>
<pre><code>Unquote(&quot;cafe\\u0301&quot;) error： invalid syntax
Unquote(&quot;`cafe\\u0301`&quot;) = cafe\u0301
Unquote(&quot;\&quot;cafe\\u0301\&quot;&quot;) = café
Unquote(&quot;'\\u00e9'&quot;) = é</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-unquotechars-string-quote-byte-value-rune-multibyte-bool-tail-string-err-error"><a class="header" href="#func-unquotechars-string-quote-byte-value-rune-multibyte-bool-tail-string-err-error">func UnquoteChar(s string, quote byte) (value rune, multibyte bool, tail string, err error)</a></h1>
<p>参数列表</p>
<ul>
<li>s         转义后的字符串</li>
<li>quote     字符串使用的引号符。
如果设置为单引号，则 s 中允许出现 ' 字符，不允许出现单独的 ' 字符
如果设置为双引号，则 s 中允许出现 &quot; 字符，不允许出现单独的 &quot; 字符
如果设置为 0，则不允许出现 ' 或 &quot; 字符，可以出现单独的 ' 或 &quot; 字符</li>
</ul>
<p>返回值：</p>
<ul>
<li>value     解码后的字符</li>
<li>multibyte value是否为多字节字符</li>
<li>tail      字符串 s 除去 value 后的剩余部分</li>
<li>err       返回 s 中是否存在语法错误</li>
</ul>
<p>功能说明：</p>
<ul>
<li>将 s 中的第一个字符“取消转义”并解码</li>
</ul>
<p>代码实例：</p>
<pre><code>func main() {
    sr := `\&quot;大\\家\\好！\&quot;`
    var c rune
    var mb bool
    var err error
    for ; len(sr) &gt; 0; c, mb, sr, err = strconv.UnquoteChar(sr, '&quot;') {
        fmt.Println(c, mb,sr,err)
    }
}
</code></pre>
<p>代码输出：</p>
<pre><code>0 false \&quot;大\\家\\好！\&quot; &lt;nil&gt;
34 false 大\\家\\好！\&quot; &lt;nil&gt;
22823 true \\家\\好！\&quot; &lt;nil&gt;
92 false 家\\好！\&quot; &lt;nil&gt;
23478 true \\好！\&quot; &lt;nil&gt;
92 false 好！\&quot; &lt;nil&gt;
22909 true ！\&quot; &lt;nil&gt;
65281 true \&quot; &lt;nil&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="strings包函数列表"><a class="header" href="#strings包函数列表">strings包函数列表</a></h1>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/strings/Contains.html">func Contains(s, substr string) bool</a> </li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/strings/ContainsAny.html">func ContainsAny(s, chars string) bool</a> </li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/strings/ContainsRune.html">func ContainsRune(s string, r rune) bool</a> </li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/strings/Count.html">func Count(s, sep string) int</a> </li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/strings/EqualFold.html">func EqualFold(s, t string) bool</a> </li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/strings/Fields.html">func Fields(s string) []string</a> </li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/strings/FieldsFunc.html">func FieldsFunc(s string, f func(rune) bool) []string </a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/strings/HasPrefix.html">func HasPrefix(s, prefix string) bool</a> </li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/strings/HasSuffix.html">func HasSuffix(s, suffix string) bool</a> </li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/strings/Index.html">func Index(s, sep string) int</a> </li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/strings/IndexAny.html">func IndexAny(s, chars string) int</a> </li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/strings/IndexFunc.html">func IndexFunc(s string, f func(rune) bool) int</a> </li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/strings/IndexRune.html">func IndexRune(s string, r rune) int</a> </li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/strings/Join.html">func Join(a []string, sep string) string</a> </li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/strings/LastIndex.html">func LastIndex(s, sep string) int</a> </li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/strings/LastIndexAny.html">func LastIndexAny(s, chars string) int</a> </li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/strings/LastIndexFunc.html">func LastIndexFunc(s string, f func(rune) bool) int</a> </li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/strings/Map.html">func Map(mapping func(rune) rune, s string) string</a> </li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/strings/Repeat.html">func Repeat(s string, count int) string</a> </li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/strings/Replace.html">func Replace(s, old, new string, n int) string</a> </li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/strings/Split.html">func Split(s, sep string) []string</a> </li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/strings/SplitAfter.html">func SplitAfter(s, sep string) []string</a> </li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/strings/SplitAfterN.html">func SplitAfterN(s, sep string, n int) []string</a> </li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/strings/SplitN.html">func SplitN(s, sep string, n int) []string</a> </li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/strings/Title.html">func Title(s string) string</a> </li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/strings/ToLower.html">func ToLower(s string) string</a> </li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/strings/ToLowerSpecial.html">func ToLowerSpecial(_case unicode.SpecialCase, s string) string</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/strings/ToTitle.html">func ToTitle(s string) string</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/strings/ToTitleSpecial.html">func ToTitleSpecial(_case unicode.SpecialCase, s string) string</a> </li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/strings/ToUpper.html">func ToUpper(s string) string</a> </li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/strings/ToUpperSpecial.html">func ToUpperSpecial(_case unicode.SpecialCase, s string) string</a> </li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/strings/Trim.html">func Trim(s string, cutset string) string</a> </li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/strings/TrimFunc.html">func TrimFunc(s string, f func(rune) bool) string</a> </li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/strings/TrimLeft.html">func TrimLeft(s string, cutset string) string</a> </li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/strings/TrimLeftFunc.html">func TrimLeftFunc(s string, f func(rune) bool) string</a> </li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/strings/TrimRight.html">func TrimRight(s string, cutset string) string</a> </li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/strings/TrimRightFunc.html">func TrimRightFunc(s string, f func(rune) bool) string</a> </li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/strings/TrimSpace.html">func TrimSpace(s string) string</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/strings/NewReader.html">func NewReader(s string) *Reader</a> </li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/strings/NewReplacer.html">func NewReplacer(oldnew ...string) *Replacer</a> </li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-containss-substr-string-bool"><a class="header" href="#func-containss-substr-string-bool">func Contains(s, substr string) bool</a></h2>
<p>参数列表</p>
<ul>
<li>s 表示需要判断的主串 </li>
<li>substr 表示包含的子串</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回bool</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是用来判断s中是否包含substr这个子串，如果包含返回true，否者返回false</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;strings&quot;
)

func main() {
	fmt.Println(strings.Contains(&quot;seafood&quot;, &quot;foo&quot;)) //true
	fmt.Println(strings.Contains(&quot;seafood&quot;, &quot;bar&quot;)) //false
	fmt.Println(strings.Contains(&quot;seafood&quot;, &quot;&quot;))    //true
	fmt.Println(strings.Contains(&quot;&quot;, &quot;&quot;))           //true
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-containsanys-chars-string-bool"><a class="header" href="#func-containsanys-chars-string-bool">func ContainsAny(s, chars string) bool</a></h1>
<p>参数列表</p>
<ul>
<li>s 表示需要判断的主串 </li>
<li>chars 表示保存的unicode字符串</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回bool</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是用来判断s中是否包含chars中的字符中的任意字符，如果包含返回true，否者返回false</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;strings&quot;
)

func main() {
	fmt.Println(strings.ContainsAny(&quot;team&quot;, &quot;i&quot;))       //false
	fmt.Println(strings.ContainsAny(&quot;failure&quot;, &quot;wwwi&quot;)) //true
	fmt.Println(strings.ContainsAny(&quot;foo&quot;, &quot;&quot;))         //false
	fmt.Println(strings.ContainsAny(&quot;&quot;, &quot;&quot;))            //false
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-containsrunes-string-r-rune-bool"><a class="header" href="#func-containsrunes-string-r-rune-bool">func ContainsRune(s string, r rune) bool</a></h1>
<p>参数列表</p>
<ul>
<li>s 表示需要判断的主串 </li>
<li>r 表示rune字符</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回bool</li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是用来判断s中是否包含rune类型的r字符，如果包含返回true，否者返回false</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;strings&quot;
)

func main() {
	fmt.Println(strings.ContainsRune(&quot;team&quot;, rune('m')))    //true
	fmt.Println(strings.ContainsRune(&quot;failure&quot;, rune('w'))) //false
	fmt.Println(strings.ContainsRune(&quot;谢foo&quot;, rune('谢')))    //true
	fmt.Println(strings.ContainsRune(&quot;&quot;, 30))               //false
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-counts-sep-string-int"><a class="header" href="#func-counts-sep-string-int">func Count(s, sep string) int</a></h1>
<p>参数列表</p>
<ul>
<li>s 表示需要判断的主串 </li>
<li>sep 需要计算的子串</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回int 表示s中包含sep的个数 </li>
</ul>
<p>功能说明：</p>
<p>这个函数主要是用来判断s中包含了多少个sep</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;strings&quot;
)

func main() {
	fmt.Println(strings.Count(&quot;cheese&quot;, &quot;e&quot;))  //3
	fmt.Println(strings.Count(&quot;cheese&quot;, &quot;ee&quot;)) //1
	fmt.Println(strings.Count(&quot;five&quot;, &quot;&quot;))     // 5

}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-equalfolds-t-string-bool"><a class="header" href="#func-equalfolds-t-string-bool">func EqualFold(s, t string) bool</a></h1>
<p>参数列表</p>
<ul>
<li>s 表示需要判断的主串 </li>
<li>t 表示需要比较的辅串</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回bool</li>
</ul>
<p>功能说明：</p>
<p>字符串s和t比较，它们在全部小写的情况下，采用UTF8编码的底层的unicode是否一致</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;strings&quot;
)

func main() {
	fmt.Println(strings.EqualFold(&quot;Go&quot;, &quot;go&quot;))  //true
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-fieldss-string-string"><a class="header" href="#func-fieldss-string-string">func Fields(s string) []string</a></h1>
<p>参数列表</p>
<ul>
<li>s 表示需要判断的主串</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回[]string </li>
</ul>
<p>功能说明：</p>
<p>s按照一个空格或者多个连续的空格分割，返回分割之后的串数组，如果字符串没有空格或者只有一个空格，那么返回元素为去空格的s字符串</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;strings&quot;
)

func main() {
	fmt.Printf(&quot;Fields are: %q&quot;, strings.Fields(&quot;  foo bar  baz   &quot;)) //Fields are: [&quot;foo&quot; &quot;bar&quot; &quot;baz&quot;]
	fmt.Printf(&quot;Fields are: %q&quot;, strings.Fields(&quot; baz &quot;)) //Fields are: [&quot;bar&quot;]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-fieldsfuncs-string-f-funcrune-bool-string"><a class="header" href="#func-fieldsfuncs-string-f-funcrune-bool-string">func FieldsFunc(s string, f func(rune) bool) []string</a></h1>
<p>参数列表</p>
<ul>
<li>s 表示需要判断的主串</li>
<li>f 表示一个函数，该函数参数是rune，返回值是bool，如果rune符合f函数的逻辑那么返回true，否者返回false</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回[]string </li>
</ul>
<p>功能说明：</p>
<p>该函数实现的功能：s的每一个字符传入函数f，如果f返回true，那么按照该字符进行分割（该字符不保留），继续下一个字符，以此类推直到最后，如果返回的都是为false或者s为空，那么将返回空的字符串slice</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;strings&quot;
)

func main() {
	a := strings.FieldsFunc(&quot;astaxie&quot;, splitfunc)
	fmt.Println(a) //输出：[asta ie]
	//如果把下面的函数t字符改成，那么将返回空slice
}

func splitfunc(a rune) bool {
	if a &gt; 't' {
		return true
	}
	return false
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-hasprefixs-prefix-string-bool"><a class="header" href="#func-hasprefixs-prefix-string-bool">func HasPrefix(s, prefix string) bool</a></h1>
<p>参数列表</p>
<ul>
<li>s 表示需要判断的主串</li>
<li>prefix 需要判断的前缀字符串</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回bool，</li>
</ul>
<p>功能说明：</p>
<p>该函数主要判断s串中是否含有前缀prefix，如果包含，那么返回true，否则返回false</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;strings&quot;
)

func main() {
	fmt.Println(strings.HasPrefix(&quot;astaxie&quot;, &quot;as&quot;)) //true
	fmt.Println(strings.HasPrefix(&quot;astaxie&quot;, &quot;ta&quot;)) //false
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-hassuffixs-suffix-string-bool"><a class="header" href="#func-hassuffixs-suffix-string-bool">func HasSuffix(s, suffix string) bool</a></h1>
<p>参数列表</p>
<ul>
<li>s 表示需要判断的主串</li>
<li>suffix 需要判断的后缀字符串</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回bool，</li>
</ul>
<p>功能说明：</p>
<p>该函数主要判断s串中是否含有后缀suffix，如果包含，那么返回true，否则返回false</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;strings&quot;
)

func main() {
	fmt.Println(strings.HasSuffix(&quot;astaxie&quot;, &quot;as&quot;)) //false
	fmt.Println(strings.HasSuffix(&quot;astaxie&quot;, &quot;xie&quot;)) //true
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-indexs-sep-string-int"><a class="header" href="#func-indexs-sep-string-int">func Index(s, sep string) int</a></h1>
<p>参数列表</p>
<ul>
<li>s 表示需要判断的主串</li>
<li>sep 需要判断的第一次出现位置的字符串</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回int，对应sep出现在s中的位置</li>
</ul>
<p>功能说明：</p>
<p>该函数主要判断sep串在s串中第一次出现的位置，如果不存在返回-1</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;strings&quot;
)

func main() {
	fmt.Println(strings.Index(&quot;chickenkenken&quot;, &quot;ken&quot;))  //4
	fmt.Println(strings.Index(&quot;chicken&quot;, &quot;dmr&quot;))        //-1
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-indexanys-chars-string-int"><a class="header" href="#func-indexanys-chars-string-int">func IndexAny(s, chars string) int</a></h1>
<p>参数列表</p>
<ul>
<li>s 表示需要判断的主串</li>
<li>chars 需要判断的第一次出现位置的字符集</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回int，对应sep出现在s中的位置</li>
</ul>
<p>功能说明：</p>
<p>该函数主要判断chars集中任意的一个字符在s串中第一次出现的位置，如果不存在返回-1</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;strings&quot;
)

func main() {
	fmt.Println(strings.IndexAny(&quot;chickenkenkenken&quot;, &quot;iken&quot;))   //2
	fmt.Println(strings.IndexAny(&quot;chicken&quot;, &quot;dmr&quot;))   //-1
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-indexfuncs-string-f-funcrune-bool-int"><a class="header" href="#func-indexfuncs-string-f-funcrune-bool-int">func IndexFunc(s string, f func(rune) bool) int</a></h1>
<p>参数列表</p>
<ul>
<li>s 表示需要判断的主串</li>
<li>f 表示一个函数，该函数参数是rune，返回值是bool，如果rune符合f函数的逻辑那么返回true，否者返回false</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回int，对应符合函数f的字符的位置</li>
</ul>
<p>功能说明：</p>
<p>该函数主要判断s中的每一个字符传入函数f，如果符合，那么返回该字符的位置，如果都不符合则返回-1</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;strings&quot;
)

func main() {
	fmt.Println(strings. IndexFunc(&quot;astaxie&quot;, splitfunc))  //符合条件的是字符x，因为字符x的rune大于t，所以这个位置应该返回4
	fmt.Println(strings. IndexFunc(&quot;aaabbbb&quot;, splitfunc))  //所有的字符都不符合条件，则返回-1
}

func splitfunc(a rune) bool {
	if a &gt; 't' {
		return true
	}
	return false
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-indexrunes-string-r-rune-int"><a class="header" href="#func-indexrunes-string-r-rune-int">func IndexRune(s string, r rune) int</a></h1>
<p>参数列表</p>
<ul>
<li>
<p>s 表示需要判断的主串</p>
</li>
<li>
<p>r 需要判断的第一次出现位置的unicode码
返回值：</p>
</li>
<li>
<p>返回int，对应r出现在s中的位置</p>
</li>
</ul>
<p>功能说明：</p>
<p>该函数主要判断unicode r在s串中第一次出现的位置，如果不存在返回-1</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;strings&quot;
)

func main() {
	fmt.Println(strings.IndexRune(&quot;chicken&quot;, 'k'))  //4
	fmt.Println(strings.IndexRune(&quot;chicken&quot;, 'd'))  //-1
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-joina-string-sep-string-string"><a class="header" href="#func-joina-string-sep-string-string">func Join(a []string, sep string) string</a></h1>
<p>参数列表</p>
<ul>
<li>a 表示需要链接起来的字符串slice</li>
<li>sep 表示链接的符号</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回string</li>
</ul>
<p>功能说明：</p>
<p>该函数主要实现字符串slice的链接功能，把slice的每一个元素通过sep进行链接</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;strings&quot;
)

func main() {
	s := []string{&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;}
	fmt.Println(strings.Join(s, &quot;, &quot;)) //foo, bar, baz
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-lastindexs-sep-string-int"><a class="header" href="#func-lastindexs-sep-string-int">func LastIndex(s, sep string) int</a></h1>
<p>参数列表</p>
<ul>
<li>s 表示需要判断的对象字符串</li>
<li>sep 表示最后出现的字符串</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回int</li>
</ul>
<p>功能说明：</p>
<p>该函数主要判断sep串在s串中最后一次出现的位置，如果不存在返回-1 </p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;strings&quot;
)

func main() {
	fmt.Println(strings.LastIndex(&quot;chickenkenken&quot;, &quot;ken&quot;))  //10
	fmt.Println(strings.LastIndex(&quot;chicken&quot;, &quot;dmr&quot;))        //-1
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-lastindexanys-chars-string-int"><a class="header" href="#func-lastindexanys-chars-string-int">func LastIndexAny(s, chars string) int</a></h1>
<p>参数列表</p>
<ul>
<li>s 表示需要判断的主串</li>
<li>chars 需要判断的最后一次出现位置的字符集</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回int，对应sep出现在s中的最后位置</li>
</ul>
<p>功能说明：</p>
<p>该函数主要判断chars集中任意的一个字符在s串中最后一次出现的位置，如果不存在返回-1</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;strings&quot;
)

func main() {
	fmt.Println(strings.LastIndexAny(&quot;chickenkenkenken&quot;, &quot;iken&quot;))   //15
	fmt.Println(strings.LastIndexAny(&quot;chicken&quot;, &quot;dmr&quot;))   //-1
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-lastindexfuncs-string-f-funcrune-bool-int"><a class="header" href="#func-lastindexfuncs-string-f-funcrune-bool-int">func LastIndexFunc(s string, f func(rune) bool) int</a></h1>
<p>参数列表</p>
<ul>
<li>s 表示需要判断的主串</li>
<li>f 表示一个函数，该函数参数是rune，返回值是bool，如果rune符合f函数的逻辑那么返回true，否者返回false</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回int，对应符合函数f的字符的位置</li>
</ul>
<p>功能说明：</p>
<p>该函数主要判断s中的每一个字符传入函数f，返回符合函数f的最后一个字符的位置，如果都不符合则返回-1</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;strings&quot;
)

func main() {
	fmt.Println(strings.LastIndexFunc(&quot;astaxie&quot;, splitfunc)) //符合条件的有字符t和x，因为字符x是最后出现的位置，所以这个位置应该返回4
	fmt.Println(strings.LastIndexFunc(&quot;aaabbbb&quot;, splitfunc)) //所有的字符都不符合条件，则返回-1
}

func splitfunc(a rune) bool {
	if a &gt; 'm' {
		return true
	}
	return false
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-mapmapping-funcrune-rune-s-string-string"><a class="header" href="#func-mapmapping-funcrune-rune-s-string-string">func Map(mapping func(rune) rune, s string) string</a></h1>
<p>参数列表</p>
<ul>
<li>mapping 处理函数，输入是字符，输出是字符</li>
<li>s 表示需要处理的主串</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回string，处理后的字符串</li>
</ul>
<p>功能说明：</p>
<p>该函数以此读取s中的字符，传入mapping函数，然后返回的字符链接起来，说白了就是字符串的每一个字符通过mapping函数的处理，最后返回处理好的字符串，如果处理不正确，那么就抛弃该字符</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;strings&quot;
)

func main() {
	rot13 := func(r rune) rune {
		switch {
		case r &gt;= 'A' &amp;&amp; r &lt;= 'Z':
			return 'A' + (r-'A'+13)%26
		case r &gt;= 'a' &amp;&amp; r &lt;= 'z':
			return 'a' + (r-'a'+13)%26
		}
		return r
	}
	fmt.Println(strings.Map(rot13, &quot;'Twas brillig and the slithy gopher...&quot;))
	//'Gjnf oevyyvt naq gur fyvgul tbcure...
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-reader-2"><a class="header" href="#type-reader-2">type Reader</a></h1>
<p>Reader是通过读取一个字符串之后实现了io.Reader, io.ReaderAt, io.Seeker, io.ByteScanner, 和io.RuneScanner 接口</p>
<h1 id="func-newreaders-string-reader"><a class="header" href="#func-newreaders-string-reader">func NewReader(s string) *Reader</a></h1>
<p>参数列表</p>
<ul>
<li>s 读取的字符串</li>
</ul>
<p>返回值：</p>
<ul>
<li>*Reader 通过读取一个字符串之后返回Reader对象</li>
</ul>
<p>对象的方法列表：</p>
<ul>
<li>func (r *Reader) Len() int   //返回未读取的字符串的长度</li>
<li>func (r *Reader) Read(b []byte) (n int, err error)  //读取数据到b中，返回读取的实际大小n，如果出错返回err，例如EOF或者b的长度为0</li>
<li>func (r *Reader) ReadAt(b []byte, off int64) (n int, err error) //按照指定的off位置开始读取内容到b，返回读取的实际大小n，如果出错返回err，例如off小于0或者大于本身的长度或者文件尾</li>
<li>func (r *Reader) ReadByte() (b byte, err error)  //读取一个byte的数据</li>
<li>func (r *Reader) ReadRune() (ch rune, size int, err error)  //读取一个rune的数据</li>
<li>func (r *Reader) Seek(offset int64, whence int) (int64, error) //根据whence来移动offset，如果whence=0为直接移动offset位置，=1为移动到当前位置之后的offset，=2为移动到当前字符串长度之后的offset位置</li>
<li>func (r *Reader) UnreadByte() error  //当前读取的位置向前移一个byte</li>
<li>func (r *Reader) UnreadRune() error  //当前读取的位置向前移一个rune</li>
</ul>
<p>功能说明：</p>
<p>该函数主要是通过把字符串读取Reader之后进行的一些读取操作</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;strings&quot;
)

func main() {
	read := strings.NewReader(&quot;I am asta谢&quot;)
	var b []byte
	fmt.Println(read.Len())  //12
	b = make([]byte,8)
	n, err := read.Read(b)
	if err != nil {
		fmt.Println(err)
	}
	fmt.Println(b)   //[73 32 97 109 32 97 115 116]
	fmt.Println(n)   //8
	n, err = read.ReadAt(b,3)
	if err != nil {
		fmt.Println(err)
	}
	fmt.Println(b)   //[109 32 97 115 116 97 232 176]
	fmt.Println(n)   //8
	bt,err:=read.ReadByte()	
	if err != nil {
		fmt.Println(err)
	}
	fmt.Println(bt)  //97
	rn,size,err:=read.ReadRune()	
	if err != nil {
		fmt.Println(err)
	}
	fmt.Println(rn)    //35874
	fmt.Println(size)  //3
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-replacer"><a class="header" href="#type-replacer">type Replacer</a></h1>
<p>这是一个字符串替换的对象</p>
<h1 id="func-newreplaceroldnew-string-replacer"><a class="header" href="#func-newreplaceroldnew-string-replacer">func NewReplacer(oldnew ...string) *Replacer</a></h1>
<p>参数列表</p>
<ul>
<li>oldnew是一个slice，是一个需要替换的字符串和新的字符串的配对出现</li>
</ul>
<p>返回参数</p>
<ul>
<li>Replacer返回一个替换对象</li>
</ul>
<p>Replacer方法列表</p>
<ul>
<li>func (r *Replacer) Replace(s string) string   // 把字符串替换为oldnew定义的</li>
<li>func (r *Replacer) WriteString(w io.Writer, s string) (n int, err error)  //替换之后的字符串写入到w之中，返回写入的数量</li>
</ul>
<p>应用示例，下面代码来自于beego的模板替换：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;strings&quot;
	&quot;os&quot;
)

func main() {
	patterns := []string{&quot;abc&quot;, &quot;efg&quot;}
	replacer := strings.NewReplacer(patterns...)
	format := replacer.Replace(&quot;abc is abc is abc&quot;)
	fmt.Println(format)
	//efg is efg is efg
	replacer.WriteString(os.Stdout,&quot;abc is abc is abc&quot;)
	//efg is efg is efg
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-repeats-string-count-int-string"><a class="header" href="#func-repeats-string-count-int-string">func Repeat(s string, count int) string</a></h1>
<p>参数列表</p>
<ul>
<li>s 表示需要重复的字符串</li>
<li>count 表示重复字数</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回string 重复的字符串</li>
</ul>
<p>功能说明：</p>
<p>该函数返回一个s的重复count字数的字符串</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;strings&quot;
)

func main() {
	fmt.Println(&quot;ba&quot; + strings.Repeat(&quot;na&quot;, 2))  //banana
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-replaces-old-new-string-n-int-string"><a class="header" href="#func-replaces-old-new-string-n-int-string">func Replace(s, old, new string, n int) string</a></h1>
<p>参数列表</p>
<ul>
<li>s 表示需要替换的主字符串</li>
<li>old 表示需要替换的字符串</li>
<li>new 表示替换的新字符串</li>
<li>n 表示替换的次数</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回string，处理之后的字符串</li>
</ul>
<p>功能说明：</p>
<p>该函数实现在s中把old替换为new字符串，替换次数为n，如果n小于0，那么就全部替换</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;strings&quot;
)

func main() {
	fmt.Println(strings.Replace(&quot;oink oink oink&quot;, &quot;k&quot;, &quot;ky&quot;, 2))   //oinky oinky oink
	fmt.Println(strings.Replace(&quot;oink oink oink&quot;, &quot;oink&quot;, &quot;moo&quot;, -1))   //moo moo moo
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-splits-sep-string-string"><a class="header" href="#func-splits-sep-string-string">func Split(s, sep string) []string</a></h1>
<p>参数列表</p>
<ul>
<li>s 表示需要处理的字符串</li>
<li>sep 表示分割的字符串</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回[]string 分割之后的字符串slice</li>
</ul>
<p>功能说明：</p>
<p>该函数s根据sep分割，返回分割之后子字符串的slice，如果sep为空，那么每一个字符都分割</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;strings&quot;
)

func main() {
	fmt.Printf(&quot;%q\n&quot;, strings.Split(&quot;a,b,c&quot;, &quot;,&quot;))   //[&quot;a&quot; &quot;b&quot; &quot;c&quot;]
	fmt.Printf(&quot;%q\n&quot;, strings.Split(&quot;a man a plan a canal panama&quot;, &quot;a &quot;))  //[&quot;&quot; &quot;man &quot; &quot;plan &quot; &quot;canal panama&quot;]
	fmt.Printf(&quot;%q\n&quot;, strings.Split(&quot; xyz &quot;, &quot;&quot;))  //[&quot; &quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; &quot; &quot;]
	fmt.Printf(&quot;%q\n&quot;, strings.Split(&quot;&quot;, &quot;Bernardo O'Higgins&quot;))   //[&quot;&quot;]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-splitafters-sep-string-string"><a class="header" href="#func-splitafters-sep-string-string">func SplitAfter(s, sep string) []string</a></h1>
<p>参数列表</p>
<ul>
<li>s 表示需要处理的字符串</li>
<li>sep 表示分割的字符串</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回[]string 分割之后的字符串slice</li>
</ul>
<p>功能说明：</p>
<p>该函数s根据sep分割，返回分割之后子字符串的slice,和split一样，只是返回的子字符串保留sep，如果sep为空，那么每一个字符都分割</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;strings&quot;
)

func main() {
	fmt.Printf(&quot;%q\n&quot;, strings.SplitAfter(&quot;a,b,c&quot;, &quot;,&quot;))  //[&quot;a,&quot; &quot;b,&quot; &quot;c&quot;]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-splitafterns-sep-string-n-int-string"><a class="header" href="#func-splitafterns-sep-string-n-int-string">func SplitAfterN(s, sep string, n int) []string</a></h1>
<p>参数列表</p>
<ul>
<li>
<p>s 表示需要处理的字符串</p>
</li>
<li>
<p>sep 表示分割的字符串</p>
</li>
<li>
<p>n 表示需要分割的子字符串</p>
<ul>
<li>n &gt; 0: 最多n个子字符串; 最后一个就是剩下未分割的子字符串.</li>
<li>n == 0: 返回为0的字符串</li>
<li>n &lt; 0: 返回所有的子字符串，和SplitAfter</li>
</ul>
</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回[]string 分割之后的字符串slice</li>
</ul>
<p>功能说明：</p>
<p>该函数s根据sep分割，返回分割之后子字符串的slice,和split一样，只是返回的子字符串保留sep，如果sep为空，那么每一个字符都分割</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;strings&quot;
)

func main() {
	fmt.Printf(&quot;%q\n&quot;, strings.SplitAfterN(&quot;a,b,c&quot;, &quot;,&quot;, 2))  //[&quot;a,&quot; &quot;b,c&quot;]
	fmt.Printf(&quot;%q\n&quot;, strings.SplitAfterN(&quot;a,b,c&quot;, &quot;&quot;, 5))   //[&quot;a&quot; &quot;,&quot; &quot;b&quot; &quot;,&quot; &quot;c&quot;]
	fmt.Printf(&quot;%q\n&quot;, strings.SplitAfterN(&quot;a,b,c&quot;, &quot;,&quot;, 1))   //[&quot;a,b,c&quot;]
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-splitns-sep-string-n-int-string"><a class="header" href="#func-splitns-sep-string-n-int-string">func SplitN(s, sep string, n int) []string</a></h1>
<p>参数列表</p>
<ul>
<li>
<p>s 表示需要处理的字符串</p>
</li>
<li>
<p>sep 表示分割的字符串</p>
</li>
<li>
<p>n 表示分割的最多子串</p>
<ul>
<li>n &gt; 0: 最多n个子字符串; 最后一个就是剩下未分割的子字符串.</li>
<li>n == 0: 返回为0的字符串</li>
<li>n &lt; 0: 返回所有的子字符串，和SplitAfter</li>
</ul>
</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回[]string 分割之后的字符串slice</li>
</ul>
<p>功能说明：</p>
<p>该函数s根据sep分割，返回分割之后子字符串的slice，返回的子串的长度如n的定义，如果sep为空，那么每一个字符都分割</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;strings&quot;
)

func main() {
	fmt.Printf(&quot;%q\n&quot;, strings.SplitN(&quot;a,b,c&quot;, &quot;,&quot;, 2))  //[&quot;a&quot; &quot;b,c&quot;]
	z := strings.SplitN(&quot;a,b,c&quot;, &quot;,&quot;, 0)
	fmt.Printf(&quot;%q (nil = %v)\n&quot;, z, z == nil)  //[] (nil = true)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-titles-string-string"><a class="header" href="#func-titles-string-string">func Title(s string) string</a></h1>
<p>参数列表</p>
<ul>
<li>s 表示需要处理的字符串</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回string 转化之后的字符串</li>
</ul>
<p>功能说明：</p>
<p>该函数把s字符串里面的每个单词首字母转化为大写</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;strings&quot;
)

func main() {
	fmt.Println(strings.Title(&quot;her royal highness&quot;))
	//Her Royal Highness
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-tolowers-string-string"><a class="header" href="#func-tolowers-string-string">func ToLower(s string) string</a></h1>
<p>参数列表</p>
<ul>
<li>s 表示需要处理的字符串</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回string 转化之后的字符串</li>
</ul>
<p>功能说明：</p>
<p>该函数把s字符串里面的每个单词转化为小写</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;strings&quot;
)

func main() {
	fmt.Println(strings.ToLower(&quot;Gopher&quot;))
	//gopher
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-tolowerspecial_case-unicodespecialcase-s-string-string"><a class="header" href="#func-tolowerspecial_case-unicodespecialcase-s-string-string">func ToLowerSpecial(_case unicode.SpecialCase, s string) string</a></h1>
<p>参数列表</p>
<ul>
<li>_case 表示unicode的SpecialCase对象</li>
<li>s 表示需要处理的字符串</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回string 转化之后的字符串</li>
</ul>
<p>功能说明：</p>
<p>该函数把s字符串里面的每个单词转化为小写，但是调用的是unicode.SpecialCase的ToLower方法</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;strings&quot;
	&quot;unicode&quot;
)

func main() {
	var SC unicode.SpecialCase
	fmt.Println(strings.ToLowerSpecial(SC, &quot;Gopher&quot;))
	//gopher
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-totitles-string-string"><a class="header" href="#func-totitles-string-string">func ToTitle(s string) string</a></h1>
<p>参数列表</p>
<ul>
<li>s 表示需要处理的字符串</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回string 转化之后的字符串</li>
</ul>
<p>功能说明：</p>
<p>该函数把s字符串里面的每个字符转化为对应的大写字符，其实和ToUpper一样的效果，但是有些语种的unicode,ToTitle和ToUpper效果不一样，但是我没试出来过，英语至少是一样的。</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;strings&quot;
)

func main() {
	fmt.Println(strings.ToTitle(&quot;Gopher&quot;))
	//GOPHER
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-totitlespecial_case-unicodespecialcase-s-string-string"><a class="header" href="#func-totitlespecial_case-unicodespecialcase-s-string-string">func ToTitleSpecial(_case unicode.SpecialCase, s string) string</a></h1>
<p>参数列表</p>
<ul>
<li>_case 表示unicode的SpecialCase对象</li>
<li>s 表示需要处理的字符串</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回string 转化之后的字符串</li>
</ul>
<p>功能说明：</p>
<p>该函数把s字符串里面的每个单词转化为标题体，但是调用的是unicode.SpecialCase的ToTitle方法</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;strings&quot;
	&quot;unicode&quot;
)

func main() {
	var SC unicode.SpecialCase
	fmt.Println(strings.ToTitleSpecial(SC, &quot;Gopher&quot;))
	//GOPHER
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-touppers-string-string"><a class="header" href="#func-touppers-string-string">func ToUpper(s string) string</a></h1>
<p>参数列表</p>
<ul>
<li>s 表示需要处理的字符串</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回string 转化之后的字符串</li>
</ul>
<p>功能说明：</p>
<p>该函数把s字符串里面的每个字符转化为大写</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;strings&quot;
)

func main() {
	fmt.Println(strings.ToUpper(&quot;Gopher&quot;))
	//GOPHER
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-toupperspecial_case-unicodespecialcase-s-string-string"><a class="header" href="#func-toupperspecial_case-unicodespecialcase-s-string-string">func ToUpperSpecial(_case unicode.SpecialCase, s string) string</a></h1>
<p>参数列表</p>
<ul>
<li>_case 表示unicode的SpecialCase对象</li>
<li>s 表示需要处理的字符串</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回string 转化之后的字符串</li>
</ul>
<p>功能说明：</p>
<p>该函数把s字符串里面的每个单词转化为大写，但是调用的是unicode.SpecialCase的ToUpper方法</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;strings&quot;
	&quot;unicode&quot;
)

func main() {
	var SC unicode.SpecialCase
	fmt.Println(strings.ToUpperSpecial(SC, &quot;Gopher&quot;))
	//GOPHER
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-trims-string-cutset-string-string"><a class="header" href="#func-trims-string-cutset-string-string">func Trim(s string, cutset string) string</a></h1>
<p>参数列表</p>
<ul>
<li>s 表示需要处理的字符串</li>
<li>cutset 表示需要过滤的字符集</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回string 转化之后的字符串</li>
</ul>
<p>功能说明：</p>
<p>该函数把s字符串开头或者结尾里面包含字符集的字符全部过滤掉，返回过滤之后的字符串</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;strings&quot;
)

func main() {
	fmt.Printf(&quot;[%q]&quot;, strings.Trim(&quot; !!! Achtung !!! &quot;, &quot;! &quot;))
	//[&quot;Achtung&quot;]
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-trimfuncs-string-f-funcrune-bool-string"><a class="header" href="#func-trimfuncs-string-f-funcrune-bool-string">func TrimFunc(s string, f func(rune) bool) string</a></h1>
<p>参数列表</p>
<ul>
<li>s 表示需要处理的字符串</li>
<li>f 表示一个函数，判断是否过滤该字符的函数，如果为真那么就过滤</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回string 转化之后的字符串</li>
</ul>
<p>功能说明：</p>
<p>该函数把s字符串里面开头和结尾部分字符传入f函数进行判断是否过滤，为真就过滤</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;strings&quot;
)

func main() {
	fmt.Printf(&quot;[%q]&quot;, strings.TrimFunc(&quot;xxastaxieyy&quot;, filte))
	//astaxie
}

func filte(r rune) bool {
	if r &gt; 't' {
		return true
	}
	return false
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-trimlefts-string-cutset-string-string"><a class="header" href="#func-trimlefts-string-cutset-string-string">func TrimLeft(s string, cutset string) string</a></h1>
<p>参数列表</p>
<ul>
<li>s 表示需要处理的字符串</li>
<li>cutset 表示需要过滤的字符集</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回string 转化之后的字符串</li>
</ul>
<p>功能说明：</p>
<p>该函数把s字符串开头里面包含字符集的字符全部过滤掉，返回过滤之后的字符串</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;strings&quot;
)

func main() {
	fmt.Printf(&quot;[%q]&quot;, strings.TrimLeft(&quot; !!! Achtung !!! &quot;, &quot;! &quot;))
	//[&quot;Achtung !!! &quot;]
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-trimleftfuncs-string-f-funcrune-bool-string"><a class="header" href="#func-trimleftfuncs-string-f-funcrune-bool-string">func TrimLeftFunc(s string, f func(rune) bool) string</a></h1>
<p>参数列表</p>
<ul>
<li>s 表示需要处理的字符串</li>
<li>f 表示一个函数，判断是否过滤该字符的函数，如果为真那么就过滤</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回string 转化之后的字符串</li>
</ul>
<p>功能说明：</p>
<p>该函数把s字符串里面开头部分字符传入f函数进行判断是否过滤，为真就过滤</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;strings&quot;
)

func main() {
	fmt.Printf(&quot;[%q]&quot;, strings.TrimLeftFunc(&quot;xxastaxieyy&quot;, filte))
	//astaxieyy
}

func filte(r rune) bool {
	if r &gt; 't' {
		return true
	}
	return false
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-trimrights-string-cutset-string-string"><a class="header" href="#func-trimrights-string-cutset-string-string">func TrimRight(s string, cutset string) string</a></h1>
<p>参数列表</p>
<ul>
<li>s 表示需要处理的字符串</li>
<li>cutset 表示需要过滤的字符集</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回string 转化之后的字符串</li>
</ul>
<p>功能说明：</p>
<p>该函数把s字符串结尾里面包含字符集的字符全部过滤掉，返回过滤之后的字符串</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;strings&quot;
)

func main() {
	fmt.Printf(&quot;[%q]&quot;, strings.TrimRight(&quot; !!! Achtung !!! &quot;, &quot;! &quot;))
	//[&quot; !!! Achtung&quot;]
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-trimrightfuncs-string-f-funcrune-bool-string"><a class="header" href="#func-trimrightfuncs-string-f-funcrune-bool-string">func TrimRightFunc(s string, f func(rune) bool) string</a></h1>
<p>参数列表</p>
<ul>
<li>s 表示需要处理的字符串</li>
<li>f 表示一个函数，判断是否过滤该字符的函数，如果为真那么就过滤</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回string 转化之后的字符串</li>
</ul>
<p>功能说明：</p>
<p>该函数把s字符串里面结尾部分字符传入f函数进行判断是否过滤，为真就过滤</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;strings&quot;
)

func main() {
	fmt.Printf(&quot;[%q]&quot;, strings.TrimRightFunc(&quot;xxastaxieyy&quot;, filte))
	//xxastaxie
}

func filte(r rune) bool {
	if r &gt; 't' {
		return true
	}
	return false
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-trimspaces-string-string"><a class="header" href="#func-trimspaces-string-string">func TrimSpace(s string) string</a></h1>
<p>参数列表</p>
<ul>
<li>s 表示需要处理的字符串</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回string 转化之后的字符串</li>
</ul>
<p>功能说明：</p>
<p>该函数把s字符串开头或者结尾里面空白符('\t', '\n', '\v', '\f', '\r', ' ', U+0085 (NEL), U+00A0 (NBSP))全部过滤掉，返回过滤之后的字符串</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;strings&quot;
)

func main() {
	fmt.Println(strings.TrimSpace(&quot; \t\n a lone gopher \n\t\r\n&quot;))
	//a lone gopher
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sync函数列表"><a class="header" href="#sync函数列表">sync函数列表</a></h1>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/sync/cond.html">func NewCond(l Locker) *Cond</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/sync/cond.html">func (c *Cond) Broadcast()</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/sync/cond.html">func (c *Cond) Signal()</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/sync/cond.html">func (c *Cond) Wait()</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/sync/mutex.html">func (m *Mutex) Lock()</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/sync/mutex.html">func (m *Mutex) Unlock()</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/sync/once.html">func (o *Once) Do(f func())</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/sync/rwmutex.html">func (rw *RWMutex) Lock()</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/sync/rwmutex.html">func (rw *RWMutex) RLock()</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/sync/rwmutex.html">func (rw *RWMutex) RLocker() Locker</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/sync/rwmutex.html">func (rw *RWMutex) RUnlock()</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/sync/rwmutex.html">func (rw *RWMutex) Unlock()</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/sync/waitgroup.html">func (wg *WaitGroup) Add(delta int)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/sync/waitgroup.html">func (wg *WaitGroup) Done()</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/sync/waitgroup.html">func (wg *WaitGroup) Wait()</a></li>
</ul>
<p>=======</p>
<h1 id="包名-62"><a class="header" href="#包名-62">包名</a></h1>
<p>函数列表</p>
<ul>
<li>xxx1</li>
<li>xxx2</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="syncatnomic"><a class="header" href="#syncatnomic">sync/atnomic</a></h1>
<p>函数列表</p>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/sync/atomic/addint32.html">func AddInt32(val *int32, delta int32) (new int32)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/sync/atomic/addint32.html">func AddInt64(val *int64, delta int64) (new int64)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/sync/atomic/addint32.html">func AddUint32(val *uint32, delta uint32) (new uint32)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/sync/atomic/addint32.html">func AddUint64(val *uint64, delta uint64) (new uint64)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/sync/atomic/addint32.html">func AddUintptr(val *uintptr, delta uintptr) (new uintptr)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/sync/atomic/compareandswapint32.html">func CompareAndSwapInt32(val *int32, old, new int32) (swapped bool)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/sync/atomic/compareandswapint32.html">func CompareAndSwapInt64(val *int64, old, new int64) (swapped bool)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/sync/atomic/compareandswapint32.html">func CompareAndSwapPointer(val *unsafe.Pointer, old, new unsafe.Pointer) (swapped bool)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/sync/atomic/compareandswapint32.html">func CompareAndSwapUint32(val *uint32, old, new uint32) (swapped bool)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/sync/atomic/compareandswapint32.html">func CompareAndSwapUint64(val *uint64, old, new uint64) (swapped bool)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/sync/atomic/compareandswapint32.html">func CompareAndSwapUint64(val *uint64, old, new uint64) (swapped bool)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/sync/atomic/loadint32.html">func LoadInt32(addr *int32) (val int32)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/sync/atomic/loadint32.html">func LoadInt64(addr *int64) (val int64)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/sync/atomic/loadint32.html">func LoadPointer(addr *unsafe.Pointer) (val unsafe.Pointer)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/sync/atomic/loadint32.html">func LoadUint32(addr *uint32) (val uint32)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/sync/atomic/loadint32.html">func LoadUint64(addr *uint64) (val uint64)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/sync/atomic/loadint32.html">func LoadUintptr(addr *uintptr) (val uintptr)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/sync/atomic/storeint32.html">func StoreInt32(addr *int32, val int32)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/sync/atomic/storeint32.html">func StoreInt64(addr *int64, val int64)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/sync/atomic/storeint32.html">func StorePointer(addr *unsafe.Pointer, val unsafe.Pointer)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/sync/atomic/storeint32.html">func StorePointer(addr *unsafe.Pointer, val unsafe.Pointer)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/sync/atomic/storeint32.html">func StorePointer(addr *unsafe.Pointer, val unsafe.Pointer)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/sync/atomic/storeint32.html">func StoreUintptr(addr *uintptr, val uintptr)</a></li>
</ul>
<p>=======</p>
<h1 id="包名-63"><a class="header" href="#包名-63">包名</a></h1>
<p>函数列表</p>
<ul>
<li>xxx1</li>
<li>xxx2</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fuc-addint32val-int32-delta-int32-new-int32"><a class="header" href="#fuc-addint32val-int32-delta-int32-new-int32">fuc AddInt32(val *int32, delta int32) (new int32)</a></h1>
<p>参数：</p>
<ul>
<li>val：即将要操作的变量。</li>
<li>delta：增量。</li>
</ul>
<p>返回值：</p>
<ul>
<li>new：返回*val+delta。</li>
</ul>
<p>功能：</p>
<ul>
<li>在对val有竞争的时候，确保<code>*val=*val+delat</code>是一个原子操作。</li>
</ul>
<p>兄弟函数：</p>
<ul>
<li>func AddInt64</li>
<li>func AddUint32</li>
<li>func AddUint64</li>
<li>func AddUintptr</li>
</ul>
<p>在使用上只要操作类型的区别。</p>
<p>代码示例：</p>
<pre><code>package main


import (
	&quot;fmt&quot;
	&quot;runtime&quot;
	&quot;sync/atomic&quot;
)

func click(total *int,ch chan int) {
	for i := 0; i &lt; 1000; i++ {
    	*total += 1
	}
	ch &lt;- 1
}

func clickat(total *int32, ch chan int) {
	for i := 0; i &lt; 1000; i++ {
    	atomic.AddInt32(total, 1)
	}
	ch &lt;- 1
}


func main() {

	runtime.GOMAXPROCS(2)		//使用多个处理器，不然都是顺序执行。

	count1 := 0;
	count2 := int32(0)

	ch := make(chan int, 200)		//保证输出时count完了

	for i := 0; i &lt; 100; i++ {
    	go click(&amp;count1, ch)
	}
	for i := 0; i &lt; 100; i++ {
    	go clickat(&amp;count2, ch)
	}

	for i := 0; i &lt; 200; i++ {
    	&lt;-ch
	}

	fmt.Printf(&quot;count1:%d\ncount2:%d\n&quot;, count1,count2)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-compareandswapint32val-int32-old-new-int32-swapped-bool"><a class="header" href="#func-compareandswapint32val-int32-old-new-int32-swapped-bool">func CompareAndSwapInt32(val *int32, old, new int32) (swapped bool)</a></h1>
<p>参数：</p>
<ul>
<li>val：需要进行修改的变量。</li>
<li>old：与*val进行比较的变量。</li>
<li>new：希望将val的值修改为new的值。</li>
</ul>
<p>返回值：</p>
<ul>
<li>swapped：如果*val=new成功则返回true，否则返回flase。</li>
</ul>
<p>功能：</p>
<ul>
<li>提供原子的compare-swap操作。过程是：</li>
</ul>
<pre><code>
	if *val == old {
		*val = new
		return true
	}
	return false
</code></pre>
<p>兄弟函数：</p>
<ul>
<li>fuc CompareAndSwapInt64</li>
<li>fuc CompareAndSwapPointer</li>
<li>fuc CompareAndSwapUint32</li>
<li>fuc CompareAndSwapUint64</li>
<li>fuc CompareAndSwapptr</li>
</ul>
<p>在使用上只用参数类型的区别</p>
<p>代码示例：</p>
<pre><code>package main


import (
	&quot;fmt&quot;
	&quot;runtime&quot;
	&quot;time&quot;
	&quot;sync/atomic&quot;
)

func c32To42(total *int32,id int) {
	if atomic.CompareAndSwapInt32(total,32,42) {
    	fmt.Printf(&quot;32 to 42:id%d, work\n&quot;,id)
	} else {
    	fmt.Printf(&quot;32 to 42:id%d, fail\n&quot;,id)
	}
}

func c42To32(total *int32,id int) {
	if atomic.CompareAndSwapInt32(total,42,32) {
    	fmt.Printf(&quot;42 to 32:id%d, work\n&quot;,id)
	} else {
    	fmt.Printf(&quot;42 to 32:id%d, fail\n&quot;,id)
	}
}

func main() {

	runtime.GOMAXPROCS(2)		//使用多个处理器，不然都是顺序执行。

	count := int32(32)

	for i:=0; i&lt;3; i++ {
   		go c32To42(&amp;count,i)
   		go c42To32(&amp;count,i)
	}

	time.Sleep(time.Second*1)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>#func LoadInt32(addr *int32) (val int32)</p>
<p>参数：</p>
<ul>
<li>addr：读取的地址。</li>
</ul>
<p>返回值</p>
<ul>
<li>val：读取的值。</li>
</ul>
<p>功能：</p>
<ul>
<li>提供互斥读，也就是说读期间无法进行其它读写操作。</li>
</ul>
<p>兄弟函数：</p>
<ul>
<li>func LoadInt64</li>
<li>func LoadPointer</li>
<li>func LoadUint32</li>
<li>func LoadUint64</li>
<li>func LoadUintptr</li>
</ul>
<p>在使用上只要类型的区别。</p>
<p>代码示例:</p>
<pre><code>package main


import &quot;fmt&quot;
import &quot;time&quot;
import &quot;sync/atomic&quot;
import &quot;runtime&quot;

func main() {

	runtime.GOMAXPROCS(2)

	var ops int32 = 0

	for i := 0; i &lt; 2; i++ {
    	go func() {
        	for i:=0; i&lt;100; i++{
            	time.Sleep(time.Nanosecond)
            	atomic.AddInt32(&amp;ops, 1)
            	if i==50 {
               		fmt.Println(&quot;ops:&quot;, atomic.LoadInt32(&amp;ops),ops)
            	}
        	}
    	}()
	}

	time.Sleep(time.Second)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>#func StoreInt32(addr *int32, val int32)</p>
<p>参数：</p>
<ul>
<li>addr：需要操作的变量地址。</li>
<li>val： 要存进addr里的值。</li>
</ul>
<p>返回值：</p>
<ul>
<li>无</li>
</ul>
<p>兄弟函数：</p>
<ul>
<li>func StoreInt64</li>
<li>func StorePointer</li>
<li>func StoreUint32</li>
<li>func StoreUint64</li>
<li>func StoreUintptr</li>
</ul>
<p>在使用上的区别只要操作类型不一样。</p>
<p>功能说明：</p>
<ul>
<li>提供互斥写操作。</li>
</ul>
<p>代码示例：</p>
<pre><code>package main


import &quot;fmt&quot;
import &quot;time&quot;
import &quot;sync/atomic&quot;
import &quot;runtime&quot;

func read(num *int32) {
	for {
    	if *num==32 {
        	fmt.Println(&quot;ops:&quot;, 32)
    	}
    	if *num==42 {
        	fmt.Println(&quot;ops:&quot;, 42)
    	}
    	time.Sleep(time.Nanosecond)
	}
}

func main() {

	runtime.GOMAXPROCS(4)

	var ops int32 = 0

	for i := 0; i &lt; 4; i++ {
    	go read(&amp;ops)
	}

	atomic.StoreInt32(&amp;ops, 32)

	time.Sleep(time.Nanosecond*5)

	ops = 42					//42的输出会不稳定。
	fmt.Println(&quot;changed&quot;)

	time.Sleep(time.Nanosecond*20)
}
</code></pre>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>4e6bb8a255a918bf287959e4f39c14c076f7cd1b</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>#Cond</p>
<p>Cond结构如下：</p>
<pre><code>type Cond struct {
	L			Locker
	m			Mutex
	oldWaiters	int
	oldSema		*uint32
	newWaiters	int
	newSema		*uint32
}
</code></pre>
<p>##成员</p>
<ul>
<li>L：外部传入的Locker实现，用于保护Cond的操作。</li>
<li>m：用于内部结构的保护。</li>
<li>oldWaiters：上一代的waiter计数。</li>
<li>oldSema：上一代的信号量。</li>
<li>newWaiters：新一代的waiter计数。</li>
<li>newSema：新一代的信号量。</li>
</ul>
<p>ps：分代管理是为了在使用<code>Signal()</code>唤醒一个waiter时，优先唤醒oldWaiter。</p>
<h2 id="func-newcondl-locker-cond"><a class="header" href="#func-newcondl-locker-cond">func NewCond(l Locker) *Cond</a></h2>
<p>参数：</p>
<ul>
<li>Locker接口，可以自己实现。</li>
</ul>
<p>返回值：</p>
<ul>
<li>Cond指针。</li>
</ul>
<p>功能：</p>
<ul>
<li>创建Cond。</li>
</ul>
<h2 id="func-c-cond-wait"><a class="header" href="#func-c-cond-wait">func (c *Cond) Wait()</a></h2>
<p>参数，返回值：</p>
<ul>
<li>无</li>
</ul>
<p>功能：</p>
<ul>
<li>添加waiter，使用时要注意先调用c.L.Lock()。详见代码示例。</li>
</ul>
<h2 id="func-c-cond-signal"><a class="header" href="#func-c-cond-signal">func (c *Cond) Signal()</a></h2>
<p>参数，返回值：</p>
<ul>
<li>无</li>
</ul>
<p>功能：</p>
<ul>
<li>唤醒一个waiter。优先唤醒上一代的waiter，如果oldWaiters==0，新一代变成上一代。详见源码cond.go</li>
</ul>
<h2 id="func-c-cond-broadcast"><a class="header" href="#func-c-cond-broadcast">func (c *Cond) Broadcast()</a></h2>
<p>参数，返回值：</p>
<ul>
<li>无</li>
</ul>
<p>功能：</p>
<ul>
<li>唤醒所有waiter，包括上一代和新一代。</li>
</ul>
<p>代码示例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;time&quot;
	&quot;sync&quot;
)

func waiter(cond *sync.Cond,id int) {
	cond.L.Lock()
	cond.Wait()
	cond.L.Unlock()
	fmt.Printf(&quot;Waiter:%d wake up!\n&quot;,id)
}

func main() {
	locker := new(sync.Mutex)
	cond := sync.NewCond(locker)  //使用Mutex作为Locker

	for i := 0; i &lt; 3; i++ {		//生成waiter
    	go waiter(cond,i)
	}
	time.Sleep(time.Second * 1)		//等待waiter到位

	cond.L.Lock()
	cond.Signal()					//唤醒一个waiter
	cond.L.Unlock()

	for i := 3; i &lt; 5; i++ {		//生成新一代waiter
    	go waiter(cond,i)
	}
	time.Sleep(time.Second * 1)

	cond.L.Lock()
	cond.Signal()					//唤醒的将是上一代（id&lt;3）的waiter之一
	cond.L.Unlock()

	cond.L.Lock()
	cond.Broadcast()				//唤醒所以waiter
	cond.L.Unlock()
	time.Sleep(time.Second * 1)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>#Mutex</p>
<p>Mutex是对Locker的一个实现。结构如下：</p>
<pre><code>type Mutex struct {
	state int32
	sema  uint32
}
</code></pre>
<p>##state
成员state用表明当前锁是处于被占用（state==1）还是空闲（state==0）。使用<code>atomic.CompareAndSwapInt32()</code>进行修改。</p>
<p>##sema
当前锁占用失败，系统监听成员sema。当sema==1，表明锁被释放。当前争用的的过程将被系统唤醒尝试去获取锁。当sema==0，当前争用过程会被系统暂停。</p>
<p>##func Lock() &amp;&amp; func Unlock()</p>
<p>参数，返回值：</p>
<ul>
<li>无</li>
</ul>
<p>功能说明：</p>
<ul>
<li>获取和释放当前锁。</li>
</ul>
<p>代码示例：</p>
<pre><code>package main


import (
	&quot;fmt&quot;
	&quot;runtime&quot;
	&quot;sync&quot;
)

func click(total *int,ch chan int) {
	for i := 0; i &lt; 1000; i++ {
    	*total += 1
	}
	ch &lt;- 1
}

func clickWithMutex(total *int,m *sync.Mutex, ch chan int) {
	for i := 0; i &lt; 1000; i++ {
    	m.Lock()
    	*total += 1
    	m.Unlock()
	}
	ch &lt;- 1
}


func main() {

	runtime.GOMAXPROCS(2)		//使用多个处理器，不然都是顺序执行。

	m := new(sync.Mutex)
	count1 := 0;
	count2 := 0;

	ch := make(chan int, 200)		//保证输出时count完了

	for i := 0; i &lt; 100; i++ {
    	go click(&amp;count1, ch)
	}
	for i := 0; i &lt; 100; i++ {
    	go clickWithMutex(&amp;count2, m, ch)
	}

	for i := 0; i &lt; 200; i++ {
    	&lt;-ch
	}

	fmt.Printf(&quot;count1:%d\ncount2:%d\n&quot;, count1,count2)
}
</code></pre>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>4e6bb8a255a918bf287959e4f39c14c076f7cd1b</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p></code></pre></p>
<p>程序输出：</p>
<ul>
<li>count1：55523		//不定</li>
<li>coutn2：100000</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>#Once</p>
<p>Once结构如下：</p>
<pre><code>type Once struct {
	m		Mutex
	done	uint32
}
</code></pre>
<p>##成员m</p>
<p>用于保证Once不会并发执行动作。</p>
<p>##成员done</p>
<p>用于保证Once只会执行一次。当done==1表明动作已经完成。</p>
<p>##func (o *Once) Do(f func())</p>
<p>参数：</p>
<ul>
<li>func 函数类型</li>
</ul>
<p>返回值：</p>
<ul>
<li>无</li>
</ul>
<p>功能：</p>
<ul>
<li>执行且仅执行f()一次</li>
</ul>
<p>代码示例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;sync&quot;
)

func main() {
	once := new(sync.Once)
	ch := make(chan int, 3)

	for i := 0; i &lt; 3; i++ {
		go func(x int) {
			once.Do(func() {
				fmt.Printf(&quot;once %d\n&quot;, x)
			})
			fmt.Printf(&quot;%d\n&quot;, x)
			ch &lt;- 1
		}(i)
	}

	for i := 0; i &lt; 3; i++ {
		&lt;-ch
	}
}
</code></pre>
<p>输出：</p>
<p>once 0</p>
<p>0</p>
<p>1</p>
<p>2</p>
<div style="break-before: page; page-break-before: always;"></div><p>#RWMutex</p>
<p>RWMutex结构如下：</p>
<pre><code>type RWMutex struct {
	w			Mutex
	writerSem	uint32
	readerSem	uint32
	readerCount	int32
	readerWait	int32
}
</code></pre>
<p>##成员</p>
<ul>
<li>w			： 用于写锁，拒绝其他写操作。</li>
<li>writerSem	： 写锁信号量，用于阻塞或唤醒写锁争夺锁的行为。</li>
<li>readerSem	： 读锁信号量，写锁来时唤醒要进来的读锁。</li>
<li>readerCount	： 读锁的持有数。</li>
<li>readerWait	： 写锁需要等待的读操作数，最后一个读离开唤醒争用写锁的过程。</li>
</ul>
<p>##func (rw *RWMutex) Rlock()</p>
<p>参数，返回值：</p>
<ul>
<li>无</li>
</ul>
<p>功能描述：</p>
<ul>
<li>获取读锁，当之前以有一个写锁存在，阻塞。</li>
</ul>
<p>##func (rw *RWMutex) RUlock()</p>
<p>参数，返回值：</p>
<ul>
<li>无</li>
</ul>
<p>功能描述：</p>
<ul>
<li>放弃读锁，当存在有尝试进入的写锁且当前是最后一个读锁时，唤醒写锁争用过程。</li>
</ul>
<p>##func (rw *RWMutex) Lock()</p>
<p>参数，返回值：</p>
<ul>
<li>无</li>
</ul>
<p>功能描述：</p>
<ul>
<li>获取写锁，当之前存在读锁，阻塞。</li>
</ul>
<p>##func (rw *RWMutex) Unlock()</p>
<p>参数，返回值：</p>
<ul>
<li>无</li>
</ul>
<p>功能描述：</p>
<ul>
<li>放弃写锁，当存在有读锁争用过程被阻塞，唤醒所以读锁。</li>
</ul>
<p>代码示例：</p>
<pre><code>package main


import (
	&quot;fmt&quot;
	&quot;runtime&quot;
	&quot;sync&quot;
)

func clickWithMutex(total *int,m *sync.RWMutex, ch chan int) {
	for i := 0; i &lt; 1000; i++ {
    	m.Lock()
    	*total += 1
    	m.Unlock()

    	if i==500 {
        	m.RLock()
        	fmt.Println(*total)
        	m.RUnlock()
    	}
	}
	ch &lt;- 1
}


func main() {

	runtime.GOMAXPROCS(2)		//使用多个处理器，不然都是顺序执行。

	m := new(sync.RWMutex)
	count := 0;

	ch := make(chan int, 10)		//保证输出时count完了

	for i := 0; i &lt; 10; i++ {
    	go clickWithMutex(&amp;count, m, ch)
	}

	for i := 0; i &lt; 10; i++ {
    	&lt;-ch
	}

	fmt.Printf(&quot;count:%d\n&quot;, count)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>#type Locker</p>
<p>Locker是一个接口类型。</p>
<pre><code>type Locker interface {
	Lock()
	Unlock()
}
</code></pre>
<p>你可以在mutux.go中找到它的定义。</p>
<p>它提供了一个抽象接口，被Mutex和RWMutex实现，是Cond的成员。</p>
<div style="break-before: page; page-break-before: always;"></div><p>#WaitGroup</p>
<p>WaitGroup的结构如下：</p>
<pre><code>type WaitGroup struct {
	m		Mutex
	counter	int32
	waiters	int32
	sema	*uint32
}
</code></pre>
<p>##成员</p>
<ul>
<li>m：防止对内部成员进行竞争操作。</li>
<li>counter：需要等待的过程数。</li>
<li>waiters：调用<code>Wait()</code>方法的次数，当counter==0时，全部唤醒。</li>
<li>sema：用于waiter的信号量。</li>
</ul>
<h2 id="func-wg-waitgroup-adddelta-int"><a class="header" href="#func-wg-waitgroup-adddelta-int">func (wg *WaitGroup) Add(delta int)</a></h2>
<p>参数：</p>
<ul>
<li>int类型。</li>
</ul>
<p>返回值：</p>
<ul>
<li>无</li>
</ul>
<p>功能：</p>
<ul>
<li>添加delta个元素进入WaitGroup。个人觉得这里的接口设计有问题，如果Add(2)，那就要掉用两次Done()。而且会有Add(2)的需求吗？</li>
</ul>
<h2 id="func-wg-waitgroup-done"><a class="header" href="#func-wg-waitgroup-done">func (wg *WaitGroup) Done()</a></h2>
<p>参数，返回值：</p>
<ul>
<li>无</li>
</ul>
<p>功能：</p>
<ul>
<li>对WaitGroup的counter减1。</li>
</ul>
<h2 id="func-wg-waitgroup-wait"><a class="header" href="#func-wg-waitgroup-wait">func (wg *WaitGroup) Wait()</a></h2>
<p>参数，返回值：</p>
<ul>
<li>无</li>
</ul>
<p>功能：</p>
<ul>
<li>阻塞，直到WaitGroup中的所以过程完成。</li>
</ul>
<p>代码示例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;sync&quot;
)

func wgProcess(wg *sync.WaitGroup,id int){
	fmt.Printf(&quot;process:%d is going!\n&quot;,id)
	wg.Done()
}

func main() {
	wg := new(sync.WaitGroup)
	for i := 0; i &lt; 3; i++ {
    	wg.Add(1)
    	go wgProcess(wg, i)
	}
	wg.Wait()
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名-64"><a class="header" href="#包名-64">包名</a></h1>
<p>函数列表</p>
<ul>
<li>xxx1</li>
<li>xxx2</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing包"><a class="header" href="#testing包">testing包</a></h1>
<p>testing包为go的代码包提供自动化测试支持。它的目标是与“go test”命令协同使用，以自动执行form的任何函数。</p>
<pre><code>func TestXxx(*testing.T)
</code></pre>
<p>Xxx可以使任何字母和数字组合的字符串（但是第一个字符必须是a-z的）并且在测试程序中时唯一的。这些TestXxx程序应该在包中声明他们是用来测试的。</p>
<p>form的函数</p>
<p>func BenchmarkXxx(*testing.B)</p>
<p>用来做基准测试，并且执行“go test -test.bench”命令后会启动这些测试。</p>
<p>一个简单的基准测试就像这样：</p>
<pre><code>func BenchmarkHello(b *testing.B) {
    for i := 0; i &lt; b.N; i++ {
        fmt.Sprintf(&quot;hello&quot;)
    }
}
</code></pre>
<p>基准测试包将会执行不同的 b.N 次直到基准测试函数可靠运行了足够长的时间。下面的输出：</p>
<pre><code>testing.BenchmarkHello    10000000    282 ns/op
</code></pre>
<p>意味着基准测试函数testing.BenchmarkHello()循环跑了10000000次，并且单次循环平均耗时 282 纳秒。</p>
<pre><code>func BenchmarkBigLen(b *testing.B) {
    b.StopTimer()
    big := NewBig()
    b.StartTimer()
    for i := 0; i &lt; b.N; i++ {
        big.Len()
    }
}
</code></pre>
<p>此包也可以运行和验证示例代码。示例测试函数可以包含结论注释语句，该语句以“Output:”开头，并当测试运行结束时标准输出会与这一注释语句相比较，下面是示例测试函数的例子：</p>
<pre><code>func ExampleHello() {
    fmt.Println(&quot;hello&quot;)
    // Output: hello
}

func ExampleSalutations() {
        fmt.Println(&quot;hello, and&quot;)
        fmt.Println(&quot;goodbye&quot;)
        // Output:
        // hello, and
        // goodbye
}
</code></pre>
<p>没有输出注释语句的示例测试函数会被编译但不会被执行。</p>
<p>为函数 F、类型 T 以及类型 T 上的方法 M 声明示例测试函数的命名规则是这样的：</p>
<pre><code>func ExampleF() { ... }
func ExampleT() { ... }
func ExampleT_M() { ... }
</code></pre>
<p>为一个类型或函数或方法编写多个示例测试函数时可以直接在函数名称上加上不同的后缀。后缀必须以小写字母开头。</p>
<pre><code>func ExampleF_suffix() { ... }
func ExampleT_suffix() { ... }
func ExampleT_M_suffix() { ... }
</code></pre>
<p>只要测试文件中有示例测试函数，它就需要被明示是一个示例测试文件。这个示例测试文件可以包含其他函数、类型变量或常量声明，但不能有普通测试函数和基准测试函数。</p>
<h1 id="testing包函数列表"><a class="header" href="#testing包函数列表">testing包函数列表</a></h1>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/testing/Main.html">func Main(matchString func(pat, str string) (bool, error), tests []InternalTest, benchmarks []InternalBenchmark, examples []InternalExample)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/testing/RunBenchmarks.html">func RunBenchmarks(matchString func(pat, str string) (bool, error), benchmarks []InternalBenchmark)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/testing/RunExamples.html">func RunExamples(matchString func(pat, str string) (bool, error), examples []InternalExample) (ok bool)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/testing/RunTests.html">func RunTests(matchString func(pat, str string) (bool, error), tests []InternalTest) (ok bool)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/testing/Short.html">func Short() bool</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/testing/B.html">type B</a>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/testing/B_Error.html">func (c *B) Error(args ...interface{})</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/testing/B_Errorf.html">func (c *B) Errorf(format string, args ...interface{})</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/testing/B_Fail.html">func (c *B) Fail()</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/testing/B_FailNow.html">func (c *B) FailNow()</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/testing/B_Failed.html">func (c *B) Failed() bool</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/testing/B_Fatal.html">func (c *B) Fatal(args ...interface{})</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/testing/B_Fatalf.html">func (c *B) Fatalf(format string, args ...interface{})</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/testing/B_Log.html">func (c *B) Log(args ...interface{})</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/testing/B_Logf.html">func (c *B) Logf(format string, args ...interface{})</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/testing/B_ResetTimer.html">func (b *B) ResetTimer()</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/testing/B_SetBytes.html">func (b *B) SetBytes(n int64)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/testing/B_StartTimer.html">func (b *B) StartTimer()</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/testing/B_StopTimer.html">func (b *B) StopTimer()</a></li>
</ul>
</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/testing/Benchmark.html">func Benchmark(f func(b *B)) BenchmarkResult</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/testing/BenchmarkResult.html">type BenchmarkResult</a>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/testing/BenchmarkResult_NsPerOp.html">func (r BenchmarkResult) NsPerOp() int64</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/testing/BenchmarkResult_String.html">func (r BenchmarkResult) String() string</a></li>
</ul>
</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/testing/InternalBenchmark.html">type InternalBenchmark</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/testing/InternalExample.html">type InternalExample</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/testing/InternalTest.html">type InternalTest</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/testing/T.html">type T</a>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/testing/T_Error.html">func (c *T) Error(args ...interface{})</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/testing/T_Errorf.html">func (c *T) Errorf(format string, args ...interface{})</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/testing/T_Fail.html">func (c *T) Fail()</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/testing/T_FailNow.html">func (c *T) FailNow()</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/testing/T_Failed.html">func (c *T) Failed() bool</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/testing/T_Fatal.html">func (c *T) Fatal(args ...interface{})</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/testing/T_Fatalf.html">func (c *T) Fatalf(format string, args ...interface{})</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/testing/T_Log.html">func (c *T) Log(args ...interface{})</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/testing/T_Logf.html">func (c *T) Logf(format string, args ...interface{})</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/testing/T_Parallel.html">func (t *T) Parallel()</a></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名-65"><a class="header" href="#包名-65">包名</a></h1>
<p>函数列表</p>
<ul>
<li>xxx1</li>
<li>xxx2</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名-66"><a class="header" href="#包名-66">包名</a></h1>
<p>函数列表</p>
<ul>
<li>xxx1</li>
<li>xxx2</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-c-b-errorargs-interface"><a class="header" href="#func-c-b-errorargs-interface">func (c *B) Error(args ...interface{})</a></h2>
<p>参数列表</p>
<ul>
<li>args 要输出的、用于描述错误的内容</li>
</ul>
<p>返回值：</p>
<p>&lt;无&gt;</p>
<p>功能说明：</p>
<p>调用Error()相当于在调用了Log()之后再调用Fail()。</p>
<p>代码实例：</p>
<pre><code>package testing_demo

import (
	&quot;testing&quot;
)

func Benchmark(b *testing.B) {
	b.Error(&quot;Error:&quot;, &quot;E&quot;)
}
</code></pre>
<p>运行方法：</p>
<p>将上面的实例代码保存在文件“$GOPATH/src/testing_demo/b_error_test.go”中。用命令行进入文件所在目录并运行命令“go test -bench=&quot;.&quot; -v”。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-c-b-errorfformat-string-args-interface"><a class="header" href="#func-c-b-errorfformat-string-args-interface">func (c *B) Errorf(format string, args ...interface{})</a></h2>
<p>参数列表</p>
<ul>
<li>format 格式字符串</li>
<li>args 要输出的、用于描述错误的内容</li>
</ul>
<p>返回值：</p>
<p>&lt;无&gt;</p>
<p>功能说明：</p>
<p>调用Error()相当于在调用了Logf()之后再调用Fail()。</p>
<p>代码实例：</p>
<pre><code>package testing_demo

import (
	&quot;testing&quot;
)

func Benchmark(b *testing.B) {
	b.Errorf(&quot;Error: %s\n&quot;, &quot;EF&quot;)
}
</code></pre>
<p>运行方法：</p>
<p>将上面的实例代码保存在文件“$GOPATH/src/testing_demo/b_errorf_test.go”中。用命令行进入文件所在目录并运行命令“go test -bench=&quot;.&quot; -v”。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-c-b-fail"><a class="header" href="#func-c-b-fail">func (c *B) Fail()</a></h2>
<p>参数列表</p>
<p>&lt;无&gt;</p>
<p>返回值：</p>
<p>&lt;无&gt;</p>
<p>功能说明：</p>
<p>调用Fail()使得当前测试函数失败，但扔会继续执行后面的代码。</p>
<p>代码实例：</p>
<pre><code>package testing_demo

import (
	&quot;testing&quot;
)

func Benchmark(b *testing.B) {
	b.Fail()
}
</code></pre>
<p>运行方法：</p>
<p>将上面的实例代码保存在文件“$GOPATH/src/testing_demo/b_fail_test.go”中。用命令行进入文件所在目录并运行命令“go test -bench=&quot;.&quot; -v”。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-c-b-failed-bool"><a class="header" href="#func-c-b-failed-bool">func (c *B) Failed() bool</a></h2>
<p>参数列表</p>
<p>&lt;无&gt;</p>
<p>返回值：</p>
<ul>
<li>bool值，测试函数是否已失败。</li>
</ul>
<p>功能说明：</p>
<p>判断测试函数是否已失败。</p>
<p>代码实例：</p>
<pre><code>package testing_demo

import (
	&quot;testing&quot;
)

func Benchmark(b *testing.B) {
	b.Logf(&quot;Failed: %v\n&quot;, b.Failed())
}
</code></pre>
<p>运行方法：</p>
<p>将上面的实例代码保存在文件“$GOPATH/src/testing_demo/b_failed_test.go”中。用命令行进入文件所在目录并运行命令“go test -bench=&quot;.&quot; -v”。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-c-b-failnow"><a class="header" href="#func-c-b-failnow">func (c *B) FailNow()</a></h2>
<p>参数列表</p>
<p>&lt;无&gt;</p>
<p>返回值：</p>
<p>&lt;无&gt;</p>
<p>功能说明：</p>
<p>调用Fail()使得当前测试函数失败且停止执行，转而执行后面的测试函数或基准测试函数。</p>
<p>代码实例：</p>
<pre><code>package testing_demo

import (
	&quot;testing&quot;
)

func Benchmark(b *testing.B) {
	b.FailNow()
}
</code></pre>
<p>运行方法：</p>
<p>将上面的实例代码保存在文件“$GOPATH/src/testing_demo/b_failnow_test.go”中。用命令行进入文件所在目录并运行命令“go test -bench=&quot;.&quot; -v”。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-c-b-fatalargs-interface"><a class="header" href="#func-c-b-fatalargs-interface">func (c *B) Fatal(args ...interface{})</a></h2>
<p>参数列表</p>
<ul>
<li>args 要输出的、用于描述错误的内容</li>
</ul>
<p>返回值：</p>
<p>&lt;无&gt;</p>
<p>功能说明：</p>
<p>调用Error()相当于在调用了Log()之后再调用FailNow()。</p>
<p>代码实例：</p>
<pre><code>package testing_demo

import (
	&quot;testing&quot;
)

func Benchmark(b *testing.B) {
	b.Fatal(&quot;Fatal:&quot;, &quot;F&quot;)
}
</code></pre>
<p>运行方法：</p>
<p>将上面的实例代码保存在文件“$GOPATH/src/testing_demo/b_fatal_test.go”中。用命令行进入文件所在目录并运行命令“go test -bench=&quot;.&quot; -v”。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-c-b-fatalfformat-string-args-interface"><a class="header" href="#func-c-b-fatalfformat-string-args-interface">func (c *B) Fatalf(format string, args ...interface{})</a></h2>
<p>参数列表</p>
<ul>
<li>format 格式字符串</li>
<li>args 要输出的、用于描述错误的内容</li>
</ul>
<p>返回值：</p>
<p>&lt;无&gt;</p>
<p>功能说明：</p>
<p>调用Error()相当于在调用了Logf()之后再调用FailNow()。</p>
<p>代码实例：</p>
<pre><code>package testing_demo

import (
	&quot;testing&quot;
)

func Benchmark(b *testing.B) {
	b.Fatalf(&quot;Fatal: %s\n&quot;, &quot;FF&quot;)
}
</code></pre>
<p>运行方法：</p>
<p>将上面的实例代码保存在文件“$GOPATH/src/testing_demo/b_fatalf_test.go”中。用命令行进入文件所在目录并运行命令“go test -bench=&quot;.&quot; -v”。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-c-b-logargs-interface"><a class="header" href="#func-c-b-logargs-interface">func (c *B) Log(args ...interface{})</a></h2>
<p>参数列表</p>
<ul>
<li>args 要输出的、用于描述错误的内容</li>
</ul>
<p>返回值：</p>
<p>&lt;无&gt;</p>
<p>功能说明：</p>
<p>Log方法用默认的格式来格式化给定的参数，类似于Println()，并在错误日志中记录文本。</p>
<p>代码实例：</p>
<pre><code>package testing_demo

import (
	&quot;testing&quot;
)

func Benchmark(b *testing.B) {
	b.Log(&quot;Log:&quot;, &quot;L&quot;)
}
</code></pre>
<p>运行方法：</p>
<p>将上面的实例代码保存在文件“$GOPATH/src/testing_demo/b_log_test.go”中。用命令行进入文件所在目录并运行命令“go test -bench=&quot;.&quot; -v”。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-c-b-logfformat-string-args-interface"><a class="header" href="#func-c-b-logfformat-string-args-interface">func (c *B) Logf(format string, args ...interface{})</a></h2>
<p>参数列表</p>
<ul>
<li>format 格式字符串</li>
<li>args 要输出的、用于描述错误的内容</li>
</ul>
<p>返回值：</p>
<p>&lt;无&gt;</p>
<p>功能说明：</p>
<p>Logf方法根据给定的格式来格式化给定的参数，类似于Printf()，并在错误日志中记录文本。</p>
<p>代码实例：</p>
<pre><code>package testing_demo

import (
	&quot;testing&quot;
)

func Benchmark(b *testing.B) {
	b.Logf(&quot;Log: %s\n&quot;, &quot;LF&quot;)
}
</code></pre>
<p>运行方法：</p>
<p>将上面的实例代码保存在文件“$GOPATH/src/testing_demo/b_logf_test.go”中。用命令行进入文件所在目录并运行命令“go test -bench=&quot;.&quot; -v”。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-b-b-resettimer"><a class="header" href="#func-b-b-resettimer">func (b *B) ResetTimer()</a></h2>
<p>参数列表</p>
<p>&lt;无&gt;</p>
<p>返回值：</p>
<p>&lt;无&gt;</p>
<p>功能说明：</p>
<p>ResetTimer方法设置基准测试耗时为0。调用此方法不会影响到计时器的运行。</p>
<p>代码实例：</p>
<pre><code>import (
	&quot;testing&quot;
	&quot;time&quot;
)

func Benchmark(b *testing.B) {
	resetTag := false
	time.Sleep(time.Second)
	b.SetBytes(1000)
	if resetTag {
		b.ResetTimer()
	}
}
</code></pre>
<p>运行方法：</p>
<p>将上面的实例代码保存在文件“$GOPATH/src/testing_demo/b_resettimer_test.go”中。用命令行进入文件所在目录并运行命令“go test -bench=&quot;.&quot; -v”。更改变量resetTag的值（true or false），再试试看。</p>
<p>备注：</p>
<p>按照运行方法反复运行代码实例，我们可以观察到：当resetTag为true时，此基准测试函数可以被运行多次，而当resetTag为false时，此基准测试函数往往只能获得一次运行机会。这是因为testing包中设置了这样一种限制：当基准测试函数单次运行时间超过指定值（默认为1秒，也可以根据命令行参数指定）时，只运行此基准测试函数一次。</p>
<p>因此，当我们调用time.Sleep()以强制延长函数运行时间之后，此基准测试函数就只会被运行一次了。而当我们在强制延时之后又调用了ResetTimer()时，相当于重置了此基准测试函数的运行时间，也即忽略了之前的强制延时操作。所以，在这种情况下，此基准测试函数自然就能运行多次了。</p>
<p>ResetTimer()方法的作用就在于此，将一些非关键的代码执行时间从基准测试函数运行时间中减去。这样也许可以获得更好的基准测试效果。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-b-b-setbytesn-int64"><a class="header" href="#func-b-b-setbytesn-int64">func (b *B) SetBytes(n int64)</a></h2>
<p>参数列表</p>
<ul>
<li>n 处理的字节数</li>
</ul>
<p>返回值：</p>
<p>&lt;无&gt;</p>
<p>功能说明：</p>
<p>SetBytes方法记录在一个单一操作中处理的字节数。如果此方法被调用，则基准测试结果中会包含于与 ns/op 和 MB/s 有关的内容。</p>
<p>代码实例：</p>
<pre><code>package testing_demo

import (
	&quot;testing&quot;
	&quot;time&quot;
)

func Benchmark(b *testing.B) {
	time.Sleep(time.Millisecond)
	b.SetBytes(1000)
}
</code></pre>
<p>运行方法：</p>
<p>将上面的实例代码保存在文件“$GOPATH/src/testing_demo/b_setbytes_test.go”中。用命令行进入文件所在目录并运行命令“go test -bench=&quot;.&quot; -v”。注释掉“b.SetBytes(1000)”这句代码，再试试看。</p>
<p>备注：</p>
<p>当在基准测试函数中调用SetBytes方法之后，测试结果中的 MB/S 前的数字表明一秒钟处理的字节数。调用SetBytes方法时所传入的参数完全是测试者自己给定的。测试者可以依此观察被测试对象（比如用于IO的操作）的性能。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-b-b-starttimer"><a class="header" href="#func-b-b-starttimer">func (b *B) StartTimer()</a></h2>
<p>参数列表</p>
<p>&lt;无&gt;</p>
<p>返回值：</p>
<p>&lt;无&gt;</p>
<p>功能说明：</p>
<p>StartTimer方法启动对一个测试的计时。当一个基准测试开始时此方法会被自动调用，它此方法也可被用于在调用StopTimer方法后重启计时。</p>
<p>代码实例：</p>
<pre><code>import (
	&quot;testing&quot;
	&quot;time&quot;
)

func Benchmark(b *testing.B) {
	customTimerTag := false
	if customTimerTag {
		b.StopTimer()
	}
	time.Sleep(time.Second)
	if customTimerTag {
		b.StartTimer()
	}
}
</code></pre>
<p>运行方法：</p>
<p>将上面的实例代码保存在文件“$GOPATH/src/testing_demo/b_starttimer_test.go”中。用命令行进入文件所在目录并运行命令“go test -bench=&quot;.&quot; -v”。更改变量customTimerTag的值（true or false），再试试看。</p>
<p>备注：</p>
<p>实例中的代码（实际上是与方法StopTimer()配合使用的）与调用ResetTimer()方法有异曲同工之妙，具体的用途和作用可以参看本文档中<a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/testing/B_ResetTimer.html">对方法ResetTimer()的说明</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-b-b-stoptimer"><a class="header" href="#func-b-b-stoptimer">func (b *B) StopTimer()</a></h2>
<p>参数列表</p>
<p>&lt;无&gt;</p>
<p>返回值：</p>
<p>&lt;无&gt;</p>
<p>功能说明：</p>
<p>StartTimer方法停止对一个测试的计时。当你有不想纳入的复杂初始化执行时间时，可以调用此方法以暂停计时器。</p>
<p>代码实例：</p>
<pre><code>import (
	&quot;testing&quot;
	&quot;time&quot;
)

func Benchmark(b *testing.B) {
	customTimerTag := false
	if customTimerTag {
		b.StopTimer()
	}
	time.Sleep(time.Second)
	if customTimerTag {
		b.StartTimer()
	}
}
</code></pre>
<p>运行方法：</p>
<p>将上面的实例代码保存在文件“$GOPATH/src/testing_demo/b_stoptimer_test.go”中。用命令行进入文件所在目录并运行命令“go test -bench=&quot;.&quot; -v”。更改变量customTimerTag的值（true or false），再试试看。</p>
<p>备注：</p>
<p>实例中的代码（实际上是与方法StartTimer()配合使用的）与调用ResetTimer()方法有异曲同工之妙，具体的用途和作用可以参看本文档中<a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/testing/B_ResetTimer.html">对方法ResetTimer()的说明</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="type-b"><a class="header" href="#type-b">type B</a></h2>
<p>结构：</p>
<pre><code>type B struct {
    N int
    // 包括被过滤或未被导出的字段
}
</code></pre>
<p>类型说明：</p>
<p>B是一个类型，它会被传递给Benchmark函数，用于管理基准测试定时和指定迭代运行次数（N）。</p>
<p>代码实例：</p>
<pre><code>package testing_demo

import (
	&quot;testing&quot;
)

func Benchmark(b *testing.B) {
	b.Logf(&quot;N: %d\n&quot;, b.N)
}
</code></pre>
<p>运行方法：</p>
<p>将上面的实例代码保存在文件“$GOPATH/src/testing_demo/b_test.go”中。用命令行进入文件所在目录并运行命令“go test -bench=&quot;.&quot; -v”，观察输出，相信你会懂的。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-benchmarkf-funcb-b-benchmarkresult"><a class="header" href="#func-benchmarkf-funcb-b-benchmarkresult">func Benchmark(f func(b *B)) BenchmarkResult</a></h2>
<p>参数列表</p>
<ul>
<li>f 要被测试的函数</li>
</ul>
<p>返回值：</p>
<ul>
<li>BenchmarkResult实例值，基准测试结果。</li>
</ul>
<p>功能说明：</p>
<p>Benchmark()用来测试单一函数。它可以被用于在不使用“go test”命令的情况下创建自定义的基准测试。</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;testing&quot;
)

func main() {
	br := testing.Benchmark(func(b *testing.B) { b.Log(&quot;B!&quot;) })
	fmt.Printf(&quot;Benchmark Result: %v\n&quot;, br)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-r-benchmarkresult-nsperop-int64"><a class="header" href="#func-r-benchmarkresult-nsperop-int64">func (r BenchmarkResult) NsPerOp() int64</a></h2>
<p>参数列表</p>
<p>&lt;无&gt;</p>
<p>返回值：</p>
<ul>
<li>int64值，单次迭代的耗时（单位：纳秒）。</li>
</ul>
<p>功能说明：</p>
<p>获取单次迭代的耗时（单位：纳秒）。</p>
<p>代码实例：</p>
<pre><code>package testing_demo

import (
	&quot;testing&quot;
	&quot;time&quot;
)

func Benchmark(b *testing.B) {
	br := testing.BenchmarkResult{N: 1, T: time.Second, Bytes: 1000}
	b.Logf(&quot;Benchmark    %d    %d ns/op    %d MB/s\n&quot;, br.N, br.T, br.Bytes)
	b.Logf(&quot;Benchmark NsPerOp: %d\n&quot;, br.NsPerOp())
}
</code></pre>
<p>运行方法：</p>
<p>将上面的实例代码保存在文件“$GOPATH/src/testing_demo/benchmarkresult_nsperop_test.go”中。用命令行进入文件所在目录并运行命令“go test -bench=&quot;.&quot; -v”。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-r-benchmarkresult-string-string"><a class="header" href="#func-r-benchmarkresult-string-string">func (r BenchmarkResult) String() string</a></h2>
<p>参数列表</p>
<p>&lt;无&gt;</p>
<p>返回值：</p>
<ul>
<li>string值，本BenchmarkResult实例值的字符串形式。</li>
</ul>
<p>功能说明：</p>
<p>获取单次迭代的耗时（单位：纳秒）。</p>
<p>代码实例：</p>
<pre><code>package testing_demo

import (
	&quot;testing&quot;
	&quot;time&quot;
)

func Benchmark(b *testing.B) {
	br := testing.BenchmarkResult{N: 1, T: time.Second, Bytes: 1000}
	b.Logf(&quot;Benchmark    %d    %d ns/op    %d MB/s\n&quot;, br.N, br.T, br.Bytes)
	b.Logf(&quot;Benchmark String: %s\n&quot;, br.String())
}
</code></pre>
<p>运行方法：</p>
<p>将上面的实例代码保存在文件“$GOPATH/src/testing_demo/benchmarkresult_string_test.go”中。用命令行进入文件所在目录并运行命令“go test -bench=&quot;.&quot; -v”。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="type-benchmarkresult"><a class="header" href="#type-benchmarkresult">type BenchmarkResult</a></h2>
<p>结构：</p>
<pre><code>type BenchmarkResult struct {
    N     int           // 迭代的次数
    T     time.Duration // 总耗时
    Bytes int64         // 单次迭代处理的字节数
}
</code></pre>
<p>类型说明：</p>
<p>基准测试的结果。</p>
<p>代码实例：</p>
<pre><code>package testing_demo

import (
	&quot;testing&quot;
	&quot;time&quot;
)

func Benchmark(b *testing.B) {
	br := testing.BenchmarkResult{N: 1, T: time.Second, Bytes: 1000}
	b.Logf(&quot;Benchmark    %d    %d ns/op    %d MB/s\n&quot;, br.N, br.T, br.Bytes)
}
</code></pre>
<p>运行方法：</p>
<p>将上面的实例代码保存在文件“$GOPATH/src/testing_demo/benchmarkresult_test.go”中。用命令行进入文件所在目录并运行命令“go test -bench=&quot;.&quot; -v”，观察输出，相信你会懂的。</p>
<p>备注：</p>
<p>运行命令“go test -bench=&quot;.&quot; &lt;...&gt;”之后所看到的输出结果就是根据结构BenchmarkResult实例来填充的。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="type-internalbenchmark"><a class="header" href="#type-internalbenchmark">type InternalBenchmark</a></h2>
<p>结构：</p>
<pre><code>type InternalBenchmark struct {
    Name string
    F    func(b *B)
}
</code></pre>
<p>类型说明：</p>
<p>一个内部类型，只为了跨包使用而成为可导出的；它是“go test”命令实现的一部分。</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;testing&quot;
)

func main() {
	iBenchmark := testing.InternalBenchmark{Name: &quot;DemoBenchMark&quot;, F: func(b *testing.B) {}}
	fmt.Printf(&quot;Benchmark: %v\n&quot;, iBenchmark)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="type-internalbenchmark-1"><a class="header" href="#type-internalbenchmark-1">type InternalBenchmark</a></h2>
<p>结构：</p>
<pre><code>type InternalExample struct {
    Name   string
    F      func()
    Output string
}
</code></pre>
<p>类型说明：</p>
<p>一个内部类型，只为了跨包使用而成为可导出的；它是“go test”命令实现的一部分。</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;testing&quot;
)

func main() {
	iExample := testing.InternalExample{Name: &quot;Example&quot;, F: func() {}, Output: &quot;&quot;}
    fmt.Printf(&quot;Example: %v\n&quot;, iExample)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="type-internaltest"><a class="header" href="#type-internaltest">type InternalTest</a></h2>
<p>结构：</p>
<pre><code>type InternalTest struct {
    Name string
    F    func(*T)
}
</code></pre>
<p>类型说明：</p>
<p>一个内部类型，只为了跨包使用而成为可导出的；它是“go test”命令实现的一部分。</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;testing&quot;
)

func main() {
	iTest := testing.InternalTest{Name: &quot;DemoTest&quot;, F: func(t *testing.T) {}}
    fmt.Printf(&quot;Test: %v\n&quot;, iTest)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-mainmatchstring-funcpat-str-string-bool-error-tests-internaltest-benchmarks-internalbenchmark-examples-internalexample"><a class="header" href="#func-mainmatchstring-funcpat-str-string-bool-error-tests-internaltest-benchmarks-internalbenchmark-examples-internalexample">func Main(matchString func(pat, str string) (bool, error), tests []InternalTest, benchmarks []InternalBenchmark, examples []InternalExample)</a></h2>
<p>参数列表</p>
<ul>
<li>matchString 测试名称匹配函数 </li>
<li>tests 内部测试结构列表</li>
<li>benchmarks 内部基准测试（性能测试）结构列表</li>
<li>examples 内部示例测试结构列表</li>
</ul>
<p>返回值：</p>
<p>&lt;无&gt;</p>
<p>功能说明：</p>
<p>一个用于运行所有类型测试的内部函数，只为了跨包使用而成为可导出的；它是“go test”命令实现的一部分。</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;regexp&quot;
	&quot;testing&quot;
)

func matchString(pat, str string) (bool, error) {
	return regexp.MatchString(pat, str)
}

func main() {
	iTest := testing.InternalTest{Name: &quot;DemoTest&quot;, F: func(t *testing.T) {}}
	iTests := make([]testing.InternalTest, 1)
	iTests[0] = iTest
	iBenchmark := testing.InternalBenchmark{Name: &quot;DemoBenchMark&quot;, F: func(b *testing.B) {}}
	iBenchmarks := make([]testing.InternalBenchmark, 1)
	iBenchmarks[0] = iBenchmark
	iExample := testing.InternalExample{Name: &quot;Example&quot;, F: func() {}, Output: &quot;&quot;}
	iExamples := make([]testing.InternalExample, 1)
	iExamples[0] = iExample
	testing.Main(matchString, iTests, iBenchmarks, iExamples)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-runbenchmarksmatchstring-funcpat-str-string-bool-error-benchmarks-internalbenchmark"><a class="header" href="#func-runbenchmarksmatchstring-funcpat-str-string-bool-error-benchmarks-internalbenchmark">func RunBenchmarks(matchString func(pat, str string) (bool, error), benchmarks []InternalBenchmark)</a></h2>
<p>参数列表</p>
<ul>
<li>matchString 测试名称匹配函数 </li>
<li>benchmarks 内部基准测试（性能测试）结构列表</li>
</ul>
<p>返回值：</p>
<p>&lt;无&gt;</p>
<p>功能说明：</p>
<p>一个用于运行基准测试的内部函数，只为了跨包使用而成为可导出的；它是“go test”命令实现的一部分。</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;regexp&quot;
	&quot;testing&quot;
)

func matchString(pat, str string) (bool, error) {
	return regexp.MatchString(pat, str)
}

func main() {
	iBenchMark := testing.InternalBenchmark{Name: &quot;DemoBenchMark&quot;, F: func(b *testing.B) {}}
	iBenchMarks := make([]testing.InternalBenchmark, 1)
	iBenchMarks[0] = iBenchMark
	testing.RunBenchmarks(matchString, iBenchMarks)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-runexamplesmatchstring-funcpat-str-string-bool-error-examples-internalexample-ok-bool"><a class="header" href="#func-runexamplesmatchstring-funcpat-str-string-bool-error-examples-internalexample-ok-bool">func RunExamples(matchString func(pat, str string) (bool, error), examples []InternalExample) (ok bool)</a></h2>
<p>参数列表</p>
<ul>
<li>matchString 测试名称匹配函数 </li>
<li>examples 内部示例测试结构列表</li>
</ul>
<p>返回值：</p>
<ul>
<li>ok bool值，是否通过测试。</li>
</ul>
<p>功能说明：</p>
<p>运行示例测试。</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;regexp&quot;
	&quot;testing&quot;
)

func matchString(pat, str string) (bool, error) {
	return regexp.MatchString(pat, str)
}

func main() {
	iExample := testing.InternalExample{Name: &quot;Example&quot;, F: func() {}, Output: &quot;&quot;}
	iExamples := make([]testing.InternalExample, 1)
	iExamples[0] = iExample
	done := testing.RunExamples(matchString, iExamples)
	fmt.Printf(&quot;Result: %v\n&quot;, done)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-runtestsmatchstring-funcpat-str-string-bool-error-tests-internaltest-ok-bool"><a class="header" href="#func-runtestsmatchstring-funcpat-str-string-bool-error-tests-internaltest-ok-bool">func RunTests(matchString func(pat, str string) (bool, error), tests []InternalTest) (ok bool)</a></h2>
<p>参数列表</p>
<ul>
<li>matchString 测试名称匹配函数 </li>
<li>tests 内部测试结构列表</li>
<li>benchmarks 内部基准测试（性能测试）结构列表</li>
<li>examples 内部示例测试结构列表</li>
</ul>
<p>返回值：</p>
<ul>
<li>ok bool值，是否通过测试。</li>
</ul>
<p>功能说明：</p>
<p>运行测试。</p>
<p>代码实例：</p>
<pre><code>import (
	&quot;fmt&quot;
	&quot;regexp&quot;
	&quot;testing&quot;
)

func matchString(pat, str string) (bool, error) {
	return regexp.MatchString(pat, str)
}

func main() {
	iExample := testing.InternalExample{Name: &quot;Example&quot;, F: func() {}, Output: &quot;&quot;}
	iExamples := make([]testing.InternalExample, 1)
	iExamples[0] = iExample
	done := testing.RunExamples(matchString, iExamples)
	fmt.Printf(&quot;Result: %v\n&quot;, done)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-short-bool"><a class="header" href="#func-short-bool">func Short() bool</a></h2>
<p>参数列表</p>
<p>&lt;无&gt;</p>
<p>返回值：</p>
<ul>
<li>bool值，指定的flag是否被设置。</li>
</ul>
<p>功能说明：</p>
<p>判断flag &quot;-test.short&quot; 是否被设置。
这一flag被设置后可以使测试跑得更快，但其具体功能由测试编写者自己实现。testing包仅仅作为其承载者。在安装脚本all.bash中设置了这一flag以使安装更有效率。但是在执行“go test”命令时，这一标记在默认情况下是不会被设置的，这使得当前包的完整测试会被运行。 </p>
<p>代码实例：</p>
<pre><code>package testing_demo

import (
	&quot;testing&quot;
)

func TestShort(t *testing.T) {
	t.Logf(&quot;The short flag: %v\n&quot;, testing.Short())
}
</code></pre>
<p>运行方法：</p>
<p>将上面的实例代码保存在文件“$GOPATH/src/testing_demo/short_test.go”中。用命令行进入文件所在目录并运行命令“go test -test.short -v”。删除命令中的字符串“-test.short”再看看效果。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-c-t-errorargs-interface"><a class="header" href="#func-c-t-errorargs-interface">func (c *T) Error(args ...interface{})</a></h2>
<p>参数列表</p>
<ul>
<li>args 要输出的、用于描述错误的内容</li>
</ul>
<p>返回值：</p>
<p>&lt;无&gt;</p>
<p>功能说明：</p>
<p>调用Error()相当于在调用了Log()之后再调用Fail()。</p>
<p>代码实例：</p>
<pre><code>import (
	&quot;testing&quot;
)

func Test(t *testing.T) {
	t.Error(&quot;Error:&quot;, &quot;E&quot;)
}
</code></pre>
<p>运行方法：</p>
<p>将上面的实例代码保存在文件“$GOPATH/src/testing_demo/t_error_test.go”中。用命令行进入文件所在目录并运行命令“go test -v”。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-c-t-errorfformat-string-args-interface"><a class="header" href="#func-c-t-errorfformat-string-args-interface">func (c *T) Errorf(format string, args ...interface{})</a></h2>
<p>参数列表</p>
<ul>
<li>format 格式字符串</li>
<li>args 要输出的、用于描述错误的内容</li>
</ul>
<p>返回值：</p>
<p>&lt;无&gt;</p>
<p>功能说明：</p>
<p>调用Error()相当于在调用了Logf()之后再调用Fail()。</p>
<p>代码实例：</p>
<pre><code>package testing_demo

import (
	&quot;testing&quot;
)

func Test(t *testing.T) {
	t.Errorf(&quot;Error: %s\n&quot;, &quot;EF&quot;)
}
</code></pre>
<p>运行方法：</p>
<p>将上面的实例代码保存在文件“$GOPATH/src/testing_demo/t_errorf_test.go”中。用命令行进入文件所在目录并运行命令“go test -v”。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-c-t-fail"><a class="header" href="#func-c-t-fail">func (c *T) Fail()</a></h2>
<p>参数列表</p>
<p>&lt;无&gt;</p>
<p>返回值：</p>
<p>&lt;无&gt;</p>
<p>功能说明：</p>
<p>调用Fail()使得当前测试函数失败，但扔会继续执行后面的代码。</p>
<p>代码实例：</p>
<pre><code>package testing_demo

import (
	&quot;testing&quot;
)

func Test(t *testing.T) {
	t.Fail()
}
</code></pre>
<p>运行方法：</p>
<p>将上面的实例代码保存在文件“$GOPATH/src/testing_demo/t_fail_test.go”中。用命令行进入文件所在目录并运行命令“go test -v”。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-c-b-failed-bool-1"><a class="header" href="#func-c-b-failed-bool-1">func (c *B) Failed() bool</a></h2>
<p>参数列表</p>
<p>&lt;无&gt;</p>
<p>返回值：</p>
<ul>
<li>bool值，测试函数是否已失败。</li>
</ul>
<p>功能说明：</p>
<p>判断测试函数是否已失败。</p>
<p>代码实例：</p>
<pre><code>package testing_demo

import (
	&quot;testing&quot;
)

func Test(t *testing.T) {
	t.Logf(&quot;Failed: %v\n&quot;, t.Failed())
}
</code></pre>
<p>运行方法：</p>
<p>将上面的实例代码保存在文件“$GOPATH/src/testing_demo/t_failed_test.go”中。用命令行进入文件所在目录并运行命令“go test -v”。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-c-t-failnow"><a class="header" href="#func-c-t-failnow">func (c *T) FailNow()</a></h2>
<p>参数列表</p>
<p>&lt;无&gt;</p>
<p>返回值：</p>
<p>&lt;无&gt;</p>
<p>功能说明：</p>
<p>调用Fail()使得当前测试函数失败且停止执行，转而执行后面的测试函数或基准测试函数。</p>
<p>代码实例：</p>
<pre><code>package testing_demo

import (
	&quot;testing&quot;
)

func Test(t *testing.T) {
	t.FailNow()
}
</code></pre>
<p>运行方法：</p>
<p>将上面的实例代码保存在文件“$GOPATH/src/testing_demo/t_failnow_test.go”中。用命令行进入文件所在目录并运行命令“go test -v”。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-c-t-fatalargs-interface"><a class="header" href="#func-c-t-fatalargs-interface">func (c *T) Fatal(args ...interface{})</a></h2>
<p>参数列表</p>
<ul>
<li>args 要输出的、用于描述错误的内容</li>
</ul>
<p>返回值：</p>
<p>&lt;无&gt;</p>
<p>功能说明：</p>
<p>调用Error()相当于在调用了Log()之后再调用FailNow()。</p>
<p>代码实例：</p>
<pre><code>package testing_demo

import (
	&quot;testing&quot;
)

func Test(t *testing.T) {
	t.Fatal(&quot;Fatal:&quot;, &quot;F&quot;)
}
</code></pre>
<p>运行方法：</p>
<p>将上面的实例代码保存在文件“$GOPATH/src/testing_demo/t_fatal_test.go”中。用命令行进入文件所在目录并运行命令“go test -v”。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-c-t-fatalfformat-string-args-interface"><a class="header" href="#func-c-t-fatalfformat-string-args-interface">func (c *T) Fatalf(format string, args ...interface{})</a></h2>
<p>参数列表</p>
<ul>
<li>format 格式字符串</li>
<li>args 要输出的、用于描述错误的内容</li>
</ul>
<p>返回值：</p>
<p>&lt;无&gt;</p>
<p>功能说明：</p>
<p>调用Error()相当于在调用了Logf()之后再调用FailNow()。</p>
<p>代码实例：</p>
<pre><code>package testing_demo

import (
	&quot;testing&quot;
)

func Test(t *testing.T) {
	t.Fatalf(&quot;Fatal: %s\n&quot;, &quot;FF&quot;)
}
</code></pre>
<p>运行方法：</p>
<p>将上面的实例代码保存在文件“$GOPATH/src/testing_demo/t_fatalf_test.go”中。用命令行进入文件所在目录并运行命令“go test -v”。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-c-t-logargs-interface"><a class="header" href="#func-c-t-logargs-interface">func (c *T) Log(args ...interface{})</a></h2>
<p>参数列表</p>
<ul>
<li>args 要输出的、用于描述错误的内容</li>
</ul>
<p>返回值：</p>
<p>&lt;无&gt;</p>
<p>功能说明：</p>
<p>Log方法用默认的格式来格式化给定的参数，类似于Println()，并在错误日志中记录文本。</p>
<p>代码实例：</p>
<pre><code>package testing_demo

import (
	&quot;testing&quot;
)

func Test(t *testing.T) {
	t.Log(&quot;Log:&quot;, &quot;L&quot;)
}
</code></pre>
<p>运行方法：</p>
<p>将上面的实例代码保存在文件“$GOPATH/src/testing_demo/t_log_test.go”中。用命令行进入文件所在目录并运行命令“go test -v”。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-c-t-logfformat-string-args-interface"><a class="header" href="#func-c-t-logfformat-string-args-interface">func (c *T) Logf(format string, args ...interface{})</a></h2>
<p>参数列表</p>
<ul>
<li>format 格式字符串</li>
<li>args 要输出的、用于描述错误的内容</li>
</ul>
<p>返回值：</p>
<p>&lt;无&gt;</p>
<p>功能说明：</p>
<p>Logf方法根据给定的格式来格式化给定的参数，类似于Printf()，并在错误日志中记录文本。</p>
<p>代码实例：</p>
<pre><code>package testing_demo

import (
	&quot;testing&quot;
)

func Test(t *testing.T) {
	t.Logf(&quot;Log: %s\n&quot;, &quot;LF&quot;)
}
</code></pre>
<p>运行方法：</p>
<p>将上面的实例代码保存在文件“$GOPATH/src/testing_demo/t_logf_test.go”中。用命令行进入文件所在目录并运行命令“go test -v”。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-t-t-parallel"><a class="header" href="#func-t-t-parallel">func (t *T) Parallel()</a></h2>
<p>参数列表</p>
<p>&lt;无&gt;</p>
<p>返回值：</p>
<p>&lt;无&gt;</p>
<p>功能说明：</p>
<p>调用Parallel()方法使当前测试与（且仅与）其他可并列运行的（同样调用了Parallel()方法的）测试并列运行于当前 CPU 组中。</p>
<p>代码实例：</p>
<pre><code>package testing_demo

import (
	&quot;testing&quot;
)

func Test(t *testing.T) {
	t.Parallel()
}
</code></pre>
<p>运行方法：</p>
<p>将上面的实例代码保存在文件“$GOPATH/src/testing_demo/t_parallel_test.go”中。用命令行进入文件所在目录并运行命令“go test -v”。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="type-t"><a class="header" href="#type-t">type T</a></h2>
<p>结构：</p>
<pre><code>type T struct {
    // 包括被过滤或未被导出的字段
}
</code></pre>
<p>类型说明：</p>
<p>T是一个类型，它会被传递给Test函数，用于管理测试状态并支持格式化了的测试日志。日志会在测试执行及标准错误被抛出的时候累积，并在测试完成时一并输出。</p>
<p>代码实例：</p>
<pre><code>package testing_demo

import (
	&quot;testing&quot;
)

func Test(t *testing.T) {
	t.Log(&quot;Testing...&quot;)
}
</code></pre>
<p>运行方法：</p>
<p>将上面的实例代码保存在文件“$GOPATH/src/testing_demo/t_test.go”中。用命令行进入文件所在目录并运行命令“go test -v”。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名-67"><a class="header" href="#包名-67">包名</a></h1>
<p>包列表</p>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/text/scanner">text/scanner</a></li>
<li>xxx2</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="textscanner包函数列表"><a class="header" href="#textscanner包函数列表">text/scanner包函数列表</a></h1>
<ul>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/text/scanner/Constants.html">Constants</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/text/scanner/TokenString.html">func TokenString(tok rune) string</a></p>
</li>
<li>
<p><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/text/scanner/Position.html">type Position</a></p>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/text/scanner/IsValid.html">func (pos *Position) IsValid() bool</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/text/scanner/String.html">func (pos Position) String() string</a></li>
</ul>
</li>
<li>
<p>type Scanner</p>
<p>Scanner用于从io.Reader中读取Unicode字符或词法单元</p>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/text/scanner/Init.html">func (s *Scanner) Init(src io.Reader) *Scanner</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/text/scanner/Next.html">func (s *Scanner) Next() rune</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/text/scanner/Peek.html">func (s *Scanner) Peek() rune</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/text/scanner/Pos.html">func (s *Scanner) Pos() (pos Position)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/text/scanner/Scan.html">func (s *Scanner) Scan() rune</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/text/scanner/TokenText.html">func (s *Scanner) TokenText() string</a></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><pre><code>const (
	ScanIdents     = 1 &lt;&lt; -Ident
	ScanInts       = 1 &lt;&lt; -Int
	ScanFloats     = 1 &lt;&lt; -Float // includes Ints
	ScanChars      = 1 &lt;&lt; -Char
	ScanStrings    = 1 &lt;&lt; -String
	ScanRawStrings = 1 &lt;&lt; -RawString
	ScanComments   = 1 &lt;&lt; -Comment
	SkipComments   = 1 &lt;&lt; -skipComment // if set with ScanComments, comments become white space
	GoTokens       = ScanIdents | ScanFloats | ScanChars | ScanStrings | ScanRawStrings | ScanComments | SkipComments
)
</code></pre>
<p>用于控制词法单元识别的预定义模式位。比如，通过以下模式位设置，可以配置一个只识别（Go）标识符、整型、并且忽略注释的词法解析器：</p>
<pre><code>ScanIdents | ScanInts | SkipComments

const (
	EOF = -(iota + 1)
	Ident
	Int
	Float
	Char
	String
	RawString
	Comment
)
</code></pre>
<p>通过Scan方法可以获取的词法单元，此外还可以获取Unicode字符。</p>
<pre><code>const GoWhitespace = 1&lt;&lt;'\t' | 1&lt;&lt;'\n' | 1&lt;&lt;'\r' | 1&lt;&lt;' '
</code></pre>
<p>GoWhitespace，Scanner的空白字符的默认值。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-s-scanner-initsrc-ioreader-scanner"><a class="header" href="#func-s-scanner-initsrc-ioreader-scanner">func (s *Scanner) Init(src io.Reader) *Scanner</a></h2>
<p>参数列表：</p>
<ul>
<li>src 输入源</li>
</ul>
<p>返回值：</p>
<ul>
<li>初始化的词法解析器</li>
</ul>
<p>功能说明：</p>
<p>初始化一个词法解析器。</p>
<p>代码实例：</p>
<pre><code>package main

import(
	&quot;fmt&quot;
	&quot;strings&quot;
	&quot;text/scanner&quot;
)

func main(){

	src := strings.NewReader(&quot;int hello = 3; hello+23; print hello;&quot;)

	fmt.Println(src)

	var s scanner.Scanner
	s.Init(src)

	tok := s.Scan()
	fmt.Println(s.TokenText())
	for tok != scanner.EOF{
		tok = s.Scan()
	fmt.Println(s.TokenText())
	}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-pos-position-isvalid-bool"><a class="header" href="#func-pos-position-isvalid-bool">func (pos *Position) IsValid() bool</a></h2>
<p>参数列表：</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>当期位置是否合法，bool类型</li>
</ul>
<p>功能说明：</p>
<p>如果当期位置合法，返回true；如果当前位置不合法，返回false。</p>
<p>代码实例：</p>
<pre><code>package main

import(
	&quot;fmt&quot;
	&quot;strings&quot;
	&quot;text/scanner&quot;
)

func main(){

	src := strings.NewReader(&quot;int num = 1;&quot;)
	var s scanner.Scanner

	s.Init(src)

	s.Next()

	pos := s.Pos()
	fmt.Println(pos.IsValid())

}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-s-scanner-next-rune"><a class="header" href="#func-s-scanner-next-rune">func (s *Scanner) Next() rune</a></h2>
<p>参数列表：</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回rune</li>
</ul>
<p>功能说明：</p>
<p>读取并返回下一个字符。如果读到源的结尾，返回EOF。如果s.Error不为nil，表示遇到了错误；并输出错误信息到控制台。Next不会更新词法解析器的Position值；可以使用Pos()获取当前位置。</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;strings&quot;
	&quot;text/scanner&quot;
)

func main() {

	src := strings.NewReader(&quot;int num = 1;&quot;)

	var s scanner.Scanner

	s.Init(src)

	//this will print &quot;i&quot; to stdout
	fmt.Println(scanner.TokenString(s.Next()))

}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-s-scanner-peek-rune"><a class="header" href="#func-s-scanner-peek-rune">func (s *Scanner) Peek() rune</a></h2>
<p>参数列表：</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回下一个字符，rune类型</li>
</ul>
<p>功能说明：</p>
<p>在不使词法解析器向前进一位的情况下，返回下一个字符。如果解析器当前位置已经在源的最后一位，返回EOF。</p>
<p>代码实例：</p>
<pre><code>package main

import(
	&quot;fmt&quot;
	&quot;strings&quot;
	&quot;text/scanner&quot;
)

func main(){

	src := strings.NewReader(&quot;int num = 1;&quot;)

	var s scanner.Scanner
	s.Init(src)

	//this will print &quot;i&quot; to stdout
	fmt.Println(scanner.TokenString(s.Peek()))
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-s-scanner-pos-pos-position"><a class="header" href="#func-s-scanner-pos-pos-position">func (s *Scanner) Pos() (pos Position)</a></h2>
<p>参数列表：</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回当前位置，Position类型</li>
</ul>
<p>功能说明：</p>
<p>这个方法用来返回当前位置，在调用Next或Scan方法之后使用。格式为“行：列”。</p>
<p>代码实例：</p>
<p>package main</p>
<p>import(
&quot;fmt&quot;
&quot;strings&quot;
&quot;text/scanner&quot;
)</p>
<p>func main(){</p>
<pre><code>src := strings.NewReader(&quot;int num = 1;&quot;)
var s scanner.Scanner

s.Init(src)

s.Scan()
//this will print &quot;1:4&quot; to stdout
fmt.Println(s.Pos().String())

s.Next()
//this will print &quot;1:5&quot; to stdout
fmt.Println(s.Pos().String())
</code></pre>
<p>}</p>
<div style="break-before: page; page-break-before: always;"></div><pre><code>type Position struct {
	Filename string // 文件名，可能为空
	Offset   int    // 位移，从0计
	Line     int    // 行数，从1计
	Column   int    // 列数，从1计（按字符计算）
}
</code></pre>
<p>Position用来表示源中的位置。行数Line &gt; 0的情况下，Position合法。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-s-scanner-scan-rune"><a class="header" href="#func-s-scanner-scan-rune">func (s *Scanner) Scan() rune</a></h2>
<p>参数列表：</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>下一个字符或token</li>
</ul>
<p>功能说明：</p>
<p>Scan方法读取源中下一个token或字符，并返回。如果读到源的结尾，返回EOF。</p>
<p>代码实例：</p>
<pre><code>package main

import(
	&quot;fmt&quot;
	&quot;strings&quot;
	&quot;text/scanner&quot;
)

func main(){

	src := strings.NewReader(&quot;int num = 1;&quot;)
	var s scanner.Scanner

	s.Init(src)

	s.Scan()
	//this will print the next token &quot;int &quot;to stdout
	fmt.Println(s.TokenText())
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-pos-position-string-string"><a class="header" href="#func-pos-position-string-string">func (pos Position) String() string</a></h2>
<p>参数列表：</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>当前位置，string类型</li>
</ul>
<p>功能说明：</p>
<p>返回当前位置的字符串表示，格式为：&quot;行：列&quot;</p>
<p>代码实例：</p>
<pre><code>package main

import(
	&quot;fmt&quot;
	&quot;strings&quot;
	&quot;text/scanner&quot;
)

func main(){

	src := strings.NewReader(&quot;int num = 1;&quot;)
	var s scanner.Scanner

	s.Init(src)

	s.Scan()
	//this will print &quot;1:4&quot; to stdout
	fmt.Println(s.Pos().String())

	s.Next()
	//this will print &quot;1:5&quot; to stdout
	fmt.Println(s.Pos().String())
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-tokenstringtok-rune-string"><a class="header" href="#func-tokenstringtok-rune-string">func TokenString(tok rune) string</a></h2>
<p>参数列表：</p>
<ul>
<li>tok 待转换字符</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回可打印字符串</li>
</ul>
<p>功能说明：</p>
<p>这个函数用来将tok转换为字符串</p>
<p>代码实例：</p>
<pre><code>package main

import(
	&quot;fmt&quot;
	&quot;text/scanner&quot;
)
func main(){

	toks := []rune(&quot;abcdef&quot;)

	for _, tok := range toks{
		fmt.Print(scanner.TokenString(tok))
	}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-s-scanner-tokentext-string"><a class="header" href="#func-s-scanner-tokentext-string">func (s *Scanner) TokenText() string</a></h2>
<p>参数列表：</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>当前被扫描到的token，string类型</li>
</ul>
<p>功能说明：</p>
<p>返回当前被扫描到token的字符串表示。在调用Scan之后使用</p>
<p>代码实例：</p>
<pre><code>package main

import(
	&quot;fmt&quot;
	&quot;strings&quot;
	&quot;text/scanner&quot;
)

func main(){

	src := strings.NewReader(&quot;int num = 1;&quot;)
	var s scanner.Scanner

	s.Init(src)

	//this will print nothing
	fmt.Print(s.TokenText())

	s.Scan()

	//this will print &quot;int&quot; to stdout
	fmt.Print(s.TokenText())

}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名-68"><a class="header" href="#包名-68">包名</a></h1>
<p>函数列表</p>
<ul>
<li>xxx1</li>
<li>xxx2</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名-69"><a class="header" href="#包名-69">包名</a></h1>
<p>函数列表</p>
<ul>
<li>xxx1</li>
<li>xxx2</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名-70"><a class="header" href="#包名-70">包名</a></h1>
<p>函数列表</p>
<ul>
<li>xxx1</li>
<li>xxx2</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名-71"><a class="header" href="#包名-71">包名</a></h1>
<p>函数列表</p>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/time/After.html">func After(d Duration) &lt;-chan time</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/time/Sleep.html">func Sleep(d Duration)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/time/Tick.html">func Tick(d Duration) &lt;-chan time</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/time/Duration.html">Duration</a>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/time/ParseDuration.html">func ParseDuration(s string) (Duration, err)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/time/Since.html">func Since(t Time) Duration</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/time/Hours.html">func (d Duration) Hours() float64</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/time/Minutes.html">func (d Duration) Minutes() float64</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/time/Nanoseconds.html">func (d Duration) Nanoseconds() int64</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/time/Seconds.html">func (d Duration) Seconds() float64</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/time/String.html">func (d Duration) String() string</a></li>
</ul>
</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/time/Location.html">Location</a>
<ul>
<li>func FixedZone(name string, offset int) *Location</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/time/LoadLocation.html">func LoadLocation(name string) (*Location, error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/time/String.html">func (l *Location) String() string</a></li>
</ul>
</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/time/Month.html">Month</a>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/time/String.html">func (m Month) String() string</a></li>
</ul>
</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/time/ParseError.html">ParseError</a>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/time/Error.html">func (e *ParseError) Error() string</a></li>
</ul>
</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/time/Ticker.html">Ticker</a>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/time/NewTicker.html">func NewTicker(d Duration) *Ticker</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/time/Stop.html">func (t *Ticker) Stop()</a></li>
</ul>
</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/time/Time.html">Time</a>
<ul>
<li>func Date(year int, month Month, day, hour, min, sec, nsec int, loc *Location) Time  参考<a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/time/Time.html">Time</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/time/Now.html">func Now() Time</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/time/Parse.html">func Parse(layout, value string) (Time, error)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/time/Unix.html">func Unix(sec int64, nsec int64) Time</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/time/Add.html">func (t Time) Add(d Duration) Time</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/time/AddDate.html">func (t Time) AddDate(years int, months int, days int) Time</a></li>
<li>func (t Time) After(u Time) bool 参考<a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/time/Time.html">Time</a></li>
<li>func (t Time) Before(u Time) bool 参考<a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/time/Time.html">Time</a></li>
<li>func (t Time) Clock() (hour, min, sec int) 参考<a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/time/Time.html">Time</a></li>
<li>func (t Time) Date() (year int, month Month, day int) 参考<a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/time/Time.html">Time</a></li>
<li>func (t Time) Day() int 参考<a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/time/Time.html">Time</a></li>
<li>func (t Time) Equal(u Time) bool 参考<a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/time/Time.html">Time</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/time/Format.html">func (t Time) Format(layout string) string</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/time/GobDecode.html">func (t Time) GobDecode(buf []byte) error</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/time/GobEncode.html">func (t Time) GobEncode() ([]byte, error)</a></li>
<li>func (t Time) Hour() int	参考<a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/time/Time.html">Time</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/time/ISOWeek.html">func (t Time) ISOWeek() (year, week int)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/time/In.html">func (t Time) In(loc *Location) Time</a></li>
<li>[func (t Time) IsZero() bool 参考<a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/time/Time.html">Time</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/time/Local.html">func (t Time) Local() Time</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/time/Location.html">func (t Time) Location() *Location</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/time/MarshalJSON.html">func (t Time) MarshalJSON() ([]byte, error)</a></li>
<li>func (t Time) Minute() int 参考<a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/time/Time.html">Time</a></li>
<li>func (t Time) Month() Month 参考<a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/time/Time.html">Time</a></li>
<li>func (t Time) Nanosecond() int 参考<a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/time/Time.html">Time</a></li>
<li>func (t Time) Second() int 参考<a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/time/Time.html">Time</a></li>
<li>func (t Time) String() string 参考<a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/time/Time.html">Time</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/time/Sub.html">func (t Time) Sub(u Time) Duration</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/time/UTC.html">func (t Time) UTC() Time</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/time/Unix.html">func (t Time) Unix() int64</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/time/UnixNano.html">func (t Time) UnixNano() int64</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/time/UnmarshalJSON.html">func (t Time) UnmarshalJSON(data []byte) (err error)</a></li>
<li>func (t Time) Weekday() Weekday 参考<a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/time/Time.html">Time</a></li>
<li>func (t Time) Year() int 参考<a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/time/Time.html">Time</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/time/Zone.html">func (t Time) Zone() (name string, offset int)</a></li>
</ul>
</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/time/Timer.html">Timer</a>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/time/AfterFunc.html">func AfterFunc(d Duration, f func()) *Timer</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/time/NewTimer.html">func NewTimer(d Duration) *Timer</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/time/Stop.html">func (t *Timer) Stop() (ok bool)</a></li>
</ul>
</li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/time/Weekday.html">Weekday</a>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/time/String.html">func (d Weekday) String() string</a></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-t-time-addd-duration-time"><a class="header" href="#func-t-time-addd-duration-time">func (t Time) Add(d Duration) Time</a></h1>
<p>参数列表：</p>
<ul>
<li>d 时间间隔</li>
</ul>
<p>返回值：</p>
<ul>
<li>Time</li>
</ul>
<p>功能说明：</p>
<p>返回时间（t + d）</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;time&quot;
)

func main() {
	now := time.Now()
	fmt.Println(&quot;now:&quot;, now)
	fmt.Println(&quot;after 3 hours&quot;, now.Add(3*time.Hour))
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-t-time-adddateyears-int-months-int-days-int-time"><a class="header" href="#func-t-time-adddateyears-int-months-int-days-int-time">func (t Time) AddDate(years int, months int, days int) Time</a></h1>
<p>参数列表：</p>
<ul>
<li>years 年</li>
<li>months 月</li>
<li>days 日</li>
</ul>
<p>返回值：</p>
<ul>
<li>Time</li>
</ul>
<p>功能说明：</p>
<p>生成由t加上参数中指定的年月日之后的时间，比如AddDate(-1, 2, 3) 使 January 1, 2011变为March 4, 2010。AddDate以和Date方法一样的方式标准化返回值，比如，10月31日加一个月之后为11月31日，标准化为12月1日</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

func main() {
    now := time.Now()
    fmt.Println(now.AddDate(2, 3, 4))
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="func-afterd-duration--chan-time"><a class="header" href="#func-afterd-duration--chan-time">func After(d Duration) &lt;-chan Time</a></h2>
<p>参数列表：</p>
<ul>
<li>d 时间跨度</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回Time类型chan</li>
</ul>
<p>功能说明：</p>
<p>等待指定时间段之后将当前时间发送给返回的chan中。等价于NewTimer(d).C</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

func main() {
	result := make(chan int)
	go func(ch chan int) {
		time.Sleep(3 * time.Second)	
		ch &lt;- 4
	}(result)

	select {
	case &lt;-time.After(2 * time.Second):
		fmt.Println(&quot;Time out&quot;)
	case &lt;-result:
		fmt.Println(result)
	}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-afterfuncd-duration-f-func-timer"><a class="header" href="#func-afterfuncd-duration-f-func-timer">func AfterFunc(d Duration, f func()) *Timer</a></h1>
<p>参数列表：</p>
<ul>
<li>d 时间间隔</li>
<li>f 回调函数</li>
</ul>
<p>返回值：</p>
<ul>
<li>*Timer </li>
</ul>
<p>功能说明：</p>
<p>经过时间d之后在自己的goroutine中调用f。可以调用返回的Timer的Stop方法来停止Timer。</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;time&quot;
)

func main() {
	f := func() {
		fmt.Println(&quot;Time out&quot;)
	}
	time.AfterFunc(2*time.Second, f)
	
	time.Sleep(3 * time.Second)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constants-2"><a class="header" href="#constants-2">Constants</a></h1>
<pre><code>ANSIC       = &quot;Mon Jan _2 15:04:05 2006&quot;
UnixDate    = &quot;Mon Jan _2 15:04:05 MST 2006&quot;
RubyDate    = &quot;Mon Jan 02 15:04:05 -0700 2006&quot;
RFC822      = &quot;02 Jan 06 15:04 MST&quot;
RFC822Z     = &quot;02 Jan 06 15:04 -0700&quot; // RFC822 with numeric zone
RFC850      = &quot;Monday, 02-Jan-06 15:04:05 MST&quot;
RFC1123     = &quot;Mon, 02 Jan 2006 15:04:05 MST&quot;
RFC1123Z    = &quot;Mon, 02 Jan 2006 15:04:05 -0700&quot; // RFC1123 with numeric zone
RFC3339     = &quot;2006-01-02T15:04:05Z07:00&quot;
RFC3339Nano = &quot;2006-01-02T15:04:05.999999999Z07:00&quot;
Kitchen     = &quot;3:04PM&quot;



// Handy time stamps.
Stamp      = &quot;Jan _2 15:04:05&quot;
StampMilli = &quot;Jan _2 15:04:05.000&quot;
StampMicro = &quot;Jan _2 15:04:05.000000&quot;
StampNano  = &quot;Jan _2 15:04:05.000000000&quot;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-duration-int64"><a class="header" href="#type-duration-int64">type Duration int64</a></h1>
<p>以int64表示两个时间点之间的间隔（纳秒数），最多表示290年</p>
<p>常量</p>
<ul>
<li>Nanosecond Duration 	= 1</li>
<li>Microsecond			= 1000 * Nanosecond</li>
<li>Millissecond			= 1000 * Microsecond</li>
<li>Second				= 1000 * Millisecond</li>
<li>Minute				= 60 * Second</li>
<li>Hour					= 60 * Minute</li>
</ul>
<p>通常没有天或者更大的时间单位，是为了避免混淆跨越夏令时区转换。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-e-parseerror-error-string-1"><a class="header" href="#func-e-parseerror-error-string-1">func (e *ParseError) Error() string</a></h1>
<p>参数列表：</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>string 错误描述</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-fixedzonename-string-offset-int-location"><a class="header" href="#func-fixedzonename-string-offset-int-location">func FixedZone(name string, offset int) *Location</a></h1>
<p>参数列表：</p>
<ul>
<li>name </li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-t-time-formatlayout-string-string"><a class="header" href="#func-t-time-formatlayout-string-string">func (t Time) Format(layout string) string</a></h1>
<p>参数列表：</p>
<ul>
<li>layout 时间格式</li>
</ul>
<p>返回值：</p>
<ul>
<li>string 时间格式化之后的字符串</li>
</ul>
<p>功能说明：</p>
<p>返回根据layout指定的格式格式化之后的字符串，layout定义了标准时间的显示格式。预定义的layout有ANSIC，UnixDate，RFC3339等。</p>
<p>常量：</p>
<pre><code>ANSIC       = &quot;Mon Jan _2 15:04:05 2006&quot;
UnixDate    = &quot;Mon Jan _2 15:04:05 MST 2006&quot;
RubyDate    = &quot;Mon Jan 02 15:04:05 -0700 2006&quot;
RFC822      = &quot;02 Jan 06 15:04 MST&quot;
RFC822Z     = &quot;02 Jan 06 15:04 -0700&quot; // RFC822 with numeric zone
RFC850      = &quot;Monday, 02-Jan-06 15:04:05 MST&quot;
RFC1123     = &quot;Mon, 02 Jan 2006 15:04:05 MST&quot;
RFC1123Z    = &quot;Mon, 02 Jan 2006 15:04:05 -0700&quot; // RFC1123 with numeric zone
RFC3339     = &quot;2006-01-02T15:04:05Z07:00&quot;
RFC3339Nano = &quot;2006-01-02T15:04:05.999999999Z07:00&quot;
Kitchen     = &quot;3:04PM&quot;
// Handy time stamps.
Stamp      = &quot;Jan _2 15:04:05&quot;
StampMilli = &quot;Jan _2 15:04:05.000&quot;
StampMicro = &quot;Jan _2 15:04:05.000000&quot;
StampNano  = &quot;Jan _2 15:04:05.000000000&quot;
</code></pre>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;time&quot;
)

func main() {
	t := time.Now()
	fmt.Println(t.Format(time.ANSIC))
	fmt.Println(t.Format(time.UnixDate))
	//...
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-t-time-gobdecodebuf-byte-error"><a class="header" href="#func-t-time-gobdecodebuf-byte-error">func (t *Time) GobDecode(buf []byte) error</a></h1>
<p>参数列表：</p>
<ul>
<li>buf gob数据</li>
</ul>
<p>返回值：</p>
<ul>
<li>error 错误</li>
</ul>
<p>功能说明：</p>
<p>GobDecode实现了gob.GobDecoder接口。</p>
<p>代码实例：</p>
<p>无</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-t-time-gobencode-byte-error"><a class="header" href="#func-t-time-gobencode-byte-error">func (t Time) GobEncode() ([]byte, error)</a></h1>
<p>参数列表：</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>[]byte gob数据</li>
<li>error 错误</li>
</ul>
<p>功能说明：</p>
<p>GobEncode实现了gob.GobEncoder接口</p>
<p>代码实例：</p>
<p>无</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-d-duration-hours-float64"><a class="header" href="#func-d-duration-hours-float64">func (d Duration) Hours() float64</a></h1>
<p>参数列表：</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>float64</li>
</ul>
<p>功能说明：</p>
<p>返回时间d以小时为单位的浮点数形式</p>
<p>代码实例：</p>
<pre><code>package main

import (
  &quot;fmt&quot;
	&quot;time&quot;
)

func main() {
	d, _ := time.ParseDuration(&quot;3h4m2s&quot;)
	fmt.Println(d.Hours())
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-t-time-inloc-location-time"><a class="header" href="#func-t-time-inloc-location-time">func (t Time) In(loc *Location) Time</a></h1>
<p>参数列表：</p>
<ul>
<li>loc 位置</li>
</ul>
<p>返回值：</p>
<ul>
<li>Time </li>
</ul>
<p>功能说明：</p>
<p>返回location设为loc的t。如果loc为nil则函数panic</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

func main() {
    t := time.Now()
    fmt.Println(t)
    fmt.Println(t.In(time.UTC))
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-t-time-isoweek-year-week-int"><a class="header" href="#func-t-time-isoweek-year-week-int">func (t Time) ISOWeek() (year, week int)</a></h1>
<p>参数列表：</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>year 年</li>
<li>week 星期</li>
</ul>
<p>功能说明：</p>
<p>返回时间t的在一年中的星期数。星期范围从1到53。每年的1月1日到3日可能会属于上一年的第52或者53周，每年的12月29日到31日可能属于下一年的第一周。</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

func main() {
    t := time.Date(2013, time.January, 7, 15, 23, 4, 100, time.UTC)
    fmt.Println(t.ISOWeek())
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-loadlocationname-string-location-error"><a class="header" href="#func-loadlocationname-string-location-error">func LoadLocation(name string) (*Location error)</a></h1>
<p>参数列表：</p>
<ul>
<li>name 时区名称</li>
</ul>
<p>返回值：</p>
<ul>
<li>Location</li>
<li>error</li>
</ul>
<p>功能说明：</p>
<p>LoadLocation返回name对应的Location。</p>
<p>如果name是&quot;&quot;或“UTC”,LoadLocation返回UTC，如果name是“Local”， LoadLocation返回Local。</p>
<p>否则，name取为IANA时区数据库中的一个文件对应的位置名称，如“America/New_York”。</p>
<p>LoadLocation使用的时区数据库可能不会被所有的系统所提供，尤其是非Unix系统。LoadLocation在ZONEINFO环境变量指定的目录或者解压的zip文件中寻找，如果没有，在Unix系统中已知的安装位置寻找，最后在 $GOROOT/lib/time/zoneinfo.zip中寻找</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;time&quot;
    &quot;fmt&quot;
)

func main() {
    loc, err := time.LoadLocation(&quot;America/New_York&quot;)
    if err != nil {
        fmt.Println(err)
        return
    }

    fmt.Println(loc)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-t-time-local-time"><a class="header" href="#func-t-time-local-time">func (t Time) Local() Time</a></h1>
<p>参数列表：</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>Time</li>
</ul>
<p>功能说明：</p>
<p>返回本地时间。等价于t.In(time.Local)</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

func main() {
    t := time.Date(2013, time.March, 14, 15, 23, 4, 100, time.UTC)
    fmt.Println(t)
    fmt.Println(t.Local())
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-t-time-location-location"><a class="header" href="#func-t-time-location-location">func (t Time) Location() *Location</a></h1>
<p>参数列表：</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>*Location</li>
</ul>
<p>功能说明：</p>
<p>返回时间t的时区信息。</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;time&quot;
)

func main() {
	fmt.Println(time.Now().Location())
}
</code></pre>
<h1 id="type-location-struct"><a class="header" href="#type-location-struct">type Location struct</a></h1>
<p>Location映射了时间瞬间和时间所在的区域.通常Location表示有相同时间偏移的地理区域的集合，例如中欧的CEST和CET。</p>
<pre><code>var Local *Location = &amp;localLoc
</code></pre>
<p>Local表示系统的本地时区</p>
<pre><code>var UTC *Location = &amp;utcLoc
</code></pre>
<p>UTC 表示通用协调时间。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-t-time-marshaljson-byte-error"><a class="header" href="#func-t-time-marshaljson-byte-error">func (t Time) MarshalJSON() ([]byte, error)</a></h1>
<p>参数列表：</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>[]byte json串</li>
<li>error 错误</li>
</ul>
<p>功能说明：</p>
<p>MarshalJSON实现了json.Marshaler接口。时间t按照RFC3339格式化。</p>
<p>代码实例：</p>
<p>无</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-d-duration-minutes-float64"><a class="header" href="#func-d-duration-minutes-float64">func (d Duration) Minutes() float64</a></h1>
<p>参数列表：</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>float64</li>
</ul>
<p>功能说明：</p>
<p>返回时间d以分钟为单位的浮点数形式</p>
<p>代码实例：</p>
<pre><code>package main

import (
  &quot;fmt&quot;
  &quot;time&quot;
)

func main() {
	d, _ := time.ParseDuration(&quot;3h4m2s&quot;)
	fmt.Println(d.Minutes())
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-month-int"><a class="header" href="#type-month-int">type Month int</a></h1>
<p>一年中的一个月</p>
<p>常量：</p>
<ul>
<li>January Month = 1 + iota</li>
<li>February</li>
<li>March</li>
<li>April</li>
<li>May</li>
<li>June</li>
<li>July</li>
<li>August</li>
<li>September</li>
<li>October</li>
<li>November</li>
<li>December</li>
</ul>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;time&quot;
)

func main() {
	_, m, _ := time.Now().Date()
	fmt.Println(m)
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-d-duration-nanoseconds-float64"><a class="header" href="#func-d-duration-nanoseconds-float64">func (d Duration) Nanoseconds() float64</a></h1>
<p>参数列表：</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>float64</li>
</ul>
<p>功能说明：</p>
<p>返回时间d以纳秒为单位的浮点数形式</p>
<p>代码实例：</p>
<pre><code>package main

import (
  &quot;fmt&quot;
  &quot;time&quot;
)

func main() {
	d, _ := time.ParseDuration(&quot;2s3ms&quot;)
	fmt.Println(d.Nanoseconds())
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-newtickerd-duration-ticker"><a class="header" href="#func-newtickerd-duration-ticker">func NewTicker(d Duration) *Ticker</a></h1>
<p>参数列表：</p>
<ul>
<li>d 时钟间隔</li>
</ul>
<p>返回值：</p>
<ul>
<li>*Ticker 定时器</li>
</ul>
<p>功能说明：</p>
<p>新建一个Ticker，包含了time channel，每隔指定d间隔的时间发送时间给这个channel。d必须大于0，否则函数会崩溃</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

func tick(ch &lt;-chan time.Time) {
    for t := range ch {
        fmt.Println(t)
    }
}

func main() {
    ticker := time.NewTicker(time.Second)
    go tick(ticker.C)
    time.Sleep(5 * time.Second)
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-newtimerd-duration-timer"><a class="header" href="#func-newtimerd-duration-timer">func NewTimer(d Duration) *Timer</a></h1>
<p>参数列表：</p>
<ul>
<li>d 时间间隔</li>
</ul>
<p>返回值：</p>
<ul>
<li>*Timer</li>
</ul>
<p>功能说明：</p>
<p>新建一个Timer，在时间d之后将当前时间发送给C</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;time&quot;
)

func main() {
	timer := time.NewTimer(2 * time.Second)
	
	t := &lt;-timer.C
	fmt.Println(t)
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-now-time"><a class="header" href="#func-now-time">func Now() Time</a></h1>
<p>参数列表：</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>Time</li>
</ul>
<p>功能说明：</p>
<p>返回当前的本地时间</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;time&quot;
)

func main() {
	fmt.Println(time.Now())
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-parselayout-value-string-time-error"><a class="header" href="#func-parselayout-value-string-time-error">func Parse(layout, value string) (Time, error)</a></h1>
<p>参数列表：</p>
<ul>
<li>layout 格式</li>
<li>value 表示时间的字符串</li>
</ul>
<p>返回值：</p>
<ul>
<li>Time</li>
<li>error</li>
</ul>
<p>功能说明：</p>
<p>根据格式化的字符串返回一个它所代表的时间值，layout定义了标准时间的显示格式（Mon Jan 2 15:04:05 -0700 MST 2006），还用来描述了待分析的字符串。预定义的layout有ANSIC，UnixDate等（见<a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/time/Contants.html">Contants</a>）。想多了解格式和标准时间定义的参见ANSIC文档。
value中省略的元素默认为0，或者不可能出现0时为1。比如转换“3：04pm”返回的时间为Jan 1, year 0, 15:04:00 UTC。年必须在0000..9999之间。星期会做语法检查，但是值会被忽略。</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

func main() {
    t, _ := time.Parse(time.ANSIC, &quot;Mon May 8 16:19:35 2013&quot;)
    fmt.Println(t)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-parsedurations-string-duration-error"><a class="header" href="#func-parsedurations-string-duration-error">func ParseDuration(s string) (Duration, error)</a></h1>
<p>参数列表：</p>
<ul>
<li>s 时间长短的字符串</li>
</ul>
<p>返回值：</p>
<ul>
<li>Duration 解析后的时间长短</li>
<li>error 错误</li>
</ul>
<p>功能说明：</p>
<p>将一个表示时间的字符串解析，每一个字符串是带有单位的十进制数序列，每个数字带有可选的单位或小数位。
合法的单位是&quot;ns&quot;, &quot;us&quot; (or &quot;µs&quot;), &quot;ms&quot;, &quot;s&quot;, &quot;m&quot;, &quot;h&quot;。</p>
<p>代码实例：</p>
<pre><code>package main

import (
  &quot;fmt&quot;
	&quot;time&quot;
)

func main() {
	d, err := time.ParseDuration(&quot;1h2m3s4ms5.8us6ns&quot;)
	fmt.Printf(&quot;%v %v&quot;, d, err)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>#type ParseError struct{}</p>
<p>描述时间转换错误</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-d-duration-seconds-float64"><a class="header" href="#func-d-duration-seconds-float64">func (d Duration) Seconds() float64</a></h1>
<p>参数列表：</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>float64</li>
</ul>
<p>功能说明：</p>
<p>返回时间d以秒为单位的浮点数形式</p>
<p>代码实例：</p>
<pre><code>package main

import (
  &quot;fmt&quot;
  &quot;time&quot;
)

func main() {
	d, _ := time.ParseDuration(&quot;3h4m2s&quot;)
	fmt.Println(d.Seconds())
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-sincet-time-duration"><a class="header" href="#func-sincet-time-duration">func Since(t Time) Duration</a></h1>
<p>参数列表：</p>
<ul>
<li>t 时间</li>
</ul>
<p>返回值：</p>
<ul>
<li>Duration</li>
</ul>
<p>功能说明：</p>
<p>返回从时间t到当前时间的间隔，time.Now().Sub(t)的简写</p>
<p>代码实例：</p>
<pre><code>package main

import (
  &quot;fmt&quot;
	&quot;time&quot;
)

func main() {
	t := time.Now()
	time.Sleep(3 * time.Second)
	fmt.Println(time.Since(t))
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-sleepd-duration"><a class="header" href="#func-sleepd-duration">func Sleep(d Duration)</a></h1>
<p>参数列表：</p>
<ul>
<li>d 时间跨度</li>
</ul>
<p>返回值：</p>
<ul>
<li>无</li>
</ul>
<p>功能说明：</p>
<p>使当前goroutine暂停指定时间</p>
<p>代码实例：</p>
<pre><code>package main

import (
  &quot;time&quot;
)

func main() {
  time.Sleep(100 * time.Millisecond)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-t-ticker-stop"><a class="header" href="#func-t-ticker-stop">func (t *Ticker) Stop()</a></h1>
<p>参数列表：</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>无</li>
</ul>
<p>功能说明：</p>
<p>停止一个定时器</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;time&quot;
)

func tick(ch &lt;-chan time.Time) {
	for t := range ch {
		fmt.Println(t)
	}
}

func main() {
	ticker := time.NewTicker(time.Second)

	go tick(ticker.C)

	&lt;-time.After(5 * time.Second)
	ticker.Stop()
}
</code></pre>
<h1 id="func-t-timer-stop-ok-bool"><a class="header" href="#func-t-timer-stop-ok-bool">func (t *Timer) Stop() (ok bool)</a></h1>
<p>参数列表：</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>ok 成功true，失败false</li>
</ul>
<p>功能说明：</p>
<p>停止Timer触发，成功返回true，已经停止或过期返回false。</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;time&quot;
)

func callback() {
	fmt.Println(&quot;Time out&quot;)
}

func main() {
	time.AfterFunc(2*time.Second, callback).Stop()
	time.Sleep(3 * time.Second)
	fmt.Println(&quot;end&quot;)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-d-duration-string-string"><a class="header" href="#func-d-duration-string-string">func (d Duration) String() string</a></h1>
<p>参数列表：</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>string</li>
</ul>
<p>功能说明：</p>
<p>根据时间返回一个&quot;72h3m0.5s&quot;形式的字符串，前导0会被省略。
特殊情况，当时间小于1秒时，会用更小的单位（毫秒，微秒，纳秒）来保证前导数字不为0。时间就为0时则仅返回0，没有单位</p>
<p>代码实例：</p>
<pre><code>package main

import (
  &quot;fmt&quot;
	&quot;time&quot;
)

func main() {
	d, _ := time.ParseDuration(&quot;1h2m3.5s&quot;)
	fmt.Println(d)
	d, _ = time.ParseDuration(&quot;3ms4ns&quot;)
	fmt.Println(d)
	d, _ = time.ParseDuration(&quot;0&quot;)
	fmt.Println(d)
}
</code></pre>
<p>#func (m Month) String() string</p>
<p>返回月份的英文形式</p>
<p>示例代码：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;time&quot;
)

func main() {
	for i := 1; i &lt;= 12; i++ {
		fmt.Println(time.Month(i))
	}
}
</code></pre>
<h1 id="func-d-weekday-string-string"><a class="header" href="#func-d-weekday-string-string">func (d Weekday) String() string</a></h1>
<p>返回星期的英文形式</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;time&quot;
)

func main() {
	for i := 0; i &lt; 7; i++ {
		fmt.Println(time.Weekday(i))
	}
}
</code></pre>
<h1 id="func-l-location-string-string"><a class="header" href="#func-l-location-string-string">func (l *Location) String() string</a></h1>
<p>返回根据LoadLocation参数的时区信息名字</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-t-time-subu-time-duration"><a class="header" href="#func-t-time-subu-time-duration">func (t Time) Sub(u Time) Duration</a></h1>
<p>参数列表：</p>
<ul>
<li>u </li>
</ul>
<p>返回值：</p>
<ul>
<li>Duration</li>
</ul>
<p>功能说明：</p>
<p>返回t - u</p>
<p>代码实例：</p>
<pre><code>package main

import(
    &quot;fmt&quot;
    &quot;time&quot;
)

func main() {
    t1 := time.Now()
    time.Sleep(3 * time.Second)
    t2 := time.Now()
    fmt.Println(t2.Sub(t1))
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-tickd-duration--chan-time"><a class="header" href="#func-tickd-duration--chan-time">func Tick(d Duration) &lt;-chan Time</a></h1>
<p>参数列表：</p>
<ul>
<li>d 时间跨度</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回Time chan</li>
</ul>
<p>功能说明：</p>
<p>Tick 是对NewTicker更易用的包装，提供了对定时器channel的访问。通常用于没必要停止定时器的客户端。</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
	&quot;time&quot;
)

func main() {
	c := time.Tick(1 * time.Second)
	for now := range c {
		fmt.Printf(&quot;%v\n&quot;, now)
	}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-ticker-struct-"><a class="header" href="#type-ticker-struct-">type Ticker struct {</a></h1>
<h1 id="c--chan-time"><a class="header" href="#c--chan-time">C &lt;-chan Time</a></h1>
<h1 id="-2"><a class="header" href="#-2">}</a></h1>
<p>保存一个同步的channel，每隔一个时钟间隔发出一个Tick</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-type-time-struct-"><a class="header" href="#func-type-time-struct-">func type Time struct {}</a></h1>
<p>精确到纳秒的时间</p>
<p>程序中通常使用值存储或传递，而不是指针。也就是说时间变量或结构体字段的类型应该是time.Time, 而不是*time.Time。一个Time值可以在多个不同的goroutine中同时使用。</p>
<p>Time实例可以通过Before，After和Equal方法进行比较。Sub方法可以使两个Time实例相减，得到Duration。Add方法使一个Time加上一个Duration得到新的Time。</p>
<p>Time类型的0值为January 1, year 1, 00:00:00.000000000 UTC。由于这个时间不太可能会在实践中用到，IsZero方法可以简单的判断一个Time是否被明确的初始化了。</p>
<p>每个Time和一个Location联系在一起，当计算时间的表现形式的时候起作用，例如Format，Hour，Year方法。Local，UTC和Ln方法，返回指定location的Time。这种形式改变location只是改变表现形式，并没有改变实际的时间，因此不影响之前的计算和描述。</p>
<p>示例代码：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

func main() {
    t1 := time.Date(2012, time.March, 12, 17, 45, 20, 30, time.Local)
    fmt.Println(t1)
    t2 := time.Now()
    fmt.Println(t2)

    fmt.Println(t1.After(t2), t1.Before(t2), t1.Equal(t2))
    fmt.Println(&quot;Year =&quot;, t1.Year())
    fmt.Println(&quot;Month =&quot;, t1.Month())
    fmt.Println(&quot;Day =&quot;, t1.Day())
    fmt.Println(&quot;Hour =&quot;, t1.Hour())
    fmt.Println(&quot;Minute =&quot;, t1.Minute())
    fmt.Println(&quot;Second =&quot;, t1.Second())
    fmt.Println(&quot;Nanosecond =&quot;, t1.Nanosecond())
    fmt.Println(&quot;Weekday =&quot;, t1.Weekday())

    fmt.Println(t1.Clock())
    fmt.Println(t1.Date())
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-timer-struct-"><a class="header" href="#type-timer-struct-">type Timer Struct {</a></h1>
<h1 id="c--time"><a class="header" href="#c--time">C &lt;-Time</a></h1>
<h1 id="-3"><a class="header" href="#-3">}</a></h1>
<p>代表一个单独的事件，当时间过期的时候，把当前的时间发送给C，除非Timer是由<a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/time/AfterFunc.html">AfterFunc</a>创建的。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-t-time-unix-int64"><a class="header" href="#func-t-time-unix-int64">func (t Time) Unix() int64</a></h1>
<p>参数列表：</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>int64</li>
</ul>
<p>功能说明：</p>
<p>返回Unix时间——t相对于January 1, 1970 UTC的时间间隔</p>
<p>代码实例：</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;time&quot;
)

func main() {
	t := time.Now()
	fmt.Println(t.Unix())
}
</code></pre>
<h1 id="func-unixsec-int64-nsec-int64-time"><a class="header" href="#func-unixsec-int64-nsec-int64-time">func Unix(sec int64, nsec int64) Time</a></h1>
<p>参数列表：</p>
<ul>
<li>sec 秒</li>
<li>nsec 纳秒</li>
</ul>
<p>返回值：</p>
<ul>
<li>Time</li>
</ul>
<p>功能说明：</p>
<p>返回参数指定的本地时间，秒和纳秒是从January 1, 1970 UTC开始计算。纳秒的取值区间为[0, 999999999]</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

func main() {
    fmt.Println(time.Unix(1000, 340))
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-t-timeunixnano-int64"><a class="header" href="#func-t-timeunixnano-int64">func (t Time)UnixNano() int64</a></h1>
<p>参数列表：</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>int64</li>
</ul>
<p>功能说明：</p>
<p>返回t从January 1, 1970 UTC开始的Unix时间的纳秒数，如果纳秒数不能用int64来表示则结果是未定义的。注意：这意味着时间零点的UnixNano结果是未定义的。</p>
<p>代码实例：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

func main() {
    now := time.Now()
    fmt.Println(now.UnixNano())
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-t-time-unmarshaljsondata-byte-err-error"><a class="header" href="#func-t-time-unmarshaljsondata-byte-err-error">func (t *Time) UnmarshalJSON(data []byte) (err error)</a></h1>
<p>参数列表：</p>
<ul>
<li>data json数据</li>
</ul>
<p>返回值：</p>
<ul>
<li>err 错误</li>
</ul>
<p>功能说明：</p>
<p>UnmarshalJSON实现了json.Unmarshaler接口。t按照RFC3339格式化。</p>
<p>代码实例：</p>
<p>无</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-t-time-utc-time"><a class="header" href="#func-t-time-utc-time">func (t Time) UTC() Time</a></h1>
<p>参数列表：</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>Time</li>
</ul>
<p>功能说明：</p>
<p>等价于 t.In(time.UTC)</p>
<p>代码实例：</p>
<p>无</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-weekday-int"><a class="header" href="#type-weekday-int">type Weekday int</a></h1>
<p>指定一周中的一天（Sunday = 0, …）</p>
<p>常量：</p>
<ul>
<li>Sunday Weekday = iota</li>
<li>Monday</li>
<li>Tuesday</li>
<li>Wednesday</li>
<li>Thursday</li>
<li>Friday</li>
<li>Saturday</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-t-time-zone-name-string-offset-int"><a class="header" href="#func-t-time-zone-name-string-offset-int">func (t Time) Zone() (name string, offset int)</a></h1>
<p>参数列表：</p>
<ul>
<li>无</li>
</ul>
<p>返回值：</p>
<ul>
<li>name 时区简写</li>
<li>offset 相对与UTC向东的秒偏移</li>
</ul>
<p>功能说明：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

func main() {
    fmt.Println(time.Now().Zone())
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名-72"><a class="header" href="#包名-72">包名</a></h1>
<p>函数列表</p>
<ul>
<li>xxx1</li>
<li>xxx2</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="utf16-包函数列表"><a class="header" href="#utf16-包函数列表">utf16 包函数列表</a></h1>
<ul>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/unicode/utf16/Decode.html">func Decode(s []utf16) []rune</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/unicode/utf16/DecodeRune.html">func DecodeRune(r1, r2 rune) rune</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/unicode/utf16/Encode.html">func Encode( []rune) []utf16</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/unicode/utf16/EncodeRune.html">func EncodeRune( r rune) (r1 rune, r2 rune)</a></li>
<li><a href="3.%20%E5%BA%93%E5%87%BD%E6%95%B0/unicode/utf16/IsSurrogate.html">func IsSurrogate(r rune) bool</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-decodes-uint16-rune"><a class="header" href="#func-decodes-uint16-rune">func Decode(s []uint16) []rune</a></h1>
<p>函数列表</p>
<ul>
<li>s utf-16序列 </li>
</ul>
<p>返回值:</p>
<ul>
<li>成功返回 Unicode 字符串</li>
</ul>
<p>功能说明:</p>
<blockquote>
<p>将utf-16序列 解码成Unicode字符序列并返回</p>
</blockquote>
<p>代码实例:</p>
<pre><code>package main

import (
 &quot;fmt&quot;
&quot;unicode/utf16&quot;
)
func main() {
u := []uint16{72, 101, 108, 108, 111, 32, 19990, 30028}
s := utf16.Decode(u)
fmt.Printf(&quot;%c&quot;, s)
// [H e l l o   世 界]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-decoderuner1-r2-runc-rune"><a class="header" href="#func-decoderuner1-r2-runc-rune">func DecodeRune(r1, r2 runc) rune</a></h1>
<p>参数列表:</p>
<ul>
<li>r1 是utf-16代理对的高位码元</li>
<li>r2 是utf-16代理对的低位码元</li>
</ul>
<p>返回值列表:</p>
<ul>
<li>返回值为解码后的 Unicode字符</li>
<li>如果r1 或者 r2不是有效的utf-16代理区字符</li>
<li>则返回 U+FFFD</li>
</ul>
<p>功能说明:</p>
<blockquote>
<p>将utf-16代理对解码成一个Unicode字符</p>
</blockquote>
<p>实例代码:</p>
<pre><code>package main

import (
&quot;fmt&quot;
&quot;unicode/utf16&quot;
)
func main() {
r := utf16.DecodeRune(0xDBFC, 0xDC00)
fmt.Printf(&quot;%U&quot;, r)
// U+10F000
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-encodes-rune-utf16"><a class="header" href="#func-encodes-rune-utf16">func Encode(s []rune) []utf16</a></h1>
<p>参数列表: </p>
<p>-s Unicode 编码序列 </p>
<p>返回值列表:</p>
<ul>
<li>返回utf16序列串</li>
</ul>
<p>功能说明：</p>
<blockquote>
<p>将 s 编码成 UTF-16 序列并返回</p>
</blockquote>
<p>实例代码:
package main</p>
<pre><code>import (
 &quot;fmt&quot;
&quot;unicode/utf16&quot;
)
func main() {
s := []rune(&quot;Hello 世界&quot;)
u := utf16.Encode(s)
fmt.Printf(&quot;%v&quot;, u)
// [72 101 108 108 111 32 19990 30028]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-encoderune-r-rune-r1-r2-rune"><a class="header" href="#func-encoderune-r-rune-r1-r2-rune">func EncodeRune( r rune) (r1, r2 rune)</a></h1>
<p>参数列表:</p>
<ul>
<li>r 要编码的字符</li>
<li>如果 r &lt; 0x10000, 则无需编码，其utf-16序列就是其自身</li>
</ul>
<p>返回值列表:
r1：编码后的 UTF-16 代理对的高位码元
r2：编码后的 UTF-16 代理对的低位码元
如果 r 不是有效的 Unicode 字符，或者是代理区字符，或者无需编码
则返回 U+FFFD, U+FFFD</p>
<p>功能说明：</p>
<blockquote>
<p>将字符 r 编码成 UTF-16 代理对</p>
</blockquote>
<p>代码实例:</p>
<p>package main</p>
<pre><code>import (
&quot;fmt&quot;
&quot;unicode/utf16&quot;
)
func main() {
r1, r2 := utf16.EncodeRune('\U0010F000')
fmt.Printf(&quot;%x, %x&quot;, r1, r2)
// dbfc, dc00
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="func-issurrogater-rune-bool"><a class="header" href="#func-issurrogater-rune-bool">func IsSurrogate(r rune) bool</a></h1>
<p>参加列表</p>
<ul>
<li>r rune字符</li>
</ul>
<p>返回值:</p>
<ul>
<li>成功返回true</li>
<li>失败返回false</li>
</ul>
<p>功能说明:</p>
<blockquote>
<p>IsSurrogate 判断 r 是否为代理区字符</p>
<p>两个代理区字符可以用来组合成一个 utf16 编码</p>
<p>代理区字符分别有三个 0xd800, 0xdc00, 0xdfff 
如果r是代理区字符，则返回true</p>
<p>如果r不是代理区字符，则返回false</p>
</blockquote>
<p>代码实例:</p>
<pre><code>package main

import ( 
    &quot;fmt&quot;
    &quot;unicode/utf16&quot;
    )

func main() {
    
fmt.Println(utf16.IsSurrogate(0xD800))// true
fmt.Println(utf16.IsSurrogate(0xDC00)) // true
fmt.Println(utf16.IsSurrogate(0xDFFF)) // true
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名-73"><a class="header" href="#包名-73">包名</a></h1>
<p>函数列表</p>
<ul>
<li>xxx1</li>
<li>xxx2</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包名-74"><a class="header" href="#包名-74">包名</a></h1>
<p>函数列表</p>
<ul>
<li>xxx1</li>
<li>xxx2</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>title: &quot;Printf&quot;
date: 2019-08-30T15:13:01+08:00</h2>
<h2 id="printf"><a class="header" href="#printf">Printf</a></h2>
<pre><code>General 
%v 以默认的方式打印变量的值
%T 打印变量的类型

Integer 
%+d 带符号的整型，fmt.Printf(&quot;%+d&quot;, 255)输出+255
%q 打印单引号
%o 不带零的八进制
%#o 带零的八进制
%x 小写的十六进制
%X 大写的十六进制
%#x 带0x的十六进制
%U 打印Unicode字符
%#U 打印带字符的Unicode
%b 打印整型的二进制

Integer width 
%5d 表示该整型最大长度是5，下面这段代码
fmt.Printf(&quot;|%5d|&quot;, 1)
fmt.Printf(&quot;|%5d|&quot;, 1234567)
输出结果如下：
|    1|
|1234567|
%-5d则相反，打印结果会自动左对齐
%05d会在数字前面补零。

Float 
%f (=%.6f) 6位小数点
%e (=%.6e) 6位小数点（科学计数法）
%g 用最少的数字来表示
%.3g 最多3位数字来表示
%.3f 最多3位小数来表示

String 
%s 正常输出字符串
%q 字符串带双引号，字符串中的引号带转义符
%#q 字符串带反引号，如果字符串内有反引号，就用双引号代替
%x 将字符串转换为小写的16进制格式
%X 将字符串转换为大写的16进制格式
% x 带空格的16进制格式

String Width  
%5s 最小宽度为5
%-5s 最小宽度为5（左对齐）
%.5s 最大宽度为5
%5.7s 最小宽度为5，最大宽度为7
%-5.7s 最小宽度为5，最大宽度为7（左对齐）
%5.3s 如果宽度大于3，则截断
%05s 如果宽度小于5，就会在字符串前面补零

Struct 
%v 正常打印。比如：{sam {12345 67890}}
%+v 带字段名称。比如：{name:sam phone:{mobile:12345 office:67890}
%#v 用Go的语法打印。
比如main.People{name:”sam”, phone:main.Phone{mobile:”12345”, office:”67890”}}

Boolean 
%t 打印true或false

Pointer 
%p 带0x的指针
%#p 不带0x的指针
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="用户贡献表"><a class="header" href="#用户贡献表">用户贡献表</a></h1>
<h2 id="表示该包未被领养"><a class="header" href="#表示该包未被领养">(###表示该包未被领养)</a></h2>
<pre><code>archive
    - tar         : Unknown   2013-03-08 finished
    - zip         : Unknown   2013-03-10 finished
bufio             : stevewang  -
builtin           : achun   2013-03-26 finished
bytes             : stevewang  -
compress          : rujews      2015-01-31   finished
    - bzip2       : rujews   2015-01-31   finished
    - flate       : rujews   2015-01-31   finished
    - gzip        : Unknown   2013-03-11
    - lzw         : rujews   2015-01-31   finished
    - zlib        : lingdecong  2014-11-27
container         : weager   2013-03-10
    - heap        : weager   2013-03-10
    - list        : weager   2013-03-10
    - ring        : weager   2013-03-10
crypto            : ###    -
    - aes         : zhanming  2013-03-14 finished
    - cipher      : ###    -
    - des         : zhanming  2013-03-15 finished
    - dsa         : ###    -
    - ecdsa       : ###    -
    - elliptic    : ###    -
    - hmac        : zhanming  2013-03-20  finished
    - md5         : zhanming  2013-03-26 finished
    - rand        : Neeke   -
    - rc4         : zhanming  2013-03-25  finished
    - rsa         : ###    -
    - sha1        : zhanming  2013-03-26 finished
    - sha256      : zhanming  2013-03-12  finished
    - sha512      : zhanming  2013-03-12  finished
    - subtle      : zhanming  2013-03-28 finished
    - tls         : ###    -
    - x509        : ###    -
database          : astaxie   2013-03-11
    - sql         : astaxie   2013-03-11
        -driver   : astaxie         2013-03-11
debug             : ###    -
    - dwarf       : ###    -
    - elf         : ###    -
    - gosym       : ###    -
    - macho       : ###    -
    - pe          : ###    -
encoding          : ###    -
    - ascii85     : ###    -
    - asn1        : ###    -
    - base32      : boilingbit  2013-03-10
    - base64      : boilingbit  2013-03-08
    - binary      : wjvlangz  2013-03-25  finished
    - csv         : metadao   -
    - gob         : sndnvaps               2014-07-14 finished     -
    - hex         : caoqx   2013-04-23
    - json        : xiocode   2013-03-10
    - pem         : ###    -
    - xml         : 0x55aa   2013-03-15
errors            :                                         finished    -
expvar            : fairlyblank  2013-07-16 finished
flag              : faberliu  2014-11-10  finished
fmt               : liudch   2013-03-08 finished
go                : ###    -
    - ast         : ###    -
    - build       : ###    -
    - doc         : ###    -
    - parser      : ###    -
    - printer     : ###    -
    - scanner     : ###    -
    - token       : ###    -
hash              : lincolnlee  2013-04-06
    - adler32     : lincolnlee  2013-04-06
    - crc32       : lincolnlee  2013-04-06
    - crc64       : lincolnlee  2013-04-06
    - fnv         : lincolnlee  2013-04-06
html              : RaymondChou  2013-03-08
    - template    : RaymondChou  2013-03-08
image             : ###    -
    - color       : shendongming    -
    - draw        : shendongming -
    - gif         : shendongming -
    - jpeg        : shendongming -
    - png         : shendongming -
index             : starchou  -
    - suffixarray : starchou  -
io                : lodevil   -
    - ioutil      : qqcocobao    -
log               : cdxahz          2012-03-10 finished
    - syslog      : ###    -
math              : freemanke       2017-10-30 -
    - big         : ###    -
    - cmplx       : ###    -
    - rand        : athom   2013-03-11 finished
mime              : ###    -
    - multipart   : ###    -
net               : nalan   -
    - http        : qinglong1983 2013-03-08
    - mail        : andelf   2013-03-08 finished
    - rpc         : LostSkyDev 2013-03-19
    - smtp        : andelf   2013-03-09 finished
    - textproto   : ###    -
    - url         : peeped   2013-03-11
os                : miraclesu  2013-03-17 finished
    - exec        : miraclesu  2013-03-12 finished
    - signal      : mikespook    -
    - user        : LostSkyDev  2013-03-10 finished
path              : novakr   -
    - filepath    : xuchdong        2013-04-18 finished
reflect           : 456Vv   -
regexp            : andelf   2013-03-08
    - syntax      : andelf   2013-03-08
runtime           : ###    -
    - cgo         : ###    -
    - debug       : wendal   2013-03-10
    - pprof       : ###    -
sort              : Hubery   2013-03-09 finished
strconv           : vzever    2014-07-15  finished
strings           : astaxie   2013-03-08 finished
sync              : SnowWee   2013-03-23  finished
    - atomic      : SnowWee   2013-03-23  finished
syscall           : ###    -
testing           : hyper-carrot 2013-03-26
    - iotest      : Neeke   -
    - quick       : ###    -
text              : ###    -
    - scanner     : cdxahz   2013-03-08  finished
    - tabwriter   : ###    -
    - template    : bluesalt  -
time              : xuyuanp   -
unicode           : ###    -
    - uft16       : sndnvaps                2014-05-12 finished     -
    - uft8        : wangtuanjie
unsafe            : SnowWee   2013-04-03
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="c-2"><a class="header" href="#c-2">c++</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h3 id="c-3"><a class="header" href="#c-3">c++</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h3 id="c-4"><a class="header" href="#c-4">c++</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h3 id="c-5"><a class="header" href="#c-5">c++</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h3 id="c-6"><a class="header" href="#c-6">c++</a></h3>
<div style="break-before: page; page-break-before: always;"></div><p>背景
Go 没有对项目的 layout 有硬性规定，也没有官方版本的 best practice，所以社区内部有几种不同的实践方式，可根据自身需求自行参考。本文仅作简要总结。</p>
<p>参考方案
根据社区 Standard Go Project Layout 提出的方案，我们可以将一个 Go Project 划分成以下几大目录：</p>
<p>Go 相关目录
cmd/
一般来说，如果不是库函数，项目最终都会编译成 1 个或多个二进制可执行文件，每个可执行文件都会对应到一个 main()，而这些可执行文件的入口代码可认为都是一个 application。</p>
<p>cmd/ 就是用来放这些 application 代码，每个 application 都应对应到 cmd/ 的某个子目录下，比如我这个项目将生成 app1，app2 和 app3，那么目录结构就应该为：</p>
<p>go-project
└── cmd
├── app1
├── app2
└── app3
应该注意的一点：不宜在 cmd/ 下放过多代码。如果你觉得你的某些代码可公开复用，应放置于 pkg/ 目录中，否则可放置于 internal/ 目录中。</p>
<p>一个好的工程习惯是：尽可能保持 cmd/ 下的 application 代码，即 main() 入口函数的简单，通过调用其他工程目录下的代码（比如 pkg/ 和 internal/） 来串联整个逻辑。</p>
<p>internal/
私有的 application 或者库代码（不希望 package 的接口被扩散到同层目录以外的空间中）。该目录下的代码受限于 Go internal package 机制的限制（见下文），只能被 internal/ 下同层代码所引用。</p>
<p>pkg/
用来放置库代码，可被项目内部或外部引用。</p>
<p>vendor/
项目依赖代码。vendor/ 下放置着依赖代码的一个副本。如果项目是库代码，则无需提交依赖代码。</p>
<p>Service 应用相关目录
api/
一般用来放着 OpenAPI/Swagger 的 spec、JSON 的 schema 文件或者 protocol 的定义。可参考 kubernetes/api。</p>
<p>Web 应用相关目录
web/
Web application 相关的组件，比如静态资源、服务端模版等。</p>
<p>通用目录
configs/
配置文件或者模版文件。</p>
<p>init/
系统初始化（如 systemd，upstart，sysv）和进程管理（如 runit，supervisord）相关工具的配置。</p>
<p>scripts/
构建，安装，分析等相关操作的脚本。</p>
<p>build/
打包（packaging）和 CI 相关文件。比如 Docker，OS（deb，rpm，pkg）相关的配置和脚本文件可放在 build/package 目录下，而 CI （travis，drone 等）相关文件可放置 build/ci 目录下。</p>
<p>deployments/
IaaS，PaaS 或者容器编排系统的配置和模版文件。</p>
<p>test/
额外的测试应用和测试数据，如 test/data。</p>
<p>其他一些目录
docs/
设计或者用户文档。</p>
<p>tools/
项目相关的一些 tool，其代码可引用 pkg/ 和 internal/ 目录下的 package。</p>
<p>examples/
项目（应用或者库）相关的示例代码。</p>
<p>third_party/
外部的第三方工具、代码或其他组件。</p>
<p>hack/
放置一些跟项目相关的 hack 工具。</p>
<p>githooks/
放置 Git hooks。</p>
<p>assets/
项目相关的其他资源依赖。</p>
<p>几个要点
1.搞清楚 Go 的 workspace 机制
Go 会将所有的代码放在一个单一的 workspace 中，其路径以 GOPATH 环境变量指定，所以你可以将你的代码放在 src 目录下，如</p>
<p>$GOPATH/src/github.com/your_github_username/your_project：绝对路径，推荐使用；</p>
<p>$GOPATH/src/your_project：相对路径，可以用，但不推荐；</p>
<ol start="2">
<li>internal/ 的设计
Go 鼓励使用者将程序分成 package 并暴露 API。但随着项目的膨胀，拆分 package 将会把一些不必要的 API 暴露在整个项目中。为解决这个问题，从 Go 1.4 开始，Go 提供了 internal package 机制。</li>
</ol>
<p>根据 internal package 机制：只能在 internal/ 的父目录下引用 internal/ 下的 package。例如：</p>
<p>在 /a/b/c/internal/d/e/f 下的代码只能在 /a/b/c 下的代码使用，无法在 /a/b/g 下使用；</p>
<p>$GOROOT/src/pkg/net/http/internal 只能在 net/http 或者 net/http/* 下使用；</p>
<p>$GOPATH/src/mypkg/internal/foo 只能在 $GOPATH/src/mypkg 下使用；</p>
<ol start="3">
<li>不要使用 src/ 目录
容易和 Go workspace 目录约束下的 src/ 起冲突；</li>
</ol>
<p>总结
就目前而言，Go 对于工程项目的 layout 并未有官方权威的指导（区别于 Go Workspace 的 layout，Go 为此有着明确的约束，即要有 bin/、pkg/ 和 src/），但是开源社区中的大部分 Go 项目对一些目录的划分已经有了一些默契。可参考的有 Kuberntes、Promethus、etcd 等等。对于应用项目（即总是可编译出一个可执行文件的项目），一般都会有 cmd/、pkg/ 和 vendor/，其他一些目录则根据社区习惯会有所不同。对于非应用项目，比如一些库，则上述的 layout 设计并不能完全适用，且从目前社区的编码习惯来看，不少库项目的 layout 都相对比较自由（比如很多项目就直接将其所有代码放置于项目根目录下）。</p>
<p>从团队协作的角度来看，必须对 Go 工程项目的 layout 定义出一个最小通用子集并为此达成使用默契。</p>
<p>所以，当你开始一个 Go 项目的时候，你可以这么做：</p>
<p>确定你要写的项目是 application 还是 library，如果是 application，尽可能有 cmd/、pkg/ 和 vendor/ 目录；如果是 library，可参考上述规则；</p>
<p>如果是一个很小的项目，可以不需要所谓的目录设计，尽可能保持清晰简单即可；</p>
<p>参考设计不构成硬性的约束条件，一切都要以实际项目的需求来权衡设计，但最终还是要能保证清晰简单；</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_line_numbers = true;
        </script>
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
    </body>
</html>
